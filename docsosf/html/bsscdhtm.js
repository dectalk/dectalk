//////////BSSCDHTML Section 1//////////
// RoboHELP® Dynamic HTML Effects Script
// Copyright © 1998-2000 eHelp Corporation.  All rights reserved.

// Version=3.72

// Warning:  Do not modify this file.  It is generated by RoboHELP® and changes will be overwritten.

//{{HH_SYMBOL_SECTION
var HH_ChmFilename = "";
var HH_WindowName = "";
var HH_GlossaryFont = "";
var HH_Glossary = "";
var HH_Avenue = "";
var HH_ActiveX = false;
//}}HH_SYMBOL_SECTION

var gbNav4 = false;
var gbIE4 = false;
var gbIE = false;
var gbIE5 = false;
var gbIE55 = false;
var gAgent = navigator.userAgent.toLowerCase(); 
var gbMac = (gAgent.indexOf("mac") != -1);
var gbWindows = ((gAgent.indexOf("win") != -1) || (gAgent.indexOf("16bit") != -1));

var error_count = 0;

gbIE = (navigator.appName.indexOf("Microsoft") != -1);
if (parseInt(navigator.appVersion) >= 4) {
	gbNav4 = (navigator.appName == "Netscape");
	gbIE4 = (navigator.appName.indexOf("Microsoft") != -1);

	if (gbIE4) {
		if (gAgent.indexOf("msie 5.0") != -1) {
			gbIE5 = true;
		}
		if (gAgent.indexOf("msie 5.5") != -1) { // curently IE 5.5 has some buggy stuff. we need do some remedy to our code.
			gbIE55 = true;
		}
	}
}

function HHActivateComponents()
{
	if (HH_ActiveX && (HH_ChmFilename != "") && ((self == top) || (self == top.frames[0])))
	{
		var objBody = document.all.tags("BODY")[0];
		if( typeof(objBody) == "object" )
		{
			objBody.insertAdjacentHTML("beforeEnd", '<OBJECT ID="HHComponentActivator" CLASSID="CLSID:399CB6C4-7312-11D2-B4D9-00105A0422DF" width=0 height=0></OBJECT>');
			if (HHComponentActivator.object)
			{
				HHComponentActivator.Activate(HH_ChmFilename, HH_WindowName, HH_GlossaryFont, HH_Glossary, HH_Avenue);
			}
		}
	}
}

var gAmc = new Array();
var BSSCSequenceIndex = 0;

function animationContext(el, progressAnimation, finishAnimiation, animationDuration, animationPeriod)
{
	this.el = el;
	this.progressAnimation = progressAnimation;
	this.finishAnimiation = finishAnimiation;
	this.animationDuration = parseFloat(animationDuration);
	this.animationPeriod = animationPeriod;
	this.animationStartTime = (new Date()).getTime();
	this.continueAnimation = true;
}

function progressFade(ndx)
{
	if( typeof( gAmc[ndx].el.filters.alpha ) != "object" )
		return;
	
	percent = ((new Date()).getTime() - gAmc[ndx].animationStartTime)/gAmc[ndx].animationDuration;
	if (percent > 1.0){
		percent = 1.0;
		gAmc[ndx].continueAnimation = false;
	}
	gAmc[ndx].el.filters.alpha.opacity = gAmc[ndx].initialOpacity*(1.0-percent) +  gAmc[ndx].finalOpacity*percent;
	
}

function finishFade(ndx)
{
	if( typeof( gAmc[ndx].el.filters.alpha ) == "object" )
		gAmc[ndx].el.filters.alpha.opacity = parseInt(gAmc[ndx].finalOpacity);
}

function progressTranslation(ndx)
{
	percent = ((new Date()).getTime() - gAmc[ndx].animationStartTime)/gAmc[ndx].animationDuration;
	if (percent > 1.0)	{
		percent = 1.0;
		gAmc[ndx].continueAnimation = false;
	}
	gAmc[ndx].el.style.pixelLeft = gAmc[ndx].startX*(1.0-percent) +  gAmc[ndx].finalX*percent;
	gAmc[ndx].el.style.pixelTop = gAmc[ndx].startY*(1.0-percent) +  gAmc[ndx].finalY*percent;
}
function progressSpiral(ndx)
{
	percent = ((new Date()).getTime() - gAmc[ndx].animationStartTime)/gAmc[ndx].animationDuration;
	if (percent > 1.0)	{
		percent = 1.0;
		gAmc[ndx].continueAnimation = false;
	}
	rf = 1.0 - percent
	t = percent * 2.0*Math.PI
	rx = Math.max(Math.abs(gAmc[ndx].el.initLeft), 200)
	ry = Math.max(Math.abs(gAmc[ndx].el.initTop),  200)
	gAmc[ndx].el.style.pixelLeft = Math.ceil(-rf*Math.cos(t)*rx)
	gAmc[ndx].el.style.pixelTop  = Math.ceil(-rf*Math.sin(t)*ry)
	gAmc[ndx].el.style.visibility="visible"	
}

function progressElasticFromRight(ndx)
{
	percent = ((new Date()).getTime() - gAmc[ndx].animationStartTime)/gAmc[ndx].animationDuration;
	if (percent > 1.0)	{
		percent = 1.0;
		gAmc[ndx].continueAnimation = false;
	}
	rf=Math.exp(-percent*7)
	t = percent * 1.5*Math.PI
	rx =Math.abs(gAmc[ndx].el.initLeft)
	gAmc[ndx].el.style.pixelLeft = rf*Math.cos(t)*rx
	gAmc[ndx].el.style.pixelTop = 0
	gAmc[ndx].el.style.visibility="visible"	
}
function progressElasticFromBottom(ndx)
{
	percent = ((new Date()).getTime() - gAmc[ndx].animationStartTime)/gAmc[ndx].animationDuration;
	if (percent > 1.0)	{
		percent = 1.0;
		gAmc[ndx].continueAnimation = false;
	}
	rf=Math.exp(-percent*7)
	t = percent * 1.5*Math.PI
	rx =Math.abs(gAmc[ndx].el.initTop)
	gAmc[ndx].el.style.pixelLeft = 0
	gAmc[ndx].el.style.pixelTop = rf*Math.cos(t)*rx
	gAmc[ndx].el.style.visibility="visible"	
}

function progressZoomIn(ndx)
{
	percent = ((new Date()).getTime() - gAmc[ndx].animationStartTime)/gAmc[ndx].animationDuration;
	if (percent > 1.0)	{
		percent = 1;
		gAmc[ndx].continueAnimation = false;
	}
	for (var index=0; index<gAmc[ndx].el.all.length; index++) {
		gAmc[ndx].el.all[index].style.fontSize = Math.ceil(50+50*percent) + "%"
	}
	gAmc[ndx].el.posLeft = 100
	gAmc[ndx].el.style.visibility="visible"

	if (percent >= 1.0)	{
		finishZoom(ndx);
	}
}

function progressZoomOut(ndx)
{
	percent = ((new Date()).getTime() - gAmc[ndx].animationStartTime)/gAmc[ndx].animationDuration;
	if (percent > 1.0)	{
		percent = 1.0;
		gAmc[ndx].continueAnimation = false;
	}

	for (var index=0; index<gAmc[ndx].el.all.length; index++)
		gAmc[ndx].el.all[index].style.fontSize = Math.ceil(100+200*(1-percent)) + "%"
	gAmc[ndx].el.posLeft = 0
	gAmc[ndx].el.style.visibility="visible"

	if (percent >= 1.0)	{
		finishZoom(ndx);
	}
}
function finishTranslation(ndx)
{
	gAmc[ndx].el.style.pixelLeft = parseInt(gAmc[ndx].finalX);
	gAmc[ndx].el.style.pixelTop = parseInt(gAmc[ndx].finalY);
}
function finishZoom(ndx)
{
	for (i=0; i<gAmc[ndx].el.all.length; i++)
		gAmc[ndx].el.all[i].style.fontSize = gAmc[ndx].OldFont

} 

function animationPump(ndx)
{
	gAmc[ndx].progressAnimation(ndx);
	if (gAmc[ndx].continueAnimation)
		gAmc[ndx].tm = setTimeout("animationPump(" + ndx + ");", gAmc[ndx].animationPeriod);
}

function clearAnimations()
{
	for (var index=0; index<gAmc.length; index++) {
		gAmc[index].finishAnimiation(index);
		clearTimeout(gAmc[index].tm);
	}
	gAmc = new Array();
}

function startNextAnimationSet()
{
	clearAnimations();
	bStarted = false;
	bFound = false

	// Determine the next sequence number
	divElements = document.all.tags("DIV");
	for (var index = 0; index < divElements.length; index++) 
	{
		el = divElements[index];
		objectOrder = el.getAttribute("BSSCObjectOrder", false);
		if(null != objectOrder)
		{
			objectOrder = parseInt(objectOrder);
			if (objectOrder > BSSCSequenceIndex && (!bFound || objectOrder < minBSSCSequenceIndexFound))
			{
				minBSSCSequenceIndexFound = objectOrder;
				bFound = true;
			}
		}
	}

	if (bFound)
	{
		BSSCSequenceIndex = minBSSCSequenceIndexFound;
		bStarted = startAnimationSet(BSSCSequenceIndex);
	}
}

function getOffsetFromTopOfBrowser(el)
{
	if (null == el.offsetParent)
		return el.offsetTop;
	else
		return el.offsetTop + getOffsetFromTopOfBrowser(el.offsetParent);
}

function startAnimationSet(ndx)
{
	var m = 0;
	bStarted = false;

	// Find document elements with "BSSCAnimationType" attribute
	divElements = document.all.tags("DIV");
	for (var index = 0; index < divElements.length; index++)
	{
		el = divElements[index];
		
		animationType = el.getAttribute("BSSCAnimationType", false);
		if(null != animationType)
		{
			framePeriod = el.getAttribute("BSSCFramePeriod", false);
			frameCount = el.getAttribute("BSSCFrameCount", false);
			sequenceIndex = el.getAttribute("BSSCObjectOrder", false);

			// Stop any currently running RevealTrans filters
			if ("RevealTrans" == animationType && parseInt(sequenceIndex) == ndx-1 && gbWindows)
				el.filters.RevealTrans.stop();  
			// Filter on ndx
			if (0 == ndx && null == sequenceIndex ||
				ndx == parseInt(sequenceIndex))
			{
				if ("FlyInFromRight" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = document.body.clientWidth + document.body.scrollLeft;
					gAmc[m].startY = 0;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyOutToRight" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = 0;
					gAmc[m].finalX = document.body.clientWidth + document.body.scrollWidth;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyInFromLeft" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					for (childIndex=0; childIndex<el.children.length; childIndex++)
					{
						if ("left" == el.children[childIndex].style.textAlign)
							el.children[childIndex].style.textAlign = "right";
					}
					pixelsToTranslate = document.body.clientWidth;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = -(document.body.clientWidth + document.body.scrollLeft);
					gAmc[m].startY = 0;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyOutToLeft" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					for (childIndex=0; childIndex<el.children.length; childIndex++)
					{
						if ("left" == el.children[childIndex].style.textAlign)
							el.children[childIndex].style.textAlign = "right";
					}
					pixelsToTranslate = document.body.clientWidth;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = 0;
					gAmc[m].finalX = -(document.body.clientWidth + document.body.scrollWidth);
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyInFromBottom" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = document.body.clientHeight + document.body.scrollTop;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyOutToBottom" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = 0;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = document.body.clientHeight + document.body.scrollHeight;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyInFromTop" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = -getOffsetFromTopOfBrowser(el) - el.offsetHeight;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyOutToTop" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = 0;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = -getOffsetFromTopOfBrowser(el) - el.offsetHeight;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyInFromBottomRight" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					pixelsToTranslate = document.body.clientWidth + document.body.scrollLeft;
					if (document.body.clientHeight + document.body.scrollTop - el.offsetTop < pixelsToTranslate)
						pixelsToTranslate = document.body.clientHeight + document.body.scrollTop - el.offsetTop;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = pixelsToTranslate;
					gAmc[m].startY = pixelsToTranslate;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyOutToBottomRight" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					pixelsToTranslate = document.body.clientWidth + document.body.scrollLeft;
					if (document.body.clientHeight + document.body.scrollTop - el.offsetTop < pixelsToTranslate)
						pixelsToTranslate = document.body.clientHeight +document.body.scrollTop - el.offsetTop;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = 0;
					gAmc[m].finalX = pixelsToTranslate;
					gAmc[m].finalY = pixelsToTranslate;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyInFromTopRight" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					pixelsToTranslate = document.body.clientWidth;
					offsetFromTopOfBrowser = getOffsetFromTopOfBrowser(el);
					if (offsetFromTopOfBrowser + el.offsetHeight < pixelsToTranslate)
						pixelsToTranslate = offsetFromTopOfBrowser + el.offsetHeight;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = pixelsToTranslate;
					gAmc[m].startY = -pixelsToTranslate;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyOutToTopRight" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					pixelsToTranslate = document.body.clientWidth;
					offsetFromTopOfBrowser = getOffsetFromTopOfBrowser(el);
					if (offsetFromTopOfBrowser + el.offsetHeight < pixelsToTranslate)
						pixelsToTranslate = offsetFromTopOfBrowser + el.offsetHeight;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = 0;
					gAmc[m].finalX = pixelsToTranslate;
					gAmc[m].finalY = -pixelsToTranslate;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyInFromTopLeft" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					for (childIndex=0; childIndex<el.children.length; childIndex++)
					{
						if ("left" == el.children[childIndex].style.textAlign)
							el.children[childIndex].style.textAlign = "right";
					}
					pixelsToTranslate = document.body.clientWidth + document.body.scrollLeft;
					offsetFromTopOfBrowser = getOffsetFromTopOfBrowser(el);
					if (offsetFromTopOfBrowser + el.offsetHeight < pixelsToTranslate)
						pixelsToTranslate = offsetFromTopOfBrowser + el.offsetHeight;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = -pixelsToTranslate;
					gAmc[m].startY = -pixelsToTranslate;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyOutToTopLeft" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					for (childIndex=0; childIndex<el.children.length; childIndex++)
					{
						if ("left" == el.children[childIndex].style.textAlign)
							el.children[childIndex].style.textAlign = "right";
					}
					pixelsToTranslate = document.body.clientWidth + document.body.scrollLeft;
					offsetFromTopOfBrowser = getOffsetFromTopOfBrowser(el);
					if (offsetFromTopOfBrowser + el.offsetHeight < pixelsToTranslate)
						pixelsToTranslate = offsetFromTopOfBrowser + el.offsetHeight;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = 0;
					gAmc[m].finalX = -pixelsToTranslate;
					gAmc[m].finalY = -pixelsToTranslate;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyInFromBottomLeft" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					for (childIndex=0; childIndex<el.children.length; childIndex++)
					{
						if ("left" == el.children[childIndex].style.textAlign)
							el.children[childIndex].style.textAlign = "right";
					}
					pixelsToTranslate = document.body.clientWidth + document.body.scrollLeft;
					if (document.body.clientHeight + document.body.scrollTop - el.offsetTop < pixelsToTranslate)
						pixelsToTranslate = document.body.clientHeight + document.body.scrollTop - el.offsetTop;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = -pixelsToTranslate;
					gAmc[m].startY = pixelsToTranslate;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("FlyOutToBottomLeft" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					for (childIndex=0; childIndex<el.children.length; childIndex++)
					{
						if ("left" == el.children[childIndex].style.textAlign)
							el.children[childIndex].style.textAlign = "right";
					}
					pixelsToTranslate = document.body.clientWidth + document.body.scrollLeft;
					if (document.body.clientHeight + document.body.scrollTop - el.offsetTop < pixelsToTranslate)
						pixelsToTranslate = document.body.clientHeight +document.body.scrollTop - el.offsetTop;
					gAmc[m] = new animationContext(el, progressTranslation, finishTranslation, animationDuration, 10);
					gAmc[m].startX = 0;
					gAmc[m].startY = 0;
					gAmc[m].finalX = -pixelsToTranslate;
					gAmc[m].finalY = pixelsToTranslate;
					animationPump(m++);
					bStarted = true;
				}
				if ("FadeIn" == animationType)
				{
					if (gbWindows)
					{
						animationDuration = el.getAttribute("BSSCDuration", false);
						if (null == animationDuration)
							animationDuration = 1000; // default to 1s
						finalOpacity = el.getAttribute("BSSCFinalOpacity", false);
						if (null == finalOpacity)
							finalOpacity = 100;
						initialOpacity = el.getAttribute("BSSCInitialOpacity", false);
						if (null == initialOpacity)
							initialOpacity = 0;
						gAmc[m] = new animationContext(el, progressFade, finishFade, animationDuration, 50);
						el.filters.opacity = initialOpacity;
						gAmc[m].initialOpacity = initialOpacity;
						gAmc[m].finalOpacity = finalOpacity;
						animationPump(m++);
						bStarted = true;
					} else {
						el.style.visibility = "";
					}
				}
				if ("Spiral" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s

					gAmc[m] = new animationContext(el, progressSpiral, finishTranslation, animationDuration, 10);
					gAmc[m].el.initLeft = el.offsetLeft+document.body.clientWidth;
					gAmc[m].el.initTop = document.body.scrollTop+el.offsetTop+document.body.clientHeight;
					gAmc[m].el.endLeft = gAmc[m].el.posLeft;
					gAmc[m].el.endTop  = gAmc[m].el.posTop;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					gAmc[m].steps = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("ElasticFromRight" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressElasticFromRight, finishTranslation, animationDuration, 10);
					gAmc[m].el.initLeft = el.offsetLeft+document.body.clientWidth;
					gAmc[m].el.initTop = gAmc[m].el.posTop;
					gAmc[m].el.endLeft = gAmc[m].el.posLeft;
					gAmc[m].el.endTop  = gAmc[m].el.posTop;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					gAmc[m].steps = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("ElasticFromBottom" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressElasticFromBottom, finishTranslation, animationDuration, 10);
					gAmc[m].el.initLeft = gAmc[m].el.posLeft;
					gAmc[m].el.initTop = document.body.scrollTop-el.offsetTop-el.offsetHeight;
					gAmc[m].el.endLeft = gAmc[m].el.posLeft;
					gAmc[m].el.endTop  = gAmc[m].el.posTop;
					gAmc[m].finalX = 0;
					gAmc[m].finalY = 0;
					gAmc[m].steps = 0;
					animationPump(m++);
					bStarted = true;
				}
				if ("ZoomIn" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressZoomIn, finishZoom, animationDuration, 10);
					gAmc[m].OldFont = gAmc[m].el.all[0].style.fontSize;
					animationPump(m++);
					bStarted = true;
				}
				if ("ZoomOut" == animationType)
				{
					animationDuration = el.getAttribute("BSSCDuration", false);
					if (null == animationDuration)
						animationDuration = 1000; // default to 1s
					gAmc[m] = new animationContext(el, progressZoomOut, finishZoom, animationDuration, 10);
					gAmc[m].OldFont = gAmc[m].el.all[0].style.fontSize;
					animationPump(m++);
					bStarted = true;
				}
				if ("RevealTrans" == animationType)
				{
					if (gbWindows) {
						Duration = el.getAttribute("BSSCDuration", false);
						if (null == Duration)
							Duration = 1000; // default to 1s
						Transition = el.getAttribute("BSSCTransition", false);
						if (null == Transition)
							Transition = 0;
						el.style.filter = "RevealTrans();";
						el.filters.RevealTrans.Transition = Transition;
						el.filters.RevealTrans.apply();
						el.style.visibility = ""; 
						el.filters.RevealTrans.play(parseInt(Duration)/1000.0);  
						bStarted = true;
					} else {
						el.style.visibility = "";
					}
				}
			}
		}
	}
	return bStarted;
}

function ApplyTextFormatting(divEl, childEl)
{
	childEl.setAttribute("BSSCOriginalStyle", childEl.style);

	// Text Change
	hoverColor = divEl.getAttribute("BSSCHoverColor", false);
	if ("Default" != divEl.getAttribute("BSSCHoverColorName"))
	{
		childEl.setAttribute("BSSCOriginalColor", childEl.style.color);
		childEl.style.color = hoverColor;
	}
	hoverFontName = divEl.getAttribute("BSSCHoverFontName", false);
	if (null != hoverFontName && hoverFontName != "*Default*")
	{
		hoverFontFamily = divEl.getAttribute("BSSCHoverFontFamily", false);
		if (null != hoverFontFamily)
		{
			childEl.setAttribute("BSSCOriginalFontFamily", childEl.style.fontFamily);
			childEl.style.fontFamily = hoverFontFamily;
		}
	}
	hoverFontSize = divEl.getAttribute("BSSCHoverFontSize", false);
	{
		if (null != hoverFontSize && hoverFontSize != "*")
		{
			childEl.setAttribute("BSSCOriginalFontSize", childEl.style.fontSize);
			childEl.style.fontSize = hoverFontSize + "pt";
		}
	}
	hoverFontStyle = divEl.getAttribute("BSSCHoverFontStyle", false);
	if (null != hoverFontStyle && "Regular" != hoverFontStyle)
	{
		if ("Italic" == hoverFontStyle)
		{
			childEl.setAttribute("BSSCOriginalFontStyle", childEl.style.fontStyle);
			childEl.style.fontStyle = "italic";
		}
		else if ("Bold" == hoverFontStyle)
		{
			childEl.setAttribute("BSSCOriginalFontWeight", childEl.style.fontWeight);
			childEl.style.fontWeight = "bold";
		}
		else if ("Bold Italic" == hoverFontStyle)
		{
			childEl.setAttribute("BSSCOriginalFontStyle", childEl.style.fontStyle);
			childEl.style.fontStyle = "italic";
			childEl.setAttribute("BSSCOriginalFontWeight", childEl.style.fontWeight);
			childEl.style.fontWeight = "bold";
		}
	}
	hoverUnderline = divEl.getAttribute("BSSCHoverUnderLine", false);
	if (null != hoverUnderline && hoverUnderline == "TRUE")
	{
		childEl.setAttribute("BSSCOriginalTextDecoration", childEl.style.textDecoration);
		childEl.style.textDecoration = "underline";
	}
}

function RemoveTextFormatting(el)
{
	originalColor = el.getAttribute("BSSCOriginalColor", false);
	if (null != originalColor)
		el.style.color = originalColor;
	originalFontFamily = el.getAttribute("BSSCOriginalFontFamily", false);
	if (null != originalFontFamily)
		el.style.fontFamily = originalFontFamily;
	originalFontSize = el.getAttribute("BSSCOriginalFontSize", false);
	if (null != originalFontSize)
		el.style.fontSize = originalFontSize;
	originalFontStyle = el.getAttribute("BSSCOriginalFontStyle", false);
	if (null != originalFontStyle)
		el.style.fontStyle = originalFontStyle;
	originalFontWeight = el.getAttribute("BSSCOriginalFontWeight", false);
	if (null != originalFontWeight)
		el.style.fontWeight = originalFontWeight;
	originalTextDecoration = el.getAttribute("BSSCOriginalTextDecoration", false);
	if (null != originalTextDecoration)
		el.style.textDecoration = originalTextDecoration;
}

function BSSCOnMouseOver(el)
{
	// Text Formatting
	hoverColor = el.getAttribute("BSSCHoverColor", false);
	if (null != hoverColor)
		for (var index=0; index<el.all.length; index++)
			ApplyTextFormatting(el, el.all[index]);

	// Glow
	glowColor = el.getAttribute("BSSCGlowColor", false);
	if (null != glowColor)
	{
		glowStrength = el.getAttribute("BSSCGlowStrength", false);
		if (null == glowStrength)
			glowStrength = "3";
		glowColorName = el.getAttribute("BSSCGlowColorName");
		if ("Default" == glowColorName)
			el.style.filter = "glow(Strength=" + glowStrength + ", enabled=1)";
		else
			el.style.filter = "glow(Color=#" + glowColor + ", Strength=" + glowStrength + ", enabled=1)";
	}
}

function BSSCOnMouseOut(el)
{
	// Text Formatting
	hoverColor = el.getAttribute("BSSCHoverColor", false);
	if (null != hoverColor)
		for (var index=0; index<el.all.length; index++)
			RemoveTextFormatting(el.all[index]);

	// Glow
	glowColor = el.getAttribute("BSSCGlowColor", false);
	if (null != glowColor)
		el.style.filter="";
}

function doStaticEffects()
{
	divElements = document.all.tags("DIV");
	for (var index = 0; index < divElements.length; index++)
	{
		el = divElements[index];
		
		dropShadowColor = el.getAttribute("BSSCDropShadowColor");
		if (null != dropShadowColor)
		{
			dropShadowXOffset = el.getAttribute("BSSCDropShadowXOffset");
			if (null == dropShadowXOffset)
				dropShadowXOffset = 0;
			dropShadowYOffset = el.getAttribute("BSSCDropShadowYOffset");
			if (null == dropShadowYOffset)
				dropShadowYOffset = 0;
			dropShadowColorName = el.getAttribute("BSSCDropShadowColorName");
			if ("Default" == dropShadowColorName)
				el.style.filter = "DropShadow(OffX=" + dropShadowXOffset + ", OffY=" + dropShadowYOffset + ")";
			else
				el.style.filter = "DropShadow(Color=" + dropShadowColor + ", OffX=" + dropShadowXOffset + ", OffY=" + dropShadowYOffset + ")";
		}
	}
}

function drop( targetId )
{ 
	target = document.all( targetId );
	if (target.style.display == 'none') {
	   target.style.display = "" ;
	} else {
	   target.style.display = "none";
	}
	event.cancelBubble = true;
}

function checkParent(src,dest)
{
	//Search for a specific parent of the current element.
	while(src !=null)
	{
		if(src.tagName == dest)
		{
			return src;
		}
		src = src.parentElement;
	}
	return null;
}

//Generic Display code
function outline2()
{
	//Expand or collapse if a list item is clicked.
	var open = event.srcElement;

	//Verify that the tag which was clicked was either the 
	//trigger tag or nested within a trigger tag.
	var el = checkParent(open,"CITE");
	if(null != el)
	{	
		var incr=0;
		var elmPos = 0;
		var parentSpan;
		var fBreak

		//Get the position of the element which was clicked
		elemPos = window.event.srcElement.sourceIndex;

		//Search for a SPAN tag
		for (parentSpan = window.event.srcElement.parentElement; parentSpan!=null;	parentSpan = parentSpan.parentElement) 
		{
			//test if already at a span tag 
		    if (parentSpan.tagName=="SPAN") {
				incr=1;
				break;
			}
			
			//Test if the tag clicked was in a body tag or in any of the possible kinds of lists
			//we perform this test because nested lists require special handling
			if (parentSpan.tagName=="BODY" || parentSpan.tagName=="UL" || parentSpan.tagName=="OL") 
			{
				//Determine where the span to be expanded is.  
				for (incr=1; (elemPos+incr) < document.all.length; incr++)
				{	
					//verify we are at an expandable Div tag
					if(document.all(elemPos+incr).tagName=="SPAN" && (document.all(elemPos+incr).className=="expanded" || document.all(elemPos+incr).className=="glossexpanded" || document.all(elemPos+incr).className=="glosscollapsed" || document.all(elemPos+incr).className=="collapsed"))
					{
						fBreak=1;
						break;
					}
					else if(document.all(elemPos+incr).tagName=="LI")
					{
						//If the next tag following the list item (li) is another list item(li) return in order to prevent accidentally opening the next span in the list
						return;
					}
				}
			}
			//determine if we need to break out of the while loop (kind of a kludge since theres no goto in javascript)
			if(fBreak==1)
			{
				break;
			}
		}
	}
	else
	{
		return;
	}

	//Now that we've identified the span, expand or collapse it
	if(document.all(elemPos+incr) == null) {	
		return;
	} else if(document.all(elemPos+incr).className=="collapsed") {
		document.all(elemPos+incr).className="expanded";
	} else if(document.all(elemPos+incr).className=="expanded")  {
		document.all(elemPos+incr).className="collapsed";
	} else if(document.all(elemPos+incr).className=="glosscollapsed") {
		document.all(elemPos+incr).className="glossexpanded";
	} else if(document.all(elemPos+incr).className=="glossexpanded") {
		document.all(elemPos+incr).className="glosscollapsed";
	} else	{
		return;
	}
	event.cancelBubble = true;
}


//////////BSSCDHTML Section 2//////////

function RemoveNavBar()
{
	// See if we are in a popup and if so remove the NavBar
	if (BSSCPopup_IsPopup()) {

		if (gbIE4) {
			var tempColl = document.all.tags("DIV");
			for (var iDiv = 0; iDiv < tempColl.length; iDiv++) {
				if (tempColl(iDiv).id == "NavBar") {
					tempColl(iDiv).style.visibility = gBsStyVisHide;
					if (gbIE5) {
						tempColl(iDiv).style.position = "absolute";
					}
					tempColl(iDiv).style.pixelTop = "-100px";
					break;
				}
			}
		} else if (gbNav4) {
			for (var iLayer = 0; iLayer < document.layers.length; iLayer++) {
				if (document.layers[iLayer].id == "NavBar") {
					document.layers[iLayer].visibility = gBsStyVisHide;
				}
			}
			if ((document.images.length > 0) && (document.images[0].src.indexOf('bsscnav1.gif') != -1)) {
				document.links[0].href = "javascript:void(null);";
			}
		}
	}
	
	return;
}



//////////////////////////////////////////////////////////////////////////////////////////////
//
//	Begin DHTML Popup Functions
//
//////////////////////////////////////////////////////////////////////////////////////////////
//variables used to isolate the browser type
var gBsDoc			= null;			
var gBsSty			= null;
var gBsHtm			= null;
var gBsStyVisShow	= null;
var gBsStyVisHide	= null;
var gBsClientWidth	= 640;
var gBsClientHeight = 480;
var gBsBrowser		= null;

// here is the varible for judge popup windows size. these parameter is for IE5.0, it may need adjust for others.
var gBRateH_W		= 0.618; // 1.618 Golden cut.
var gBMaxXOfParent	= 0.8; 
var gBMaxYOfParent	= 0.8;
var gBscrollHeight   = 16;
var gBscrollWidth   =  16;
var gBpermitXDelta	= 3;
var gBpermitYDelta	= 3;



//the browser information itself
function _BSPSBrowserItself()
{
	var agent  = navigator.userAgent.toLowerCase();
	this.major = parseInt(navigator.appVersion);
	this.minor = parseFloat(navigator.appVersion);
	this.ns    = ((agent.indexOf('mozilla') != -1) && ((agent.indexOf('spoofer') == -1) && (agent.indexOf('compatible') == -1)));
	this.ns2   = ((this.ns) && (this.major == 2));
	this.ns3   = ((this.ns) && (this.major == 3));
	this.ns4   = ((this.ns) && (this.major >= 4));
	this.ie	   = (agent.indexOf("msie") != -1);
	this.ie3   = ((this.ie) && (this.major == 2));
	this.ie4   = ((this.ie) && (this.major >= 4));
	this.op3   = (agent.indexOf("opera") != -1);

	if (this.ns4)
	{
		gBsDoc		= "document";
		gBsSty		= "";
		gBsHtm		= ".document";
		gBsStyVisShow	= "show";
		gBsStyVisHide	= "hide";

	}
	else if (this.ie4)
	{
		gBsDoc		 = "document.all";
		gBsSty 		= ".style";
		gBsHtm 		= "";
		gBsStyVisShow	= "visible";
		gBsStyVisHide	= "hidden";
	}
}

//Here is the browser type 
function _BSPSGetBrowserInfo()
{
	gBsBrowser	= new _BSPSBrowserItself();
}

//Get client size info
function _BSPSGetClientSize()
{
	if (gBsBrowser.ns4)
	{
		gBsClientWidth	= innerWidth;
		gBsClientHeight = innerHeight;

	}
	else if (gBsBrowser.ie4)
	{
		gBsClientWidth	= document.body.clientWidth;
		gBsClientHeight = document.body.clientHeight;
	}
}


var gstrPopupID = 'BSSCPopup';
var gstrPopupShadowID = 'BSSCPopupShadow';
var gstrPopupTopicID = 'BSSCPopupTopic';
var gstrPopupIFrameID = 'BSSCPopupIFrame';
var gstrPopupIFrameName = 'BSSCPopupIFrameName';

var gstrPopupSecondWindowName = 'BSSCPopup';

var	gPopupDiv = null;
var gPopupDivStyle = null;
var	gPopupShadow = null;
var	gPopupTopic = null;
var gPopupIFrame = null;
var gPopupIFrameStyle = null;
var gPopupWindow = null;
var gnPopupClickX = 0;
var gnPopupClickY = 0;

var gnPopupScreenClickX = 0;
var gnPopupScreenClickY = 0;

var gbPopupTimeoutExpired = false;

var gbScriptName = "EHELP_DHTM";
var gbPathofJS = "";


if (gbIE4) {
	var aScripts = document.scripts;
	var aScript = null;
	var i = 0;
	for (i = 0; i < aScripts.length ; i ++ )
	{
		if (aScripts[i].name == gbScriptName) {
			aScript = aScripts[i];
			break;
		}
		
	}

	if (aScript != null) {
		var nPathPos = 0;
		var strCurrentSrc = "";
		strCurrentSrc = aScript.src;
		var nPathPos1 = strCurrentSrc.lastIndexOf("\\");
		var nPathPos2 = strCurrentSrc.lastIndexOf("/");
		if (nPathPos1 > nPathPos2)
			nPathPos = nPathPos1 + 1;
		else
			nPathPos = nPathPos2 + 1;

		gbPathofJS = strCurrentSrc.substring(0, nPathPos);
	}
}

// Replace point - Used by SingleSource 
// var gbBlankPageForIFrame = gbPathofJS + "_blank.htm";
var gbBlankPageForIFrame = "about:blank";

if (BSSCPopup_IsPopup()) {
	document.write("<base target=\"_parent\">");
}

function DHTMLPopupSupport()
{
	if ((gbIE4) && (!gbMac)) {
		return true;
	}
	return false;
}



function BSSCPopup_IsPopup()
{
	if (DHTMLPopupSupport() && (this.name == gstrPopupIFrameName)) {
		return true;
	} else if ((gbNav4 || gbIE4) && (this.name == gstrPopupID)) {
		return true;
	} else {
		return false;
	}
}

var gbBsCreateDiv = false;
function _BSSCCreatePopupDiv()
{
	if (!gbBsCreateDiv) {
		if (DHTMLPopupSupport()) {
			document.write("<DIV ID='" + gstrPopupID + "' STYLE='position:absolute; width:0; height:0; top:-100; left:0; z-index:600; visibility:hidden;'>");
			document.write("<DIV ID='" + gstrPopupShadowID + "' STYLE=\"position:absolute;top:0; left:0;  width:0; height:0; background-color:#C0C0C0;\"></DIV>");
			document.write("<DIV ID='" + gstrPopupTopicID + "' STYLE=\"position:absolute;top:0; left:0;  width:0; height:0; background-color:#FFFFFF;border:1px #000000 outset;\">");
			document.write("<IFRAME ID='" + gstrPopupIFrameID + "' name='" + gstrPopupIFrameName + "' src = '" + gbBlankPageForIFrame + "' frameborder=0 scrolling=auto></IFRAME>");
			document.write("</DIV></DIV>");
		}
	}
	gbBsCreateDiv = true;
}

function BSSCPopup_Timeout()
{
	if ((gPopupIFrame.document.readyState == "complete") &&
		(gPopupIFrame.document.body != null) && 
		(gPopupIFrame.location.href.indexOf(gbBlankPageForIFrame) == -1)) {
		window.gPopupDivStyle.visibility = gBsStyVisShow;
		BSSCPopup_TimeoutReal();
	} else {
		setTimeout("BSSCPopup_Timeout()", 100);
	}
}

function BSSCPopup_TimeoutReal()
{
	window.gbPopupTimeoutExpired = true;

	if (gPopupIFrame.document) {
		BSSCPopup_ChangeTargettoParent(gPopupIFrame.document);
		gPopupIFrame.document.body.onclick = BSSCPopupClicked;
	}
	document.onmousedown = BSSCPopupParentClicked;
}

function BSSCPopup_ChangeTargettoParent(tagsObject)
{
	var collA = tagsObject.all.tags("A");
	var j = 0;
	if (collA != null) {
		for (j = 0; j < collA.length; j ++ )
		{
			collA[j].target = "_parent";
		}

	}
}

function BSPSPopupTopicWinHelp(strURL)
{
	_BSSCPopup(strURL);
	return;
}

var gb_strURL = "";

function _BSSCPopup(strURL)
{
	gb_strURL = strURL;
	if (DHTMLPopupSupport()) {
		// If we are already in a popup, replace the contents
		if (BSSCPopup_IsPopup()) {

			location.href = strURL;
			parent.window.gbPopupTimeoutExpired = false;
			if (gbMac) {
				setTimeout("BSSCPopup_AfterLoad()", 400);
			} else {
				setTimeout("BSSCPopup_AfterLoad()", 100);
			}
			
		} else {

			var tempColl = document.all.tags("DIV");
			for (var iDiv = 0; iDiv < tempColl.length; iDiv++) {
				if (tempColl(iDiv).id == gstrPopupID) {
					gPopupDiv = tempColl(iDiv);
				}
				if (tempColl(iDiv).id == gstrPopupShadowID) {
					gPopupShadow = tempColl(iDiv);
				}
				if (tempColl(iDiv).id == gstrPopupTopicID) {
					gPopupTopic = tempColl(iDiv);
				}
			}
		
			gPopupIFrame = eval("gPopupDiv.document.frames['" + gstrPopupIFrameName + "']");
			gPopupDivStyle = eval("gPopupDiv" + gBsSty);
			gPopupIFrameStyle = eval(gBsDoc + "['" + gstrPopupIFrameName + "']" + gBsSty);


			// Load the requested URL into the IFRAME
			gPopupIFrame.location.href = strURL;
			window.gbPopupTimeoutExpired = false;
			if (gbMac) {
				setTimeout("BSSCPopup_AfterLoad()", 400);
			} else {
				setTimeout("BSSCPopup_AfterLoad()", 100);
			}
		}

	} else {
		_BSSCPopup2(strURL);
	}
	return;
}


function _BSSCPopup2(strURL)
{
	if (window.name == gstrPopupSecondWindowName) {
		window.location = strURL;
	} else {

		BSSCHidePopupWindow();
		var nX = 0;
		var nY = 0;
		var nHeight = 300;
		var nWidth = 400;
		_BSPSGetClientSize();
		if (gBsBrowser.ns4) {
			nX = window.screenX + (window.outerWidth - window.innerWidth) + window.gnPopupClickX;
			nY = window.screenY + (window.outerHeight - window.innerHeight) + window.gnPopupClickY;
		} else {
			nX = window.gnPopupScreenClickX;
			nY = window.gnPopupScreenClickY;
		}
		if (nY + nHeight + 40 > screen.availHeight) {
			nY = screen.availHeight - nHeight - 40;
		}
		if (nX + nWidth + 40 > screen.availWidth) {
			nX = screen.availWidth - nWidth - 40;
		}
		// Launch a separate window
		var strParam = "titlebar=no,toolbar=no,status=no,location=no,menubar=no,resizable=yes,scrollbars=yes";
		if (gBsBrowser.ns) {
			strParam += ",OuterHeight=" + nHeight + ",OuterWidth=" + nWidth;
			strParam += ",screenX=" + nX + ",screenY=" + nY;
			strParam += ",dependent=yes";
		}
		else {
			strParam += ",height=" + nHeight + ",width=" + nWidth;
			strParam += ",left=" + nX + ",top=" + nY;
		}
		window.gPopupWindow = window.open(strURL, gstrPopupSecondWindowName, strParam);
		if (gBsBrowser.ns4) {
			window.gPopupWindow.captureEvents(Event.CLICK | Event.BLUE);
			window.gPopupWindow.onclick = NonIEPopup_HandleClick;
			window.gPopupWindow.onblur = NonIEPopup_HandleBlur;
		}
		else if (gBsBrowser.ie4)
		{
			window.gPopupWindow.focus();
		}
	}
	return;
}

function NonIEPopup_HandleBlur(e)
{
	window.gPopupWindow.focus();
}

function NonIEPopup_HandleClick(e)
{
	// Because navigator will give the event to the handler before the hyperlink, let's
	// first route the event to see if we are clicking on a Popup menu in a popup.
	document.routeEvent(e);

	// If a popup menu is active then don't do anything with the click
	if (window.gPopupWindow.gbInPopupMenu) {
		window.gPopupWindow.captureEvents(Event.CLICK);
		window.gPopupWindow.onclick = NonIEPopup_HandleClick;
		return false;
	}

	// Close the popup window
	if (e.target.href != null) {
		window.location.href = e.target.href;
		if (e.target.href.indexOf("BSSCPopup") == -1) {
			this.close();
		}
	} else {
		this.close();
	}
	return false;
}

function BSSCPopup_AfterLoad()
{	
	if (typeof(window.gPopupIFrame.document) == "unknown") {
		_BSSCPopup2(gb_strURL);
		return;
	}
	if ((window.gPopupIFrame.document.readyState == "complete") &&
		(window.gPopupIFrame.document.body != null) && 
		(window.gPopupIFrame.location.href.indexOf(gbBlankPageForIFrame) == -1)) {
		BSSCPopup_ResizeAfterLoad(gb_strURL);
	}  else {
		setTimeout("BSSCPopup_AfterLoad()", 200);
	}
}


function BSSCPopup_ResizeAfterLoad(strURL)
{
	window.gPopupDivStyle.visibility = gBsStyVisHide;

	// Determine the width and height for the window
	//var size = new BSSCSize(0, 0);
	//BSSCGetContentSize(window.gPopupIFrame, size);
	//var nWidth = size.x;
	//var nHeight = size.y;


	_BSPSGetClientSize();

	var size = new BSSCSize(0, 0);

	BSSCGetContentSize(window.gPopupIFrame, size);

	// Determine the width and height for the window
	var nWidth = size.x;
	var nHeight = size.y;
		
	window.gPopupDivStyle.width = nWidth;
	window.gPopupDivStyle.height = nHeight;

	// Determine the position of the window
	var nClickX = window.gnPopupClickX;
	var nClickY = window.gnPopupClickY;
	var nTop = 0;
	var nLeft = 0;

	if (nClickY + nHeight + 20 < gBsClientHeight + document.body.scrollTop) {
		nTop = nClickY + 10;
	} else {
		nTop = (document.body.scrollTop + gBsClientHeight) - nHeight - 20;
	}
	if (nClickX + nWidth < gBsClientWidth + document.body.scrollLeft) {
		nLeft = nClickX;
	} else {
		nLeft = (document.body.scrollLeft + gBsClientWidth) - nWidth - 8;
	}
	
	if (nTop < document.body.scrollTop ) nTop  = document.body.scrollTop + 1;
	if (nLeft< document.body.scrollLeft) nLeft = document.body.scrollLeft + 1;


	window.gPopupDivStyle.left = nLeft;
	window.gPopupDivStyle.top = nTop;

	// Set the location of the background blocks
	window.gPopupShadow.style.left = 6;
	window.gPopupShadow.style.top = 6;
	if (gbIE55)
	{
		window.gPopupShadow.style.left = 4;
		window.gPopupShadow.style.top = 4;
	}
	window.gPopupShadow.style.width = nWidth;
	window.gPopupShadow.style.height = nHeight;
	window.gPopupTopic.style.width = nWidth;
	window.gPopupTopic.style.height = nHeight;
	if (gbIE55)
	{
		window.gPopupShadow.style.width = nWidth + 2;
		window.gPopupShadow.style.height = nHeight + 2;
		window.gPopupTopic.style.width = nWidth + 2;
		window.gPopupTopic.style.height = nHeight + 2;
	}


	if (gbMac) {
		// Total hack on the iMac to get the IFrame to position properly
		window.gPopupIFrameStyle.pixelLeft = 100;
		window.gPopupIFrameStyle.pixelLeft = 0;
		// Explicitly call BSSCOnLoad because the Mac doesn't seem to do it
		window.gPopupIFrame.window.BSSCOnLoad();
	}
	//var nOriWidth = window.gPopupIFrameStyle.width

	window.gPopupIFrameStyle.width = nWidth;
	window.gPopupIFrameStyle.height = nHeight;
	if (gbIE55)
	{
		window.gPopupIFrameStyle.top = 0;
		window.gPopupIFrameStyle.left = 0;
	}

	gPopupIFrame.location.href = strURL;  // reload again, this will fix the bookmark misunderstand in IE5.

	setTimeout("BSSCPopup_Timeout();", 100);
	
	return false;
}


function	BSSCSize(x, y)
{
	this.x = x;
	this.y = y;
}

function BSSCGetContentSize(thisWindow, size)
{
	if (!((gBsBrowser.ie4) || (gBsBrowser.ns4)))
		return;

	if (gbMac) {
		size.x = 300;
		size.y = 300;
		return;
	}

	// Resize the width until it is wide enough to handle the content
	// The trick is to start wide and determine when the scrollHeight changes
	// because then we know a scrollbar is necessary. We can then go back
	// to the next widest size (for no scrollbar)

	var ClientRate = gBsClientHeight / gBsClientWidth;

	var GoldenSize = new BSSCSize(0,0);
	GoldenSize.x = gBsClientWidth * gBMaxXOfParent;
	GoldenSize.y = gBsClientHeight *gBMaxYOfParent ;

	if (ClientRate > gBRateH_W) {
		GoldenSize.y = GoldenSize.x * gBRateH_W;
	}
	else {
		GoldenSize.x = GoldenSize.y / gBRateH_W;
	}

	// Try to using parent specified max x.
	var x = 0;
	var maxgoldx = GoldenSize.x;
	var maxx = gBsClientWidth * gBMaxXOfParent;
	
	// This double resize causes the document to re-render (and we need it to)
	thisWindow.moveTo(10000,10000); // this is used to fix the flash on IE4.
	thisWindow.resizeTo(1, 1);
	thisWindow.resizeTo(1, 1);
	thisWindow.resizeTo(maxgoldx, thisWindow.document.body.scrollHeight + gBscrollHeight);
	thisWindow.resizeTo(maxgoldx, thisWindow.document.body.scrollHeight + gBscrollHeight);
		
	var miny = thisWindow.document.body.scrollHeight + gBscrollHeight;
	
	if (miny > GoldenSize.y) // the popup does not fix in the parent wanted golden area. so try to expand itself as large as it can
	{
		thisWindow.resizeTo(maxx , thisWindow.document.body.scrollHeight + gBscrollHeight);
		thisWindow.resizeTo(maxx , thisWindow.document.body.scrollHeight + gBscrollHeight);
		
		miny = 	thisWindow.document.body.scrollHeight + gBscrollHeight;
		maxy = gBsClientHeight * gBMaxYOfParent;
		
		if (miny > maxy) { // the popup must have a scroll, OK let it be.
			miny = maxy;
			size.x = maxx;
			size.y = maxy;
		}
		else { // popup still can fit in the parent area by someway. now we choose the same h/w rate as parent.
			size.y = miny;
			
			//  downsize from maxx , now I try to using binary divide.
			x = maxx;
			deltax = -maxx/2;
			//j = 0;
			while (true) {
				x = x + deltax;
				thisWindow.resizeTo(x, miny);
				thisWindow.resizeTo(x, miny);
				diffy = thisWindow.document.body.scrollHeight + gBscrollHeight - x * ClientRate;
				if (diffy >  gBpermitYDelta ) // it is higher than wanted, so x need to be wide a little bitter
					deltax = Math.abs(deltax) /2;
				else if (diffy <  -gBpermitYDelta) // it is shorter than wanted, so x need to be narrow a little bitter
					deltax = -Math.abs(deltax) /2;
				else 
					// the y is close enough to wanted.
					break;
				if (Math.abs(deltax) < gBpermitXDelta) // the next change is too slight and it can be ignore.
					break;
				//j ++;
				
			}
			size.x = thisWindow.document.body.scrollWidth; //+ gBscrollWidth;
			size.y = thisWindow.document.body.scrollHeight;// + gBscrollHeight;	
			thisWindow.document.body.scroll = 'no'; // At this time we do not want to show scroll any more. so it will looks better a little.
			
		// Handle absurd cases just in case IE flakes
	//		if (size.y < 100) {
	//			size.y = 100;
	//		}
		}
	}
	else {
		//  downsize from maxgoldx , now I try to using binary divide.
		x = maxgoldx;
		deltax = -maxgoldx/2;
		//i = 0;
		while (true) {
			x = x + deltax;
			thisWindow.resizeTo(x, miny);
			thisWindow.resizeTo(x, miny);
			diffy = thisWindow.document.body.scrollHeight + gBscrollHeight - x * gBRateH_W;
			if (diffy >  gBpermitYDelta ) // it is higher than wanted, so x need to be wide a little bitter
				deltax = Math.abs(deltax) /2;
			else if (diffy <  -gBpermitYDelta) // it is shorter than wanted, so x need to be narrow a little bitter
				deltax = -Math.abs(deltax) /2;
			else 
				// the y is close enough to wanted.
				break;
			if (Math.abs(deltax) < gBpermitXDelta) // the next change is too slight and it can be ignore.
				break;
			//i ++;
				
		}
		size.x = thisWindow.document.body.scrollWidth ;//+ gBscrollWidth;
		size.y = thisWindow.document.body.scrollHeight ;//+ gBscrollHeight;	
		thisWindow.document.body.scroll = 'no'; // At this time we do not want to show scroll any more. so it will looks better a little.
	}

	size.x = size.x + 16;	//reserve a width for scrollbar 

	thisWindow.resizeTo(size.x, size.y);
	thisWindow.resizeTo(size.x, size.y);

	return;
}



function BSSCPopupParentClicked()
{
	BSSCPopupClicked();
	return;
}


function BSSCPopupClicked()
{
	if (!window.gbPopupTimeoutExpired) {
		return false;
	}

	if (gPopupIFrame.window.gbInPopupMenu) {
		return false;
	}

	// Give the user a message about javascript calls through objects.
	if ((gPopupIFrame.window.event != null) &&
	    (gPopupIFrame.window.event.srcElement != null) &&
	    (gPopupIFrame.window.event.srcElement.tagName == "A") &&
	    (gPopupIFrame.window.event.srcElement.href.indexOf("javascript:") == 0) &&
	    (gPopupIFrame.window.event.srcElement.href.indexOf(".") != -1)) {
		gPopupIFrame.window.event.cancelBubble = true;
		alert('Hyperlinks to objects do not work in popups.');
		return false;
	}

	document.onclick = null;
	document.onmousedown = null;

	// Simply hide the popup
	gPopupDivStyle.visibility = gBsStyVisHide;
	gPopupIFrame.location.href = gbBlankPageForIFrame;

	window.gbPopupTimeoutExpired = false;

	return true;
}


//trace the mouse over's position for hotspot
function  BSPSPopupOnMouseOver(event)
{
	if (gBsBrowser.ie4) {
		window.gnPopupClickX = event.clientX + document.body.scrollLeft;
		window.gnPopupClickY = event.clientY + document.body.scrollTop;
		window.gnPopupScreenClickX = event.screenX;
		window.gnPopupScreenClickY = event.screenY;
	} else if (gBsBrowser.ns4) {
		window.gnPopupClickX = event.pageX;
		window.gnPopupClickY = event.pageY;
	}
}

function BSSCHidePopupWindow()
{
	if (window.gPopupWindow != null) {
		if (gBsBrowser.ns4) {
			if ((typeof window.gPopupWindow != "undefined") && (!window.gPopupWindow.closed)) {
				window.gPopupWindow.close();
				window.gPopupWindow = null;
			}
		}
	}

	return;
}

var gbPopupMenuTimeoutExpired = false;
var gbInPopupMenu = false;
var gbPopupMenuTopicList = null;

//////////////////////////////////////////////////////////////////////////////////////////
//
// Popup Menu code
//
//////////////////////////////////////////////////////////////////////////////////////////


function _WritePopupMenuLayer()
{
	if (gbNav4) {
//Do not try to write ininle styles for NS!  NS can not handle it and will not stop downloading the html page...
	   document.write("<DIV CLASS='WebHelpPopupMenu' ID='PopupMenu'></DIV>");
	} else {
  	   document.write("<DIV ID='PopupMenu' STYLE='position:absolute; left:0px; top:0px; z-index:4; visibility:hidden;'></DIV>");
           if (gbIE4) {
		document.write("<STYLE TYPE='text/css'>");
		if (gbMac) {
			document.write(".PopupOver {font-family:'Arial'; color:white; background:navy; font-size:10pt; text-decoration:none;}");
			document.write(".PopupNotOver {font-family:'Arial'; color:black; background:#c0c0c0; font-size:10pt; text-decoration:none;}");
		} else {
			document.write(".PopupOver {font-family:'Arial'; color:white; background:navy; font-size:8pt; text-decoration:none;}");
			document.write(".PopupNotOver {font-family:'Arial'; color:black; background:#c0c0c0; font-size:8pt; text-decoration:none;}");
		}
		document.write("</STYLE>");
           }
	}
}

//Define variable arguments as: strTitle, strUrl
function PopupMenuTopicEntry() 
{
	this.strTitle = PopupMenuTopicEntry.arguments[0];
	this.strURL = PopupMenuTopicEntry.arguments[1];
}

// If the topic list is set, it is an array of TopicEntry objects (defined in WebHelp3.js)
function PopupMenu_SetTopicList(aPopupTopicArray)
{
	gbPopupMenuTopicList = aPopupTopicArray;
}

//Seek for the bsscright frame 
function _SeekFrameByName( cRoot, strName )
{
	if( cRoot == null )	return null;
	if( cRoot.frames == null )	return null;
	if( cRoot.frames[strName] != null )	return cRoot.frames[strName];
	for (var i=0; i<cRoot.frames.length; i++)
	{
		var cObj = _SeekFrameByName( cRoot.frames(i).document, strName );
		if( cObj != null )		return cObj;
	};
	return null;
}
function _GetFrameByName( cRoot, strName )
{
	if( cRoot == null )	return null;
	var cRet = _SeekFrameByName(cRoot, strName);
	if( cRet != null )	return cRet;
	return _GetFrameByName( cRoot.parent, strName );
}

function _PopupMenu_Invoke(fn_arguments)
{
	if ((!gbIE4 && !gbNav4) || ((gbMac) && (gbIE4) && (window.event.srcElement.tagName == "AREA"))) {
	
		var argLen 	= fn_arguments.length;

		// Create the window that the hyperlinks will go into
		var nHeight = argLen * 15;
		var nWidth = 400;
		var strParam = "titlebar=no,toolbar=no,status=no,location=no,menubar=no,resizable=yes,scrollbars=auto";
		strParam += ",height=" + nHeight + ",width=200";
		strParam += ",resizable";

		// Create a temporary window first to ensure the real popup comes up on top
		var wndTemp = window.open("", "temp", strParam);

		// Create the real popup window
		var wndPopupLinks = window.open("", "popuplinks", strParam);

		// Close the temporary
		wndTemp.close();

		wndPopupLinks.document.open("text/html");
		wndPopupLinks.document.write("<html><head></head>");
		wndPopupLinks.document.write("<body onBlur=\'self.focus();\'>");
		var strParaLine = "";
		for (var i = 0; i < (argLen - 2) / 2; i++) {
			strParaLine = "";
			strParaLine += "<a href=\"javascript:";
			if (gbIE) {
				strParaLine += "onBlur=null; ";
			}
			strParaLine += "opener.location=\'";
			strParaLine += fn_arguments[2 * i + 3];
			strParaLine += "\';close();\"";
			if (fn_arguments[1] != '') {
				strParaLine += " TARGET='" + fn_arguments[1] + "'";
			}
			strParaLine += ">";
			strParaLine += fn_arguments[2 * i + 2];
			strParaLine += "</a>";
			strParaLine += "<br>";
			wndPopupLinks.document.write(strParaLine);
		}
		wndPopupLinks.document.write("</body></html>");
		wndPopupLinks.document.close();
		window.gbInPopupMenu = true;
		if (!gbIE) {
			wndPopupLinks.focus();
		}

		return false;
	}

	// Make sure we have reasonable arguments
	var argLen = fn_arguments.length;
	if (argLen < 3) {
		return false;
	}

	// Check to see if we only have one target
	var strTarget = "";
	if (((argLen < 5) && ((isNaN(fn_arguments[2])) || (gbPopupMenuTopicList == null))) ||
		((argLen < 4) && ((!isNaN(fn_arguments[2])) && (gbPopupMenuTopicList != null)))) {

		// Get the place that we will be putting the topic into
		var targetDoc = null;
		if (fn_arguments[1] == '') {
			targetDoc = window.document;
		} else {
			targetDoc = _GetFrameByName( parent, fn_arguments[1] );
			if (targetDoc == null) {
				targetDoc  = window.document;
			}
			//if (gbIE4) {
		    //		targetDoc = eval("top.document.frames['" + fn_arguments[1] + "']");
		    //	} else if (gbNav4) {
			//	targetDoc = eval("window.top." + fn_arguments[1] + ".document");
			//}
			strTarget = "TARGET='" + fn_arguments[1] + "'";
		}
		if (isNaN(fn_arguments[2]) ||  (gbPopupMenuTopicList == null)) {
			targetDoc.location.href = fn_arguments[3];
		} else {
			targetDoc.location.href = gbPopupMenuTopicList[fn_arguments[2]].strURL;
		}
		window.gbInPopupMenu = true;
		return false;
	}
	
	var strMenu = "";
	if (gbNav4) {
		strMenu = '<TABLE BORDER="1" CELLSPACING=0 CELLPADDING=3 BGCOLOR="#c0c0c0">';
	} else {
		strMenu = '<TABLE STYLE="border:2px outset white;" CELLSPACING=0';
		if (gbMac) {
			strMenu += ' CELLPADDING=4';
		} else {
			strMenu += ' CELLPADDING=2';
		}	
		strMenu += ' BGCOLOR=#c0c0c0>';
	}

	// Add each of the items
	var i = 2;
	while (i <= argLen - 1) {
		strMenu += '<TR><TD><NOBR>'
		// If the destination is a number then look it up in the topic list
		if (isNaN(fn_arguments[i]) ||  (gbPopupMenuTopicList == null)) {
			strMenu += '<DIV STYLE="padding-left:3pt; padding-right:3pt;"><A HREF="' + fn_arguments[i + 1] + '"' + strTarget;
		} else {
			strMenu += '<DIV STYLE="padding-left:3pt; padding-right:3pt;"><A HREF="' + gbPopupMenuTopicList[fn_arguments[i]].strURL + '"' + strTarget;
		}
		strMenu += ' onclick="PopupMenu_HandleClick(event);"';
		strMenu += ' onmouseover="PopupMenu_Over(event);"';
		strMenu += ' onmouseout="PopupMenu_Out(event);"';
		strMenu += '>';
		if (isNaN(fn_arguments[i]) || (gbPopupMenuTopicList == null)) {
			strMenu += '<SPAN CLASS="PopupNotOver">' + fn_arguments[i] + '</SPAN>';
		} else {
			strMenu += '<SPAN CLASS="PopupNotOver">' + gbPopupMenuTopicList[fn_arguments[i]].strTitle + '</SPAN>';
		}
		strMenu += '</A></DIV></NOBR></TD></TR>';

		if (isNaN(fn_arguments[i]) || (gbPopupMenuTopicList == null)) {
			i += 2;
		} else {
			i += 1;
		}
	}
	strMenu += "</TABLE>";

	if (gbMac) {
	// totally hack. because ie5 in mac need something. </TABLE> is one of them. mac is mad.
		strMenu +="<TABLE></TABLE>";
	}

	var layerPopup = null;
	var stylePopup = null;
	var nEventX = 0;
	var nEventY = 0;
	var nWindowWidth = 0;
	if (gbIE4) {

		layerPopup = document.all["PopupMenu"];
		layerPopup.innerHTML = strMenu;
		stylePopup = layerPopup.style;

		_BSPSGetClientSize();

		// Get the position of the item causing the event (relative to its parent)
		//if (gbMac) {
		if (true) {
			nEventX = window.event.clientX;
			nEventY = window.event.clientY;
		} else {
			//??? YJ: Can not remember why we calculate envent position by following code...
			//but it is wrong in a case like: CENTER->P->TABLE:
			//the offset positions of TABLE, P and CENTER are same (same offsetTop,offsetLeft)
			//so we get triple times of offset of x and y as we expect... 

			nEventX = window.event.srcElement.offsetLeft - document.body.scrollLeft;
			nEventY = window.event.srcElement.offsetTop - document.body.scrollTop;

			// Get the location of the parent
			var nParentLocX = 0;
			var nParentLocY = 0;

			var ParentItem = window.event.srcElement.offsetParent;
			while (ParentItem != null) {
				if (ParentItem.offsetLeft)	{
					nParentLocX += ParentItem.offsetLeft;
					nParentLocY += ParentItem.offsetTop;
				}
				ParentItem = ParentItem.parentElement;
			}

			// Adjust the location of the item using the location of the parent(s)
			nEventX += nParentLocX;
			nEventY += nParentLocY;
		}

		if (nEventY + layerPopup.scrollHeight + 10 < gBsClientHeight) {
			nEventY += document.body.scrollTop + 10;
		} else {
			nEventY = (document.body.scrollTop + gBsClientHeight) - layerPopup.scrollHeight - 20;
		}
		stylePopup.top = nEventY;

		if (nEventX + layerPopup.scrollWidth + 20 > gBsClientWidth) {
			if (gBsClientWidth - layerPopup.scrollWidth < 5) {
				stylePopup.left = 5;
			} else {
				stylePopup.left = gBsClientWidth - layerPopup.scrollWidth - 5;
			}
		} else {
			stylePopup.left = nEventX + document.body.scrollLeft + 20;
		}

		stylePopup.visibility = "visible";
		document.onclick = PopupMenu_HandleClick;
	} else if (gbNav4) {
		layerPopup = document.layers.PopupMenu;
		layerPopup.visibility = "hide";
		stylePopup = layerPopup.document;
		stylePopup.write(strMenu);
		stylePopup.close();
		var e = fn_arguments[0];
		nEventX = e.pageX;
		nEventY = e.pageY;
		_BSPSGetClientSize();
		if (nEventY + layerPopup.clip.height + 20 < window.pageYOffset + gBsClientHeight) {
			nEventY += 20;
		} else {
			nEventY = gBsClientHeight + window.pageYOffset- layerPopup.clip.height - 20;
		}
		layerPopup.top = nEventY;

		if (nEventX + layerPopup.clip.width + 20 > gBsClientWidth + window.pageXOffset) {
			if (gBsClientWidth + window.pageXOffset - layerPopup.clip.width < 20) {
				nEventX = 5;
			} else {
				nEventX = gBsClientWidth + window.pageXOffset - layerPopup.clip.width - 20;
			}
		} else {
			nEventX += 20;
		}

		layerPopup.left = nEventX;

		layerPopup.visibility = "show";

//		window.captureEvents(Event.CLICK | Event.MOUSEDOWN);
		window.captureEvents(Event.MOUSEDOWN);
//		window.onclick = PopupMenu_HandleClick;
		window.onmousedown = PopupMenu_HandleClick;
	}

	window.gbInPopupMenu = true;
	window.gbPopupMenuTimeoutExpired = false;
	setTimeout("PopupMenu_Timeout();", 100);
	return false;
}


function PopupMenu_Timeout()
{
	window.gbPopupMenuTimeoutExpired = true;
}

function PopupMenu_Over(e)
{
    if (gbIE4) {
		e.srcElement.className = "PopupOver";
    } else if (gbNav4) {
//		this.bgColor = "red";
//        e.target.document.className = "PopupOver";
    }
	return;
}

function PopupMenu_Out(e)
{
    if (gbIE4) {
		e.srcElement.className = "PopupNotOver";
    } else if (gbNav4) {
        this.bgColor = "#f0f0f0";
    }
	return;
}


function PopupMenu_HandleClick(e)
{
	if (!window.gbPopupMenuTimeoutExpired) {
		return;
	}

	window.gbInPopupMenu = false;

	if (gbNav4) {
//		window.releaseEvents(Event.CLICK);
		window.releaseEvents(Event.MOUSEDOWN);
	}

	var layerPopup = null;
	var stylePopup = null;
	if (gbIE4) {
		layerPopup = document.all["PopupMenu"];
		stylePopup = layerPopup.style;
		stylePopup.visibility = "hidden";
	} else if (gbNav4) {
		layerPopup = document.layers.PopupMenu;
		layerPopup.visibility = "hide";
	}

	return;
}

// This function should be deleted when all old projects are cleaned up
function BSPSWritePopupFrameForIE4()
{
	return false;
}

/////////////////////////////////////////////////////////////////////
function BSSCPopup_ClickMac()
{
	if ((!DHTMLPopupSupport()) && (gbIE4))
	{	
		var bClickOnAnchor = false;
		var el;
		if ((window.event != null) &&
		    (window.event.srcElement != null))
		{
		    el = window.event.srcElement;
			while (el != null)
			{
				if ((el.tagName == "A") || (el.tagName == "AREA")) 	{
					bClickOnAnchor = true;
					break;
				}
				if (el.tagName == "BODY") {
					break;
				}
				el = el.parentElement;
			}
		}
		if (BSSCPopup_IsPopup())
		{
			if (!bClickOnAnchor) {
				parent.window.gPopupWindow = null;
				self.close();
			}
		}
		else
		{
			bClosePopupWindow = true;
			if ((bClickOnAnchor) &&
				(el.href) &&
			    (el.href.indexOf("javascript:BSSCPopup") != -1))
			{
				bClosePopupWindow = false;
			}
			if (bClosePopupWindow)
			{
				if (window.gPopupWindow != null)
				{
					var strParam = "titlebar=no,toolbar=no,status=no,location=no,menubar=no,resizable=yes,scrollbars=yes,height=300,width=400";
					window.gPopupWindow = window.open("", gstrPopupSecondWindowName,strParam);
					window.gPopupWindow.close();
					window.gPopupWindow = null;
				}
			}
		}
	}
 }

//////////////////////////////////////////////////////////////////////

_BSPSGetBrowserInfo();

function _BSSCOnLoad()
{
	if (!gbIE4 && !gbNav4)
		return;

	// Make everything visible in navigator
	if (gbNav4) {
		// Make some special effects items visible
		for (var iLayer = 0; iLayer < document.layers.length; iLayer++) {
			document.layers[iLayer].visibility = gBsStyVisShow;
			document.layers[iLayer].left = 0;
		}
	}

	// Remove the NavBar if necessary
	RemoveNavBar();
		
	// Don't continue without IE4
	if (gbIE4) {
		HHActivateComponents();
		doStaticEffects();
		startAnimationSet(0);
	}
}

function _BSSCOnUnload()
{
}

function _BSSCOnClick()
{
	if (!gbIE4)
		return;

	BSSCPopup_ClickMac();
	startNextAnimationSet();
}

function _BSSCOnError(message)
{
	if(-1 != message.indexOf("denied") 
		|| -1 != message.indexOf("Object required"))
	 return true;
}


function ResizeBasedonRate(thisWindow, size, rate, maxx, maxy)
{
	x = maxx;
	y = maxy;
	deltax = -maxx/2;
	while (true) {
		x = x + deltax;
		thisWindow.resizeTo(x, y);
		thisWindow.resizeTo(x, y);
		diffy = thisWindow.document.body.scrollHeight + gBscrollHeight - x * rate;
		if (diffy >  gBpermitYDelta ) // it is higher than wanted, so x need to be wide a little bitter
			deltax = Math.abs(deltax) /2;
		else if (diffy <  -permitYDelta) // it is shorter than wanted, so x need to be narrow a little bitter
			deltax = -Math.abs(deltax) /2;
		else 
			// the y is close enough to wanted.
			break;
		if (Math.abs(deltax) < gBpermitXDelta) // the next change is too slight and it can be ignore.
			break;
		//j ++;
				
	}
	size.x = thisWindow.document.body.scrollWidth; //+ gBscrollWidth;
	size.y = thisWindow.document.body.scrollHeight;// + gBscrollHeight;	
	thisWindow.document.body.scroll = 'no'; // At this time we do not want to show scroll any more. so it will looks better a little.
}

//////////BSSCDHTML Section Embedded Code//////////
var s_strAgent = navigator.userAgent.toLowerCase();
var s_nVer	   = parseInt(navigator.appVersion);

var s_bIE  = (s_strAgent.indexOf('msie') != -1);
var s_bNS  = (s_strAgent.indexOf('mozilla') != -1) && ((s_strAgent.indexOf('spoofer') == -1) && (s_strAgent.indexOf('compatible') == -1));
var s_bOpera	= (s_strAgent.indexOf('opera') != -1);

var s_bIE3Before = ((s_bIE) && (s_nVer <= 2));
var s_bNS3Before = ((s_bNS) && (s_nVer <= 3));

var s_bNS2		= ((s_bNS) && (s_nVer <= 2));
var s_bNS3		= ((s_bNS) && (s_nVer == 3));
var s_bIE300301	= ((s_bIE) && (s_nVer == 2) && ((s_strAgent.indexOf("3.00") != -1)||(s_strAgent.indexOf("3.0a") != -1)||(s_strAgent.indexOf("3.0b")!=-1)||(s_strAgent.indexOf("3.01")!=-1)));
var s_bIE302	= ((s_bIE) && (s_nVer == 2) && (s_strAgent.indexOf("3.02") != -1));


function HasExtJs()
{
	if (s_bIE3Before) { return false;}
	if (s_bNS3Before) {	return false;}
	if (typeof (_BSSCOnLoad) == "undefined"){ return false; }
	return true;
}

function BSSCOnLoad()
{
	if (HasExtJs()) { _BSSCOnLoad(); }
}

function BSSCOnUnload()
{
	if (HasExtJs()) { _BSSCOnUnload(); }
}

function BSSCOnClick()
{
	if (HasExtJs()) { _BSSCOnClick(); }
}

function BSSCOnError(message)
{
	if (HasExtJs()) { return _BSSCOnError(message); }
}


function WritePopupMenuLayer()
{
	if (HasExtJs()) {_WritePopupMenuLayer();}
}

function BSSCCreatePopupDiv()
{
	if (HasExtJs()) {_BSSCCreatePopupDiv();	}
}

function BSSCPopup(strURL)
{
	if (HasExtJs())	{ 
		_BSSCPopup(strURL);
	}else{
		//Create a temporary window first to ensure the real popup comes up on top
		var wndTemp = null;
		if (!s_bNS3) {
			wndTemp = window.open("", "temp", "titlebar=no,toolbar=no,status=no,location=no,menubar=no,resizable=yes,scrollbars=yes,height=3,width=4");
		}
		// Create the real popup window
		var wndPopup = window.open(strURL, "BSSCPopup", "titlebar=no,toolbar=no,status=no,location=no,menubar=no,resizable=yes,scrollbars=yes,height=300,width=400");
		// Close the temporary
		if (!s_bNS3) {
			wndTemp.close();
		} else {
			wndPopup.focus();
		}
	}
}

var gbWndTemp = null, gbWndPopupLinks = null;
var gbstrParaTotal = "";

function PopupMenu_Invoke()
{
	if (HasExtJs()) {
		return _PopupMenu_Invoke(PopupMenu_Invoke.arguments);
	}
	if (s_bNS3Before || s_bIE3Before )	{
		var argLen 	= PopupMenu_Invoke.arguments.length;
		if (argLen < 5) {
			window.document.location.href = PopupMenu_Invoke.arguments[3];
			return false;
		}
		gbWndTemp = null;
		gbWndPopupLinks = null;
		gbstrParatotal = "";
		for (var i = 0; i < (argLen - 2) / 2; i++) {
			var strParaLine = "";
			if (s_bNS2 || s_bOpera){
				strParaLine += "<a href=\"";
				strParaLine += PopupMenu_Invoke.arguments[2 * i + 3];
				strParaLine += "\">"
				strParaLine += PopupMenu_Invoke.arguments[2 * i + 2];
				strParaLine += "</a>";
			} else {
				strParaLine += "<a href=\"javascript:";
				strParaLine += "gotoUrl(\'";
				strParaLine += PopupMenu_Invoke.arguments[2 * i + 3];
				strParaLine += "\');\"";
				if (PopupMenu_Invoke.arguments[1] != '') {
					strParaLine += " TARGET='" + PopupMenu_Invoke.arguments[1] + "'";
				}
				strParaLine += ">";
				strParaLine += PopupMenu_Invoke.arguments[2 * i + 2];
				strParaLine += "</a>";
			}
			strParaLine += "<br>";
			gbstrParaTotal += strParaLine;
		}
		var nHeight = argLen * 15;
		var nWidth = 400;
		var strParam = "titlebar=no,toolbar=no,status=no,location=no,menubar=no,resizable=yes,scrollbars=auto";
		strParam += ",height=" + nHeight + ",width=200,resizable";
		
		//Create a temporary window first to ensure the real popup comes up on top
		//var wndTemp = null;
		if (!s_bNS3) {
			gbWndTemp = window.open("", "temp", "titlebar=no,toolbar=no,status=no,location=no,menubar=no,resizable=yes,scrollbars=yes,height=3,width=4");
		} 
		gbWndPopupLinks = window.open("", "popuplinks", strParam);

		setTimeout("Wait_PopupMenuReady()", 100);
	}
	return true;
}

function Wait_PopupMenuReady() 
{
	if (gbWndPopupLinks != null && "object" == typeof(gbWndPopupLinks.document)) {
		PopupMenu_InvokeReady();
	}
	else 
		setTimeout("Wait_PopupMenuReady()", 100);
}


function PopupMenu_InvokeReady()
{
	if (gbWndPopupLinks != null) {
		gbWndPopupLinks.document.open("text/html");
		gbWndPopupLinks.document.write("<html><head>");
		if (s_bNS2 || s_bOpera) {
			gbWndPopupLinks.document.write("<base href=\"" + location +"\">");
		} else {
			//YJ: IE301,302 and NS3.x works fine
			gbWndPopupLinks.document.write("<");
			gbWndPopupLinks.document.write("script>");
			gbWndPopupLinks.document.write("function gotoUrl(aUrl) {opener.window.location=aUrl; close();}");
			gbWndPopupLinks.document.write("<");
			gbWndPopupLinks.document.write("/script>");
		}
		gbWndPopupLinks.document.write("</head><body onBlur=\'self.focus();\'>");
		gbWndPopupLinks.document.write(gbstrParaTotal);
		gbWndPopupLinks.document.write("</body></html>");
		gbWndPopupLinks.document.close();

		// Close the temporary
		if (!s_bNS3 && gbWndTemp != null) {
			gbWndTemp.close();
		}else {
			gbWndPopupLinks.focus();
		}

		return true;
	}
	return false;
}

  
onload = BSSCOnLoad;
document.onclick = BSSCOnClick;
onunload = BSSCOnUnload;
onerror = BSSCOnError;