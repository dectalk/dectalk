	TITLE	D:\work\product\dapi\src\api\ttsapi.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_gnInstanceCounter
PUBLIC	_tl_gnInstanceCounter
PUBLIC	_gpufdic
PUBLIC	_gufdic_entries
PUBLIC	_szLicenseKey
PUBLIC	_hMapObject
_DATA	SEGMENT
COMM	_LanguageParamsArray:QWORD
_DATA	ENDS
_BSS	SEGMENT
_gnInstanceCounter DD 01H DUP (?)
_tl_gnInstanceCounter DB 0cH DUP (?)
_gpufdic DD	01H DUP (?)
_gufdic_entries DD 01H DUP (?)
_guiLoadedLicenseShare DD 01H DUP (?)
_lpvMemLicense DD 01H DUP (?)
_hMapObject DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_szLicenseKey DB 'Software\DECtalk Software\DECtalk\4.60', 00H
	ORG $+1
_?wExponentLut@?1??LinearToMuLaw@@9@9 DW 00H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
_ptab	DB	065H
	DB	03H
	DB	061H
	DB	06H
	DB	069H
	DB	01H
	DB	045H
	DB	04H
	DB	041H
	DB	07H
	DB	049H
	DB	02H
	DB	04fH
	DB	0cH
	DB	06fH
	DB	0bH
	DB	075H
	DB	0eH
	DB	05eH
	DB	09H
	DB	057H
	DB	08H
	DB	059H
	DB	010H
	DB	052H
	DB	0fH
	DB	063H
	DB	0aH
	DB	040H
	DB	05H
	DB	055H
	DB	0dH
	DB	07cH
	DB	012H
	DB	078H
	DB	011H
	DB	070H
	DB	02dH
	DB	074H
	DB	02fH
	DB	06bH
	DB	031H
	DB	066H
	DB	025H
	DB	054H
	DB	027H
	DB	073H
	DB	029H
	DB	053H
	DB	02bH
	DB	043H
	DB	036H
	DB	077H
	DB	018H
	DB	079H
	DB	019H
	DB	068H
	DB	01cH
	DB	06cH
	DB	01bH
	DB	04cH
	DB	022H
	DB	04eH
	DB	024H
	DB	062H
	DB	02eH
	DB	064H
	DB	030H
	DB	067H
	DB	032H
	DB	076H
	DB	026H
	DB	044H
	DB	028H
	DB	07aH
	DB	02aH
	DB	05aH
	DB	02cH
	DB	04aH
	DB	037H
	DB	06dH
	DB	01fH
	DB	06eH
	DB	020H
	DB	047H
	DB	021H
	DB	072H
	DB	01aH
	DB	071H
	DB	035H
	DB	051H
	DB	034H
	DB	026H
	DB	033H
	DB	046H
	DB	038H
	DB	042H
	DB	013H
	DB	04bH
	DB	014H
	DB	050H
	DB	015H
	DB	04dH
	DB	016H
	DB	06aH
	DB	017H
	DB	02cH
	DB	073H
	DB	020H
	DB	06fH
	DB	09H
	DB	06fH
	DB	027H
	DB	067H
	DB	060H
	DB	066H
	DB	022H
	DB	068H
	DB	023H
	DB	06eH
	DB	028H
	DB	070H
	DB	029H
	DB	071H
	DB	02aH
	DB	06dH
	DB	07eH
	DB	064H
	DB	02dH
	DB	06cH
_DATA	ENDS
PUBLIC	_all_digits
_TEXT	SEGMENT
_input$ = 8
_all_digits PROC NEAR

; 579  : 	while (*input)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _input$[esp-4]
  00004	8a 01		 mov	 al, BYTE PTR [ecx]
  00006	84 c0		 test	 al, al
  00008	74 10		 je	 SHORT $L71516
$L71515:

; 580  : 	{
; 581  : 		if (*input<'0' || *input >'9')

  0000a	3c 30		 cmp	 al, 48			; 00000030H
  0000c	7c 12		 jl	 SHORT $L73226
  0000e	3c 39		 cmp	 al, 57			; 00000039H
  00010	7f 0e		 jg	 SHORT $L73226
  00012	8a 41 01	 mov	 al, BYTE PTR [ecx+1]

; 583  : 		input++;

  00015	41		 inc	 ecx
  00016	84 c0		 test	 al, al
  00018	75 f0		 jne	 SHORT $L71515
$L71516:

; 584  : 	}
; 585  : 	return(1);

  0001a	b8 01 00 00 00	 mov	 eax, 1

; 586  : }

  0001f	c3		 ret	 0
$L73226:

; 582  : 			return(0);

  00020	33 c0		 xor	 eax, eax

; 586  : }

  00022	c3		 ret	 0
_all_digits ENDP
_TEXT	ENDS
PUBLIC	_LibMain@12
_TEXT	SEGMENT
_LibMain@12 PROC NEAR

; 641  : 	switch(ul_reason_being_called)
; 642  : 	{
; 643  : 	/*
; 644  : 	* DLL is attaching to a process.It could be
; 645  : 	* while process getting loaded (The process 
; 646  : 	* might have used load-time dynamic linking i.e
; 647  : 	* built using dectalk.lib import library)
; 648  : 	* OR   
; 649  : 	* Process made a call to LoadLibrary(dectalk.dll)
; 650  : 		*/
; 651  : 	case DLL_PROCESS_ATTACH :
; 652  : 		//#ifdef LICENSES
; 653  : 		//              if (!AddLicenseRef())
; 654  : 		//                      return FALSE; // no licenses.
; 655  : 		//#endif
; 656  : 		break;
; 657  : 	case DLL_THREAD_ATTACH:
; 658  : 		break;
; 659  : 	case DLL_THREAD_DETACH:
; 660  : 		break;
; 661  : 	case DLL_PROCESS_DETACH :
; 662  : 		//#ifdef LICENSES
; 663  : 		//              ReleaseLicenseRef();
; 664  : 		//#endif
; 665  : 		break;
; 666  : 	}
; 667  : 	
; 668  : 	return(TRUE);

  00030	b8 01 00 00 00	 mov	 eax, 1

; 669  : 	//  return( 1 );
; 670  : 	//  UNREFERENCED_PARAMETER( hInst );
; 671  : 	//  UNREFERENCED_PARAMETER( ul_reason_being_called );
; 672  : 	//  UNREFERENCED_PARAMETER( lpReserved );
; 673  : }

  00035	c2 0c 00	 ret	 12			; 0000000cH
_LibMain@12 ENDP
_TEXT	ENDS
PUBLIC	_AddLicenseRef
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	__imp__CreateFileMappingA@24:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	__imp__fclose:NEAR
EXTRN	__imp__fflush:NEAR
EXTRN	__imp__fopen:NEAR
EXTRN	__imp__fprintf:NEAR
EXTRN	__imp__MapViewOfFile@20:NEAR
EXTRN	__imp__UnmapViewOfFile@4:NEAR
EXTRN	__strdate:NEAR
EXTRN	__strtime:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71581 DB	'a+', 00H
	ORG $+1
$SG71582 DB	'\dtlic.log', 00H
	ORG $+1
$SG71588 DB	'%s %s : Text-to-speech license information invalid!', 0aH
	DB	00H
	ORG $+3
$SG71593 DB	'DECtalkDllLicensememfilemap', 00H
$SG71611 DB	'a+', 00H
	ORG $+1
$SG71612 DB	'\dtlic.log', 00H
	ORG $+1
$SG71616 DB	'%s %s : Insufficient Text-to-Speech Run-time Licenses.', 0aH
	DB	00H
_DATA	ENDS
_TEXT	SEGMENT
_szDateBuf$71584 = -64
_szTimeBuf$71585 = -128
_szDateBuf$71614 = -128
_szTimeBuf$71615 = -64
_AddLicenseRef PROC NEAR

; 753  : {

  00040	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00046	56		 push	 esi
  00047	57		 push	 edi

; 754  : 	BOOL fInit,fIgnore;
; 755  : 	DWORD dwMAXRunTimeLicenses ;
; 756  : 	DWORD dwLicenseCount;
; 757  : 	
; 758  : 
; 759  : 	dwMAXRunTimeLicenses = GetFromSomeWhere();

  00048	e8 00 00 00 00	 call	 _GetFromSomeWhere
  0004d	8b f8		 mov	 edi, eax

; 760  : 	
; 761  : 	if(dwMAXRunTimeLicenses == LICENSE_KEY_ERROR)

  0004f	83 ff ff	 cmp	 edi, -1
  00052	75 5f		 jne	 SHORT $L71579

; 762  : 	{
; 763  : #ifndef UNDER_CE
; 764  : #ifdef DEBUG // removed message box from release code BATS#741
; 765  : 		MessageBox(NULL,"Text-to-speech license information invalid!",
; 766  : 			"LicenseKey",MB_ICONSTOP|MB_OK);
; 767  : #endif
; 768  : 		{
; 769  : 			FILE *outfile;
; 770  : 			outfile=fopen("\\dtlic.log","a+");

  00054	68 00 00 00 00	 push	 OFFSET FLAT:$SG71581
  00059	68 00 00 00 00	 push	 OFFSET FLAT:$SG71582
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00064	8b f0		 mov	 esi, eax
  00066	83 c4 08	 add	 esp, 8

; 771  : 			if (outfile)

  00069	85 f6		 test	 esi, esi
  0006b	74 3b		 je	 SHORT $L71613

; 772  : 			{
; 773  : 				char szDateBuf[64];
; 774  : 				char szTimeBuf[64];
; 775  : 			   // log the pertinent info
; 776  : 			   _strdate(szDateBuf);

  0006d	8d 44 24 48	 lea	 eax, DWORD PTR _szDateBuf$71584[esp+136]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 __strdate

; 777  : 			   _strtime(szTimeBuf);

  00077	8d 4c 24 0c	 lea	 ecx, DWORD PTR _szTimeBuf$71585[esp+140]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 __strtime

; 778  : 			   fprintf(outfile,"%s %s : Text-to-speech license information invalid!\n",
; 779  : 				   szDateBuf, szTimeBuf);

  00081	8d 54 24 10	 lea	 edx, DWORD PTR _szTimeBuf$71585[esp+144]
  00085	8d 44 24 50	 lea	 eax, DWORD PTR _szDateBuf$71584[esp+144]
  00089	52		 push	 edx
  0008a	50		 push	 eax
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:$SG71588
$L73231:
  00090	56		 push	 esi
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf

; 780  : 			   fflush(outfile);

  00097	56		 push	 esi
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush

; 781  : 			   fclose(outfile);

  0009e	56		 push	 esi
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000a5	83 c4 20	 add	 esp, 32			; 00000020H
$L71613:
  000a8	5f		 pop	 edi

; 782  : 			}
; 783  : 		}
; 784  : 
; 785  : #else
; 786  : #ifdef DEBUG // removed message box from release code BATS#790
; 787  : 
; 788  : 		MessageBox(NULL,_T("Text-to-speech license information invalid!"),
; 789  : 			_T("LicenseKey"),MB_ICONSTOP|MB_OK);
; 790  : #endif
; 791  : #endif
; 792  : 		return FALSE;  // Don't load DLL

  000a9	33 c0		 xor	 eax, eax
  000ab	5e		 pop	 esi

; 940  : 	}
; 941  : 	
; 942  : }

  000ac	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  000b2	c3		 ret	 0
$L71579:

; 793  : 	}
; 794  : 	/* Create a named file mapping object */ 
; 795  : 	// 0 means Unlimited Licenses :Just return from DllEntry function.
; 796  : 	if(!dwMAXRunTimeLicenses)     

  000b3	85 ff		 test	 edi, edi

; 797  : 		return TRUE;

  000b5	0f 84 16 01 00
	00		 je	 $L71606

; 798  : 	if (!guiLoadedLicenseShare)			 /* tek 08Jan97 BATS 205*/

  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _guiLoadedLicenseShare
  000c0	85 c0		 test	 eax, eax
  000c2	75 7b		 jne	 SHORT $L73230

; 799  : 	{
; 800  : 		hMapObject = CreateFileMapping( 
; 801  : 			(HANDLE) 0xFFFFFFFF, /* use paging file    */ 
; 802  : 			NULL,                /* no security attr.  */ 
; 803  : 			PAGE_READWRITE,      /* read/write access  */ 
; 804  : 			0,                   /* size: high 32-bits */ 
; 805  : 			SHMEMSIZE,           /* size: low 32-bits  */
; 806  : #ifndef ACI_LICENSE	//tek 01may97
; 807  : #ifdef WILLOWPOND
; 808  : 			"wpDECtalkDllLicensememfilemap");    /* name of map object */
; 809  : #else // not aci, not willowpond
; 810  : #ifdef ACCESS32 // tek 15sep97
; 811  : 		"a32DECtalkDllFileMap");                        /* name of map object */
; 812  : #else // not aci, not willowpond, not access32
; 813  : 		"DECtalkDllLicensememfilemap");    /* name of map object */

  000c4	68 00 00 00 00	 push	 OFFSET FLAT:$SG71593
  000c9	6a 0a		 push	 10			; 0000000aH
  000cb	6a 00		 push	 0
  000cd	6a 04		 push	 4
  000cf	6a 00		 push	 0
  000d1	6a ff		 push	 -1
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingA@24

; 814  : #endif //ACCESS32
; 815  : #endif //WILLOWPOND
; 816  : #else
; 817  : 		"AciSpeechLicenseMemFileMap");	/* name of map object */
; 818  : #endif
; 819  : 		
; 820  : 		if (hMapObject == NULL) 

  000d9	85 c0		 test	 eax, eax
  000db	a3 00 00 00 00	 mov	 DWORD PTR _hMapObject, eax
  000e0	75 09		 jne	 SHORT $L71595
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 940  : 	}
; 941  : 	
; 942  : }

  000e4	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  000ea	c3		 ret	 0
$L71595:

; 821  : 			return FALSE; 
; 822  : 		
; 823  : 		/* The first process to attach initializes memory. */ 
; 824  : 		
; 825  : 		fInit = (GetLastError() != ERROR_ALREADY_EXISTS); 

  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 826  : #ifdef ACCESS32 //tek 15sep97 SMIT licensing
; 827  : 		// ACCESS32 requires the SMITxx code to do the init..
; 828  : 		if (fInit)      // false if the section already exists
; 829  : 		{
; 830  : 			// get rid of the handle
; 831  : 			CloseHandle(hMapObject);
; 832  : 			// return a license failure.
; 833  : 			return FALSE;
; 834  : 		} // if (fInit)
; 835  : #endif //ACCESS32
; 836  : 		/* Get a pointer to the file-mapped shared memory. */
; 837  : 		
; 838  : 		lpvMemLicense = MapViewOfFile( 
; 839  : 			hMapObject,     /* object to map view of    */ 
; 840  : 			FILE_MAP_WRITE, /* read/write access        */ 
; 841  : 			0,              /* high offset:   map from  */ 
; 842  : 			0,              /* low offset:    beginning */ 
; 843  : 			0);             /* default: map entire file */ 

  000f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hMapObject
  000f7	33 c9		 xor	 ecx, ecx
  000f9	6a 00		 push	 0
  000fb	3d b7 00 00 00	 cmp	 eax, 183		; 000000b7H
  00100	6a 00		 push	 0
  00102	6a 00		 push	 0
  00104	0f 95 c1	 setne	 cl
  00107	6a 02		 push	 2
  00109	52		 push	 edx
  0010a	8b f1		 mov	 esi, ecx
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20

; 844  : 		if (lpvMemLicense == NULL) 

  00112	85 c0		 test	 eax, eax
  00114	a3 00 00 00 00	 mov	 DWORD PTR _lpvMemLicense, eax
  00119	75 09		 jne	 SHORT $L71597
  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi

; 940  : 	}
; 941  : 	
; 942  : }

  0011d	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00123	c3		 ret	 0
$L71597:

; 845  : 			return FALSE; 
; 846  : 		
; 847  : 		/* Initialize memory if this is the first process. */ 
; 848  : 		if (fInit)

  00124	85 f6		 test	 esi, esi
  00126	74 0b		 je	 SHORT $L71598

; 849  : 		{
; 850  : 			//memset(lpvMemLicense, '\0', SHMEMSIZE);
; 851  : 			*(PDWORD)lpvMemLicense = (DWORD)0;

  00128	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
$L71598:

; 852  : 			// To set the Number of Licenses
; 853  : 			
; 854  : 		}
; 855  : #ifdef ACCESS32 //tek 15sep97 SMIT licensing
; 856  :         else
; 857  :         {
; 858  : 			char *szMemLicense=NULL;
; 859  : 			char szEncryptedString[512]="";
; 860  : 			UINT uiResult=0;
; 861  : 			// we have to check that the memory area is valid..
; 862  : 			szMemLicense = (char *)(lpvMemLicense);
; 863  : 			strcpy(szEncryptedString,&szMemLicense[4]);     // this is [4], because the
; 864  : 			// first DWORD is the license
; 865  : 			// count.
; 866  : 			// decrypt it..
; 867  : 			uiResult = decryptString(szEncryptedString,
; 868  : 				DEFAULT_ACCESS32_KEY,
; 869  : 				gszA32Id);
; 870  : 			
; 871  : 			if (!uiResult)
; 872  : 			{
; 873  : 				// unmap the section
; 874  : 				UnmapViewOfFile(lpvMemLicense);
; 875  : 				// get rid of the handle
; 876  : 				CloseHandle(hMapObject);
; 877  : 				// return a license failure.
; 878  : 				return FALSE;
; 879  : 			}
; 880  :         }
; 881  : 		
; 882  : #endif //ACCESS32
; 883  : 		
; 884  : 		guiLoadedLicenseShare = TRUE;

  00133	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 1
  0013d	eb 05		 jmp	 SHORT $L71590
$L73230:
  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
$L71590:

; 885  : 	}
; 886  : 	/* tek 08jan97, BATS 205 */
; 887  : 	/* make sure we have the section.. */
; 888  : 	if (lpvMemLicense == NULL) 

  00144	85 c0		 test	 eax, eax
  00146	75 09		 jne	 SHORT $L71602
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi

; 940  : 	}
; 941  : 	
; 942  : }

  0014a	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00150	c3		 ret	 0
$L71602:

; 889  : 		return FALSE; 
; 890  : 	
; 891  : 	// Increment Run-time License Counter.(i.e How many Processes are using DECtalk.dll)
; 892  : 	(*(PDWORD)lpvMemLicense)++;

  00151	8b 30		 mov	 esi, DWORD PTR [eax]
  00153	46		 inc	 esi
  00154	89 30		 mov	 DWORD PTR [eax], esi

; 893  : 	dwLicenseCount =  (*(PDWORD)lpvMemLicense);
; 894  : 	
; 895  : 	if(*(PDWORD)lpvMemLicense > dwMAXRunTimeLicenses)

  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpvMemLicense
  0015c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0015e	3b c7		 cmp	 eax, edi
  00160	76 6f		 jbe	 SHORT $L71606

; 896  : 	{
; 897  : 		// Decrement Run-time License Counter.(i.e How many Processes are using DECtalk.dll)
; 898  : 		(*(PDWORD)lpvMemLicense)--;

  00162	48		 dec	 eax
  00163	89 01		 mov	 DWORD PTR [ecx], eax

; 899  : 		/* tek 08jan97 BATS 205 */
; 900  : 		/* only unmap the section if the count is zero - which */
; 901  : 		/* should never happen, I think.. */
; 902  : 		if (*(PDWORD)lpvMemLicense == 0)

  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  0016a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0016d	75 1d		 jne	 SHORT $L71609

; 903  : 		{
; 904  : 			/* Unmap shared memory from the process's address space. */ 
; 905  : 			fIgnore = UnmapViewOfFile(lpvMemLicense); 

  0016f	50		 push	 eax
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 906  : 			/* Close the process's handle to the file-mapping object. */ 
; 907  : 			fIgnore = CloseHandle(hMapObject); 

  00176	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  0017b	50		 push	 eax
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 908  : 			guiLoadedLicenseShare = FALSE;

  00182	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 0
$L71609:

; 909  : 		}
; 910  : 		
; 911  : #ifndef UNDER_CE
; 912  : #ifdef DEBUG // removed message box from release code BATS#741
; 913  : 		 MessageBox(NULL,"Insufficient Text-to-Speech Run-time Licenses.","Licenses",MB_ICONSTOP|MB_OK);
; 914  : #endif
; 915  :  		{
; 916  : 			FILE *outfile;
; 917  : 			outfile=fopen("\\dtlic.log","a+");

  0018c	68 00 00 00 00	 push	 OFFSET FLAT:$SG71611
  00191	68 00 00 00 00	 push	 OFFSET FLAT:$SG71612
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0019c	8b f0		 mov	 esi, eax
  0019e	83 c4 08	 add	 esp, 8

; 918  : 			if (outfile)

  001a1	85 f6		 test	 esi, esi
  001a3	0f 84 ff fe ff
	ff		 je	 $L71613

; 919  : 			{
; 920  : 				char szDateBuf[64];
; 921  : 				char szTimeBuf[64];
; 922  : 			   // log the pertinent info
; 923  : 			   _strdate(szDateBuf);

  001a9	8d 4c 24 08	 lea	 ecx, DWORD PTR _szDateBuf$71614[esp+136]
  001ad	51		 push	 ecx
  001ae	e8 00 00 00 00	 call	 __strdate

; 924  : 			   _strtime(szTimeBuf);

  001b3	8d 54 24 4c	 lea	 edx, DWORD PTR _szTimeBuf$71615[esp+140]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 __strtime

; 925  : 			   fprintf(outfile,"%s %s : Insufficient Text-to-Speech Run-time Licenses.\n",
; 926  : 				   szDateBuf, szTimeBuf);

  001bd	8d 44 24 50	 lea	 eax, DWORD PTR _szTimeBuf$71615[esp+144]
  001c1	8d 4c 24 10	 lea	 ecx, DWORD PTR _szDateBuf$71614[esp+144]
  001c5	50		 push	 eax
  001c6	51		 push	 ecx
  001c7	68 00 00 00 00	 push	 OFFSET FLAT:$SG71616

; 927  : 			   fflush(outfile);
; 928  : 			   fclose(outfile);
; 929  : 			}
; 930  : 		}
; 931  : 
; 932  : #else
; 933  : 		MessageBox(NULL,_T("Insufficient Text-to-Speech Run-time Licenses."),_T("Licenses"),MB_ICONSTOP|MB_OK);
; 934  : #endif
; 935  : 		return FALSE; //Don't load DLL

  001cc	e9 bf fe ff ff	 jmp	 $L73231
$L71606:
  001d1	5f		 pop	 edi

; 936  : 	}
; 937  : 	else
; 938  : 	{
; 939  : 		return TRUE;

  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	5e		 pop	 esi

; 940  : 	}
; 941  : 	
; 942  : }

  001d8	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  001de	c3		 ret	 0
_AddLicenseRef ENDP
_TEXT	ENDS
EXTRN	__imp__RegOpenKeyExA@20:NEAR
EXTRN	__imp__RegQueryValueExA@24:NEAR
EXTRN	_decryptString:NEAR
EXTRN	__imp__RegCloseKey@4:NEAR
EXTRN	__imp__atol:NEAR
_DATA	SEGMENT
$SG71566 DB	'Licenses', 00H
_DATA	ENDS
_TEXT	SEGMENT
_hKeyLicense$ = -212
_szLicensesEncrypted$ = -136
_szLicenses$ = -200
_dwType$ = -204
_cbData$ = -208
_GetFromSomeWhere PROC NEAR

; 682  : {

  001e0	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H

; 683  : #ifdef ACCESS32 // tek 15sep97 SMIT licensing
; 684  : #define ACCESS32_LICENSE_COUNT (4)
; 685  : 	return ACCESS32_LICENSE_COUNT;
; 686  : #else //ACCESS32
; 687  : 	HKEY hKeyLicense = NULL;
; 688  : 	// tek 01may97 key now comes from coop.h
; 689  : 	CHAR szLicensesEncrypted[MAX_STR];
; 690  : #ifdef UNDER_CE //mfg 09jan99 Windows CE support
; 691  : 	TCHAR wszLicensesEncrypted[MAX_STR/2];
; 692  : #endif
; 693  : 	char szLicenses[64];
; 694  : 	DWORD dwType,cbData;
; 695  : 	
; 696  : 	if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
; 697  : 		szLicenseKey,
; 698  : 		0,
; 699  : 		KEY_QUERY_VALUE,
; 700  : 		&hKeyLicense ) != ERROR_SUCCESS )

  001e6	8d 44 24 00	 lea	 eax, DWORD PTR _hKeyLicense$[esp+212]
  001ea	c7 44 24 00 00
	00 00 00	 mov	 DWORD PTR _hKeyLicense$[esp+212], 0
  001f2	50		 push	 eax
  001f3	6a 01		 push	 1
  001f5	6a 00		 push	 0
  001f7	68 00 00 00 00	 push	 OFFSET FLAT:_szLicenseKey
  001fc	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00207	85 c0		 test	 eax, eax

; 701  : 	{
; 702  : 		return LICENSE_KEY_ERROR;

  00209	75 79		 jne	 SHORT $L71569

; 703  : 	}
; 704  : 	else
; 705  : 	{
; 706  : 		cbData = MAX_STR;
; 707  : 		if ( RegQueryValueEx( hKeyLicense,
; 708  : #ifndef UNDER_CE //mfg 09jan99 Windows CE support
; 709  : 			"Licenses",
; 710  : #else
; 711  : 			TEXT("Licenses"),
; 712  : #endif
; 713  : 			NULL,
; 714  : 			&dwType,
; 715  : #ifndef UNDER_CE //mfg 09jan99 Windows CE support
; 716  : 			(LPBYTE)szLicensesEncrypted,
; 717  : #else
; 718  : 			(LPBYTE)wszLicensesEncrypted,
; 719  : #endif
; 720  : 			&cbData ) != ERROR_SUCCESS )

  0020b	8d 4c 24 04	 lea	 ecx, DWORD PTR _cbData$[esp+212]
  0020f	8d 54 24 4c	 lea	 edx, DWORD PTR _szLicensesEncrypted$[esp+212]
  00213	51		 push	 ecx
  00214	8b 4c 24 04	 mov	 ecx, DWORD PTR _hKeyLicense$[esp+216]
  00218	8d 44 24 0c	 lea	 eax, DWORD PTR _dwType$[esp+216]
  0021c	52		 push	 edx
  0021d	50		 push	 eax
  0021e	6a 00		 push	 0
  00220	68 00 00 00 00	 push	 OFFSET FLAT:$SG71566
  00225	51		 push	 ecx
  00226	c7 44 24 1c 86
	00 00 00	 mov	 DWORD PTR _cbData$[esp+236], 134 ; 00000086H
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00234	85 c0		 test	 eax, eax

; 721  : 		{
; 722  : 			return LICENSE_KEY_ERROR;

  00236	75 4c		 jne	 SHORT $L71569

; 723  : 		}       
; 724  : #ifdef UNDER_CE	//mfg 09jan99 Windows CE support
; 725  : WideStringtoAsciiString(szLicensesEncrypted, wszLicensesEncrypted, MAX_STR);
; 726  : #endif		
; 727  : 		RegCloseKey( hKeyLicense );

  00238	8b 54 24 00	 mov	 edx, DWORD PTR _hKeyLicense$[esp+212]
  0023c	52		 push	 edx
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 728  : 	}
; 729  : 	
; 730  : 	if (decryptString((const unsigned char *)szLicensesEncrypted,LICENSE_KEY,(unsigned char *)szLicenses))

  00243	8d 44 24 0c	 lea	 eax, DWORD PTR _szLicenses$[esp+212]
  00247	8d 4c 24 4c	 lea	 ecx, DWORD PTR _szLicensesEncrypted$[esp+212]
  0024b	50		 push	 eax
  0024c	68 13 61 00 00	 push	 24851			; 00006113H
  00251	51		 push	 ecx
  00252	e8 00 00 00 00	 call	 _decryptString
  00257	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025a	85 c0		 test	 eax, eax
  0025c	74 26		 je	 SHORT $L71569

; 731  : 	{
; 732  : 		if (all_digits(szLicenses)==0)

  0025e	8d 54 24 0c	 lea	 edx, DWORD PTR _szLicenses$[esp+212]
  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 _all_digits
  00268	83 c4 04	 add	 esp, 4
  0026b	85 c0		 test	 eax, eax

; 733  : 		{	
; 734  : 			return(LICENSE_KEY_ERROR);

  0026d	74 15		 je	 SHORT $L71569

; 735  : 		}
; 736  : 		return(atol(szLicenses));

  0026f	8d 44 24 0c	 lea	 eax, DWORD PTR _szLicenses$[esp+212]
  00273	50		 push	 eax
  00274	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atol
  0027a	83 c4 04	 add	 esp, 4

; 739  : #endif //ACCESS32
; 740  : }

  0027d	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  00283	c3		 ret	 0
$L71569:

; 737  : 	}
; 738  : 	return(LICENSE_KEY_ERROR);

  00284	83 c8 ff	 or	 eax, -1

; 739  : #endif //ACCESS32
; 740  : }

  00287	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0028d	c3		 ret	 0
_GetFromSomeWhere ENDP
_TEXT	ENDS
PUBLIC	_ReleaseLicenseRef
_TEXT	SEGMENT
_ReleaseLicenseRef PROC NEAR

; 951  : #ifndef LICENSES
; 952  : 	return;
; 953  : #else
; 954  : 	BOOL    fIgnore;
; 955  : 	DWORD dwMAXRunTimeLicenses ;
; 956  : 	dwMAXRunTimeLicenses = GetFromSomeWhere();

  00290	e8 00 00 00 00	 call	 _GetFromSomeWhere

; 957  : 	if(dwMAXRunTimeLicenses == LICENSE_KEY_ERROR)

  00295	83 f8 ff	 cmp	 eax, -1
  00298	74 35		 je	 SHORT $L71626

; 958  : 		return;
; 959  : 	if(!dwMAXRunTimeLicenses)  //MVP: For '0'licenses return.   

  0029a	85 c0		 test	 eax, eax
  0029c	74 31		 je	 SHORT $L71626

; 960  : 		return;
; 961  : 	// Decrement Run-time license counter.
; 962  : 	(*(PDWORD)lpvMemLicense)--;

  0029e	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  002a3	8b 10		 mov	 edx, DWORD PTR [eax]
  002a5	4a		 dec	 edx
  002a6	89 10		 mov	 DWORD PTR [eax], edx

; 963  : 	if (*(PDWORD)lpvMemLicense == 0)  /* tek 08jan96 BATS 205 */

  002a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  002ad	83 38 00	 cmp	 DWORD PTR [eax], 0
  002b0	75 1d		 jne	 SHORT $L71626

; 964  : 	{
; 965  : 		/* Unmap shared memory from the process's address space. */ 
; 966  : 		fIgnore = UnmapViewOfFile(lpvMemLicense); 

  002b2	50		 push	 eax
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 967  : 		/* Close the process's handle to the file-mapping object. */ 
; 968  : 		fIgnore = CloseHandle(hMapObject); 

  002b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  002be	50		 push	 eax
  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 969  : 		guiLoadedLicenseShare = FALSE;

  002c5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 0
$L71626:

; 970  : 	}
; 971  : #endif // LICENSES ( above GetFromSomeWhere() )
; 972  : }

  002cf	c3		 ret	 0
_ReleaseLicenseRef ENDP
_TEXT	ENDS
PUBLIC	__real@8@4008fa00000000000000
PUBLIC	_TextToSpeechStartupEx
PUBLIC	_TextToSpeechReset
PUBLIC	_PlayAudioCallbackRoutine
EXTRN	__imp__calloc:NEAR
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__InitializeCriticalSection@4:NEAR
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	_create_pipe:NEAR
EXTRN	__imp__RegisterWindowMessageA@4:NEAR
EXTRN	_PA_CreatePlayHandle:NEAR
EXTRN	__fltused:NEAR
EXTRN	_PA_GetFormat:NEAR
EXTRN	_cmd_main@4:NEAR
EXTRN	_lts_main@4:NEAR
EXTRN	_ph_main@4:NEAR
EXTRN	_vtm_main@4:NEAR
EXTRN	_sync_main@4:NEAR
EXTRN	_OP_CreateMutex:NEAR
_DATA	SEGMENT
	ORG $+3
$SG71765 DB	'DECtalkErrorMessage', 00H
$SG71767 DB	'DECtalkIndexMessage', 00H
$SG71769 DB	'DECtalkBookmarkMessage', 00H
	ORG $+1
$SG71771 DB	'DECtalkWordposMessage', 00H
	ORG $+2
$SG71773 DB	'DECtalkStartMessage', 00H
$SG71775 DB	'DECtalkStopMessage', 00H
	ORG $+1
$SG71777 DB	'DECtalkVisualMessage', 00H
	ORG $+3
$SG71779 DB	'DECtalkBufferMessage', 00H
_DATA	ENDS
;	COMDAT __real@8@4008fa00000000000000
; File D:\work\product\dapi\src\api\ttsapi.c
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_pphTTS$ = 8
_uiDeviceNumber$ = 12
_dwDeviceOptions$ = 16
_DtCallbackRoutine$ = 20
_dwTTSInstanceParameter$ = 24
_pPlayAudio$ = -16
_cmd_pipe$ = 20
_lts_pipe$ = -8
_vtm_pipe$ = 24
_sync_pipe$ = -12
_TextToSpeechStartupEx PROC NEAR

; 1470 : {

  002d0	83 ec 10	 sub	 esp, 16			; 00000010H
  002d3	53		 push	 ebx
  002d4	55		 push	 ebp
  002d5	56		 push	 esi
  002d6	57		 push	 edi

; 1471 : 	MMRESULT mmStatus;
; 1472 : 	UINT i;
; 1473 : #if defined __osf__ || defined __linux__
; 1474 : 	int  productIndex; /* Index into product license list */
; 1475 : #endif
; 1476 : 	
; 1477 : #ifdef OLEDECTALK
; 1478 : 	LPAUDIO_HANDLE_T pPlayAudio;
; 1479 : #else
; 1480 : 	HPLAY_AUDIO_T pPlayAudio;         //New audio Integration
; 1481 : #endif //OLEDECTALK
; 1482 : 	
; 1483 : 	LPWAVEFORMATEX pWaveFormat;	// 01aug97 bats423: now used for both SAPI and DAPI
; 1484 : 	
; 1485 : 	LPTTS_HANDLE_T phTTS;
; 1486 : 	int nReturnCode;           /*MVP : a variable to hold the return value of this API*/
; 1487 : 	
; 1488 : 	P_PIPE cmd_pipe = NULL_PIPE;
; 1489 : 	P_PIPE lts_pipe = NULL_PIPE;
; 1490 : 	P_PIPE ph_pipe  = NULL_PIPE;
; 1491 : 	P_PIPE vtm_pipe = NULL_PIPE;
; 1492 : 	P_PIPE sync_pipe = NULL_PIPE;
; 1493 : 
; 1494 : #ifdef NEW_TRANSPORT
; 1495 : 	P_PIPE new_lts_pipe = NULL_PIPE;
; 1496 : #endif
; 1497 : 
; 1498 : 	/* Define a variable for kernel_share_data to allocate after dynamically :MVP
; 1499 : 	*/
; 1500 : 	PKSD_T pKsd_t = NULL;
; 1501 : 	
; 1502 : #ifdef LICENSES
; 1503 : #if defined WIN32 || defined __linux__
; 1504 : #define MAX_INSTANCES_EXCEEDED  (MMSYSERR_ALLOCATED) // tek 29jul96
; 1505 : 	if (!AddLicenseRef())

  002d7	e8 00 00 00 00	 call	 _AddLicenseRef
  002dc	85 c0		 test	 eax, eax
  002de	75 0d		 jne	 SHORT $L71660
  002e0	5f		 pop	 edi
  002e1	5e		 pop	 esi
  002e2	5d		 pop	 ebp

; 1506 : 	{
; 1507 : 		return MAX_INSTANCES_EXCEEDED;

  002e3	b8 04 00 00 00	 mov	 eax, 4
  002e8	5b		 pop	 ebx

; 2663 : }

  002e9	83 c4 10	 add	 esp, 16			; 00000010H
  002ec	c3		 ret	 0
$L71660:

; 1508 : 	}
; 1509 : #else
; 1510 : 	/* Check for a valid license */
; 1511 : 	mmStatus = CheckLicenses();
; 1512 : 	if (mmStatus)
; 1513 : 	{
; 1514 : 		if (mmStatus == LIC_NO_MORE_UNITS)
; 1515 : 			return (MMSYSERR_ALLOCATED);
; 1516 : 		else
; 1517 : 			if (mmStatus == LIC_NO_PAK)
; 1518 : 				return (MMSYSERR_NOTENABLED);
; 1519 : 			else
; 1520 : 				return (MMSYSERR_ERROR);
; 1521 : 	}
; 1522 : #endif /* WIN32 */
; 1523 : #endif //LICENSES
; 1524 : 	
; 1525 : 	/********************************************************************/
; 1526 : 	/*  Set default parameters.                                         */
; 1527 : 	/********************************************************************/
; 1528 : 	
; 1529 : 	/* 
; 1530 : 	* Allocate kernel_share_data structure to make unique for each instance MVP
; 1531 : 	*/
; 1532 : 	
; 1533 : 	if((pKsd_t = (PKSD_T) calloc(1,sizeof(KSD_T))) == NULL)

  002ed	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__calloc
  002f3	bd 01 00 00 00	 mov	 ebp, 1
  002f8	68 88 04 00 00	 push	 1160			; 00000488H
  002fd	55		 push	 ebp
  002fe	ff d6		 call	 esi
  00300	8b d8		 mov	 ebx, eax
  00302	33 ff		 xor	 edi, edi
  00304	83 c4 08	 add	 esp, 8
  00307	3b df		 cmp	 ebx, edi

; 1534 : 	{
; 1535 : #if defined WIN32 || defined __linux__
; 1536 : #ifdef LICENSES
; 1537 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1538 : #endif //LICENSES
; 1539 : 		return( MMSYSERR_NOMEM );

  00309	0f 84 53 04 00
	00		 je	 $L73243

; 1540 : #endif /* WIN32 */
; 1541 : 	}
; 1542 : 	
; 1543 : 	/* GL 09/25/1997 initialize the dictionary entry */
; 1544 : 	for (i=0; i < MAX_languages; ++i)

  0030f	8d 43 38	 lea	 eax, DWORD PTR [ebx+56]
  00312	b9 07 00 00 00	 mov	 ecx, 7
$L71665:

; 1545 : 	{
; 1546 : 		pKsd_t->adic[i] = 0;

  00317	89 78 38	 mov	 DWORD PTR [eax+56], edi

; 1547 : 		pKsd_t->udic[i] = 0;

  0031a	89 38		 mov	 DWORD PTR [eax], edi

; 1548 : 		pKsd_t->fdic[i] = 0;

  0031c	89 78 c8	 mov	 DWORD PTR [eax-56], edi

; 1549 : 		pKsd_t->adic_entries[i] = 0;

  0031f	89 78 54	 mov	 DWORD PTR [eax+84], edi

; 1550 : 		pKsd_t->udic_entries[i] = 0;

  00322	89 78 1c	 mov	 DWORD PTR [eax+28], edi

; 1551 : 		pKsd_t->fdic_entries[i] = 0;

  00325	89 78 e4	 mov	 DWORD PTR [eax-28], edi
  00328	83 c0 04	 add	 eax, 4
  0032b	49		 dec	 ecx
  0032c	75 e9		 jne	 SHORT $L71665

; 1552 : 	}
; 1553 : 	
; 1554 : 	pKsd_t->cmd_flush = FALSE;
; 1555 : 	pKsd_t->spc_flush = FALSE;
; 1556 : 	pKsd_t->halting = FALSE;
; 1557 : 	pKsd_t->logflag  = 0;
; 1558 : 	/* GL 11/15/1996 set defaulted Spanish to Latin */
; 1559 : #ifdef SPANISH_LA
; 1560 : 	pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
; 1561 : #else
; 1562 : 	pKsd_t->modeflag = MODE_CITATION;
; 1563 : #endif //SPANISH_LA
; 1564 : 	pKsd_t->sayflag = SAY_CLAUSE;
; 1565 : 	pKsd_t->pronflag = 0;
; 1566 : 	pKsd_t->wbreak = FALSE;
; 1567 : 	pKsd_t->text_flush = FALSE;
; 1568 : 	pKsd_t->async_change = FALSE;
; 1569 : 	pKsd_t->SamplePeriod = 9.07029478458E-5 ;  /* Initialize sample period */
; 1570 : 	pKsd_t->spc_pkt_save = NULL_SPC_PACKET;
; 1571 : 	pKsd_t->loaded_languages = NULL;           //MVP:05/10/96 Fixed an exception(When DECtalk runs on a machine without audio card)
; 1572 : 	/********************************************************************/
; 1573 : 	/*  Create the TTS handle.                                          */
; 1574 : 	/********************************************************************/
; 1575 : 	
; 1576 : 	phTTS = (LPTTS_HANDLE_T )calloc(1,sizeof(TTS_HANDLE_T));

  0032e	68 ec 00 00 00	 push	 236			; 000000ecH
  00333	c7 83 30 02 00
	00 07 f0 51 c7	 mov	 DWORD PTR [ebx+560], -950931449 ; c751f007H
  0033d	55		 push	 ebp
  0033e	89 bb 6c 01 00
	00		 mov	 DWORD PTR [ebx+364], edi
  00344	89 bb a4 01 00
	00		 mov	 DWORD PTR [ebx+420], edi
  0034a	89 bb 74 01 00
	00		 mov	 DWORD PTR [ebx+372], edi
  00350	89 bb 04 02 00
	00		 mov	 DWORD PTR [ebx+516], edi
  00356	c7 83 00 02 00
	00 00 01 00 00	 mov	 DWORD PTR [ebx+512], 256 ; 00000100H
  00360	89 bb 08 02 00
	00		 mov	 DWORD PTR [ebx+520], edi
  00366	89 bb 0c 02 00
	00		 mov	 DWORD PTR [ebx+524], edi
  0036c	89 bb 14 02 00
	00		 mov	 DWORD PTR [ebx+532], edi
  00372	89 bb 70 01 00
	00		 mov	 DWORD PTR [ebx+368], edi
  00378	89 bb 38 02 00
	00		 mov	 DWORD PTR [ebx+568], edi
  0037e	c7 83 34 02 00
	00 f8 c6 17 3f	 mov	 DWORD PTR [ebx+564], 1058522872 ; 3f17c6f8H
  00388	89 bb 7c 01 00
	00		 mov	 DWORD PTR [ebx+380], edi
  0038e	89 bb 54 04 00
	00		 mov	 DWORD PTR [ebx+1108], edi
  00394	ff d6		 call	 esi
  00396	8b f0		 mov	 esi, eax
  00398	83 c4 08	 add	 esp, 8

; 1577 : 	
; 1578 : 	if ( phTTS == NULL )

  0039b	3b f7		 cmp	 esi, edi
  0039d	75 1c		 jne	 SHORT $L71673

; 1579 : 	{
; 1580 : #if defined WIN32 || defined __linux__
; 1581 : #ifdef LICENSES
; 1582 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0039f	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 1583 : #endif //LICENSES
; 1584 : #endif /* WIN32 */
; 1585 : 		free(pKsd_t);			// tek 23sep96 plug memory leak

  003a4	53		 push	 ebx
  003a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  003ab	83 c4 04	 add	 esp, 4

; 2335 : #endif //LICENSES
; 2336 : #endif
; 2337 : 			return( MMSYSERR_NOMEM );

  003ae	b8 07 00 00 00	 mov	 eax, 7
  003b3	5f		 pop	 edi
  003b4	5e		 pop	 esi
  003b5	5d		 pop	 ebp
  003b6	5b		 pop	 ebx

; 2663 : }

  003b7	83 c4 10	 add	 esp, 16			; 00000010H
  003ba	c3		 ret	 0
$L71673:

; 1586 : 		pKsd_t = NULL;
; 1587 : 		return( MMSYSERR_NOMEM );
; 1588 : 	}
; 1589 : 	// tek 20aug98 fill in the back pointer in kernel_share
; 1590 : 	pKsd_t->phTTS = phTTS;
; 1591 : 	
; 1592 : 	phTTS->dwDeviceOptions = dwDeviceOptions;

  003bb	8b 44 24 2c	 mov	 eax, DWORD PTR _dwDeviceOptions$[esp+28]
  003bf	89 b3 84 04 00
	00		 mov	 DWORD PTR [ebx+1156], esi

; 1593 : #ifdef WIN32
; 1594 : 	// tek 13nov97 bats whatever: fix use of instance parameter as window
; 1595 : 	if (dwDeviceOptions&TTSSTARTUP_USING_DEFAULT_CALLBACK)

  003c5	8b c8		 mov	 ecx, eax
  003c7	89 46 74	 mov	 DWORD PTR [esi+116], eax
  003ca	8b 44 24 34	 mov	 eax, DWORD PTR _dwTTSInstanceParameter$[esp+28]
  003ce	81 e1 00 00 00
	08		 and	 ecx, 134217728		; 08000000H
  003d4	f7 d9		 neg	 ecx
  003d6	1b c9		 sbb	 ecx, ecx

; 1596 : 	{
; 1597 : #endif
; 1598 : 		phTTS->hWnd = (HWND)dwTTSInstanceParameter;  //Backward compatibilty for TextToSpeechStartupEx
; 1599 : #ifdef WIN32
; 1600 : 	}
; 1601 : 	else
; 1602 : 	{
; 1603 : 		phTTS->hWnd = NULL; // the instance param is just that!
; 1604 : 	}
; 1605 : #endif
; 1606 : 	
; 1607 : 	phTTS->uiCurrentMsgNumber = 1;
; 1608 : 	phTTS->uiLastTextMsgNumber = 0;
; 1609 : 	phTTS->uiFlushMsgNumber = 0;
; 1610 : #if defined __osf__ || defined __linux__ 
; 1611 : 	phTTS->uiLastQueuedTextMsgNumber = 0; // tek 01sep98
; 1612 : 	phTTS->uiTextThreadExit = FALSE;
; 1613 : 	phTTS->bInReset = FALSE;
; 1614 : 	phTTS->uiID_Error_Message = TTS_MSG_STATUS;
; 1615 : 	phTTS->uiID_Index_Message = TTS_MSG_INDEX_MARK;
; 1616 : 	phTTS->uiID_Buffer_Message = TTS_MSG_BUFFER;
; 1617 : 	phTTS->uiID_Error_Message = TTS_MSG_STATUS;
; 1618 : 	phTTS->uiID_Index_Message = TTS_MSG_INDEX_MARK;
; 1619 : 	phTTS->uiID_Buffer_Message = TTS_MSG_BUFFER;
; 1620 : 	phTTS->bInReset = FALSE;
; 1621 : #endif
; 1622 : 	phTTS->dwQueuedSampleCount = 0;
; 1623 : 	phTTS->uiQueuedCharacterCount = 0;
; 1624 : 	phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 1625 : 	phTTS->bEnableErrorMessage = TRUE;
; 1626 : 	phTTS->bMemoryReset = FALSE;
; 1627 : 	phTTS->szPhonemeBuffer = NULL; // tek 19aug98 ConvertToPhonemes
; 1628 : 	phTTS->dwPhonemeCvtFlags = 0;	// 20aug98 ConvertToPhonemes
; 1629 : 	/* Initialize new element "pKernelShareData" for MI :MVP */
; 1630 : 	phTTS->pKernelShareData = pKsd_t;
; 1631 : 	/********************************************************************/
; 1632 : 	/*  Initialize all of the handle objects to NULL.                   */
; 1633 : 	/********************************************************************/
; 1634 : 	
; 1635 : 	phTTS->pAudioHandle = NULL;
; 1636 : 	phTTS->hSyncEvent = NULL;
; 1637 : 	phTTS->hNotEmptyingVtmPipeEvent = NULL;
; 1638 : 	phTTS->pcsLogFile = NULL;
; 1639 : 	phTTS->pcsQueuedCharacterCount = NULL;
; 1640 : 	phTTS->pcsFlushMsgNumber = NULL;
; 1641 : 	phTTS->pcsLastQueuedTextMsgNumber = NULL;
; 1642 : 	phTTS->pcsQueuedSampleCount = NULL;
; 1643 : 	phTTS->pcsMemoryBuffer = NULL;
; 1644 : #ifdef WIN32
; 1645 : 	phTTS->pcsBufferPipe = NULL;
; 1646 : #endif
; 1647 : 	phTTS->hThread_TXT = NULL;
; 1648 : 	phTTS->hThread_CMD = NULL;
; 1649 : 	phTTS->hThread_LTS = NULL;
; 1650 : 	phTTS->hThread_PH = NULL;
; 1651 : 	phTTS->hThread_VTM = NULL;
; 1652 : 	phTTS->hThread_SYNC = NULL;	
; 1653 : #if defined __osf__ || defined __linux__
; 1654 : 	phTTS->hTextInQueueEvent = NULL;
; 1655 : 	phTTS->pcsTextMsgList = NULL;
; 1656 : 	phTTS->pcsBufferPipe = NULL;
; 1657 : #endif
; 1658 : 
; 1659 : 	/*************************************************************************/
; 1660 : 	/*  Initialize all of the Thread specific data structure pointers to NULL*/
; 1661 : 	/*  Murthy Parakala : for multiple instances                             */
; 1662 : 	/*************************************************************************/
; 1663 : 	phTTS->pCMDThreadData = NULL;            /*CMD Thread */
; 1664 : 	phTTS->pLTSThreadData = NULL;            /*LTS Thread */ 
; 1665 : 	phTTS->pVTMThreadData = NULL;            /*VTM Thread */
; 1666 : 	phTTS->pPHThreadData = NULL;             /*PH  Thread */
; 1667 : 	phTTS->hMallocSuccessEvent = NULL;   /* Event handle for successful memory allocations*/
; 1668 : #ifdef TYPING_MODE	//09jun97 tek
; 1669 : 	phTTS->wTypingFrameCount=0;
; 1670 : #endif //TYPING_MODE  
; 1671 : 	/*****************************************************************/
; 1672 : 	/*  Initialize Instance specific CallbackFunction,Instance parameter
; 1673 : 	/*  MVP : 05/08/96
; 1674 : 	/*****************************************************************/
; 1675 : 	phTTS->DtCallbackRoutine = DtCallbackRoutine;

  003d8	8b 54 24 30	 mov	 edx, DWORD PTR _DtCallbackRoutine$[esp+28]
  003dc	23 c8		 and	 ecx, eax

; 1676 : 	phTTS->dwTTSInstanceParameter = dwTTSInstanceParameter;
; 1677 : #ifdef WIN32
; 1678 : 	phTTS->hmxCallback = NULL;
; 1679 : #endif /* WIN32 */
; 1680 : #if defined __osf__ || defined __linux__
; 1681 : 	phTTS->pcsCallback = NULL;
; 1682 : #endif /* osf || __linux__ */
; 1683 : 	/********************************************************************/
; 1684 : 	/*  Create the queued sample count critical section.                */
; 1685 : 	/********************************************************************/
; 1686 : #ifdef WIN32
; 1687 : 	phTTS->pcsQueuedSampleCount =
; 1688 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  003de	6a 18		 push	 24			; 00000018H
  003e0	89 0e		 mov	 DWORD PTR [esi], ecx
  003e2	89 6e 44	 mov	 DWORD PTR [esi+68], ebp
  003e5	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  003e8	89 7e 50	 mov	 DWORD PTR [esi+80], edi
  003eb	89 7e 7c	 mov	 DWORD PTR [esi+124], edi
  003ee	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  003f1	c7 86 84 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+132], 4
  003fb	89 ae 88 00 00
	00		 mov	 DWORD PTR [esi+136], ebp
  00401	89 be 8c 00 00
	00		 mov	 DWORD PTR [esi+140], edi
  00407	89 be dc 00 00
	00		 mov	 DWORD PTR [esi+220], edi
  0040d	89 be e8 00 00
	00		 mov	 DWORD PTR [esi+232], edi
  00413	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00416	89 be d4 00 00
	00		 mov	 DWORD PTR [esi+212], edi
  0041c	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  0041f	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
  00422	89 be c4 00 00
	00		 mov	 DWORD PTR [esi+196], edi
  00428	89 be c0 00 00
	00		 mov	 DWORD PTR [esi+192], edi
  0042e	89 be bc 00 00
	00		 mov	 DWORD PTR [esi+188], edi
  00434	89 be b8 00 00
	00		 mov	 DWORD PTR [esi+184], edi
  0043a	89 be b4 00 00
	00		 mov	 DWORD PTR [esi+180], edi
  00440	89 be b0 00 00
	00		 mov	 DWORD PTR [esi+176], edi
  00446	89 be c8 00 00
	00		 mov	 DWORD PTR [esi+200], edi
  0044c	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  0044f	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00452	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  00455	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  00458	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  0045b	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0045e	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00461	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00464	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00467	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0046a	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0046d	89 96 a4 00 00
	00		 mov	 DWORD PTR [esi+164], edx
  00473	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax
  00479	89 be ac 00 00
	00		 mov	 DWORD PTR [esi+172], edi
  0047f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00485	83 c4 04	 add	 esp, 4

; 1689 : #endif /* WIN32 */
; 1690 : #if defined __osf__ || defined __linux__
; 1691 : 	phTTS->pcsQueuedSampleCount = OP_CreateMutex();
; 1692 : #endif /* osf */
; 1693 : 	if ( phTTS->pcsQueuedSampleCount == NULL )

  00488	3b c7		 cmp	 eax, edi
  0048a	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax

; 1694 : 	{
; 1695 : 		DeleteTextToSpeechObjects( phTTS );
; 1696 : #if defined WIN32 || defined __linux__
; 1697 : #ifdef LICENSES
; 1698 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1699 : #endif //LICENSES
; 1700 : #endif /* WIN32 */
; 1701 : 		return( MMSYSERR_NOMEM );

  00490	0f 84 c3 02 00
	00		 je	 $L73241

; 1702 : 	}
; 1703 : 	
; 1704 : #ifdef WIN32
; 1705 : #ifdef DTALK50
; 1706 : 	phTTS->CPanelThread = CPInitAPI();
; 1707 : #endif //DTALK50
; 1708 : 	
; 1709 : 	InitializeCriticalSection( phTTS->pcsQueuedSampleCount );

  00496	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__InitializeCriticalSection@4
  0049c	50		 push	 eax
  0049d	ff d5		 call	 ebp

; 1710 : #endif /* WIN32 */
; 1711 : 
; 1712 : 	/********************************************************************/
; 1713 : 	/*  Create the 'Buffer Pipe' mutex.                                 */
; 1714 : 	/********************************************************************/
; 1715 : 	
; 1716 : #ifdef WIN32
; 1717 : 	phTTS->pcsBufferPipe =
; 1718 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  0049f	6a 18		 push	 24			; 00000018H
  004a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  004a7	83 c4 04	 add	 esp, 4

; 1719 : #endif
; 1720 : #if defined __osf__ || defined __linux__
; 1721 : 	phTTS->pcsBufferPipe = OP_CreateMutex();
; 1722 : #endif
; 1723 : 	if ( phTTS->pcsBufferPipe == NULL )

  004aa	3b c7		 cmp	 eax, edi
  004ac	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax

; 1724 : 	{
; 1725 : 		DeleteTextToSpeechObjects( phTTS );
; 1726 : #if defined WIN32 || defined __linux__
; 1727 : #ifdef LICENSES
; 1728 : 		ReleaseLicenseRef();
; 1729 : #endif
; 1730 : #endif
; 1731 : 		return( MMSYSERR_NOMEM );

  004b2	0f 84 a1 02 00
	00		 je	 $L73241

; 1732 : 	}
; 1733 : #ifdef WIN32
; 1734 : 	InitializeCriticalSection( phTTS->pcsBufferPipe );

  004b8	50		 push	 eax
  004b9	ff d5		 call	 ebp

; 1735 : #endif /* WIN32 */
; 1736 : 	
; 1737 : 	/********************************************************************/
; 1738 : 	/*  Create the 'Text List' mutex.                                   */
; 1739 : 	/********************************************************************/
; 1740 : #if defined __osf__ || defined __linux__
; 1741 : 	
; 1742 : 	phTTS->pcsTextMsgList = OP_CreateMutex();
; 1743 : 	
; 1744 : 	if ( phTTS->pcsTextMsgList == NULL )
; 1745 : 	{
; 1746 : 		DeleteTextToSpeechObjects( phTTS );
; 1747 : #ifdef __linux__
; 1748 : #ifdef LICENSES
; 1749 : 		ReleaseLicenseRef();
; 1750 : #endif
; 1751 : #endif
; 1752 : 		return( MMSYSERR_NOMEM );
; 1753 : 	}
; 1754 : #endif /* __osf__ || __linux__ */
; 1755 : 	
; 1756 : 	/********************************************************************/
; 1757 : 	/*  Create the last queued text message number critical section.    */
; 1758 : 	/********************************************************************/
; 1759 : #ifdef WIN32
; 1760 : 	phTTS->pcsLastQueuedTextMsgNumber =
; 1761 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  004bb	6a 18		 push	 24			; 00000018H
  004bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  004c3	83 c4 04	 add	 esp, 4

; 1762 : #endif
; 1763 : #if defined __osf__ || defined __linux__
; 1764 : 	phTTS->pcsLastQueuedTextMsgNumber = OP_CreateMutex();
; 1765 : #endif /* __osf__ */
; 1766 : 	
; 1767 : 	if ( phTTS->pcsLastQueuedTextMsgNumber == NULL )

  004c6	3b c7		 cmp	 eax, edi
  004c8	89 86 b8 00 00
	00		 mov	 DWORD PTR [esi+184], eax

; 1768 : 	{
; 1769 : 		DeleteTextToSpeechObjects( phTTS );
; 1770 : #if defined WIN32 || defined __linux__
; 1771 : #ifdef LICENSES
; 1772 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1773 : #endif //LICENSES
; 1774 : #endif /* WIN32 */
; 1775 : 		return( MMSYSERR_NOMEM );

  004ce	0f 84 85 02 00
	00		 je	 $L73241

; 1776 : 	}
; 1777 : 	
; 1778 : #ifdef WIN32
; 1779 : 	InitializeCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  004d4	50		 push	 eax
  004d5	ff d5		 call	 ebp

; 1780 : #endif /* WIN32 */
; 1781 : 	
; 1782 : 	/********************************************************************/
; 1783 : 	/*  Create the flush message number critical section.               */
; 1784 : 	/********************************************************************/
; 1785 : 	
; 1786 : #ifdef WIN32
; 1787 : 	phTTS->pcsFlushMsgNumber =
; 1788 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  004d7	6a 18		 push	 24			; 00000018H
  004d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  004df	83 c4 04	 add	 esp, 4

; 1789 : #endif /* WIN32 */
; 1790 : #if defined __osf__ || defined __linux__
; 1791 : 	phTTS->pcsFlushMsgNumber = OP_CreateMutex();
; 1792 : #endif /* __osf__ */
; 1793 : 	
; 1794 : 	
; 1795 : 	if ( phTTS->pcsFlushMsgNumber == NULL )

  004e2	3b c7		 cmp	 eax, edi
  004e4	89 86 bc 00 00
	00		 mov	 DWORD PTR [esi+188], eax

; 1796 : 	{
; 1797 : 		DeleteTextToSpeechObjects( phTTS );
; 1798 : #if defined WIN32 || defined __linux__
; 1799 : #ifdef LICENSES
; 1800 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1801 : #endif //LICENSES
; 1802 : #endif /* WIN32 */
; 1803 : 		return( MMSYSERR_NOMEM );

  004ea	0f 84 69 02 00
	00		 je	 $L73241

; 1804 : 	}
; 1805 : 	
; 1806 : #ifdef WIN32
; 1807 : 	InitializeCriticalSection( phTTS->pcsFlushMsgNumber );

  004f0	50		 push	 eax
  004f1	ff d5		 call	 ebp

; 1808 : #endif /* WIN32 */
; 1809 : 	/********************************************************************/
; 1810 : 	/*  Create the queued character count critical section.             */
; 1811 : 	/********************************************************************/
; 1812 : 	
; 1813 : #ifdef WIN32
; 1814 : 	phTTS->pcsQueuedCharacterCount =
; 1815 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  004f3	6a 18		 push	 24			; 00000018H
  004f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  004fb	83 c4 04	 add	 esp, 4

; 1816 : #endif /* WIN32 */
; 1817 : #if defined __osf__ || defined __linux__
; 1818 : 	phTTS->pcsQueuedCharacterCount = OP_CreateMutex();
; 1819 : #endif /* __osf__ || __linux__*/
; 1820 : 	
; 1821 : 	if ( phTTS->pcsQueuedCharacterCount == NULL )

  004fe	3b c7		 cmp	 eax, edi
  00500	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax

; 1822 : 	{
; 1823 : 		DeleteTextToSpeechObjects( phTTS );
; 1824 : #if defined WIN32 || defined __linux__
; 1825 : #ifdef LICENSES
; 1826 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1827 : #endif //LICENSES
; 1828 : #endif /* WIN32 */
; 1829 : 		return( MMSYSERR_NOMEM );

  00506	0f 84 4d 02 00
	00		 je	 $L73241

; 1830 : 	}
; 1831 : 	
; 1832 : #ifdef WIN32
; 1833 : 	InitializeCriticalSection( phTTS->pcsQueuedCharacterCount );

  0050c	50		 push	 eax
  0050d	ff d5		 call	 ebp

; 1834 : #endif /* WIN32 */
; 1835 : 	
; 1836 : #ifdef WIN32
; 1837 : 	/* tek 6mar97 bats 278 */
; 1838 : 	/********************************************************************/
; 1839 : 	/*  Create the index list critical section.                         */
; 1840 : 	/********************************************************************/
; 1841 : 	
; 1842 : 	pKsd_t->pcsSpcPktSave =
; 1843 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  0050f	6a 18		 push	 24			; 00000018H
  00511	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00517	83 c4 04	 add	 esp, 4

; 1844 : 	
; 1845 : 	if ( pKsd_t->pcsSpcPktSave == NULL )

  0051a	3b c7		 cmp	 eax, edi
  0051c	89 83 80 01 00
	00		 mov	 DWORD PTR [ebx+384], eax
  00522	75 1b		 jne	 SHORT $L71725

; 1846 : 	{
; 1847 : #ifdef LICENSES
; 1848 : 		ReleaseLicenseRef(); // tek 23sep96

  00524	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 1849 : #endif
; 1850 : 		DeleteTextToSpeechObjects( phTTS );

  00529	56		 push	 esi
  0052a	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  0052f	83 c4 04	 add	 esp, 4

; 2335 : #endif //LICENSES
; 2336 : #endif
; 2337 : 			return( MMSYSERR_NOMEM );

  00532	b8 07 00 00 00	 mov	 eax, 7
  00537	5f		 pop	 edi
  00538	5e		 pop	 esi
  00539	5d		 pop	 ebp
  0053a	5b		 pop	 ebx

; 2663 : }

  0053b	83 c4 10	 add	 esp, 16			; 00000010H
  0053e	c3		 ret	 0
$L71725:

; 1851 : 		return( MMSYSERR_NOMEM );
; 1852 : 	}
; 1853 : 	
; 1854 : 	InitializeCriticalSection( pKsd_t->pcsSpcPktSave );

  0053f	50		 push	 eax
  00540	ff d5		 call	 ebp

; 1855 : 	
; 1856 : 	/* end 6mar97 bats 278 */
; 1857 : 	
; 1858 : 	/********************************************************************/
; 1859 : 	/*  Create the vtm pipe read critical section.                      */
; 1860 : 	/********************************************************************/
; 1861 : 	// tek 09jun97 needed to allow fast flushing of the  VTM
; 1862 : 	pKsd_t->pcsVtmPipeRead =
; 1863 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  00542	6a 18		 push	 24			; 00000018H
  00544	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0054a	83 c4 04	 add	 esp, 4

; 1864 : 	
; 1865 : 	if ( pKsd_t->pcsVtmPipeRead == NULL )

  0054d	3b c7		 cmp	 eax, edi
  0054f	89 83 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], eax
  00555	75 1b		 jne	 SHORT $L71729

; 1866 : 	{
; 1867 : #ifdef LICENSES
; 1868 : 		ReleaseLicenseRef(); // tek 23sep96

  00557	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 1869 : #endif
; 1870 : 		DeleteTextToSpeechObjects( phTTS );

  0055c	56		 push	 esi
  0055d	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  00562	83 c4 04	 add	 esp, 4

; 2335 : #endif //LICENSES
; 2336 : #endif
; 2337 : 			return( MMSYSERR_NOMEM );

  00565	b8 07 00 00 00	 mov	 eax, 7
  0056a	5f		 pop	 edi
  0056b	5e		 pop	 esi
  0056c	5d		 pop	 ebp
  0056d	5b		 pop	 ebx

; 2663 : }

  0056e	83 c4 10	 add	 esp, 16			; 00000010H
  00571	c3		 ret	 0
$L71729:

; 1871 : 		return( MMSYSERR_NOMEM );
; 1872 : 	}
; 1873 : 	
; 1874 : 	InitializeCriticalSection( pKsd_t->pcsVtmPipeRead );

  00572	50		 push	 eax
  00573	ff d5		 call	 ebp

; 1875 : #endif /* WIN32 */
; 1876 : 	
; 1877 : 	/********************************************************************/
; 1878 : 	/*  Create the log file critical section.                           */
; 1879 : 	/********************************************************************/
; 1880 : #ifdef WIN32
; 1881 : 	phTTS->pcsLogFile =
; 1882 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  00575	6a 18		 push	 24			; 00000018H
  00577	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0057d	83 c4 04	 add	 esp, 4

; 1883 : #endif /* WIN32 */
; 1884 : #if defined __osf__ || defined __linux__
; 1885 : 	phTTS->pcsLogFile = OP_CreateMutex();
; 1886 : #endif /* __osf__ */
; 1887 : 	
; 1888 : 	if ( phTTS->pcsLogFile == NULL )

  00580	3b c7		 cmp	 eax, edi
  00582	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax

; 1889 : 	{
; 1890 : 		DeleteTextToSpeechObjects( phTTS );
; 1891 : #if defined WIN32 || defined __linux__
; 1892 : #ifdef LICENSES
; 1893 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1894 : #endif //LICENSES
; 1895 : #endif /* WIN32 */
; 1896 : 		return( MMSYSERR_NOMEM );

  00588	0f 84 cb 01 00
	00		 je	 $L73241

; 1897 : 	}
; 1898 : 	
; 1899 : #ifdef WIN32
; 1900 : 	InitializeCriticalSection( phTTS->pcsLogFile );

  0058e	50		 push	 eax
  0058f	ff d5		 call	 ebp

; 1901 : #endif
; 1902 : 	/********************************************************************/
; 1903 : 	/*  Create a "Sync" event. The initial state is not signaled.       */
; 1904 : 	/********************************************************************/
; 1905 : 
; 1906 : 	phTTS->hSyncEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

  00591	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__CreateEventA@16
  00597	57		 push	 edi
  00598	57		 push	 edi
  00599	6a 01		 push	 1
  0059b	57		 push	 edi
  0059c	ff d5		 call	 ebp

; 1907 : 	
; 1908 : 	if ( phTTS->hSyncEvent == NULL )

  0059e	3b c7		 cmp	 eax, edi
  005a0	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1909 : 	{
; 1910 : 		DeleteTextToSpeechObjects( phTTS );
; 1911 : #if defined WIN32 || defined __linux__
; 1912 : #ifdef LICENSES
; 1913 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1914 : #endif //LICENSES
; 1915 : #endif /* WIN32 */
; 1916 : 		return( MMSYSERR_NOMEM );

  005a3	0f 84 b0 01 00
	00		 je	 $L73241

; 1917 : 	}
; 1918 : 	
; 1919 : #if defined __osf__ || defined __linux__
; 1920 : 	
; 1921 : 	/********************************************************************/
; 1922 : 	/*  Create a "Text in Queue" event. The initial state is not signaled.*/
; 1923 : 	/********************************************************************/
; 1924 : 	
; 1925 : 	phTTS->hTextInQueueEvent = OP_CreateEvent( TRUE, FALSE );
; 1926 : 	
; 1927 : 	if ( phTTS->hTextInQueueEvent == NULL )
; 1928 : 	{
; 1929 : 		DeleteTextToSpeechObjects( phTTS );
; 1930 : 		return( MMSYSERR_NOMEM );
; 1931 : 	}
; 1932 : #endif /* __osf__ */
; 1933 : 	
; 1934 : 	/********************************************************************/
; 1935 : 	/*  Create a "Not Emptying Vtm Pipe" event. The initial state is    */
; 1936 : 	/*  signaled.                                                       */
; 1937 : 	/********************************************************************/
; 1938 : 	
; 1939 : 	phTTS->hNotEmptyingVtmPipeEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

  005a9	57		 push	 edi
  005aa	6a 01		 push	 1
  005ac	6a 01		 push	 1
  005ae	57		 push	 edi
  005af	ff d5		 call	 ebp

; 1940 : 
; 1941 : 	if ( phTTS->hNotEmptyingVtmPipeEvent == NULL )

  005b1	3b c7		 cmp	 eax, edi
  005b3	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 1942 : 	{
; 1943 : 		DeleteTextToSpeechObjects( phTTS );
; 1944 : #if defined WIN32 || defined __linux__
; 1945 : #ifdef LICENSES
; 1946 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1947 : #endif //LICENSES
; 1948 : #endif /* WIN32 */
; 1949 : 		return( MMSYSERR_NOMEM );

  005b6	0f 84 9d 01 00
	00		 je	 $L73241

; 1950 : 	}
; 1951 : 	
; 1952 : 	/*******************************************************************/
; 1953 : 	/*  Create the TTS callback mutex.                                 */
; 1954 : 	/*******************************************************************/
; 1955 : 	
; 1956 : 	if ( DtCallbackRoutine != NULL )

  005bc	39 7c 24 30	 cmp	 DWORD PTR _DtCallbackRoutine$[esp+28], edi
  005c0	74 13		 je	 SHORT $L71745

; 1957 : 	{
; 1958 : #ifdef WIN32
; 1959 : 		phTTS->hmxCallback = OP_CreateMutex();

  005c2	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1960 : 		if ( phTTS->hmxCallback == NULL )

  005c7	3b c7		 cmp	 eax, edi
  005c9	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax

; 1961 : #endif
; 1962 : #if defined __osf__ || defined __linux__
; 1963 : 			phTTS->pcsCallback = OP_CreateMutex();
; 1964 : 		if ( phTTS->pcsCallback == NULL )
; 1965 : #endif
; 1966 : 		{
; 1967 : 			DeleteTextToSpeechObjects( phTTS );
; 1968 : #if defined WIN32 || defined __linux__
; 1969 : #ifdef LICENSES
; 1970 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1971 : #endif //LICENSES
; 1972 : #endif //WIN32
; 1973 : 			return MMSYSERR_NOMEM;

  005cf	0f 84 84 01 00
	00		 je	 $L73241
$L71745:

; 1974 : 		}
; 1975 : 	}
; 1976 : 	
; 1977 : 	
; 1978 : 	/********************************************************************************/
; 1979 : 	/*  MVP :Create a "Successful Memory Allocation " event.                        */
; 1980 : 	/*  The event configuration is non-inheritable,AUTO RESET,not signaled, Unnamed */
; 1981 : 	/********************************************************************************/
; 1982 : 
; 1983 : 	phTTS->hMallocSuccessEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  005d5	57		 push	 edi
  005d6	57		 push	 edi
  005d7	57		 push	 edi
  005d8	57		 push	 edi
  005d9	ff d5		 call	 ebp

; 1984 : 	
; 1985 : 	if ( phTTS->hMallocSuccessEvent == NULL )

  005db	3b c7		 cmp	 eax, edi
  005dd	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 1986 : 	{
; 1987 : 		DeleteTextToSpeechObjects( phTTS );
; 1988 : #if defined WIN32 || defined __linux__
; 1989 : #ifdef LICENSES
; 1990 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1991 : #endif //LICENSES
; 1992 : #endif
; 1993 : 		return( MMSYSERR_NOMEM );

  005e0	0f 84 73 01 00
	00		 je	 $L73241

; 1994 : 	}
; 1995 : 	
; 1996 : 	/********************************************************************/
; 1997 : 	/*  Initialize the inter-thread communication pipes.                */
; 1998 : 	/********************************************************************/
; 1999 : 	
; 2000 : 	cmd_pipe = create_pipe( BYTE_PIPE, CMD_PIPE_LENGTH );

  005e6	6a 40		 push	 64			; 00000040H
  005e8	57		 push	 edi
  005e9	e8 00 00 00 00	 call	 _create_pipe
  005ee	83 c4 08	 add	 esp, 8

; 2001 : 	
; 2002 : 	if ( cmd_pipe == NULL )

  005f1	3b c7		 cmp	 eax, edi
  005f3	89 44 24 30	 mov	 DWORD PTR _cmd_pipe$[esp+28], eax

; 2003 : 	{
; 2004 : 		DeleteTextToSpeechObjects( phTTS );
; 2005 : #if defined WIN32 || defined __linux__
; 2006 : #ifdef LICENSES
; 2007 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2008 : #endif //LICENSES
; 2009 : #endif
; 2010 : 		return( MMSYSERR_NOMEM );

  005f7	0f 84 5c 01 00
	00		 je	 $L73241

; 2011 : 	}
; 2012 : 	
; 2013 : 	lts_pipe = create_pipe( WORD_PIPE, LTS_PIPE_LENGTH );

  005fd	68 80 00 00 00	 push	 128			; 00000080H
  00602	6a 01		 push	 1
  00604	e8 00 00 00 00	 call	 _create_pipe
  00609	83 c4 08	 add	 esp, 8

; 2014 : 	
; 2015 : 	if ( lts_pipe == NULL )

  0060c	3b c7		 cmp	 eax, edi
  0060e	89 44 24 18	 mov	 DWORD PTR _lts_pipe$[esp+32], eax

; 2016 : 	{
; 2017 : 		DeleteTextToSpeechObjects( phTTS );
; 2018 : #if defined WIN32 || defined __linux__
; 2019 : #ifdef LICENSES
; 2020 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2021 : #endif //LICENSES
; 2022 : #endif
; 2023 : 		return( MMSYSERR_NOMEM );

  00612	0f 84 41 01 00
	00		 je	 $L73241

; 2024 : 	}
; 2025 : 	
; 2026 : #ifdef NEW_TRANSPORT
; 2027 : 	new_lts_pipe = create_pipe( DWORD_PIPE, LTS_PIPE_LENGTH );
; 2028 : 	
; 2029 : 	if ( new_lts_pipe == NULL )
; 2030 : 	{
; 2031 : 		DeleteTextToSpeechObjects( phTTS );
; 2032 : #if defined WIN32 || defined __linux__
; 2033 : #ifdef LICENSES
; 2034 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2035 : #endif //LICENSES
; 2036 : #endif
; 2037 : 		return( MMSYSERR_NOMEM );
; 2038 : 	}
; 2039 : #endif
; 2040 : 
; 2041 : 
; 2042 : 	ph_pipe = create_pipe( WORD_PIPE, PH_PIPE_LENGTH );

  00618	68 00 01 00 00	 push	 256			; 00000100H
  0061d	6a 01		 push	 1
  0061f	e8 00 00 00 00	 call	 _create_pipe
  00624	8b e8		 mov	 ebp, eax
  00626	83 c4 08	 add	 esp, 8

; 2043 : 	
; 2044 : 	if ( ph_pipe == NULL )

  00629	3b ef		 cmp	 ebp, edi

; 2045 : 	{
; 2046 : 		DeleteTextToSpeechObjects( phTTS );
; 2047 : #if defined WIN32 || defined __linux__
; 2048 : #ifdef LICENSES
; 2049 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2050 : #endif //LICENSES
; 2051 : #endif
; 2052 : 		return( MMSYSERR_NOMEM );

  0062b	0f 84 28 01 00
	00		 je	 $L73241

; 2053 : 	}
; 2054 : 	
; 2055 : 	vtm_pipe = create_pipe( WORD_PIPE, VTM_PIPE_LENGTH );

  00631	68 00 40 00 00	 push	 16384			; 00004000H
  00636	6a 01		 push	 1
  00638	e8 00 00 00 00	 call	 _create_pipe
  0063d	83 c4 08	 add	 esp, 8

; 2056 : 	
; 2057 : 	if ( vtm_pipe == NULL )

  00640	3b c7		 cmp	 eax, edi
  00642	89 44 24 34	 mov	 DWORD PTR _vtm_pipe$[esp+28], eax

; 2058 : 	{
; 2059 : 		DeleteTextToSpeechObjects( phTTS );
; 2060 : #if defined WIN32 || defined __linux__
; 2061 : #ifdef LICENSES
; 2062 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2063 : #endif //LICENSES
; 2064 : #endif
; 2065 : 		return( MMSYSERR_NOMEM );

  00646	0f 84 0d 01 00
	00		 je	 $L73241

; 2066 : 	}
; 2067 : 	
; 2068 : 	sync_pipe = create_pipe( DWORD_PIPE, SYNC_PIPE_LENGTH );

  0064c	68 00 08 00 00	 push	 2048			; 00000800H
  00651	6a 02		 push	 2
  00653	e8 00 00 00 00	 call	 _create_pipe
  00658	83 c4 08	 add	 esp, 8

; 2069 : 	
; 2070 : 	if ( sync_pipe == NULL )

  0065b	3b c7		 cmp	 eax, edi
  0065d	89 44 24 14	 mov	 DWORD PTR _sync_pipe$[esp+32], eax

; 2071 : 	{
; 2072 : 		DeleteTextToSpeechObjects( phTTS );
; 2073 : #if defined WIN32 || defined __linux__
; 2074 : #ifdef LICENSES
; 2075 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2076 : #endif //LICENSES
; 2077 : #endif
; 2078 : 		return( MMSYSERR_NOMEM );

  00661	0f 84 f2 00 00
	00		 je	 $L73241

; 2079 : 	}
; 2080 : 	
; 2081 : 	/********************************************************************/
; 2082 : 	/*  Set default pipe parameters.                                    */
; 2083 : 	/********************************************************************/
; 2084 : 	/* Comment out the below line for MI : MVP */
; 2085 : 	/*
; 2086 : 	kernel_share = &kernel_data;
; 2087 : 	*/
; 2088 : 	
; 2089 : 	for ( i = 0; i < MAX_languages; i++ )

  00667	8d 93 34 01 00
	00		 lea	 edx, DWORD PTR [ebx+308]
  0066d	b8 07 00 00 00	 mov	 eax, 7
  00672	8b ca		 mov	 ecx, edx
$L71760:

; 2090 : 	{
; 2091 : 		pKsd_t->lang_lts[i] = NULL_PIPE;

  00674	89 79 e4	 mov	 DWORD PTR [ecx-28], edi

; 2092 : 		pKsd_t->lang_ph[i]  = NULL_PIPE;

  00677	89 39		 mov	 DWORD PTR [ecx], edi

; 2093 : 		pKsd_t->lang_ready[i] = 0;

  00679	89 79 c8	 mov	 DWORD PTR [ecx-56], edi
  0067c	83 c1 04	 add	 ecx, 4
  0067f	48		 dec	 eax
  00680	75 f2		 jne	 SHORT $L71760

; 2094 : 	}
; 2095 : 	
; 2096 : 	/* GL 04/21/1997 add code to support the local language pipe */
; 2097 : 	pKsd_t->lang_lts[0] = lts_pipe;
; 2098 : 	pKsd_t->lang_ph[0] = ph_pipe;
; 2099 : 	
; 2100 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[0];
; 2101 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[0];
; 2102 : 	
; 2103 : 	pKsd_t->cmd_pipe = cmd_pipe;

  00682	8b 44 24 30	 mov	 eax, DWORD PTR _cmd_pipe$[esp+28]

; 2104 : 	pKsd_t->vtm_pipe = vtm_pipe;

  00686	8b 4c 24 34	 mov	 ecx, DWORD PTR _vtm_pipe$[esp+28]
  0068a	89 83 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], eax

; 2105 : 	pKsd_t->sync_pipe = sync_pipe;

  00690	8b 44 24 14	 mov	 eax, DWORD PTR _sync_pipe$[esp+32]
  00694	89 83 e0 00 00
	00		 mov	 DWORD PTR [ebx+224], eax

; 2106 : 	
; 2107 : 	/*
; 2108 : 	GL 12/11/1996, set up the language flag pKsd_t->lang_curr
; 2109 : 	this flag will be used in CMD and phlog.c to pick up the language
; 2110 : 	depended code
; 2111 : 	*/
; 2112 : #ifdef ENGLISH_US
; 2113 : 	pKsd_t->lang_lts[LANG_english] = lts_pipe;

  0069a	8b 44 24 18	 mov	 eax, DWORD PTR _lts_pipe$[esp+32]
  0069e	89 8b dc 00 00
	00		 mov	 DWORD PTR [ebx+220], ecx
  006a4	89 83 18 01 00
	00		 mov	 DWORD PTR [ebx+280], eax

; 2114 : 	pKsd_t->lang_ph[LANG_english] = ph_pipe;
; 2115 : 	
; 2116 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_english];

  006aa	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax

; 2117 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_english];

  006b0	89 ab d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ebp

; 2118 : 	pKsd_t->lang_curr = LANG_english;

  006b6	89 bb f8 00 00
	00		 mov	 DWORD PTR [ebx+248], edi

; 2119 : #endif //ENGLISH_US
; 2120 : #ifdef ENGLISH_UK
; 2121 : 	pKsd_t->lang_lts[LANG_british] = lts_pipe;
; 2122 : 	pKsd_t->lang_ph[LANG_british] = ph_pipe;
; 2123 : 	
; 2124 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_british];
; 2125 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_british];
; 2126 : 	pKsd_t->lang_curr = LANG_british;
; 2127 : #endif //ENGLISH_UK
; 2128 : 
; 2129 : #ifdef SPANISH_SP
; 2130 :   pKsd_t->lang_lts[LANG_spanish] = lts_pipe;
; 2131 :   pKsd_t->lang_ph[LANG_spanish] = ph_pipe;
; 2132 : 
; 2133 :   pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_spanish];
; 2134 :   pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_spanish];
; 2135 : 
; 2136 :   pKsd_t->lang_curr = LANG_spanish;
; 2137 : #endif //SPANISH_SP
; 2138 : #ifdef SPANISH_LA
; 2139 :   pKsd_t->lang_lts[LANG_latin_american] = lts_pipe;
; 2140 :   pKsd_t->lang_ph[LANG_latin_american] = ph_pipe;
; 2141 : 
; 2142 :   pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_latin_american];
; 2143 :   pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_latin_american];
; 2144 : 
; 2145 :   pKsd_t->lang_curr = LANG_latin_american;
; 2146 : #endif //SPANISH_LA
; 2147 : 
; 2148 : #ifdef GERMAN
; 2149 : 	pKsd_t->lang_lts[LANG_german] = lts_pipe;
; 2150 : 	pKsd_t->lang_ph[LANG_german] = ph_pipe;
; 2151 : 	
; 2152 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_german];
; 2153 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_german];
; 2154 : 	pKsd_t->lang_curr = LANG_german;
; 2155 : #endif //GERMAN
; 2156 : #ifdef FRENCH
; 2157 : 	pKsd_t->lang_lts[LANG_french] = lts_pipe;
; 2158 : 	pKsd_t->lang_ph[LANG_french] = ph_pipe;
; 2159 : 	
; 2160 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_french];
; 2161 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_french];
; 2162 : 	pKsd_t->lang_curr = LANG_french;
; 2163 : #endif //FRENCH
; 2164 : 
; 2165 : #ifdef NEW_TRANSPORT
; 2166 : 	pKsd_t->new_lts_pipe=new_lts_pipe;
; 2167 : #endif
; 2168 : 
; 2169 : #ifdef WIN32
; 2170 : 	/********************************************************************/
; 2171 : 	/*  Get the DECtalk error message.                                  */
; 2172 : 	/********************************************************************/
; 2173 : 	
; 2174 :   phTTS->uiID_Error_Message =
; 2175 : #if UNDER_CE //mfgce
; 2176 : 	  RegisterWindowMessage(TEXT("DECtalkErrorMessage"));
; 2177 : #else
; 2178 : 	  RegisterWindowMessage("DECtalkErrorMessage");

  006bc	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__RegisterWindowMessageA@4
  006c2	68 00 00 00 00	 push	 OFFSET FLAT:$SG71765
  006c7	89 2a		 mov	 DWORD PTR [edx], ebp
  006c9	ff d3		 call	 ebx

; 2179 : #endif
; 2180 : 	
; 2181 : 	if ( phTTS->uiID_Error_Message == 0 )

  006cb	3b c7		 cmp	 eax, edi
  006cd	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 2182 : 	{
; 2183 : 		DeleteTextToSpeechObjects( phTTS );
; 2184 : #ifdef LICENSES
; 2185 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2186 : #endif //LICENSES
; 2187 : 		return( MMSYSERR_NOMEM );

  006d0	0f 84 83 00 00
	00		 je	 $L73241

; 2188 : 	}
; 2189 : 	
; 2190 : 	/********************************************************************/
; 2191 : 	/*  Get the DECtalk index mark message.                             */
; 2192 : 	/********************************************************************/
; 2193 : 	
; 2194 :   phTTS->uiID_Index_Message =
; 2195 : #if UNDER_CE //mfgce
; 2196 : 	RegisterWindowMessage(TEXT("DECtalkIndexMessage"));
; 2197 : #else
; 2198 :     RegisterWindowMessage("DECtalkIndexMessage");

  006d6	68 00 00 00 00	 push	 OFFSET FLAT:$SG71767
  006db	ff d3		 call	 ebx

; 2199 : #endif
; 2200 : 	
; 2201 : 	if ( phTTS->uiID_Index_Message == 0 )

  006dd	3b c7		 cmp	 eax, edi
  006df	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 2202 : 	{
; 2203 : 		DeleteTextToSpeechObjects( phTTS );
; 2204 : #ifdef LICENSES
; 2205 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2206 : #endif //LICENSES
; 2207 : 		return( MMSYSERR_NOMEM );

  006e2	74 75		 je	 SHORT $L73241

; 2208 : 	}
; 2209 : 	
; 2210 : 	// tek 01aug97 bats 404 register messages for 
; 2211 : 	// bookmark, wordpos, start, stop.
; 2212 : 	
; 2213 : phTTS->uiID_Bookmark_Message =
; 2214 : #if UNDER_CE //mfgce
; 2215 : 	RegisterWindowMessage(TEXT("DECtalkBookmarkMessage"));
; 2216 : #else
; 2217 :     RegisterWindowMessage("DECtalkBookmarkMessage");

  006e4	68 00 00 00 00	 push	 OFFSET FLAT:$SG71769
  006e9	ff d3		 call	 ebx

; 2218 : #endif
; 2219 : 	
; 2220 : 	if ( phTTS->uiID_Bookmark_Message == 0 )

  006eb	3b c7		 cmp	 eax, edi
  006ed	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 2221 : 	{
; 2222 : 		DeleteTextToSpeechObjects( phTTS );
; 2223 : #ifdef LICENSES
; 2224 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2225 : #endif //LICENSES
; 2226 : 		return( MMSYSERR_NOMEM );

  006f0	74 67		 je	 SHORT $L73241

; 2227 : 	}
; 2228 : 	
; 2229 : phTTS->uiID_Wordpos_Message =
; 2230 : #if UNDER_CE //mfgce
; 2231 : 	RegisterWindowMessage(TEXT("DECtalkWordposMessage"));
; 2232 : #else
; 2233 : 	RegisterWindowMessage("DECtalkWordposMessage");

  006f2	68 00 00 00 00	 push	 OFFSET FLAT:$SG71771
  006f7	ff d3		 call	 ebx

; 2234 : #endif
; 2235 : 	
; 2236 : 	if ( phTTS->uiID_Wordpos_Message == 0 )

  006f9	3b c7		 cmp	 eax, edi
  006fb	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 2237 : 	{
; 2238 : 		DeleteTextToSpeechObjects( phTTS );
; 2239 : #ifdef LICENSES
; 2240 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2241 : #endif //LICENSES
; 2242 : 		return( MMSYSERR_NOMEM );

  006fe	74 59		 je	 SHORT $L73241

; 2243 : 	}
; 2244 : 	
; 2245 : phTTS->uiID_Start_Message =
; 2246 : #if UNDER_CE //mfgce
; 2247 : 	RegisterWindowMessage(TEXT("DECtalkStartMessage"));
; 2248 : #else
; 2249 :     RegisterWindowMessage("DECtalkStartMessage");

  00700	68 00 00 00 00	 push	 OFFSET FLAT:$SG71773
  00705	ff d3		 call	 ebx

; 2250 : #endif
; 2251 : 	
; 2252 : 	if ( phTTS->uiID_Start_Message == 0 )

  00707	3b c7		 cmp	 eax, edi
  00709	89 46 68	 mov	 DWORD PTR [esi+104], eax

; 2253 : 	{
; 2254 : 		DeleteTextToSpeechObjects( phTTS );
; 2255 : #ifdef LICENSES
; 2256 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2257 : #endif //LICENSES
; 2258 : 		return( MMSYSERR_NOMEM );

  0070c	74 4b		 je	 SHORT $L73241

; 2259 : 	}
; 2260 : 	
; 2261 : 	phTTS->uiID_Stop_Message =
; 2262 : #if UNDER_CE //mfgce
; 2263 : 	RegisterWindowMessage(TEXT("DECtalkStopMessage"));
; 2264 : #else
; 2265 : 	RegisterWindowMessage("DECtalkStopMessage");

  0070e	68 00 00 00 00	 push	 OFFSET FLAT:$SG71775
  00713	ff d3		 call	 ebx

; 2266 : #endif
; 2267 : 	
; 2268 : 	if ( phTTS->uiID_Stop_Message == 0 )

  00715	3b c7		 cmp	 eax, edi
  00717	89 46 6c	 mov	 DWORD PTR [esi+108], eax

; 2269 : 	{
; 2270 : 		DeleteTextToSpeechObjects( phTTS );
; 2271 : #ifdef LICENSES
; 2272 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2273 : #endif //LICENSES
; 2274 : 		return( MMSYSERR_NOMEM );

  0071a	74 3d		 je	 SHORT $L73241

; 2275 : 	}
; 2276 : 	
; 2277 : 	// tek 27aug97 
; 2278 :   phTTS->uiID_Visual_Message =
; 2279 : #if UNDER_CE //mfgce
; 2280 : 	RegisterWindowMessage(TEXT("DECtalkVisualMessage"));
; 2281 : #else
; 2282 : 	RegisterWindowMessage("DECtalkVisualMessage");

  0071c	68 00 00 00 00	 push	 OFFSET FLAT:$SG71777
  00721	ff d3		 call	 ebx

; 2283 : #endif
; 2284 : 	
; 2285 : 	if ( phTTS->uiID_Visual_Message == 0 )

  00723	3b c7		 cmp	 eax, edi
  00725	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 2286 : 	{
; 2287 : 		DeleteTextToSpeechObjects( phTTS );
; 2288 : #ifdef LICENSES
; 2289 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2290 : #endif //LICENSES
; 2291 : 		return( MMSYSERR_NOMEM );

  00728	74 2f		 je	 SHORT $L73241

; 2292 : 	}
; 2293 : 	
; 2294 : 	
; 2295 : 	/********************************************************************/
; 2296 : 	/*  Get the DECtalk buffer message.                                 */
; 2297 : 	/********************************************************************/
; 2298 : 	
; 2299 :   phTTS->uiID_Buffer_Message =
; 2300 : #if UNDER_CE //mfgce
; 2301 : 	RegisterWindowMessage(TEXT("DECtalkBufferMessage"));
; 2302 : #else
; 2303 :     RegisterWindowMessage("DECtalkBufferMessage");

  0072a	68 00 00 00 00	 push	 OFFSET FLAT:$SG71779
  0072f	ff d3		 call	 ebx

; 2304 : #endif
; 2305 : 	
; 2306 : 	if ( phTTS->uiID_Buffer_Message == 0 )

  00731	3b c7		 cmp	 eax, edi
  00733	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 2307 : 	{
; 2308 : 		DeleteTextToSpeechObjects( phTTS );
; 2309 : #ifdef LICENSES
; 2310 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2311 : #endif //LICENSES
; 2312 : 		return( MMSYSERR_NOMEM );

  00736	74 21		 je	 SHORT $L73241

; 2313 : 	}
; 2314 : 	
; 2315 : #endif /* WIN32 */
; 2316 : 	
; 2317 : 	/********************************************************************/
; 2318 : 	/*  Initialize the audio driver.                                    */
; 2319 : 	/********************************************************************/
; 2320 : 	
; 2321 : 	if (( dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  00738	8b 6c 24 2c	 mov	 ebp, DWORD PTR _dwDeviceOptions$[esp+28]
  0073c	f7 c5 00 00 00
	80		 test	 ebp, -2147483648	; 80000000H
  00742	0f 85 db 00 00
	00		 jne	 $L71781

; 2322 : 	{
; 2323 : 		/********************************************************************/
; 2324 : 		/*  Allocate memory for the local WAVEFORMATEX structure.           */
; 2325 : 		/********************************************************************/
; 2326 : 		// 01aug97 bats423: allocate this for both SAPI and DAPI
; 2327 : 		pWaveFormat = (LPWAVEFORMATEX)malloc(sizeof(WAVEFORMATEX));

  00748	6a 12		 push	 18			; 00000012H
  0074a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00750	8b d8		 mov	 ebx, eax
  00752	83 c4 04	 add	 esp, 4

; 2328 : 		
; 2329 : 		if ( pWaveFormat == NULL )

  00755	3b df		 cmp	 ebx, edi
  00757	75 1b		 jne	 SHORT $L71785
$L73241:

; 2330 : 		{
; 2331 : 			DeleteTextToSpeechObjects( phTTS );

  00759	56		 push	 esi
  0075a	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  0075f	83 c4 04	 add	 esp, 4
$L73243:

; 2332 : #if defined WIN32 || defined __linux__
; 2333 : #ifdef LICENSES
; 2334 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00762	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  00767	5f		 pop	 edi
  00768	5e		 pop	 esi
  00769	5d		 pop	 ebp

; 2335 : #endif //LICENSES
; 2336 : #endif
; 2337 : 			return( MMSYSERR_NOMEM );

  0076a	b8 07 00 00 00	 mov	 eax, 7
  0076f	5b		 pop	 ebx

; 2663 : }

  00770	83 c4 10	 add	 esp, 16			; 00000010H
  00773	c3		 ret	 0
$L71785:

; 2338 : 		}
; 2339 : 		
; 2340 : #ifndef OLEDECTALK
; 2341 : 		/********************************************************************/
; 2342 : 		/*  Fill in all the required fields of the WAVEFORMATEX structure.  */
; 2343 : 		/********************************************************************/
; 2344 : 		
; 2345 : 		pWaveFormat->wFormatTag = WAVE_FORMAT_PCM;
; 2346 : 		pWaveFormat->nSamplesPerSec = PC_SAMPLE_RATE;
; 2347 : 		pWaveFormat->nChannels = 1;
; 2348 : 		pWaveFormat->wBitsPerSample = 16;
; 2349 : 		/********************************************************************/
; 2350 : 		/*  Open the audio device.                                          */
; 2351 : 		/********************************************************************/
; 2352 : 		
; 2353 : 		mmStatus = PA_CreatePlayHandle( &pPlayAudio,
; 2354 : 			uiDeviceNumber,
; 2355 : 			pWaveFormat,
; 2356 : 			dwDeviceOptions,
; 2357 : 			PlayAudioCallbackRoutine,
; 2358 : 			(ATYPE_T)phTTS);

  00774	8b 4c 24 28	 mov	 ecx, DWORD PTR _uiDeviceNumber$[esp+28]
  00778	56		 push	 esi
  00779	68 00 00 00 00	 push	 OFFSET FLAT:_PlayAudioCallbackRoutine
  0077e	55		 push	 ebp
  0077f	53		 push	 ebx
  00780	8d 54 24 20	 lea	 edx, DWORD PTR _pPlayAudio$[esp+48]
  00784	51		 push	 ecx
  00785	52		 push	 edx
  00786	66 c7 03 01 00	 mov	 WORD PTR [ebx], 1
  0078b	c7 43 04 11 2b
	00 00		 mov	 DWORD PTR [ebx+4], 11025 ; 00002b11H
  00792	66 c7 43 02 01
	00		 mov	 WORD PTR [ebx+2], 1
  00798	66 c7 43 0e 10
	00		 mov	 WORD PTR [ebx+14], 16	; 00000010H
  0079e	e8 00 00 00 00	 call	 _PA_CreatePlayHandle
  007a3	8b e8		 mov	 ebp, eax
  007a5	83 c4 18	 add	 esp, 24			; 00000018H

; 2359 : 		// bats423: free (pWaveFormat) done later
; 2360 : #else //OLEDECTALK
; 2361 : 		/*******************************************************/
; 2362 : 		/* Initialize the DECtalk audio system for OLE-DECTALK */
; 2363 : 		/*******************************************************/
; 2364 : 			      mmStatus = InitializeDECtalkAudio((HWND)dwTTSInstanceParameter,&pPlayAudio);
; 2365 : #endif //OLEDECTALK
; 2366 : 		
; 2367 : 		if ( mmStatus )

  007a8	3b ef		 cmp	 ebp, edi
  007aa	74 31		 je	 SHORT $L71789

; 2368 : 		{
; 2369 : #if defined WIN32 || defined __linux__
; 2370 : #ifdef LICENSES
; 2371 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  007ac	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 2372 : #endif //LICENSES
; 2373 : #endif
; 2374 : 			DeleteTextToSpeechObjects( phTTS );

  007b1	56		 push	 esi
  007b2	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects

; 2375 : 
; 2376 : 			free( pWaveFormat ); // bats423

  007b7	53		 push	 ebx
  007b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  007be	83 c4 08	 add	 esp, 8

; 2377 : #ifdef API_DEBUG
; 2378 : 			OutputDebugString("ttsapi: error initializing audio\n");
; 2379 : #endif //API_DEBUG
; 2380 : 			if ( mmStatus == MMSYSERR_ERROR ) // tek 24sep96

  007c1	83 fd 01	 cmp	 ebp, 1
  007c4	75 0d		 jne	 SHORT $L71788
  007c6	5f		 pop	 edi
  007c7	5e		 pop	 esi
  007c8	5d		 pop	 ebp

; 2381 : 			{
; 2382 : 				return( MMSYSERR_NODRIVER );

  007c9	b8 06 00 00 00	 mov	 eax, 6
  007ce	5b		 pop	 ebx

; 2663 : }

  007cf	83 c4 10	 add	 esp, 16			; 00000010H
  007d2	c3		 ret	 0
$L71788:
  007d3	5f		 pop	 edi

; 2383 : 			}
; 2384 : #ifdef DONT_RETURN_BADFORMAT
; 2385 : 			else if (mmStatus == WAVERR_BADFORMAT)
; 2386 : 			{	// tek 24sep96 we'd really like to return BADFORMAT here
; 2387 : 				// but that will break existing users. Baggage..
; 2388 : 				return (MMSYSERR_NODRIVER);
; 2389 : 			} 
; 2390 : #endif //DONT_RETURN_BADFORMAT
; 2391 : 			else
; 2392 : 				return( mmStatus );

  007d4	8b c5		 mov	 eax, ebp
  007d6	5e		 pop	 esi
  007d7	5d		 pop	 ebp
  007d8	5b		 pop	 ebx

; 2663 : }

  007d9	83 c4 10	 add	 esp, 16			; 00000010H
  007dc	c3		 ret	 0
$L71789:

; 2393 : 		}
; 2394 : 		
; 2395 : 		phTTS->pAudioHandle = pPlayAudio;

  007dd	8b 44 24 10	 mov	 eax, DWORD PTR _pPlayAudio$[esp+32]

; 2396 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 2397 : 		// tek 01aug97 bats423 init some stuff for later use here..
; 2398 : #ifdef OLEDECTALK
; 2399 : 		phTTS->pAudioHandle->pcMode = NULL; // this gets filled in later.
; 2400 : #endif //OLEDECTALK
; 2401 : 		// get the sample rate and stash it away.. 
; 2402 : 		PA_GetFormat(pPlayAudio,pWaveFormat);

  007e1	53		 push	 ebx
  007e2	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  007e8	89 be 84 00 00
	00		 mov	 DWORD PTR [esi+132], edi
  007ee	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+36]
  007f2	51		 push	 ecx
  007f3	e8 00 00 00 00	 call	 _PA_GetFormat

; 2403 : 		pPlayAudio->dMsecPerSample = 
; 2404 : 			(double)(1000)/(double)(pWaveFormat->nAvgBytesPerSec);

  007f8	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  007fb	89 7c 24 24	 mov	 DWORD PTR -8+[esp+44], edi
  007ff	89 54 24 20	 mov	 DWORD PTR -8+[esp+40], edx
  00803	8b 44 24 18	 mov	 eax, DWORD PTR _pPlayAudio$[esp+40]
  00807	df 6c 24 20	 fild	 QWORD PTR -8+[esp+40]

; 2405 : 		free( pWaveFormat );

  0080b	53		 push	 ebx
  0080c	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@8@4008fa00000000000000
  00812	dd 98 a8 00 00
	00		 fstp	 QWORD PTR [eax+168]
  00818	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0081e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2406 : 		
; 2407 : 	}
; 2408 : 	else // tek 01jul97/01aug97 bats 423

  00821	eb 06		 jmp	 SHORT $L71792
$L71781:

; 2409 : 		//have to deal with the DO_NOT_USE_AUDIO_DEVICE
; 2410 : 		// case for DAPI..  (well, not really, but doing this here 
; 2411 : 		// reminds us that there IS another case..
; 2412 : 	{
; 2413 : 		phTTS->pAudioHandle = NULL;

  00823	89 be d4 00 00
	00		 mov	 DWORD PTR [esi+212], edi
$L71792:

; 2414 : 	}
; 2415 : 	
; 2416 : 	/********************************************************************/
; 2417 : 	/*  Start the Synchronization thread.                               */
; 2418 : 	/********************************************************************/
; 2419 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_SYNC),
; 2420 : #ifdef WIN32
; 2421 : 		FALSE,(start_address)sync_main))== MMSYSERR_NOMEM)

  00829	68 00 00 00 00	 push	 OFFSET FLAT:_sync_main@4
  0082e	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  00831	57		 push	 edi
  00832	50		 push	 eax
  00833	56		 push	 esi
  00834	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  00839	83 c4 10	 add	 esp, 16			; 00000010H
  0083c	83 f8 07	 cmp	 eax, 7
  0083f	75 12		 jne	 SHORT $L71795

; 2422 : #endif
; 2423 : #if defined __osf__ || defined __linux__
; 2424 : 		FALSE, sync_main))== MMSYSERR_NOMEM)
; 2425 : #endif
; 2426 : 	{
; 2427 : #if defined WIN32 || defined __linux__
; 2428 : #ifdef LICENSES
; 2429 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00841	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  00846	5f		 pop	 edi
  00847	5e		 pop	 esi
  00848	5d		 pop	 ebp

; 2430 : #endif // LICENSES
; 2431 : #endif
; 2432 : 		return(MMSYSERR_NOMEM);

  00849	b8 07 00 00 00	 mov	 eax, 7
  0084e	5b		 pop	 ebx

; 2663 : }

  0084f	83 c4 10	 add	 esp, 16			; 00000010H
  00852	c3		 ret	 0
$L71795:

; 2433 : 	}
; 2434 : 	
; 2435 : 	/********************************************************************/
; 2436 : 	/*  Start the Vocal Tract Model thread.                             */
; 2437 : 	/********************************************************************/
; 2438 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_VTM),
; 2439 : #ifdef WIN32
; 2440 : 		TRUE,(start_address)vtm_main))== MMSYSERR_NOMEM)

  00853	68 00 00 00 00	 push	 OFFSET FLAT:_vtm_main@4
  00858	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  0085b	6a 01		 push	 1
  0085d	50		 push	 eax
  0085e	56		 push	 esi
  0085f	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  00864	83 c4 10	 add	 esp, 16			; 00000010H
  00867	83 f8 07	 cmp	 eax, 7
  0086a	75 12		 jne	 SHORT $L71797

; 2441 : #endif
; 2442 : #if defined __osf__ || defined __linux__
; 2443 : 		TRUE, vtm_main))== MMSYSERR_NOMEM)
; 2444 : #endif
; 2445 : 	{
; 2446 : #if defined WIN32 || defined __linux__
; 2447 : #ifdef LICENSES
; 2448 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0086c	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  00871	5f		 pop	 edi
  00872	5e		 pop	 esi
  00873	5d		 pop	 ebp

; 2449 : #endif //LICENSES
; 2450 : #endif
; 2451 : 		return(MMSYSERR_NOMEM);

  00874	b8 07 00 00 00	 mov	 eax, 7
  00879	5b		 pop	 ebx

; 2663 : }

  0087a	83 c4 10	 add	 esp, 16			; 00000010H
  0087d	c3		 ret	 0
$L71797:

; 2452 : 	}
; 2453 : 	
; 2454 : 	/********************************************************************/
; 2455 : 	/*  Start the Phonetic processing thread.                           */
; 2456 : 	/********************************************************************/
; 2457 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_PH),
; 2458 : #ifdef WIN32
; 2459 : 		TRUE, (start_address)ph_main))== MMSYSERR_NOMEM)

  0087e	68 00 00 00 00	 push	 OFFSET FLAT:_ph_main@4
  00883	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  00886	6a 01		 push	 1
  00888	50		 push	 eax
  00889	56		 push	 esi
  0088a	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  0088f	83 c4 10	 add	 esp, 16			; 00000010H
  00892	83 f8 07	 cmp	 eax, 7
  00895	75 12		 jne	 SHORT $L71799

; 2460 : #endif
; 2461 : #if defined __osf__ || defined __linux__
; 2462 : 		TRUE, ph_main))== MMSYSERR_NOMEM)
; 2463 : #endif
; 2464 : 	{
; 2465 : #if defined WIN32 || defined __linux__
; 2466 : #ifdef LICENSES
; 2467 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00897	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  0089c	5f		 pop	 edi
  0089d	5e		 pop	 esi
  0089e	5d		 pop	 ebp

; 2468 : #endif //LICENSES
; 2469 : #endif 
; 2470 : 		return(MMSYSERR_NOMEM);

  0089f	b8 07 00 00 00	 mov	 eax, 7
  008a4	5b		 pop	 ebx

; 2663 : }

  008a5	83 c4 10	 add	 esp, 16			; 00000010H
  008a8	c3		 ret	 0
$L71799:

; 2471 : 	}
; 2472 : 	
; 2473 : #ifdef TYPING_MODE	 //09jun97 tek
; 2474 : 	// elevate the PH and VTM thread priority
; 2475 : 	if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)
; 2476 : 	{
; 2477 : 		// 19nov97 VTM adjusts the priority of both PH and VTM, so we
; 2478 : 		// set it high to start and then let it back down automagically
; 2479 : #ifndef UNDER_CE
; 2480 : 		OP_SetThreadPriority((phTTS->hThread_PH),OP_PRIORITY_HIGHEST);
; 2481 : 		OP_SetThreadPriority((phTTS->hThread_VTM),OP_PRIORITY_HIGHEST);
; 2482 : #endif
; 2483 : 	}
; 2484 : #ifndef UNDER_CE
; 2485 : 	OP_SetThreadPriority((phTTS->hThread_SYNC),OP_PRIORITY_ABOVE_NORMAL);
; 2486 : #endif
; 2487 : #endif //TYPING_MODE
; 2488 : 	
; 2489 : 	/********************************************************************/
; 2490 : 	/*  Start the Letter To Sound thread.                               */
; 2491 : 	/********************************************************************/
; 2492 : 	nReturnCode = StartDecTalkSystemThread(phTTS, &(phTTS->hThread_LTS),
; 2493 : #ifdef WIN32
; 2494 : 		TRUE,(start_address)lts_main);

  008a9	68 00 00 00 00	 push	 OFFSET FLAT:_lts_main@4
  008ae	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  008b1	6a 01		 push	 1
  008b3	50		 push	 eax
  008b4	56		 push	 esi
  008b5	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  008ba	8b d8		 mov	 ebx, eax
  008bc	83 c4 10	 add	 esp, 16			; 00000010H

; 2495 : #endif
; 2496 : #if defined __osf__ || defined __linux__
; 2497 : 		TRUE, lts_main);			
; 2498 : #endif
; 2499 : 		if(nReturnCode == MMSYSERR_NOMEM ||
; 2500 : 			nReturnCode == MMSYSERR_INVALPARAM ||
; 2501 : 			nReturnCode == MMSYSERR_ERROR )

  008bf	83 fb 07	 cmp	 ebx, 7
  008c2	0f 84 82 00 00
	00		 je	 $L71802
  008c8	83 fb 0b	 cmp	 ebx, 11			; 0000000bH
  008cb	74 7d		 je	 SHORT $L71802
  008cd	83 fb 01	 cmp	 ebx, 1
  008d0	74 78		 je	 SHORT $L71802

; 2509 : 		}
; 2510 : 		
; 2511 : 		/********************************************************************/
; 2512 : 		/*  Start the Command thread.                                       */
; 2513 : 		/********************************************************************/
; 2514 : 		if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_CMD),
; 2515 : #ifdef WIN32
; 2516 : 			TRUE,(start_address)cmd_main))== MMSYSERR_NOMEM)

  008d2	68 00 00 00 00	 push	 OFFSET FLAT:_cmd_main@4
  008d7	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  008da	6a 01		 push	 1
  008dc	50		 push	 eax
  008dd	56		 push	 esi
  008de	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  008e3	83 c4 10	 add	 esp, 16			; 00000010H
  008e6	83 f8 07	 cmp	 eax, 7
  008e9	75 12		 jne	 SHORT $L71804

; 2517 : #endif
; 2518 : #if defined __osf__ || defined __linux__
; 2519 : 			TRUE, cmd_main))== MMSYSERR_NOMEM)
; 2520 : #endif
; 2521 : 		{
; 2522 : #if defined WIN32 || defined __linux__
; 2523 : #ifdef LICENSES
; 2524 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  008eb	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  008f0	5f		 pop	 edi
  008f1	5e		 pop	 esi
  008f2	5d		 pop	 ebp

; 2525 : #endif //LICENSES
; 2526 : #endif
; 2527 : 			return(MMSYSERR_NOMEM);

  008f3	b8 07 00 00 00	 mov	 eax, 7
  008f8	5b		 pop	 ebx

; 2663 : }

  008f9	83 c4 10	 add	 esp, 16			; 00000010H
  008fc	c3		 ret	 0
$L71804:

; 2528 : 		}
; 2529 : 		
; 2530 : 		/********************************************************************/
; 2531 : 		/*  Start the Text Queueing thread.                                 */
; 2532 : 		/********************************************************************/
; 2533 : 		phTTS->hTextToSpeechWnd = (int)NULL;
; 2534 : 		
; 2535 : 		nReturnCode = StartDecTalkSystemThread(phTTS, &(phTTS->hThread_TXT),
; 2536 : #ifdef WIN32
; 2537 : 			TRUE,(start_address)TextToSpeechThreadMain);

  008fd	68 00 00 00 00	 push	 OFFSET FLAT:_TextToSpeechThreadMain@4
  00902	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00905	6a 01		 push	 1
  00907	50		 push	 eax
  00908	56		 push	 esi
  00909	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0090c	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  00911	8b f8		 mov	 edi, eax
  00913	83 c4 10	 add	 esp, 16			; 00000010H

; 2538 : #endif
; 2539 : #if defined __osf__ || defined __linux__
; 2540 : 		TRUE, TextToSpeechThreadMain);
; 2541 : #endif
; 2542 : 		if(nReturnCode == MMSYSERR_NOMEM ||
; 2543 : 			nReturnCode == MMSYSERR_ERROR)

  00916	83 ff 07	 cmp	 edi, 7
  00919	74 20		 je	 SHORT $L71809
  0091b	83 ff 01	 cmp	 edi, 1
  0091e	74 1b		 je	 SHORT $L71809

; 2551 : 		}
; 2552 : 		
; 2553 : #ifdef OLD
; 2554 : 		phTTS->hThread_TXT = CreateThread( NULL,
; 2555 : 			0,
; 2556 : 			(LPTHREAD_START_ROUTINE)TextToSpeechThreadMain,
; 2557 : 			(LPVOID)phTTS,
; 2558 : 			0,
; 2559 : 			&ID_Thread_TXT );
; 2560 : 		
; 2561 : 		/********************************************************************/
; 2562 : 		/*  Wait here until the LTS thread loads the dictionary.            */
; 2563 : 		/********************************************************************/
; 2564 : 		/* GL 11/05/1997  for BATS#510 */
; 2565 : 		for ( i = 0; pKsd_t->fdic_entries[pKsd_t->lang_curr] == 0; i++ )
; 2566 : 		{
; 2567 : 			Sleep( STARTUP_LOOP_WAIT_TIME );
; 2568 : 			if ( i > MAX_STARTUP_WAIT_COUNT )
; 2569 : 			{                                                            
; 2570 : 				DeleteTextToSpeechObjects( phTTS );
; 2571 : #if defined WIN32 || defined __linux__            
; 2572 : #ifdef LICENSES
; 2573 : 				ReleaseLicenseRef();	
; 2574 : /* tek 23sep96 give back the license unit */
; 2575 : #endif //LICENSES
; 2576 : #endif
; 2577 : 				return( MMSYSERR_ERROR );
; 2578 : 			}
; 2579 : 		}
; 2580 : 		
; 2581 : 		/********************************************************************/
; 2582 : 		/*  If the dictionary length was set to 0xFFFFFFFF then the         */
; 2583 : 		/*  dictionary file was not found. Return an error.                 */
; 2584 : 		/********************************************************************/
; 2585 : 		
; 2586 : 		/* GL 11/05/1997  for BATS#510 */
; 2587 : 		if ( pKsd_t->fdic_entries[pKsd_t->lang_curr] == 0xFFFFFFFF )
; 2588 : 		{
; 2589 : #if defined WIN32 || defined __linux__  
; 2590 : #ifdef LICENSES
; 2591 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2592 : #endif //LICENSES
; 2593 : #endif
; 2594 : 			return( MMSYSERR_ERROR );
; 2595 : 		}
; 2596 : 		
; 2597 : 		/********************************************************************/
; 2598 : 		/*  Wait here until the Text-To-Speech main thread initializes the  */
; 2599 : 		/*  Text-To-Speech window handle.                                   */
; 2600 : /********************************************************************/
; 2601 : 
; 2602 : 		for ( i = 0; phTTS->hTextToSpeechWnd == NULL; i++ )
; 2603 : 		{
; 2604 : 			Sleep( STARTUP_LOOP_WAIT_TIME );
; 2605 : 			if ( i > MAX_STARTUP_WAIT_COUNT )
; 2606 : 			{
; 2607 : 				DeleteTextToSpeechObjects( phTTS );
; 2608 : #if defined WIN32 || defined __linux__ 
; 2609 : #ifdef LICENSES
; 2610 : 				ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2611 : #endif //LICENSES
; 2612 : #endif
; 2613 : 				return( MMSYSERR_NOMEM );
; 2614 : 			}
; 2615 : 		}
; 2616 : 		
; 2617 : 		if ( phTTS->hThread_TXT == NULL )
; 2618 : 		{
; 2619 : 			DeleteTextToSpeechObjects( phTTS );
; 2620 : #if defined WIN32 || defined __linux__ 
; 2621 : #ifdef LICENSES
; 2622 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2623 : #endif //LICENSES
; 2624 : #endif
; 2625 : 			return( MMSYSERR_NOMEM );
; 2626 : 		}
; 2627 : 		
; 2628 : #endif //OLD
; 2629 : 		
; 2630 : 		
; 2631 : 		/********************************************************************/
; 2632 : 		/*  MVP:06/19/96 Initialize the TextToSpeech handle the function        */
; 2633 : 		/*  returns through pphTTS argument.                                */
; 2634 : 		/********************************************************************/
; 2635 : 		
; 2636 : 		*pphTTS = phTTS;

  00920	8b 4c 24 24	 mov	 ecx, DWORD PTR _pphTTS$[esp+28]

; 2637 : 		
; 2638 : 		/******************************************************************/
; 2639 : 		/*  Put the system into a known state.                            */
; 2640 : 		/******************************************************************/
; 2641 : 		
; 2642 : 		TextToSpeechReset( phTTS, TRUE );

  00924	6a 01		 push	 1
  00926	56		 push	 esi
  00927	89 31		 mov	 DWORD PTR [ecx], esi
  00929	e8 00 00 00 00	 call	 _TextToSpeechReset
  0092e	83 c4 08	 add	 esp, 8

; 2643 : 		
; 2644 : 		//MVP: Increment InstanceCounter on successful creation of a speech object.
; 2645 : 		//gnInstanceCounter++; // tek bats 668 12may98 this is done by the dic loader.
; 2646 : #if defined __osf__ || defined __linux__
; 2647 : 		gnInstanceCounter++;
; 2648 : #endif
; 2649 : 		
; 2650 : #ifdef DECTALKBETA430        //MVP:04/09/96 A message will be spoken for Beta releases.
; 2651 : #ifdef ENGLISH
; 2652 : 		TextToSpeechSpeak(phTTS, "DECtalk beta S D K version 4.4a is running. For evaluation only. ", TTS_FORCE);
; 2653 : #endif //ENGLISH
; 2654 : #ifdef SPANISH
; 2655 : 		TextToSpeechSpeak(phTTS, "DECtalk beta S d k versin 4.4a est corriendo. Para evaluacin solamente.", TTS_FORCE);
; 2656 : #endif //SPANISH
; 2657 : #ifdef GERMAN
; 2658 : 		TextToSpeechSpeak(phTTS, "Dies ist das DECtalk S D K, beta Version 4.4 A. Unlizensierte Testversion.", TTS_FORCE);
; 2659 : #endif //GERMAN
; 2660 : #endif //DECTALKBETA430
; 2661 : 		
; 2662 : 		return( MMSYSERR_NOERROR );

  00931	33 c0		 xor	 eax, eax
  00933	5f		 pop	 edi
  00934	5e		 pop	 esi
  00935	5d		 pop	 ebp
  00936	5b		 pop	 ebx

; 2663 : }

  00937	83 c4 10	 add	 esp, 16			; 00000010H
  0093a	c3		 ret	 0
$L71809:

; 2544 : 		{
; 2545 : #if defined WIN32 || defined __linux__
; 2546 : #ifdef LICENSES
; 2547 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0093b	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 2548 : #endif //LICENSES
; 2549 : #endif
; 2550 : 			return(nReturnCode);

  00940	8b c7		 mov	 eax, edi
  00942	5f		 pop	 edi
  00943	5e		 pop	 esi
  00944	5d		 pop	 ebp
  00945	5b		 pop	 ebx

; 2663 : }

  00946	83 c4 10	 add	 esp, 16			; 00000010H
  00949	c3		 ret	 0
$L71802:

; 2502 : 		{
; 2503 : #if defined WIN32 || defined __linux__
; 2504 : #ifdef LICENSES
; 2505 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0094a	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  0094f	5f		 pop	 edi
  00950	5e		 pop	 esi

; 2506 : #endif //LICENSES
; 2507 : #endif
; 2508 : 			return(nReturnCode);

  00951	8b c3		 mov	 eax, ebx
  00953	5d		 pop	 ebp
  00954	5b		 pop	 ebx

; 2663 : }

  00955	83 c4 10	 add	 esp, 16			; 00000010H
  00958	c3		 ret	 0
_TextToSpeechStartupEx ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechStartup
PUBLIC	_DefaultTTSCallbackRoutine
_TEXT	SEGMENT
_hWnd$ = 8
_pphTTS$ = 12
_uiDeviceNumber$ = 16
_dwDeviceOptions$ = 20
_TextToSpeechStartup PROC NEAR

; 2766 : 	// tek 13nov97 flag that we're using the default callback, so that
; 2767 : 	// we know that the instance param is actually hWnd..
; 2768 : 	return(TextToSpeechStartupEx(pphTTS,
; 2769 : 		uiDeviceNumber,
; 2770 : 		dwDeviceOptions|TTSSTARTUP_USING_DEFAULT_CALLBACK,
; 2771 : 		DefaultTTSCallbackRoutine,
; 2772 : 		(LONG)hWnd));

  00960	8b 44 24 04	 mov	 eax, DWORD PTR _hWnd$[esp-4]
  00964	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwDeviceOptions$[esp-4]
  00968	8b 54 24 0c	 mov	 edx, DWORD PTR _uiDeviceNumber$[esp-4]
  0096c	50		 push	 eax
  0096d	8b 44 24 0c	 mov	 eax, DWORD PTR _pphTTS$[esp]
  00971	81 c9 00 00 00
	08		 or	 ecx, 134217728		; 08000000H
  00977	68 00 00 00 00	 push	 OFFSET FLAT:_DefaultTTSCallbackRoutine
  0097c	51		 push	 ecx
  0097d	52		 push	 edx
  0097e	50		 push	 eax
  0097f	e8 00 00 00 00	 call	 _TextToSpeechStartupEx
  00984	83 c4 14	 add	 esp, 20			; 00000014H

; 2773 : 
; 2774 : /* GL 11/19/1998, the following codes never get used */
; 2775 : #if 0
; 2776 : 
; 2777 : 	/********************************************************************/
; 2778 : 	/*  Get the DECtalk error message.                                  */
; 2779 : 	/********************************************************************/
; 2780 : 	
; 2781 : 	phTTS->uiID_Error_Message =
; 2782 : 	  RegisterWindowMessage("DECtalkErrorMessage");
; 2783 : 	
; 2784 : 	if ( phTTS->uiID_Error_Message == 0 )
; 2785 : 	{
; 2786 : 	    DeleteTextToSpeechObjects( phTTS );
; 2787 : 	    return( MMSYSERR_NOMEM );
; 2788 : 	}
; 2789 : 	
; 2790 : 	/********************************************************************/
; 2791 : 	/*  Get the DECtalk index mark message.                             */
; 2792 : 	/********************************************************************/
; 2793 : 	
; 2794 : 	phTTS->uiID_Index_Message =
; 2795 : 	  RegisterWindowMessage("DECtalkIndexMessage");
; 2796 : 	
; 2797 : 	if ( phTTS->uiID_Index_Message == 0 )
; 2798 : 	{
; 2799 : 	    DeleteTextToSpeechObjects( phTTS );
; 2800 : 	    return( MMSYSERR_NOMEM );
; 2801 : 	}
; 2802 : 	
; 2803 : 	/********************************************************************/
; 2804 : 	/*  Get the DECtalk buffer message.                                 */
; 2805 : 	/********************************************************************/
; 2806 : 	
; 2807 : 	phTTS->uiID_Buffer_Message =
; 2808 : 	  RegisterWindowMessage("DECtalkBufferMessage");
; 2809 : 	
; 2810 : 	if ( phTTS->uiID_Buffer_Message == 0 )
; 2811 : 	{
; 2812 : 	    DeleteTextToSpeechObjects( phTTS );
; 2813 : 	    return( MMSYSERR_NOMEM );
; 2814 : 	}
; 2815 : #endif
; 2816 : 
; 2817 : }

  00987	c3		 ret	 0
_TextToSpeechStartup ENDP
_TEXT	ENDS
EXTRN	__imp__PostMessageA@16:NEAR
_TEXT	SEGMENT
_lParam1$ = 8
_lParam2$ = 12
_dwInstanceParam$ = 16
_uiMsg$ = 20
_DefaultTTSCallbackRoutine PROC NEAR

; 2825 : #ifdef API_DEBUG
; 2826 : 	char szTemp[256]="";
; 2827 : 	ULONG ulStartTime,ulEndTime;
; 2828 : 	ulStartTime=timeGetTime();
; 2829 : 	sprintf(szTemp, "DTTSCallback(%ld) at %ld.\n", lParam1,ulStartTime);
; 2830 : 	OutputDebugString(szTemp);
; 2831 : #endif //API_DEBUG
; 2832 : 	
; 2833 : 	switch( lParam1 )
; 2834 : 	{

  00990	8b 4c 24 04	 mov	 ecx, DWORD PTR _lParam1$[esp-4]
  00994	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00997	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0099a	77 0f		 ja	 SHORT $L71833
  0099c	33 d2		 xor	 edx, edx
  0099e	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L73247[eax]
  009a4	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L73248[edx*4]
$L71833:

; 2835 : 	case TTS_AUDIO_PLAY_START:
; 2836 : 	case TTS_AUDIO_PLAY_STOP:
; 2837 : 	case ERROR_OPENING_WAVE_OUTPUT_DEVICE:
; 2838 : 	case ERROR_IN_AUDIO_WRITE:
; 2839 : 	case ERROR_GETTING_DEVICE_CAPABILITIES:
; 2840 : 		PostMessage((HWND)dwInstanceParam,uiMsg,lParam1,lParam2);
; 2841 : 		break;
; 2842 : 		
; 2843 : 	default:
; 2844 : 		// tek 19aug96 must this be a post?
; 2845 : 		PostMessage((HWND)dwInstanceParam,uiMsg,lParam1,lParam2);

  009ab	8b 44 24 08	 mov	 eax, DWORD PTR _lParam2$[esp-4]
  009af	8b 54 24 0c	 mov	 edx, DWORD PTR _dwInstanceParam$[esp-4]
  009b3	50		 push	 eax
  009b4	51		 push	 ecx
  009b5	8b 4c 24 18	 mov	 ecx, DWORD PTR _uiMsg$[esp+4]
  009b9	51		 push	 ecx
  009ba	52		 push	 edx
  009bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 2846 : 		break;
; 2847 : 	}
; 2848 : }

  009c1	c3		 ret	 0
  009c2	8b ff		 npad	 2
$L73248:
  009c4	00 00 00 00	 DD	 $L71833
  009c8	00 00 00 00	 DD	 $L71833
$L73247:
  009cc	00		 DB	 0
  009cd	00		 DB	 0
  009ce	00		 DB	 0
  009cf	01		 DB	 1
  009d0	01		 DB	 1
  009d1	01		 DB	 1
  009d2	01		 DB	 1
  009d3	01		 DB	 1
  009d4	01		 DB	 1
  009d5	01		 DB	 1
  009d6	01		 DB	 1
  009d7	00		 DB	 0
  009d8	00		 DB	 0
_DefaultTTSCallbackRoutine ENDP
_TEXT	ENDS
EXTRN	__imp__WaitForMultipleObjects@16:NEAR
EXTRN	__imp___beginthreadex:NEAR
EXTRN	__imp__GetExitCodeThread@8:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_ppDecTalkThread$ = 12
_bMalloc$ = 16
_ThreadFunction$ = 20
_IDThread$ = 20
_WaitObjArray$ = -8
_exit_code$ = 8
_StartDecTalkSystemThread PROC NEAR

; 2889 : 	UINT IDThread;
; 2890 : 	DWORD cNumObjects =2;
; 2891 : #if !defined __osf__ && !defined __linux__
; 2892 : 	HANDLE WaitObjArray[2];
; 2893 : 	ULONG exit_code ;
; 2894 : #endif
; 2895 : 	/*typedef int ( * _stdcall Stdstart_address ) (void *);*/
; 2896 : 	
; 2897 : #ifdef WIN32
; 2898 : 	*ppDecTalkThread = (HANDLE) _beginthreadex(NULL,
; 2899 : 								0,
; 2900 : 								ThreadFunction,             
; 2901 : 								(void *)phTTS,                                   
; 2902 : 								0,
; 2903 : 								&IDThread
; 2904 : 								);

  009e0	8b 4c 24 10	 mov	 ecx, DWORD PTR _ThreadFunction$[esp-4]
  009e4	83 ec 08	 sub	 esp, 8
  009e7	8d 44 24 18	 lea	 eax, DWORD PTR _IDThread$[esp+4]
  009eb	56		 push	 esi
  009ec	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  009f0	57		 push	 edi
  009f1	50		 push	 eax
  009f2	6a 00		 push	 0
  009f4	56		 push	 esi
  009f5	51		 push	 ecx
  009f6	6a 00		 push	 0
  009f8	6a 00		 push	 0
  009fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthreadex
  00a00	8b 7c 24 30	 mov	 edi, DWORD PTR _ppDecTalkThread$[esp+36]
  00a04	83 c4 18	 add	 esp, 24			; 00000018H

; 2905 : #endif
; 2906 : #if defined __osf__ || defined __linux__
; 2907 : 	*ppDecTalkThread = OP_CreateThread(0,
; 2908 : 					   ThreadFunction,             
; 2909 : 					   (void *)phTTS);
; 2910 : #endif
; 2911 : 	
; 2912 : 	if ( *ppDecTalkThread == NULL )

  00a07	85 c0		 test	 eax, eax
  00a09	89 07		 mov	 DWORD PTR [edi], eax
  00a0b	75 14		 jne	 SHORT $L71854

; 2913 : 	{
; 2914 : 		DeleteTextToSpeechObjects( phTTS );

  00a0d	56		 push	 esi
  00a0e	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  00a13	83 c4 04	 add	 esp, 4

; 2915 : 		return( MMSYSERR_NOMEM );

  00a16	b8 07 00 00 00	 mov	 eax, 7
  00a1b	5f		 pop	 edi
  00a1c	5e		 pop	 esi

; 2942 : #endif
; 2943 : #if defined __osf__ || defined __linux__
; 2944 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 2945 : 		DeleteTextToSpeechObjects( phTTS );
; 2946 : 	
; 2947 : 	return (phTTS->uiThreadError);
; 2948 : #endif
; 2949 : }

  00a1d	83 c4 08	 add	 esp, 8
  00a20	c3		 ret	 0
$L71854:

; 2916 : 	}
; 2917 : 	
; 2918 : 	if(bMalloc == FALSE)          /* No dynamic memory allocations within thread main function */

  00a21	8b 4c 24 1c	 mov	 ecx, DWORD PTR _bMalloc$[esp+12]
  00a25	85 c9		 test	 ecx, ecx
  00a27	75 08		 jne	 SHORT $L71855
  00a29	5f		 pop	 edi

; 2919 : 		return MMSYSERR_NOERROR;  /*No errors */

  00a2a	33 c0		 xor	 eax, eax
  00a2c	5e		 pop	 esi

; 2942 : #endif
; 2943 : #if defined __osf__ || defined __linux__
; 2944 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 2945 : 		DeleteTextToSpeechObjects( phTTS );
; 2946 : 	
; 2947 : 	return (phTTS->uiThreadError);
; 2948 : #endif
; 2949 : }

  00a2d	83 c4 08	 add	 esp, 8
  00a30	c3		 ret	 0
$L71855:

; 2920 : #if !defined __osf__ && !defined __linux__
; 2921 : 	WaitObjArray[0] = *ppDecTalkThread;
; 2922 : 	WaitObjArray[1] = phTTS->hMallocSuccessEvent;

  00a31	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00a34	89 44 24 08	 mov	 DWORD PTR _WaitObjArray$[esp+16], eax

; 2923 : 	
; 2924 : 	WaitForMultipleObjects(cNumObjects,WaitObjArray,FALSE,INFINITE); 

  00a38	6a ff		 push	 -1
  00a3a	8d 44 24 0c	 lea	 eax, DWORD PTR _WaitObjArray$[esp+20]
  00a3e	6a 00		 push	 0
  00a40	50		 push	 eax
  00a41	6a 02		 push	 2
  00a43	89 54 24 1c	 mov	 DWORD PTR _WaitObjArray$[esp+36], edx
  00a47	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForMultipleObjects@16

; 2925 : 	
; 2926 : 	GetExitCodeThread(*ppDecTalkThread,&exit_code);

  00a4d	8b 17		 mov	 edx, DWORD PTR [edi]
  00a4f	8d 4c 24 14	 lea	 ecx, DWORD PTR _exit_code$[esp+12]
  00a53	51		 push	 ecx
  00a54	52		 push	 edx
  00a55	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8

; 2927 : #endif /* __osf__ && __linux__ */
; 2928 : #if defined __osf__ || defined __linux__
; 2929 : 	OP_WaitForEvent( phTTS->hMallocSuccessEvent, OP_INFINITE );
; 2930 : #endif
; 2931 : 	
; 2932 : #if !defined __osf__ && !defined __linux__
; 2933 : 	if(exit_code == MMSYSERR_NOMEM ||
; 2934 : 		exit_code == MMSYSERR_INVALPARAM ||
; 2935 : 		exit_code == MMSYSERR_ERROR )

  00a5b	8b 44 24 14	 mov	 eax, DWORD PTR _exit_code$[esp+12]
  00a5f	83 f8 07	 cmp	 eax, 7
  00a62	74 12		 je	 SHORT $L71857
  00a64	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00a67	74 0d		 je	 SHORT $L71857
  00a69	83 f8 01	 cmp	 eax, 1
  00a6c	74 08		 je	 SHORT $L71857
  00a6e	5f		 pop	 edi

; 2939 : 	}
; 2940 : 	
; 2941 : 	return MMSYSERR_NOERROR;    /*No errors */

  00a6f	33 c0		 xor	 eax, eax
  00a71	5e		 pop	 esi

; 2942 : #endif
; 2943 : #if defined __osf__ || defined __linux__
; 2944 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 2945 : 		DeleteTextToSpeechObjects( phTTS );
; 2946 : 	
; 2947 : 	return (phTTS->uiThreadError);
; 2948 : #endif
; 2949 : }

  00a72	83 c4 08	 add	 esp, 8
  00a75	c3		 ret	 0
$L71857:

; 2936 : 	{
; 2937 : 		DeleteTextToSpeechObjects( phTTS );

  00a76	56		 push	 esi
  00a77	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects

; 2938 : 		return(exit_code);

  00a7c	8b 44 24 18	 mov	 eax, DWORD PTR _exit_code$[esp+16]
  00a80	83 c4 04	 add	 esp, 4
  00a83	5f		 pop	 edi
  00a84	5e		 pop	 esi

; 2942 : #endif
; 2943 : #if defined __osf__ || defined __linux__
; 2944 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 2945 : 		DeleteTextToSpeechObjects( phTTS );
; 2946 : 	
; 2947 : 	return (phTTS->uiThreadError);
; 2948 : #endif
; 2949 : }

  00a85	83 c4 08	 add	 esp, 8
  00a88	c3		 ret	 0
_StartDecTalkSystemThread ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechShutdown
PUBLIC	_TextToSpeechCloseInMemory
EXTRN	__imp__IsBadWritePtr@8:NEAR
EXTRN	_ThreadLock:NEAR
EXTRN	_ThreadUnlock:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechShutdown PROC NEAR

; 2982 : {

  00a90	56		 push	 esi

; 2983 : 	/********************************************************************/
; 2984 : 	/*  Return error if invalid handle.                                 */
; 2985 : 	/********************************************************************/
; 2986 : 	
; 2987 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  00a91	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00a95	6a 04		 push	 4
  00a97	56		 push	 esi
  00a98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  00a9e	85 c0		 test	 eax, eax
  00aa0	74 07		 je	 SHORT $L71861

; 2988 : 		return( MMSYSERR_INVALHANDLE );

  00aa2	b8 05 00 00 00	 mov	 eax, 5
  00aa7	5e		 pop	 esi

; 3040 : }

  00aa8	c3		 ret	 0
$L71861:

; 2989 : 	
; 2990 : 	/********************************************************************/
; 2991 : 	/*  If the last item in the TextToSpeechStartup() function was      */
; 2992 : 	/*  initialized then reset the the Text-To-Speech system.           */
; 2993 : 	/********************************************************************/
; 2994 : 	
; 2995 : 	/* The if statement is not reqd as phTTSglobal is going to be oboselete for MI :MVP */
; 2996 : 	/*if ( phTTSglobal != NULL )*/
; 2997 : 	if(phTTS != NULL)

  00aa9	85 f6		 test	 esi, esi
  00aab	74 0b		 je	 SHORT $L71863

; 2998 : 		TextToSpeechReset( phTTS, TRUE );

  00aad	6a 01		 push	 1
  00aaf	56		 push	 esi
  00ab0	e8 00 00 00 00	 call	 _TextToSpeechReset
  00ab5	83 c4 08	 add	 esp, 8
$L71863:

; 2999 : 	
; 3000 : #ifdef DTALK50
; 3001 : 	CPUnitAPI(phTTS->CPanelThread);       // Remove the Control Panel - KSB
; 3002 : #endif //DTALK50
; 3003 : 	
; 3004 : 	/********************************************************************/
; 3005 : 	/*  Delete any objects created by the TextToSpeechInMemory().       */
; 3006 : 	/*  function.                                                       */
; 3007 : 	/********************************************************************/
; 3008 : 	
; 3009 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  00ab8	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  00abf	75 09		 jne	 SHORT $L71864

; 3010 : 		TextToSpeechCloseInMemory( phTTS );

  00ac1	56		 push	 esi
  00ac2	e8 00 00 00 00	 call	 _TextToSpeechCloseInMemory
  00ac7	83 c4 04	 add	 esp, 4
$L71864:

; 3011 : 	
; 3012 : 	/********************************************************************/
; 3013 : 	/*  Delete all objects created in the TextToSpeechStartup()         */
; 3014 : 	/*  function.                                                       */
; 3015 : 	/********************************************************************/
; 3016 : 	// tek bats668 12may98 this must be decremented here to make sure 
; 3017 : 	// the dictionary gets unloaded.
; 3018 : 	// tek 27may98 bats 689:
; 3019 : 	// we need to lock around this to make sure we don't end up with a 
; 3020 : 	// startup and a shutdown colliding
; 3021 : #ifdef WIN32
; 3022 : 	ThreadLock(&tl_gnInstanceCounter,5); // tek 27may98 bats 689

  00aca	6a 05		 push	 5
  00acc	68 00 00 00 00	 push	 OFFSET FLAT:_tl_gnInstanceCounter
  00ad1	e8 00 00 00 00	 call	 _ThreadLock

; 3023 : #endif
; 3024 : 	gnInstanceCounter--;     /* MVP: Decrement the instance counter */

  00ad6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gnInstanceCounter

; 3025 : 	
; 3026 : 	DeleteTextToSpeechObjects( phTTS );

  00adc	56		 push	 esi
  00add	49		 dec	 ecx
  00ade	89 0d 00 00 00
	00		 mov	 DWORD PTR _gnInstanceCounter, ecx
  00ae4	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects

; 3027 : 	
; 3028 : #ifdef WIN32
; 3029 : 	ThreadUnlock(&tl_gnInstanceCounter); // tek 27may98 bats 689

  00ae9	68 00 00 00 00	 push	 OFFSET FLAT:_tl_gnInstanceCounter
  00aee	e8 00 00 00 00	 call	 _ThreadUnlock
  00af3	83 c4 10	 add	 esp, 16			; 00000010H

; 3030 : #endif
; 3031 : 	
; 3032 : 	// release the license count..
; 3033 : #if defined WIN32 || defined __linux__
; 3034 : #ifdef LICENSES
; 3035 : 	ReleaseLicenseRef();

  00af6	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 3036 : #endif //LICENSES
; 3037 : #endif
; 3038 : 	
; 3039 : 	return( MMSYSERR_NOERROR );

  00afb	33 c0		 xor	 eax, eax
  00afd	5e		 pop	 esi

; 3040 : }

  00afe	c3		 ret	 0
_TextToSpeechShutdown ENDP
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:NEAR
EXTRN	__imp__SetEvent@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	_write_pipe:NEAR
EXTRN	_exit_pipe:NEAR
EXTRN	_destroy_pipe:NEAR
EXTRN	_PA_DestroyPlayHandle:NEAR
EXTRN	__imp__SendMessageA@16:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	_FreePHInstanceData:NEAR
EXTRN	_unload_dictionary:NEAR
EXTRN	_FreeCMDThreadMemory:NEAR
EXTRN	__imp__UnregisterClassA@8:NEAR
EXTRN	_OP_DestroyMutex:NEAR
_DATA	SEGMENT
	ORG $+3
$SG71902 DB	'TextToSpeechWndClass', 00H
	ORG $+3
$SG71903 DB	'%s_%08X', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pCmd_t$ = -272
_dwDump$ = -268
_wDump$ = -280
_cDump$ = -284
_wndclass$ = -256
_DeleteTextToSpeechObjects PROC NEAR

; 3071 : {

  00b00	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00b06	53		 push	 ebx
  00b07	55		 push	 ebp
  00b08	56		 push	 esi

; 3072 : 	/* Added the following 2 varaibles for MI :MVP */
; 3073 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00b09	8b b4 24 2c 01
	00 00		 mov	 esi, DWORD PTR _phTTS$[esp+292]

; 3074 : 	PVOID pCmd_t = phTTS->pCMDThreadData;
; 3075 : 	DWORD dwDump[3] = { 0x0b, 0x0b, 0x0b };  /*MVP not a static variable,is a const*/
; 3076 : 	WORD wDump[3] = { 0x0b, 0x0b, 0x0b };    /*MVP not a static variable,is a const*/
; 3077 : 	char cDump[3] = { 0x0b, 0x0b, 0x0b };    /*MVP not a static variable,is a const*/
; 3078 : #ifdef WIN32
; 3079 : 	HINSTANCE hInstance;	// 06may97 BATS320   
; 3080 : 	char wndclass[255];	// Window Class (KSB Aug-13-97)
; 3081 : #endif
; 3082 : #if defined __osf__ || defined __linux__
; 3083 : 	THREAD_STATUS_T ThreadStatus;
; 3084 : #endif
; 3085 : 	
; 3086 : 	/********************************************************************/
; 3087 : 	/*  Terminate all threads.                                          */
; 3088 : 	/********************************************************************/
; 3089 : 	
; 3090 : 	if ( pKsd_t->sync_pipe != NULL )

  00b10	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CloseHandle@4
  00b16	57		 push	 edi
  00b17	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00b1a	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00b1d	89 44 24 1c	 mov	 DWORD PTR _pCmd_t$[esp+300], eax
  00b21	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00b26	89 44 24 20	 mov	 DWORD PTR _dwDump$[esp+300], eax
  00b2a	89 44 24 24	 mov	 DWORD PTR _dwDump$[esp+304], eax
  00b2e	89 44 24 28	 mov	 DWORD PTR _dwDump$[esp+308], eax
  00b32	66 89 44 24 14	 mov	 WORD PTR _wDump$[esp+300], ax
  00b37	66 89 44 24 16	 mov	 WORD PTR _wDump$[esp+302], ax
  00b3c	66 89 44 24 18	 mov	 WORD PTR _wDump$[esp+304], ax
  00b41	88 44 24 10	 mov	 BYTE PTR _cDump$[esp+300], al
  00b45	88 44 24 11	 mov	 BYTE PTR _cDump$[esp+301], al
  00b49	88 44 24 12	 mov	 BYTE PTR _cDump$[esp+302], al
  00b4d	8b 87 e0 00 00
	00		 mov	 eax, DWORD PTR [edi+224]
  00b53	33 ed		 xor	 ebp, ebp
  00b55	3b c5		 cmp	 eax, ebp
  00b57	0f 84 7f 01 00
	00		 je	 $L71892

; 3091 : 	{
; 3092 : 		/******************************************************************/
; 3093 : 		/*  Shut down the SYNC thread.                                    */
; 3094 : 		/******************************************************************/
; 3095 : 		
; 3096 : 		if ( phTTS->hThread_SYNC != NULL )

  00b5d	39 6e 34	 cmp	 DWORD PTR [esi+52], ebp
  00b60	74 31		 je	 SHORT $L71878

; 3097 : 		{
; 3098 : 												exit_pipe( pKsd_t->sync_pipe );

  00b62	50		 push	 eax
  00b63	e8 00 00 00 00	 call	 _exit_pipe

; 3099 : 												write_pipe( pKsd_t->sync_pipe, dwDump, 3 );

  00b68	8b 97 e0 00 00
	00		 mov	 edx, DWORD PTR [edi+224]
  00b6e	8d 4c 24 24	 lea	 ecx, DWORD PTR _dwDump$[esp+304]
  00b72	6a 03		 push	 3
  00b74	51		 push	 ecx
  00b75	52		 push	 edx
  00b76	e8 00 00 00 00	 call	 _write_pipe

; 3100 : #ifdef WIN32
; 3101 : 												WaitForSingleObject( phTTS->hThread_SYNC,
; 3102 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00b7b	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00b7e	83 c4 10	 add	 esp, 16			; 00000010H
  00b81	68 e8 03 00 00	 push	 1000			; 000003e8H
  00b86	50		 push	 eax
  00b87	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3103 : 												
; 3104 : 												CloseHandle( phTTS->hThread_SYNC );

  00b8d	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00b90	51		 push	 ecx
  00b91	ff d3		 call	 ebx
$L71878:

; 3105 : #endif
; 3106 : #if defined __osf__ || defined __linux__
; 3107 : 												OP_WaitForThreadTermination( phTTS->hThread_SYNC,
; 3108 : 													&ThreadStatus,
; 3109 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3110 : #endif
; 3111 : 		}
; 3112 : 		
; 3113 : 		/******************************************************************/
; 3114 : 		/*  Shut down the VTM thread.                                     */
; 3115 : 		/******************************************************************/
; 3116 : 		
; 3117 : 		if ( phTTS->hThread_VTM != NULL )

  00b93	39 6e 30	 cmp	 DWORD PTR [esi+48], ebp
  00b96	74 4b		 je	 SHORT $L71880

; 3118 : 		{
; 3119 : 												exit_pipe( pKsd_t->vtm_pipe );

  00b98	8b 97 dc 00 00
	00		 mov	 edx, DWORD PTR [edi+220]
  00b9e	52		 push	 edx
  00b9f	e8 00 00 00 00	 call	 _exit_pipe

; 3120 : 												write_pipe( pKsd_t->vtm_pipe, wDump, 3 );

  00ba4	8b 8f dc 00 00
	00		 mov	 ecx, DWORD PTR [edi+220]
  00baa	8d 44 24 18	 lea	 eax, DWORD PTR _wDump$[esp+304]
  00bae	6a 03		 push	 3
  00bb0	50		 push	 eax
  00bb1	51		 push	 ecx
  00bb2	e8 00 00 00 00	 call	 _write_pipe

; 3121 : 												
; 3122 : 												/*MVP Free the allocated memory in LTS thread activity */
; 3123 : 												if(phTTS->pVTMThreadData)

  00bb7	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00bba	83 c4 10	 add	 esp, 16			; 00000010H
  00bbd	3b c5		 cmp	 eax, ebp
  00bbf	74 0d		 je	 SHORT $L71881

; 3124 : 												{
; 3125 : 													free(phTTS->pVTMThreadData);

  00bc1	50		 push	 eax
  00bc2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00bc8	83 c4 04	 add	 esp, 4

; 3126 : 													phTTS->pVTMThreadData = NULL;

  00bcb	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
$L71881:

; 3127 : 												}
; 3128 : 												
; 3129 : #ifdef WIN32
; 3130 : 												WaitForSingleObject( phTTS->hThread_VTM,
; 3131 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00bce	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00bd1	68 e8 03 00 00	 push	 1000			; 000003e8H
  00bd6	52		 push	 edx
  00bd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3132 : 												
; 3133 : 												CloseHandle( phTTS->hThread_VTM );

  00bdd	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00be0	50		 push	 eax
  00be1	ff d3		 call	 ebx
$L71880:

; 3134 : #endif
; 3135 : #if defined __osf__ || defined __linux__
; 3136 : 												OP_WaitForThreadTermination( phTTS->hThread_VTM,
; 3137 : 													&ThreadStatus,
; 3138 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3139 : #endif
; 3140 : 												
; 3141 : 		}
; 3142 : 		
; 3143 : 		/******************************************************************/
; 3144 : 		/*  Shut down the PH thread.                                      */
; 3145 : 		/******************************************************************/
; 3146 : 		
; 3147 : 		if ( phTTS->hThread_PH != NULL )

  00be3	39 6e 2c	 cmp	 DWORD PTR [esi+44], ebp
  00be6	74 4a		 je	 SHORT $L71884

; 3148 : 		{
; 3149 : 												exit_pipe( pKsd_t->ph_pipe );

  00be8	8b 8f d4 00 00
	00		 mov	 ecx, DWORD PTR [edi+212]
  00bee	51		 push	 ecx
  00bef	e8 00 00 00 00	 call	 _exit_pipe

; 3150 : 												write_pipe( pKsd_t->ph_pipe, wDump, 3 );

  00bf4	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00bfa	8d 54 24 18	 lea	 edx, DWORD PTR _wDump$[esp+304]
  00bfe	6a 03		 push	 3
  00c00	52		 push	 edx
  00c01	50		 push	 eax
  00c02	e8 00 00 00 00	 call	 _write_pipe

; 3151 : 												/*MVP Free the allocated memory in PH thread activity */
; 3152 : 												if(phTTS->pPHThreadData)

  00c07	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00c0a	83 c4 10	 add	 esp, 16			; 00000010H
  00c0d	3b c5		 cmp	 eax, ebp
  00c0f	74 09		 je	 SHORT $L71885

; 3153 : 													FreePHInstanceData(phTTS->pPHThreadData); /* 04aug96 */

  00c11	50		 push	 eax
  00c12	e8 00 00 00 00	 call	 _FreePHInstanceData
  00c17	83 c4 04	 add	 esp, 4
$L71885:

; 3154 : 												phTTS->pPHThreadData = NULL;
; 3155 : 												
; 3156 : #ifdef WIN32
; 3157 : 												WaitForSingleObject( phTTS->hThread_PH,
; 3158 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00c1a	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00c1d	68 e8 03 00 00	 push	 1000			; 000003e8H
  00c22	51		 push	 ecx
  00c23	89 6e 18	 mov	 DWORD PTR [esi+24], ebp
  00c26	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3159 : 												
; 3160 : 												CloseHandle( phTTS->hThread_PH );

  00c2c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00c2f	52		 push	 edx
  00c30	ff d3		 call	 ebx
$L71884:

; 3161 : #endif
; 3162 : #if defined __osf__ || defined __linux__
; 3163 : 												OP_WaitForThreadTermination( phTTS->hThread_PH,
; 3164 : 													&ThreadStatus,
; 3165 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3166 : #endif
; 3167 : 		}
; 3168 : 		
; 3169 : 		/******************************************************************/
; 3170 : 		/*  Shut down the LTS thread.                                     */
; 3171 : 		/******************************************************************/
; 3172 : 		
; 3173 : 		if ( phTTS->hThread_LTS != NULL )

  00c32	39 6e 28	 cmp	 DWORD PTR [esi+40], ebp
  00c35	74 4b		 je	 SHORT $L71888

; 3174 : 		{
; 3175 : 												exit_pipe( pKsd_t->lts_pipe );

  00c37	8b 87 d0 00 00
	00		 mov	 eax, DWORD PTR [edi+208]
  00c3d	50		 push	 eax
  00c3e	e8 00 00 00 00	 call	 _exit_pipe

; 3176 : 												write_pipe( pKsd_t->lts_pipe, wDump, 3 );

  00c43	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00c49	8d 4c 24 18	 lea	 ecx, DWORD PTR _wDump$[esp+304]
  00c4d	6a 03		 push	 3
  00c4f	51		 push	 ecx
  00c50	52		 push	 edx
  00c51	e8 00 00 00 00	 call	 _write_pipe

; 3177 : 												/*MVP Free the allocated memory in LTS thread activity */
; 3178 : 												if(phTTS->pLTSThreadData)

  00c56	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00c59	83 c4 10	 add	 esp, 16			; 00000010H
  00c5c	3b c5		 cmp	 eax, ebp
  00c5e	74 0a		 je	 SHORT $L71889

; 3179 : 													free(phTTS->pLTSThreadData);

  00c60	50		 push	 eax
  00c61	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00c67	83 c4 04	 add	 esp, 4
$L71889:

; 3180 : 												phTTS->pLTSThreadData = NULL;
; 3181 : #ifdef WIN32
; 3182 : 												WaitForSingleObject( phTTS->hThread_LTS,
; 3183 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00c6a	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00c6d	68 e8 03 00 00	 push	 1000			; 000003e8H
  00c72	50		 push	 eax
  00c73	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
  00c76	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3184 : 												
; 3185 : 												CloseHandle( phTTS->hThread_LTS );

  00c7c	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00c7f	51		 push	 ecx
  00c80	ff d3		 call	 ebx
$L71888:

; 3186 : #endif
; 3187 : #if defined __osf__ || defined __linux__
; 3188 : 												OP_WaitForThreadTermination( phTTS->hThread_LTS,
; 3189 : 													&ThreadStatus,
; 3190 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3191 : #endif
; 3192 : 		}
; 3193 : 
; 3194 : 		
; 3195 : 		/******************************************************************/
; 3196 : 		/*  Shut down the CMD thread.                                     */
; 3197 : 		/******************************************************************/
; 3198 : 		
; 3199 : 		if ( phTTS->hThread_CMD != NULL )

  00c82	39 6e 24	 cmp	 DWORD PTR [esi+36], ebp
  00c85	74 55		 je	 SHORT $L71892

; 3200 : 		{
; 3201 : 												exit_pipe( pKsd_t->cmd_pipe );

  00c87	8b 97 d8 00 00
	00		 mov	 edx, DWORD PTR [edi+216]
  00c8d	52		 push	 edx
  00c8e	e8 00 00 00 00	 call	 _exit_pipe

; 3202 : 												write_pipe( pKsd_t->cmd_pipe, cDump, 3 );

  00c93	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  00c99	8d 44 24 14	 lea	 eax, DWORD PTR _cDump$[esp+304]
  00c9d	6a 03		 push	 3
  00c9f	50		 push	 eax
  00ca0	51		 push	 ecx
  00ca1	e8 00 00 00 00	 call	 _write_pipe

; 3203 : 												/*MVP Free the allocated memory in CMD thread activity */
; 3204 : 												if(pCmd_t)

  00ca6	8b 44 24 2c	 mov	 eax, DWORD PTR _pCmd_t$[esp+316]
  00caa	83 c4 10	 add	 esp, 16			; 00000010H
  00cad	3b c5		 cmp	 eax, ebp
  00caf	74 09		 je	 SHORT $L71893

; 3205 : 													FreeCMDThreadMemory(pCmd_t);

  00cb1	50		 push	 eax
  00cb2	e8 00 00 00 00	 call	 _FreeCMDThreadMemory
  00cb7	83 c4 04	 add	 esp, 4
$L71893:

; 3206 : 												phTTS->pCMDThreadData = pCmd_t = NULL;
; 3207 : 												
; 3208 : #ifdef WIN32
; 3209 : 												SetEvent( phTTS->hSyncEvent );

  00cba	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00cbd	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00cc0	52		 push	 edx
  00cc1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 3210 : 												
; 3211 : 												WaitForSingleObject( phTTS->hThread_CMD,
; 3212 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00cc7	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00cca	68 e8 03 00 00	 push	 1000			; 000003e8H
  00ccf	50		 push	 eax
  00cd0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3213 : 												
; 3214 : 												CloseHandle( phTTS->hThread_CMD );

  00cd6	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00cd9	51		 push	 ecx
  00cda	ff d3		 call	 ebx
$L71892:

; 3215 : #endif
; 3216 : #if defined __osf__ || defined __linux__
; 3217 : 												OP_SetEvent( phTTS->hSyncEvent );
; 3218 : 												
; 3219 : 												OP_WaitForThreadTermination( phTTS->hThread_CMD,
; 3220 : 													&ThreadStatus,
; 3221 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3222 : #endif
; 3223 : 		}
; 3224 :   }
; 3225 :   
; 3226 :   /********************************************************************/
; 3227 :   /*  Shutdown the Audio thread                                       */
; 3228 :   /********************************************************************/
; 3229 :   
; 3230 :   if ( phTTS->pAudioHandle != NULL )

  00cdc	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  00ce2	3b c5		 cmp	 eax, ebp
  00ce4	74 09		 je	 SHORT $L71896

; 3231 : 	  PA_DestroyPlayHandle( phTTS->pAudioHandle );

  00ce6	50		 push	 eax
  00ce7	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00cec	83 c4 04	 add	 esp, 4
$L71896:

; 3232 :   
; 3233 :   /********************************************************************/
; 3234 :   /*  Terminate the Text-To-Speech thread.                            */
; 3235 :   /********************************************************************/
; 3236 :   
; 3237 :   // 06may97 tek BATS320
; 3238 :   // get the instance so that we can unregister the class
; 3239 :   // after the window is destroyed
; 3240 :   // tek 13nov97 we have no idea whether hWnd is valid, so use NULL.
; 3241 :   //hInstance = (HINSTANCE)GetWindowLong( phTTS->hWnd,
; 3242 :   //					GWL_HINSTANCE );
; 3243 : #ifdef WIN32
; 3244 :   hInstance = NULL;
; 3245 : #endif
; 3246 :   
; 3247 :   if ( phTTS->hThread_TXT != NULL )

  00cef	39 6e 20	 cmp	 DWORD PTR [esi+32], ebp
  00cf2	74 4b		 je	 SHORT $L71899

; 3248 :   {
; 3249 : #if !defined __osf__ && !defined __linux__
; 3250 : 	  MMRESULT mmStatus=0;
; 3251 : 	  SendMessage( phTTS->hTextToSpeechWnd,
; 3252 : 		  ID_TTS_Destroy,
; 3253 : 		  0L,
; 3254 : 		  0L );

  00cf4	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00cf7	55		 push	 ebp
  00cf8	55		 push	 ebp
  00cf9	68 01 04 00 00	 push	 1025			; 00000401H
  00cfe	52		 push	 edx
  00cff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 3255 : 	  
; 3256 : 	  WaitForSingleObject( phTTS->hThread_TXT,
; 3257 : 		  TIMEOUT_INTERVAL_IN_MSEC );

  00d05	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00d08	68 e8 03 00 00	 push	 1000			; 000003e8H
  00d0d	50		 push	 eax
  00d0e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3258 : 	  
; 3259 : 	  CloseHandle( phTTS->hThread_TXT );

  00d14	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00d17	51		 push	 ecx
  00d18	ff d3		 call	 ebx

; 3260 : 	  sprintf(wndclass,"%s_%08X",TEXTTOSPEECHWNDCLASS,(unsigned long int) phTTS);

  00d1a	56		 push	 esi
  00d1b	68 00 00 00 00	 push	 OFFSET FLAT:$SG71902
  00d20	8d 54 24 34	 lea	 edx, DWORD PTR _wndclass$[esp+308]
  00d24	68 00 00 00 00	 push	 OFFSET FLAT:$SG71903
  00d29	52		 push	 edx
  00d2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00d30	83 c4 10	 add	 esp, 16			; 00000010H

; 3261 : 	  mmStatus = UnregisterClass(wndclass,hInstance);

  00d33	8d 44 24 2c	 lea	 eax, DWORD PTR _wndclass$[esp+300]
  00d37	55		 push	 ebp
  00d38	50		 push	 eax
  00d39	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
$L71899:

; 3262 : #endif
; 3263 : #if defined __osf__ || defined __linux__
; 3264 : 	  phTTS->uiTextThreadExit = TRUE;
; 3265 : 	  OP_SetEvent(phTTS->hTextInQueueEvent);
; 3266 : 	  OP_WaitForThreadTermination(phTTS->hThread_TXT, 
; 3267 : 		  &ThreadStatus, 
; 3268 : 		  OP_INFINITE);
; 3269 : 	  phTTS->hThread_TXT = NULL;
; 3270 : #endif	
; 3271 :   }
; 3272 :   
; 3273 :   /********************************************************************/
; 3274 :   /*  Free the handle to the "Not Emptying Vtm Pipe" event.           */
; 3275 :   /********************************************************************/
; 3276 :   
; 3277 :   if ( phTTS->hNotEmptyingVtmPipeEvent != NULL )

  00d3f	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00d42	3b c5		 cmp	 eax, ebp
  00d44	74 03		 je	 SHORT $L71905

; 3278 :   {
; 3279 : #ifdef WIN32
; 3280 : 	  CloseHandle( phTTS->hNotEmptyingVtmPipeEvent );

  00d46	50		 push	 eax
  00d47	ff d3		 call	 ebx
$L71905:

; 3281 : #endif
; 3282 : #if defined __osf__ || defined __linux__
; 3283 : 	  OP_DestroyEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 3284 : #endif
; 3285 :   }
; 3286 :   
; 3287 :   /********************************************************************/
; 3288 :   /*  Free the handle to the "Sync" event.                            */
; 3289 :   /********************************************************************/
; 3290 :   
; 3291 :   if ( phTTS->hSyncEvent != NULL )

  00d49	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00d4c	3b c5		 cmp	 eax, ebp
  00d4e	74 03		 je	 SHORT $L71907

; 3292 :   {
; 3293 : #ifdef WIN32
; 3294 : 	  CloseHandle( phTTS->hSyncEvent );

  00d50	50		 push	 eax
  00d51	ff d3		 call	 ebx
$L71907:

; 3295 : #endif
; 3296 : #if defined __osf__ || defined __linux__
; 3297 : 	  OP_DestroyEvent( phTTS->hSyncEvent );
; 3298 : #endif
; 3299 :   }
; 3300 :   
; 3301 : #if defined __osf__ || defined __linux__
; 3302 :   
; 3303 :   /********************************************************************/
; 3304 :   /*  Free the handle to the "TextInQueue" event.                     */
; 3305 :   /********************************************************************/
; 3306 :   
; 3307 :   if ( phTTS->hTextInQueueEvent != NULL )
; 3308 :   {
; 3309 : 	  OP_DestroyEvent( phTTS->hTextInQueueEvent );
; 3310 : 	  phTTS->hTextInQueueEvent = NULL;
; 3311 :   }
; 3312 : #endif
; 3313 :   
; 3314 :   /********************************************************************/
; 3315 :   /*  Free the handle to the "Successful Memory alloacation" event.   */
; 3316 :   /********************************************************************/
; 3317 :   
; 3318 :   if (phTTS->hMallocSuccessEvent != NULL)

  00d53	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00d56	3b c5		 cmp	 eax, ebp
  00d58	74 06		 je	 SHORT $L71909

; 3319 :   {
; 3320 : #ifdef WIN32
; 3321 : 	  CloseHandle(phTTS->hMallocSuccessEvent);

  00d5a	50		 push	 eax
  00d5b	ff d3		 call	 ebx

; 3322 : #endif
; 3323 : #if defined __osf__ || defined __linux__
; 3324 : 	  OP_DestroyEvent(phTTS->hMallocSuccessEvent);
; 3325 : #endif
; 3326 : 	  phTTS->hMallocSuccessEvent = NULL;

  00d5d	89 6e 1c	 mov	 DWORD PTR [esi+28], ebp
$L71909:

; 3327 : 	  
; 3328 :   }
; 3329 :   
; 3330 :   /********************************************************************/
; 3331 :   /*  Free the handle to the "TTS Callback Mutex .                    */
; 3332 :   /********************************************************************/
; 3333 :   
; 3334 : #ifdef WIN32
; 3335 :   if (phTTS->hmxCallback != NULL)

  00d60	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  00d66	3b c5		 cmp	 eax, ebp
  00d68	74 0f		 je	 SHORT $L71912

; 3336 :   {
; 3337 : 	  OP_DestroyMutex(phTTS->hmxCallback);    // tek 03aug96

  00d6a	50		 push	 eax
  00d6b	e8 00 00 00 00	 call	 _OP_DestroyMutex
  00d70	83 c4 04	 add	 esp, 4

; 3338 : 	  phTTS->hmxCallback = NULL;

  00d73	89 ae ac 00 00
	00		 mov	 DWORD PTR [esi+172], ebp
$L71912:

; 3339 :   }
; 3340 : #endif
; 3341 : #if defined __osf__ || defined __linux__
; 3342 :   if (phTTS->pcsCallback != NULL)
; 3343 :   {
; 3344 : 	  OP_DestroyMutex(phTTS->pcsCallback);
; 3345 : 	  phTTS->pcsCallback = NULL;
; 3346 :   }
; 3347 : #endif
; 3348 :   
; 3349 :   /********************************************************************/
; 3350 :   /*  Delete the log file critical section.                           */
; 3351 :   /********************************************************************/
; 3352 :   
; 3353 :   if ( phTTS->pcsLogFile != NULL )

  00d79	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  00d7f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeleteCriticalSection@4
  00d85	3b c5		 cmp	 eax, ebp
  00d87	74 13		 je	 SHORT $L71915

; 3354 :   {
; 3355 : #ifdef WIN32
; 3356 : 	  DeleteCriticalSection( phTTS->pcsLogFile );

  00d89	50		 push	 eax
  00d8a	ff d3		 call	 ebx

; 3357 : 	  
; 3358 : 	  free( phTTS->pcsLogFile );

  00d8c	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  00d92	51		 push	 ecx
  00d93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00d99	83 c4 04	 add	 esp, 4
$L71915:

; 3359 : #endif
; 3360 : #if defined __osf__ || defined __linux__
; 3361 : 	  OP_DestroyMutex( phTTS->pcsLogFile );
; 3362 : #endif 
; 3363 : 	  
; 3364 :   }
; 3365 :   
; 3366 :   /********************************************************************/
; 3367 :   /*  Delete the queued character count critical section.             */
; 3368 :   /********************************************************************/
; 3369 :   
; 3370 :   if ( phTTS->pcsQueuedCharacterCount != NULL )

  00d9c	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00da2	3b c5		 cmp	 eax, ebp
  00da4	74 13		 je	 SHORT $L71917

; 3371 :   {
; 3372 : #ifdef WIN32
; 3373 : 	  DeleteCriticalSection( phTTS->pcsQueuedCharacterCount );

  00da6	50		 push	 eax
  00da7	ff d3		 call	 ebx

; 3374 : 	  
; 3375 : 	  free( phTTS->pcsQueuedCharacterCount );

  00da9	8b 96 c0 00 00
	00		 mov	 edx, DWORD PTR [esi+192]
  00daf	52		 push	 edx
  00db0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00db6	83 c4 04	 add	 esp, 4
$L71917:

; 3376 : #endif
; 3377 : #if defined __osf__ || defined __linux__
; 3378 : 	  OP_DestroyMutex( phTTS->pcsQueuedCharacterCount );
; 3379 : #endif
; 3380 :   }
; 3381 :   
; 3382 : #ifdef WIN32
; 3383 :   /* tek 6mar97 bats 278 */
; 3384 :   /********************************************************************/
; 3385 :   /*  Delete the index queue critical section.                        */
; 3386 :   /********************************************************************/
; 3387 :   
; 3388 :   if ( pKsd_t->pcsSpcPktSave != NULL )

  00db9	8b 87 80 01 00
	00		 mov	 eax, DWORD PTR [edi+384]
  00dbf	3b c5		 cmp	 eax, ebp
  00dc1	74 19		 je	 SHORT $L71919

; 3389 :   {
; 3390 : 	  DeleteCriticalSection( pKsd_t->pcsSpcPktSave );

  00dc3	50		 push	 eax
  00dc4	ff d3		 call	 ebx

; 3391 : 	  
; 3392 : 	  free( pKsd_t->pcsSpcPktSave );

  00dc6	8b 87 80 01 00
	00		 mov	 eax, DWORD PTR [edi+384]
  00dcc	50		 push	 eax
  00dcd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00dd3	83 c4 04	 add	 esp, 4

; 3393 : 	  pKsd_t->pcsSpcPktSave = NULL;

  00dd6	89 af 80 01 00
	00		 mov	 DWORD PTR [edi+384], ebp
$L71919:

; 3394 :   }
; 3395 : #endif
; 3396 :   
; 3397 :   
; 3398 :   /********************************************************************/
; 3399 :   /*  Delete the flush message number critical section.               */
; 3400 :   /********************************************************************/
; 3401 :   
; 3402 :   if ( phTTS->pcsFlushMsgNumber != NULL )

  00ddc	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  00de2	3b c5		 cmp	 eax, ebp
  00de4	74 13		 je	 SHORT $L71922

; 3403 :   {
; 3404 : #ifdef WIN32
; 3405 : 	  DeleteCriticalSection( phTTS->pcsFlushMsgNumber );

  00de6	50		 push	 eax
  00de7	ff d3		 call	 ebx

; 3406 : 	  
; 3407 : 	  free( phTTS->pcsFlushMsgNumber );

  00de9	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  00def	51		 push	 ecx
  00df0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00df6	83 c4 04	 add	 esp, 4
$L71922:

; 3408 : #endif
; 3409 : #if defined __osf__ || defined __linux__
; 3410 : 	  OP_DestroyMutex( phTTS->pcsFlushMsgNumber );
; 3411 : #endif
; 3412 :   }
; 3413 :   
; 3414 :   
; 3415 :   /********************************************************************/
; 3416 :   /*  Delete the Buffer Pipe mutex.                                   */
; 3417 :   /********************************************************************/
; 3418 :   
; 3419 :   if ( phTTS->pcsBufferPipe != NULL )

  00df9	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  00dff	3b c5		 cmp	 eax, ebp
  00e01	74 13		 je	 SHORT $L71924

; 3420 :   {
; 3421 : #ifdef WIN32
; 3422 : 	  DeleteCriticalSection( phTTS->pcsBufferPipe );

  00e03	50		 push	 eax
  00e04	ff d3		 call	 ebx

; 3423 : 	  
; 3424 : 	  free( phTTS->pcsBufferPipe );

  00e06	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  00e0c	52		 push	 edx
  00e0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00e13	83 c4 04	 add	 esp, 4
$L71924:

; 3425 : #endif
; 3426 : #if defined __osf__ || defined __linux__
; 3427 : 	  OP_DestroyMutex( phTTS->pcsBufferPipe );
; 3428 : #endif
; 3429 :   }
; 3430 :   
; 3431 : #if defined __osf__ || defined __linux__
; 3432 :   /********************************************************************/
; 3433 :   /*  Delete the Text Msg mutex.                                      */
; 3434 :   /********************************************************************/
; 3435 :   
; 3436 :   if ( phTTS->pcsTextMsgList != NULL )
; 3437 :   {
; 3438 : 	  OP_DestroyMutex( phTTS->pcsTextMsgList );
; 3439 :   }
; 3440 : #endif
; 3441 :   
; 3442 :   /********************************************************************/
; 3443 :   /*  Delete the last queued text message number critical section.    */
; 3444 :   /********************************************************************/
; 3445 :   
; 3446 :   if ( phTTS->pcsLastQueuedTextMsgNumber != NULL )

  00e16	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  00e1c	3b c5		 cmp	 eax, ebp
  00e1e	74 13		 je	 SHORT $L71926

; 3447 :   {
; 3448 : #ifdef WIN32
; 3449 : 	  DeleteCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  00e20	50		 push	 eax
  00e21	ff d3		 call	 ebx

; 3450 : 	  
; 3451 : 	  free( phTTS->pcsLastQueuedTextMsgNumber );

  00e23	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  00e29	50		 push	 eax
  00e2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00e30	83 c4 04	 add	 esp, 4
$L71926:

; 3452 : #endif
; 3453 : #if defined __osf__ || defined __linux__
; 3454 : 	  OP_DestroyMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3455 : #endif
; 3456 :   }
; 3457 :   
; 3458 :   /********************************************************************/
; 3459 :   /*  Delete the queued sample count critical section.                */
; 3460 :   /********************************************************************/
; 3461 :   
; 3462 :   if ( phTTS->pcsQueuedSampleCount != NULL )

  00e33	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  00e39	3b c5		 cmp	 eax, ebp
  00e3b	74 13		 je	 SHORT $L71928

; 3463 :   {
; 3464 : #ifdef WIN32
; 3465 : 	  DeleteCriticalSection( phTTS->pcsQueuedSampleCount );

  00e3d	50		 push	 eax
  00e3e	ff d3		 call	 ebx

; 3466 : 	  
; 3467 : 	  free( phTTS->pcsQueuedSampleCount );

  00e40	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  00e46	51		 push	 ecx
  00e47	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00e4d	83 c4 04	 add	 esp, 4
$L71928:

; 3468 :   }
; 3469 :   
; 3470 :   // tek 24oct97 bats 497 delete and deallocate this critical section object
; 3471 :   if ( pKsd_t->pcsVtmPipeRead != NULL )

  00e50	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  00e56	3b c5		 cmp	 eax, ebp
  00e58	74 1d		 je	 SHORT $L73252

; 3472 :   {
; 3473 : 	  DeleteCriticalSection( pKsd_t->pcsVtmPipeRead );

  00e5a	50		 push	 eax
  00e5b	ff d3		 call	 ebx

; 3474 : 	  
; 3475 : 	  free( pKsd_t->pcsVtmPipeRead );

  00e5d	8b 97 f4 00 00
	00		 mov	 edx, DWORD PTR [edi+244]
  00e63	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  00e69	52		 push	 edx
  00e6a	ff d3		 call	 ebx
  00e6c	83 c4 04	 add	 esp, 4

; 3476 : 	  pKsd_t->pcsVtmPipeRead = NULL;

  00e6f	89 af f4 00 00
	00		 mov	 DWORD PTR [edi+244], ebp
  00e75	eb 06		 jmp	 SHORT $L71930
$L73252:
  00e77	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
$L71930:

; 3477 :   }
; 3478 :   // tek 24oct97 end of bats 497
; 3479 : #endif
; 3480 : #if defined __osf__ || defined __linux__
; 3481 :   OP_DestroyMutex( phTTS->pcsQueuedSampleCount );
; 3482 :   }
; 3483 : #endif
; 3484 :   
; 3485 :   /********************************************************************/
; 3486 :   /*  Free the dictionary memory.                                     */
; 3487 :   /********************************************************************/
; 3488 :   /*MVP : Unload dictionary when no other instance of DECtalk speech  */
; 3489 :   /*      object is running                                           */
; 3490 :   
; 3491 :   if(!gnInstanceCounter)        

  00e7d	39 2d 00 00 00
	00		 cmp	 DWORD PTR _gnInstanceCounter, ebp
  00e83	75 2b		 jne	 SHORT $L71933

; 3492 :   {
; 3493 : 	  /* GL 11/05/1997  for BATS#510 */
; 3494 : 	  if ( pKsd_t->fdic_entries[pKsd_t->lang_curr] != 0 )

  00e85	8b 87 f8 00 00
	00		 mov	 eax, DWORD PTR [edi+248]
  00e8b	8b 54 87 1c	 mov	 edx, DWORD PTR [edi+eax*4+28]
  00e8f	8d 4c 87 1c	 lea	 ecx, DWORD PTR [edi+eax*4+28]
  00e93	3b d5		 cmp	 edx, ebp
  00e95	74 19		 je	 SHORT $L71933

; 3495 : 	  {
; 3496 : 		  unload_dictionary((void **)&(pKsd_t->fdic[pKsd_t->lang_curr]),
; 3497 : 			  (unsigned int *)&(pKsd_t->fdic_entries[pKsd_t->lang_curr]));

  00e97	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  00e9a	51		 push	 ecx
  00e9b	50		 push	 eax
  00e9c	e8 00 00 00 00	 call	 _unload_dictionary
  00ea1	83 c4 08	 add	 esp, 8

; 3498 : 		  gpufdic = NULL;

  00ea4	89 2d 00 00 00
	00		 mov	 DWORD PTR _gpufdic, ebp

; 3499 : 		  gufdic_entries = 0;

  00eaa	89 2d 00 00 00
	00		 mov	 DWORD PTR _gufdic_entries, ebp
$L71933:

; 3500 : 	  }
; 3501 :   }
; 3502 :   
; 3503 :   /********************************************************************/
; 3504 :   /*  Free the user dictionary memory.                                */
; 3505 :   /********************************************************************/
; 3506 :   
; 3507 :   /* GL 11/05/1997  for BATS#510 */
; 3508 :   if ( pKsd_t->udic_entries[pKsd_t->lang_curr] != 0 )

  00eb0	8b 87 f8 00 00
	00		 mov	 eax, DWORD PTR [edi+248]
  00eb6	8b 54 87 54	 mov	 edx, DWORD PTR [edi+eax*4+84]
  00eba	8d 4c 87 54	 lea	 ecx, DWORD PTR [edi+eax*4+84]
  00ebe	3b d5		 cmp	 edx, ebp
  00ec0	74 0e		 je	 SHORT $L71937

; 3509 :   {
; 3510 : 	  unload_dictionary((void **)&pKsd_t->udic[pKsd_t->lang_curr],
; 3511 : 		  (unsigned int *)&pKsd_t->udic_entries[pKsd_t->lang_curr] );

  00ec2	51		 push	 ecx
  00ec3	8d 4c 87 38	 lea	 ecx, DWORD PTR [edi+eax*4+56]
  00ec7	51		 push	 ecx
  00ec8	e8 00 00 00 00	 call	 _unload_dictionary
  00ecd	83 c4 08	 add	 esp, 8
$L71937:

; 3512 :   }
; 3513 :   
; 3514 :   /********************************************************************/
; 3515 :   /*  Destroy all the pipes.                                          */
; 3516 :   /********************************************************************/
; 3517 :   /* tek 30aug96 be kind; NULL the pointers when done.. */
; 3518 :   if ( pKsd_t->sync_pipe != NULL )

  00ed0	8b 87 e0 00 00
	00		 mov	 eax, DWORD PTR [edi+224]
  00ed6	3b c5		 cmp	 eax, ebp
  00ed8	74 0f		 je	 SHORT $L71941

; 3519 :   {
; 3520 : 	  destroy_pipe( pKsd_t->sync_pipe );

  00eda	50		 push	 eax
  00edb	e8 00 00 00 00	 call	 _destroy_pipe
  00ee0	83 c4 04	 add	 esp, 4

; 3521 : 	  pKsd_t->sync_pipe = NULL;

  00ee3	89 af e0 00 00
	00		 mov	 DWORD PTR [edi+224], ebp
$L71941:

; 3522 :   }
; 3523 :   
; 3524 :   if ( pKsd_t->vtm_pipe != NULL )

  00ee9	8b 87 dc 00 00
	00		 mov	 eax, DWORD PTR [edi+220]
  00eef	3b c5		 cmp	 eax, ebp
  00ef1	74 0f		 je	 SHORT $L71944

; 3525 :   {
; 3526 : 	  destroy_pipe( pKsd_t->vtm_pipe );

  00ef3	50		 push	 eax
  00ef4	e8 00 00 00 00	 call	 _destroy_pipe
  00ef9	83 c4 04	 add	 esp, 4

; 3527 : 	  pKsd_t->vtm_pipe = NULL;

  00efc	89 af dc 00 00
	00		 mov	 DWORD PTR [edi+220], ebp
$L71944:

; 3528 :   }
; 3529 :   
; 3530 :   if ( pKsd_t->ph_pipe != NULL )

  00f02	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00f08	3b c5		 cmp	 eax, ebp
  00f0a	74 0f		 je	 SHORT $L71947

; 3531 :   {
; 3532 : 	  destroy_pipe( pKsd_t->ph_pipe );

  00f0c	50		 push	 eax
  00f0d	e8 00 00 00 00	 call	 _destroy_pipe
  00f12	83 c4 04	 add	 esp, 4

; 3533 : 	  pKsd_t->ph_pipe = NULL;

  00f15	89 af d4 00 00
	00		 mov	 DWORD PTR [edi+212], ebp
$L71947:

; 3534 :   }
; 3535 :   
; 3536 :   if ( pKsd_t->lts_pipe != NULL )

  00f1b	8b 87 d0 00 00
	00		 mov	 eax, DWORD PTR [edi+208]
  00f21	3b c5		 cmp	 eax, ebp
  00f23	74 0f		 je	 SHORT $L71950

; 3537 :   {
; 3538 : 	  destroy_pipe( pKsd_t->lts_pipe );

  00f25	50		 push	 eax
  00f26	e8 00 00 00 00	 call	 _destroy_pipe
  00f2b	83 c4 04	 add	 esp, 4

; 3539 : 	  pKsd_t->lts_pipe = NULL;

  00f2e	89 af d0 00 00
	00		 mov	 DWORD PTR [edi+208], ebp
$L71950:

; 3540 :   }
; 3541 :   
; 3542 :   if ( pKsd_t->cmd_pipe != NULL )

  00f34	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  00f3a	3b c5		 cmp	 eax, ebp
  00f3c	74 0f		 je	 SHORT $L71953

; 3543 :   {
; 3544 : 	  destroy_pipe( pKsd_t->cmd_pipe );

  00f3e	50		 push	 eax
  00f3f	e8 00 00 00 00	 call	 _destroy_pipe
  00f44	83 c4 04	 add	 esp, 4

; 3545 : 	  pKsd_t->cmd_pipe = NULL;

  00f47	89 af d8 00 00
	00		 mov	 DWORD PTR [edi+216], ebp
$L71953:

; 3546 :   }
; 3547 :   
; 3548 :   /********************************************************************/
; 3549 :   /* Free the "loaded_languages" element of Kernel_share_data structure*/
; 3550 :   /* This element have been allocated in Kernel sub-system in usa_init*/
; 3551 :   /* function. MVP MI                                                 */
; 3552 :   /********************************************************************/
; 3553 :   if(pKsd_t->loaded_languages != NULL)  

  00f4d	8b 87 54 04 00
	00		 mov	 eax, DWORD PTR [edi+1108]
  00f53	3b c5		 cmp	 eax, ebp
  00f55	74 0c		 je	 SHORT $L71956

; 3554 :   {
; 3555 : 	  free(pKsd_t->loaded_languages);

  00f57	50		 push	 eax
  00f58	ff d3		 call	 ebx
  00f5a	83 c4 04	 add	 esp, 4

; 3556 : 	  pKsd_t->loaded_languages = NULL;

  00f5d	89 af 54 04 00
	00		 mov	 DWORD PTR [edi+1108], ebp
$L71956:

; 3557 :   }
; 3558 :   
; 3559 :   /********************************************************************/
; 3560 :   /* Free the kernel_share_data element in TTS structure for MI :MVP  */
; 3561 :   /********************************************************************/
; 3562 :   if(phTTS->pKernelShareData != NULL)

  00f63	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00f66	3b c5		 cmp	 eax, ebp
  00f68	74 09		 je	 SHORT $L71959

; 3563 :   {
; 3564 : 	  free(phTTS->pKernelShareData);

  00f6a	50		 push	 eax
  00f6b	ff d3		 call	 ebx
  00f6d	83 c4 04	 add	 esp, 4

; 3565 : 	  phTTS->pKernelShareData = NULL;

  00f70	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
$L71959:

; 3566 :   }
; 3567 :   
; 3568 :   /********************************************************************/
; 3569 :   /*  Free the TTS handle structure.                                  */
; 3570 :   /********************************************************************/
; 3571 :   
; 3572 :   free( phTTS );

  00f73	56		 push	 esi
  00f74	ff d3		 call	 ebx
  00f76	83 c4 04	 add	 esp, 4
  00f79	5f		 pop	 edi
  00f7a	5e		 pop	 esi
  00f7b	5d		 pop	 ebp
  00f7c	5b		 pop	 ebx

; 3573 :   phTTS=NULL;
; 3574 :   
; 3575 :   return;
; 3576 : }

  00f7d	81 c4 1c 01 00
	00		 add	 esp, 284		; 0000011cH
  00f83	c3		 ret	 0
_DeleteTextToSpeechObjects ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSpeak
PUBLIC	_TextToSpeechSpeakEx
_TEXT	SEGMENT
_phTTS$ = 8
_pszTextString$ = 12
_dwFlags$ = 16
_TextToSpeechSpeak PROC NEAR

; 3639 : {

  00f90	56		 push	 esi

; 3640 : 
; 3641 : #ifdef UNDER_CE	//01jan99 mfg convert unicode string to char string for Windows CE
; 3642 : char string[16384];
; 3643 : 
; 3644 : WideStringtoAsciiString(string, pszTextString, 16384);
; 3645 : #endif
; 3646 : 
; 3647 : 	/********************************************************************/
; 3648 : 	/*  Return error if invalid handle.                                 */
; 3649 : 	/********************************************************************/
; 3650 : #ifdef WIN32
; 3651 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  00f91	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00f95	6a 04		 push	 4
  00f97	56		 push	 esi
  00f98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  00f9e	85 c0		 test	 eax, eax
  00fa0	74 07		 je	 SHORT $L71969

; 3652 : 		return( MMSYSERR_INVALHANDLE );

  00fa2	b8 05 00 00 00	 mov	 eax, 5
  00fa7	5e		 pop	 esi

; 3668 : 		// will break existing apps.. sigh..
; 3669 : 	}
; 3670 : #endif
; 3671 : #if defined __osf__ || defined __linux__
; 3672 : 	char proc_name[]="TextToSpeechSpeak";
; 3673 : 	int uiTextLength = 0;
; 3674 : 	unsigned char * pText;
; 3675 : 	LPTEXT_MSG_T pTextMsg;
; 3676 : 	LPTEXT_MSG_T pNextTextMsg;
; 3677 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 3678 : 	const char cForce2 = (char)(SYNC);
; 3679 : 	
; 3680 : #ifdef TTSDBG
; 3681 : 	printf("%s\n",proc_name);
; 3682 : #endif
; 3683 : 	
; 3684 : 	/********************************************************************/
; 3685 : 	/*  Return error if NULL handle.                                    */
; 3686 : 	/********************************************************************/
; 3687 : 	if (phTTS == NULL)
; 3688 : 		return( MMSYSERR_INVALHANDLE );
; 3689 : 	
; 3690 : 	/********************************************************************/
; 3691 : 	/*  Allocate the memory locked Text Message structure.              */
; 3692 : 	/********************************************************************/
; 3693 : 	
; 3694 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 3695 : 	
; 3696 : 	if ( pTextMsg == NULL )
; 3697 : 		return( MMSYSERR_NOMEM );
; 3698 : 	
; 3699 : 	pTextMsg->pLink = NULL;
; 3700 : 	
; 3701 : 	/********************************************************************/
; 3702 : 	/*  Adjust string length for force character.                       */
; 3703 : 	/********************************************************************/
; 3704 : 	
; 3705 : 	uiTextLength = strlen(pszTextString);
; 3706 : 	
; 3707 : 	if( dwFlags & TTS_FORCE )
; 3708 : 	{
; 3709 : 		uiTextLength++;
; 3710 : 	}
; 3711 : 	
; 3712 : 	/********************************************************************/
; 3713 : 	/*  If the text length is zero then exit with success.              */
; 3714 : 	/********************************************************************/
; 3715 : 	
; 3716 : 	if ( uiTextLength == 0 )
; 3717 : 	{
; 3718 : 		free( pTextMsg );
; 3719 : 		return MMSYSERR_NOERROR;
; 3720 : 	}
; 3721 : 	
; 3722 : 	/********************************************************************/
; 3723 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 3724 : 	/*  location in case the force character is appended to the text    */
; 3725 : 	/*  string.                                                         */
; 3726 : 	/********************************************************************/
; 3727 : 	
; 3728 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 3729 : 	
; 3730 : 	if ( pText == NULL )
; 3731 : 	{ 
; 3732 : 		free( pTextMsg );
; 3733 : 		return( MMSYSERR_NOMEM );
; 3734 : 	} 
; 3735 : 	
; 3736 : 	/********************************************************************/
; 3737 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 3738 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 3739 : 	/*  should not be used after the call to the function.              */
; 3740 : 	/********************************************************************/
; 3741 : 	
; 3742 : 	strcpy( pText, pszTextString );
; 3743 : 	
; 3744 : 	/********************************************************************/
; 3745 : 	/*  Conditionally append the force character to the text.           */
; 3746 : 	/********************************************************************/
; 3747 : 	
; 3748 : 	if( dwFlags & TTS_FORCE )
; 3749 : 	{
; 3750 : 		pText[uiTextLength-1] = cForce;
; 3751 : 	}
; 3752 : 	
; 3753 : 	pTextMsg->pText = pText;
; 3754 : 	pTextMsg->uiLength = uiTextLength;
; 3755 : 	
; 3756 :     // tek 01sep98
; 3757 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 3758 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 3759 : 	phTTS->uiCurrentMsgNumber++;
; 3760 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 3761 : 	
; 3762 : 	/********************************************************************/
; 3763 : 	/*  Increment the queued character count.                           */
; 3764 : 	/********************************************************************/
; 3765 : 	
; 3766 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 3767 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 3768 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 3769 : 	
; 3770 : 	/*
; 3771 : 	* keep track of what we've queued so that we can 
; 3772 : 	* sync correctly
; 3773 : 	* (tek 11aug98)
; 3774 : 	*/
; 3775 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3776 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 3777 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3778 : 
; 3779 : 	/********************************************************************/
; 3780 : 	/*  Add the text message to the text-message linked list.           */
; 3781 : 	/********************************************************************/
; 3782 : 	
; 3783 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 3784 : 	
; 3785 : 	/********************************************************************/
; 3786 : 	/*  Put the Text Message at the end of the linked list.             */
; 3787 : 	/********************************************************************/
; 3788 : 	
; 3789 : 	if ( phTTS->pTextMsgList == NULL )
; 3790 : 	{
; 3791 : 		phTTS->pTextMsgList = pTextMsg;
; 3792 : 	}
; 3793 : 	else
; 3794 : 	{
; 3795 : 		pNextTextMsg = phTTS->pTextMsgList;
; 3796 : 		
; 3797 : 		while ( pNextTextMsg->pLink != NULL )
; 3798 : 		{
; 3799 : 			pNextTextMsg = pNextTextMsg->pLink;
; 3800 : 		}
; 3801 : 		
; 3802 : 		pNextTextMsg->pLink = pTextMsg;
; 3803 : 	}
; 3804 : 	
; 3805 : 	/********************************************************************/
; 3806 : 	/*  Set the Text In Queue event.                                    */
; 3807 : 	/********************************************************************/
; 3808 : 	
; 3809 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 3810 : 	
; 3811 : 	/********************************************************************/
; 3812 : 	/*  Unlock the text-message linked list.                            */
; 3813 : 	/********************************************************************/
; 3814 : 	
; 3815 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 3816 : 	
; 3817 : 	return( MMSYSERR_NOERROR );
; 3818 : #endif
; 3819 : 	
; 3820 : }

  00fa8	c3		 ret	 0
$L71969:

; 3653 : 	
; 3654 : 	if (!phTTS->bInReset)

  00fa9	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  00faf	85 c0		 test	 eax, eax
  00fb1	75 17		 jne	 SHORT $L71970

; 3655 : 	{
; 3656 : 		return (TextToSpeechSpeakEx( phTTS,
; 3657 : #ifdef UNDER_CE
; 3658 : 				string,
; 3659 : #else
; 3660 : 				pszTextString,
; 3661 : #endif
; 3662 : 				dwFlags,
; 3663 : 				TRUE));

  00fb3	8b 44 24 10	 mov	 eax, DWORD PTR _dwFlags$[esp]
  00fb7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pszTextString$[esp]
  00fbb	6a 01		 push	 1
  00fbd	50		 push	 eax
  00fbe	51		 push	 ecx
  00fbf	56		 push	 esi
  00fc0	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx
  00fc5	83 c4 10	 add	 esp, 16			; 00000010H
  00fc8	5e		 pop	 esi

; 3668 : 		// will break existing apps.. sigh..
; 3669 : 	}
; 3670 : #endif
; 3671 : #if defined __osf__ || defined __linux__
; 3672 : 	char proc_name[]="TextToSpeechSpeak";
; 3673 : 	int uiTextLength = 0;
; 3674 : 	unsigned char * pText;
; 3675 : 	LPTEXT_MSG_T pTextMsg;
; 3676 : 	LPTEXT_MSG_T pNextTextMsg;
; 3677 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 3678 : 	const char cForce2 = (char)(SYNC);
; 3679 : 	
; 3680 : #ifdef TTSDBG
; 3681 : 	printf("%s\n",proc_name);
; 3682 : #endif
; 3683 : 	
; 3684 : 	/********************************************************************/
; 3685 : 	/*  Return error if NULL handle.                                    */
; 3686 : 	/********************************************************************/
; 3687 : 	if (phTTS == NULL)
; 3688 : 		return( MMSYSERR_INVALHANDLE );
; 3689 : 	
; 3690 : 	/********************************************************************/
; 3691 : 	/*  Allocate the memory locked Text Message structure.              */
; 3692 : 	/********************************************************************/
; 3693 : 	
; 3694 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 3695 : 	
; 3696 : 	if ( pTextMsg == NULL )
; 3697 : 		return( MMSYSERR_NOMEM );
; 3698 : 	
; 3699 : 	pTextMsg->pLink = NULL;
; 3700 : 	
; 3701 : 	/********************************************************************/
; 3702 : 	/*  Adjust string length for force character.                       */
; 3703 : 	/********************************************************************/
; 3704 : 	
; 3705 : 	uiTextLength = strlen(pszTextString);
; 3706 : 	
; 3707 : 	if( dwFlags & TTS_FORCE )
; 3708 : 	{
; 3709 : 		uiTextLength++;
; 3710 : 	}
; 3711 : 	
; 3712 : 	/********************************************************************/
; 3713 : 	/*  If the text length is zero then exit with success.              */
; 3714 : 	/********************************************************************/
; 3715 : 	
; 3716 : 	if ( uiTextLength == 0 )
; 3717 : 	{
; 3718 : 		free( pTextMsg );
; 3719 : 		return MMSYSERR_NOERROR;
; 3720 : 	}
; 3721 : 	
; 3722 : 	/********************************************************************/
; 3723 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 3724 : 	/*  location in case the force character is appended to the text    */
; 3725 : 	/*  string.                                                         */
; 3726 : 	/********************************************************************/
; 3727 : 	
; 3728 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 3729 : 	
; 3730 : 	if ( pText == NULL )
; 3731 : 	{ 
; 3732 : 		free( pTextMsg );
; 3733 : 		return( MMSYSERR_NOMEM );
; 3734 : 	} 
; 3735 : 	
; 3736 : 	/********************************************************************/
; 3737 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 3738 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 3739 : 	/*  should not be used after the call to the function.              */
; 3740 : 	/********************************************************************/
; 3741 : 	
; 3742 : 	strcpy( pText, pszTextString );
; 3743 : 	
; 3744 : 	/********************************************************************/
; 3745 : 	/*  Conditionally append the force character to the text.           */
; 3746 : 	/********************************************************************/
; 3747 : 	
; 3748 : 	if( dwFlags & TTS_FORCE )
; 3749 : 	{
; 3750 : 		pText[uiTextLength-1] = cForce;
; 3751 : 	}
; 3752 : 	
; 3753 : 	pTextMsg->pText = pText;
; 3754 : 	pTextMsg->uiLength = uiTextLength;
; 3755 : 	
; 3756 :     // tek 01sep98
; 3757 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 3758 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 3759 : 	phTTS->uiCurrentMsgNumber++;
; 3760 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 3761 : 	
; 3762 : 	/********************************************************************/
; 3763 : 	/*  Increment the queued character count.                           */
; 3764 : 	/********************************************************************/
; 3765 : 	
; 3766 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 3767 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 3768 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 3769 : 	
; 3770 : 	/*
; 3771 : 	* keep track of what we've queued so that we can 
; 3772 : 	* sync correctly
; 3773 : 	* (tek 11aug98)
; 3774 : 	*/
; 3775 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3776 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 3777 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3778 : 
; 3779 : 	/********************************************************************/
; 3780 : 	/*  Add the text message to the text-message linked list.           */
; 3781 : 	/********************************************************************/
; 3782 : 	
; 3783 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 3784 : 	
; 3785 : 	/********************************************************************/
; 3786 : 	/*  Put the Text Message at the end of the linked list.             */
; 3787 : 	/********************************************************************/
; 3788 : 	
; 3789 : 	if ( phTTS->pTextMsgList == NULL )
; 3790 : 	{
; 3791 : 		phTTS->pTextMsgList = pTextMsg;
; 3792 : 	}
; 3793 : 	else
; 3794 : 	{
; 3795 : 		pNextTextMsg = phTTS->pTextMsgList;
; 3796 : 		
; 3797 : 		while ( pNextTextMsg->pLink != NULL )
; 3798 : 		{
; 3799 : 			pNextTextMsg = pNextTextMsg->pLink;
; 3800 : 		}
; 3801 : 		
; 3802 : 		pNextTextMsg->pLink = pTextMsg;
; 3803 : 	}
; 3804 : 	
; 3805 : 	/********************************************************************/
; 3806 : 	/*  Set the Text In Queue event.                                    */
; 3807 : 	/********************************************************************/
; 3808 : 	
; 3809 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 3810 : 	
; 3811 : 	/********************************************************************/
; 3812 : 	/*  Unlock the text-message linked list.                            */
; 3813 : 	/********************************************************************/
; 3814 : 	
; 3815 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 3816 : 	
; 3817 : 	return( MMSYSERR_NOERROR );
; 3818 : #endif
; 3819 : 	
; 3820 : }

  00fc9	c3		 ret	 0
$L71970:

; 3664 : 	}
; 3665 : 	else
; 3666 : 	{
; 3667 : 		return (MMSYSERR_NOERROR); // _HANDLEBUSY would be better, but

  00fca	33 c0		 xor	 eax, eax
  00fcc	5e		 pop	 esi

; 3668 : 		// will break existing apps.. sigh..
; 3669 : 	}
; 3670 : #endif
; 3671 : #if defined __osf__ || defined __linux__
; 3672 : 	char proc_name[]="TextToSpeechSpeak";
; 3673 : 	int uiTextLength = 0;
; 3674 : 	unsigned char * pText;
; 3675 : 	LPTEXT_MSG_T pTextMsg;
; 3676 : 	LPTEXT_MSG_T pNextTextMsg;
; 3677 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 3678 : 	const char cForce2 = (char)(SYNC);
; 3679 : 	
; 3680 : #ifdef TTSDBG
; 3681 : 	printf("%s\n",proc_name);
; 3682 : #endif
; 3683 : 	
; 3684 : 	/********************************************************************/
; 3685 : 	/*  Return error if NULL handle.                                    */
; 3686 : 	/********************************************************************/
; 3687 : 	if (phTTS == NULL)
; 3688 : 		return( MMSYSERR_INVALHANDLE );
; 3689 : 	
; 3690 : 	/********************************************************************/
; 3691 : 	/*  Allocate the memory locked Text Message structure.              */
; 3692 : 	/********************************************************************/
; 3693 : 	
; 3694 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 3695 : 	
; 3696 : 	if ( pTextMsg == NULL )
; 3697 : 		return( MMSYSERR_NOMEM );
; 3698 : 	
; 3699 : 	pTextMsg->pLink = NULL;
; 3700 : 	
; 3701 : 	/********************************************************************/
; 3702 : 	/*  Adjust string length for force character.                       */
; 3703 : 	/********************************************************************/
; 3704 : 	
; 3705 : 	uiTextLength = strlen(pszTextString);
; 3706 : 	
; 3707 : 	if( dwFlags & TTS_FORCE )
; 3708 : 	{
; 3709 : 		uiTextLength++;
; 3710 : 	}
; 3711 : 	
; 3712 : 	/********************************************************************/
; 3713 : 	/*  If the text length is zero then exit with success.              */
; 3714 : 	/********************************************************************/
; 3715 : 	
; 3716 : 	if ( uiTextLength == 0 )
; 3717 : 	{
; 3718 : 		free( pTextMsg );
; 3719 : 		return MMSYSERR_NOERROR;
; 3720 : 	}
; 3721 : 	
; 3722 : 	/********************************************************************/
; 3723 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 3724 : 	/*  location in case the force character is appended to the text    */
; 3725 : 	/*  string.                                                         */
; 3726 : 	/********************************************************************/
; 3727 : 	
; 3728 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 3729 : 	
; 3730 : 	if ( pText == NULL )
; 3731 : 	{ 
; 3732 : 		free( pTextMsg );
; 3733 : 		return( MMSYSERR_NOMEM );
; 3734 : 	} 
; 3735 : 	
; 3736 : 	/********************************************************************/
; 3737 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 3738 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 3739 : 	/*  should not be used after the call to the function.              */
; 3740 : 	/********************************************************************/
; 3741 : 	
; 3742 : 	strcpy( pText, pszTextString );
; 3743 : 	
; 3744 : 	/********************************************************************/
; 3745 : 	/*  Conditionally append the force character to the text.           */
; 3746 : 	/********************************************************************/
; 3747 : 	
; 3748 : 	if( dwFlags & TTS_FORCE )
; 3749 : 	{
; 3750 : 		pText[uiTextLength-1] = cForce;
; 3751 : 	}
; 3752 : 	
; 3753 : 	pTextMsg->pText = pText;
; 3754 : 	pTextMsg->uiLength = uiTextLength;
; 3755 : 	
; 3756 :     // tek 01sep98
; 3757 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 3758 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 3759 : 	phTTS->uiCurrentMsgNumber++;
; 3760 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 3761 : 	
; 3762 : 	/********************************************************************/
; 3763 : 	/*  Increment the queued character count.                           */
; 3764 : 	/********************************************************************/
; 3765 : 	
; 3766 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 3767 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 3768 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 3769 : 	
; 3770 : 	/*
; 3771 : 	* keep track of what we've queued so that we can 
; 3772 : 	* sync correctly
; 3773 : 	* (tek 11aug98)
; 3774 : 	*/
; 3775 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3776 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 3777 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3778 : 
; 3779 : 	/********************************************************************/
; 3780 : 	/*  Add the text message to the text-message linked list.           */
; 3781 : 	/********************************************************************/
; 3782 : 	
; 3783 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 3784 : 	
; 3785 : 	/********************************************************************/
; 3786 : 	/*  Put the Text Message at the end of the linked list.             */
; 3787 : 	/********************************************************************/
; 3788 : 	
; 3789 : 	if ( phTTS->pTextMsgList == NULL )
; 3790 : 	{
; 3791 : 		phTTS->pTextMsgList = pTextMsg;
; 3792 : 	}
; 3793 : 	else
; 3794 : 	{
; 3795 : 		pNextTextMsg = phTTS->pTextMsgList;
; 3796 : 		
; 3797 : 		while ( pNextTextMsg->pLink != NULL )
; 3798 : 		{
; 3799 : 			pNextTextMsg = pNextTextMsg->pLink;
; 3800 : 		}
; 3801 : 		
; 3802 : 		pNextTextMsg->pLink = pTextMsg;
; 3803 : 	}
; 3804 : 	
; 3805 : 	/********************************************************************/
; 3806 : 	/*  Set the Text In Queue event.                                    */
; 3807 : 	/********************************************************************/
; 3808 : 	
; 3809 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 3810 : 	
; 3811 : 	/********************************************************************/
; 3812 : 	/*  Unlock the text-message linked list.                            */
; 3813 : 	/********************************************************************/
; 3814 : 	
; 3815 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 3816 : 	
; 3817 : 	return( MMSYSERR_NOERROR );
; 3818 : #endif
; 3819 : 	
; 3820 : }

  00fcd	c3		 ret	 0
_TextToSpeechSpeak ENDP
_TEXT	ENDS
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pszTextString$ = 12
_dwFlags$ = 16
_bIsUser$ = 20
_TextToSpeechSpeakEx PROC NEAR

; 3827 : {

  00fd0	53		 push	 ebx
  00fd1	55		 push	 ebp
  00fd2	56		 push	 esi

; 3828 : 	UINT i;
; 3829 : 	UINT uiLength;
; 3830 : 	unsigned char * pTextBuffer;
; 3831 : 	TEXT_MSG_T * pTextMsg;
; 3832 : 	const char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 3833 : 	const char cForce2 = (char)(SYNC);
; 3834 : 	
; 3835 : 	
; 3836 : 	
; 3837 : 	
; 3838 : 	/********************************************************************/
; 3839 : 	/*  Return error if invalid handle.                                 */
; 3840 : 	/********************************************************************/
; 3841 : 	
; 3842 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  00fd3	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  00fd7	57		 push	 edi
  00fd8	6a 04		 push	 4
  00fda	56		 push	 esi
  00fdb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  00fe1	85 c0		 test	 eax, eax
  00fe3	74 0a		 je	 SHORT $L71989
  00fe5	5f		 pop	 edi
  00fe6	5e		 pop	 esi
  00fe7	5d		 pop	 ebp

; 3843 : 		return( MMSYSERR_INVALHANDLE );

  00fe8	b8 05 00 00 00	 mov	 eax, 5
  00fed	5b		 pop	 ebx

; 4003 : }

  00fee	c3		 ret	 0
$L71989:

; 3844 : 	
; 3845 : 	// if this is the null state, and it is a user call, don't accept the text (for now)...
; 3846 : 	if (phTTS->dwOutputState == STATE_OUTPUT_NULL && bIsUser)

  00fef	83 be 84 00 00
	00 04		 cmp	 DWORD PTR [esi+132], 4
  00ff6	75 12		 jne	 SHORT $L71990
  00ff8	8b 44 24 20	 mov	 eax, DWORD PTR _bIsUser$[esp+12]
  00ffc	85 c0		 test	 eax, eax
  00ffe	74 0a		 je	 SHORT $L71990
  01000	5f		 pop	 edi
  01001	5e		 pop	 esi
  01002	5d		 pop	 ebp

; 3847 : 		return(MMSYSERR_ERROR);

  01003	b8 01 00 00 00	 mov	 eax, 1
  01008	5b		 pop	 ebx

; 4003 : }

  01009	c3		 ret	 0
$L71990:

; 3848 : 
; 3849 : 	
; 3850 : #ifdef TYPING_MODE
; 3851 : 	// tek 06nov97 (during BATS508)
; 3852 : 	// we have to clear out the typing mode flag here, because if
; 3853 : 	// we don't we can end up with a message queued but still do
; 3854 : 	// a typing-mode fast reset (which will leave this sneak
; 3855 : 	// message inside the synthesizer)
; 3856 : 	phTTS->bInTypingMode = FALSE;
; 3857 : #endif TYPING_MODE
; 3858 : 	
; 3859 : 	/********************************************************************/
; 3860 : 	/*  Allocate the Text Message structure.                            */
; 3861 : 	/********************************************************************/
; 3862 : 	
; 3863 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));

  0100a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__malloc
  01010	6a 0c		 push	 12			; 0000000cH
  01012	ff d5		 call	 ebp
  01014	8b d8		 mov	 ebx, eax
  01016	83 c4 04	 add	 esp, 4

; 3864 : 	
; 3865 : 	if ( pTextMsg == NULL )

  01019	85 db		 test	 ebx, ebx
  0101b	75 0a		 jne	 SHORT $L71994
  0101d	5f		 pop	 edi
  0101e	5e		 pop	 esi
  0101f	5d		 pop	 ebp

; 3866 : 		return( MMSYSERR_NOMEM );

  01020	b8 07 00 00 00	 mov	 eax, 7
  01025	5b		 pop	 ebx

; 4003 : }

  01026	c3		 ret	 0
$L71994:

; 3867 : 	
; 3868 : 	/********************************************************************/
; 3869 : 	/*  Get the character string length.                                */
; 3870 : 	/********************************************************************/
; 3871 : 	
; 3872 : 	uiLength = strlen( pszTextString );

  01027	8b 7c 24 18	 mov	 edi, DWORD PTR _pszTextString$[esp+12]
  0102b	83 c9 ff	 or	 ecx, -1
  0102e	33 c0		 xor	 eax, eax
  01030	f2 ae		 repne scasb
  01032	f7 d1		 not	 ecx
  01034	49		 dec	 ecx
  01035	8b f9		 mov	 edi, ecx

; 3873 : 	
; 3874 : 	/********************************************************************/
; 3875 : 	/*  Allocate the pipe text buffer. Allocate 1 extra location in     */
; 3876 : 	/*  case the force character is appended to the text string.        */
; 3877 : 	/* now allocate 2 extra for the two forcing chars.. tex 16aug96     */
; 3878 : 	/********************************************************************/
; 3879 : 	
; 3880 : 	pTextBuffer = (unsigned char *)malloc(( uiLength + 2 ) * sizeof(char));

  01037	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  0103a	50		 push	 eax
  0103b	ff d5		 call	 ebp
  0103d	8b e8		 mov	 ebp, eax
  0103f	83 c4 04	 add	 esp, 4

; 3881 : 	
; 3882 : 	if ( pTextBuffer == NULL )

  01042	85 ed		 test	 ebp, ebp
  01044	75 14		 jne	 SHORT $L71998

; 3883 : 	{
; 3884 : 		free( pTextMsg );

  01046	53		 push	 ebx
  01047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0104d	83 c4 04	 add	 esp, 4

; 3885 : 		return( MMSYSERR_NOMEM );

  01050	b8 07 00 00 00	 mov	 eax, 7
  01055	5f		 pop	 edi
  01056	5e		 pop	 esi
  01057	5d		 pop	 ebp
  01058	5b		 pop	 ebx

; 4003 : }

  01059	c3		 ret	 0
$L71998:

; 3886 : 	}
; 3887 : 	
; 3888 : 	/********************************************************************/
; 3889 : 	/*  The memory pointed to by pTextMsg and pTextBuffer is            */
; 3890 : 	/*  deallocated in the Text To Speech thread window procedure and   */
; 3891 : 	/*  should not be used after the call to the SendMessage()          */
; 3892 : 	/*  function.                                                       */
; 3893 : 	/********************************************************************/
; 3894 : 	
; 3895 : 	for ( i = 0; i < uiLength; i++ )

  0105a	85 ff		 test	 edi, edi
  0105c	76 1d		 jbe	 SHORT $L72001
  0105e	8b 4c 24 18	 mov	 ecx, DWORD PTR _pszTextString$[esp+12]
  01062	8b c5		 mov	 eax, ebp
  01064	2b cd		 sub	 ecx, ebp
  01066	89 7c 24 18	 mov	 DWORD PTR 12+[esp+12], edi
$L71999:

; 3896 : 		pTextBuffer[i] = pszTextString[i];

  0106a	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0106d	88 10		 mov	 BYTE PTR [eax], dl
  0106f	8b 54 24 18	 mov	 edx, DWORD PTR 12+[esp+12]
  01073	40		 inc	 eax
  01074	4a		 dec	 edx
  01075	89 54 24 18	 mov	 DWORD PTR 12+[esp+12], edx
  01079	75 ef		 jne	 SHORT $L71999
$L72001:

; 3897 : 	
; 3898 : 	/********************************************************************/
; 3899 : 	/*  Conditionally append the force character to the text.           */
; 3900 : 	/********************************************************************/
; 3901 : 	
; 3902 : 	if ( dwFlags & TTS_FORCE )

  0107b	f6 44 24 1c 01	 test	 BYTE PTR _dwFlags$[esp+12], 1
  01080	74 0a		 je	 SHORT $L72002

; 3903 : 	{
; 3904 : 		pTextBuffer[uiLength] = cForce;

  01082	c6 04 2f 0b	 mov	 BYTE PTR [edi+ebp], 11	; 0000000bH

; 3905 : 		uiLength++;

  01086	47		 inc	 edi

; 3906 : 		pTextBuffer[uiLength] = cForce2;

  01087	c6 04 2f 0a	 mov	 BYTE PTR [edi+ebp], 10	; 0000000aH

; 3907 : 		uiLength++;

  0108b	47		 inc	 edi
$L72002:

; 3908 : 	}
; 3909 : 	// tek 05nov97 bats472 we have to do all message numbering and 
; 3910 : 	// queueing under a critical section, so that we are absolutely
; 3911 : 	// sure that the numbers will be monotonically increasing; if 
; 3912 : 	// they aren't. WaitForTextQueueingToComplete will end up 
; 3913 : 	// waiting forever.
; 3914 : 
; 3915 : 	EnterCriticalSection( phTTS->pcsQueuedCharacterCount );

  0108c	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  01092	50		 push	 eax
  01093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 3916 : 
; 3917 : 	/********************************************************************/
; 3918 : 	/*  Set up the Text Message structure.                              */
; 3919 : 	/*  The message number is used in the Text-To-Speech thread to      */
; 3920 : 	/*  to throw away window messages which are received after          */
; 3921 : 	/*  TextToSpeechReset() is called.                                  */
; 3922 : 	/********************************************************************/
; 3923 : 	
; 3924 : 	pTextMsg->pText = pTextBuffer;

  01099	89 6b 08	 mov	 DWORD PTR [ebx+8], ebp

; 3925 : 	pTextMsg->uiLength = uiLength;

  0109c	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 3926 : 	
; 3927 : 	EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  0109f	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  010a5	51		 push	 ecx
  010a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 3928 : 
; 3929 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;

  010ac	8b 56 44	 mov	 edx, DWORD PTR [esi+68]

; 3930 : 	phTTS->uiCurrentMsgNumber++;
; 3931 : 
; 3932 : 	LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  010af	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__LeaveCriticalSection@4
  010b5	89 13		 mov	 DWORD PTR [ebx], edx
  010b7	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  010ba	40		 inc	 eax
  010bb	89 46 44	 mov	 DWORD PTR [esi+68], eax
  010be	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  010c4	50		 push	 eax
  010c5	ff d5		 call	 ebp

; 3933 : 
; 3934 : 	// tek 16jun97 bats 385 moves the store/increment inside the CS
; 3935 : 	
; 3936 : 	/********************************************************************/
; 3937 : 	/*  Save this message number in the Text-To-Speech handle for       */
; 3938 : 	/*  the TextToSpeechSync() function.                                */
; 3939 : 	/********************************************************************/
; 3940 : 	
; 3941 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 3942 : 	
; 3943 : 	/********************************************************************/
; 3944 : 	/*  Accumulate the queued character count.                          */
; 3945 : 	/********************************************************************/
; 3946 : 	
; 3947 : 	//tek bats472: move this up to before the point where we 
; 3948 : 	// take a number
; 3949 : 	//EnterCriticalSection( phTTS->pcsQueuedCharacterCount );
; 3950 : 	phTTS->uiQueuedCharacterCount += uiLength;

  010c7	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  010ca	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  010cc	03 d7		 add	 edx, edi

; 3951 : 	// tek bats472: move this to after the PostMessage.
; 3952 : 	//LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );
; 3953 : #ifdef API_DEBUG
; 3954 : 	{
; 3955 : 		char szTemp[256]="";
; 3956 : 		char szTemp2[128]="";
; 3957 : 		int	i=0;
; 3958 : 		for (i=0;i<127 && i<pTextMsg->uiLength ;i++)
; 3959 : 		{
; 3960 : 			if (!isprint(pTextBuffer[i]))
; 3961 : 			{
; 3962 : 				szTemp2[i]='.';
; 3963 : 			}
; 3964 : 			else
; 3965 : 			{
; 3966 : 				szTemp2[i]=pTextBuffer[i];
; 3967 : 			}
; 3968 : 		}
; 3969 : 		szTemp2[i]='\0';
; 3970 : 		sprintf(szTemp,"  .. TTSMessage %u posting. [%s]\n",
; 3971 : 			pTextMsg->uiMsgNumber,
; 3972 : 			szTemp2);
; 3973 : 		OutputDebugString(szTemp);
; 3974 : 	}
; 3975 : #endif //API_DEBUG
; 3976 : 	/********************************************************************/
; 3977 : 	/*  Send the structure pointed to by pTextMsg to the text thread.   */
; 3978 : 	/********************************************************************/
; 3979 : 	
; 3980 : 	PostMessage( phTTS->hTextToSpeechWnd,
; 3981 : 		ID_TTS_Queue_Text,
; 3982 : 		0L,
; 3983 : 		(LPARAM)pTextMsg );

  010ce	53		 push	 ebx
  010cf	89 56 40	 mov	 DWORD PTR [esi+64], edx
  010d2	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  010d5	6a 00		 push	 0
  010d7	68 00 04 00 00	 push	 1024			; 00000400H
  010dc	52		 push	 edx
  010dd	89 4e 48	 mov	 DWORD PTR [esi+72], ecx
  010e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 3984 : 	// tek bats472: OK to do this now.
; 3985 : 	LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );

  010e6	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  010ec	50		 push	 eax
  010ed	ff d5		 call	 ebp
  010ef	5f		 pop	 edi
  010f0	5e		 pop	 esi
  010f1	5d		 pop	 ebp

; 3986 : 	/********************************************************************/
; 3987 : 	/*  Re-enable error messages in the audio thread. The audio thread  */
; 3988 : 	/*  disables the audio error handler after sending a message. This  */
; 3989 : 	/*  is done to ensure that the application only receives at most    */
; 3990 : 	/*  only one error message per call to the TextToSpeechSpeak()      */
; 3991 : 	/*  function. Otherwise a message would be sent each time the audio */
; 3992 : 	/*  thread was unable to open the audio device.                     */
; 3993 : 	/********************************************************************/
; 3994 : 	
; 3995 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
; 3996 : 	{
; 3997 : #ifndef OLEDECTALK
; 3998 : 		//  EnableAudioErrorMessage( phTTS->pAudioHandle );
; 3999 : #endif //OLEDECTALK
; 4000 : 	}
; 4001 : 	
; 4002 : 	return( MMSYSERR_NOERROR );

  010f2	33 c0		 xor	 eax, eax
  010f4	5b		 pop	 ebx

; 4003 : }

  010f5	c3		 ret	 0
_TextToSpeechSpeakEx ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechPause
EXTRN	_PA_Pause:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechPause PROC NEAR

; 4038 : {

  01100	56		 push	 esi

; 4039 : 	MMRESULT mmStatus;
; 4040 : 	
; 4041 : 	/********************************************************************/
; 4042 : 	/*  Return error if invalid handle.                                 */
; 4043 : 	/********************************************************************/
; 4044 : 	
; 4045 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01101	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01105	6a 04		 push	 4
  01107	56		 push	 esi
  01108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0110e	85 c0		 test	 eax, eax
  01110	74 07		 je	 SHORT $L72009

; 4046 : 	{
; 4047 : 		mmStatus = MMSYSERR_INVALHANDLE;

  01112	b8 05 00 00 00	 mov	 eax, 5
  01117	5e		 pop	 esi

; 4053 : #endif //OLEDECTALK
; 4054 : 	}
; 4055 : 	return( mmStatus );
; 4056 : }

  01118	c3		 ret	 0
$L72009:

; 4048 : 	}
; 4049 : 	else
; 4050 : 	{
; 4051 : #ifndef OLEDECTALK
; 4052 : 		mmStatus = PA_Pause( phTTS->pAudioHandle );

  01119	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  0111f	50		 push	 eax
  01120	e8 00 00 00 00	 call	 _PA_Pause
  01125	83 c4 04	 add	 esp, 4
  01128	5e		 pop	 esi

; 4053 : #endif //OLEDECTALK
; 4054 : 	}
; 4055 : 	return( mmStatus );
; 4056 : }

  01129	c3		 ret	 0
_TextToSpeechPause ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechResume
EXTRN	_PA_Resume:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechResume PROC NEAR

; 4090 : {

  01130	56		 push	 esi

; 4091 : 	MMRESULT mmStatus;
; 4092 : 	
; 4093 : 	/********************************************************************/
; 4094 : 	/*  Return error if invalid handle.                                 */
; 4095 : 	/********************************************************************/
; 4096 : 	
; 4097 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01131	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01135	6a 04		 push	 4
  01137	56		 push	 esi
  01138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0113e	85 c0		 test	 eax, eax
  01140	74 07		 je	 SHORT $L72015

; 4098 : 	{
; 4099 : 		mmStatus = MMSYSERR_INVALHANDLE;

  01142	b8 05 00 00 00	 mov	 eax, 5
  01147	5e		 pop	 esi

; 4105 : #endif //OLEDECTALK
; 4106 : 	}
; 4107 : 	return( mmStatus );
; 4108 : }

  01148	c3		 ret	 0
$L72015:

; 4100 : 	}
; 4101 : 	else
; 4102 : 	{
; 4103 : #ifndef OLEDECTALK
; 4104 : 		mmStatus = PA_Resume( phTTS->pAudioHandle );

  01149	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  0114f	50		 push	 eax
  01150	e8 00 00 00 00	 call	 _PA_Resume
  01155	83 c4 04	 add	 esp, 4
  01158	5e		 pop	 esi

; 4105 : #endif //OLEDECTALK
; 4106 : 	}
; 4107 : 	return( mmStatus );
; 4108 : }

  01159	c3		 ret	 0
_TextToSpeechResume ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenWaveOutFile
PUBLIC	_TextToSpeechSync
EXTRN	__imp__fwrite:NEAR
EXTRN	_SetSampleRate:NEAR
_DATA	SEGMENT
$SG72043 DB	'wb', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pszFileName$ = 12
_dwFormat$ = 16
_TextToSpeechOpenWaveOutFile PROC NEAR

; 4168 : {

  01160	53		 push	 ebx
  01161	55		 push	 ebp
  01162	56		 push	 esi
  01163	57		 push	 edi

; 4169 :   MMRESULT mmStatus;
; 4170 :   WAVE_FILE_HDR_T * pWaveFileHdr;
; 4171 : #ifdef UNDER_CE
; 4172 :   DWORD dwRW;
; 4173 : #endif
; 4174 : 
; 4175 : 	/********************************************************************/
; 4176 : 	/*  Return error if invalid handle.                                 */
; 4177 : 	/********************************************************************/
; 4178 : 	
; 4179 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01164	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  01168	6a 04		 push	 4
  0116a	57		 push	 edi
  0116b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01171	85 c0		 test	 eax, eax
  01173	74 0a		 je	 SHORT $L72026
  01175	5f		 pop	 edi
  01176	5e		 pop	 esi
  01177	5d		 pop	 ebp

; 4180 : 		return( MMSYSERR_INVALHANDLE );

  01178	b8 05 00 00 00	 mov	 eax, 5
  0117d	5b		 pop	 ebx

; 4321 : }

  0117e	c3		 ret	 0
$L72026:

; 4181 : 	
; 4182 : 	/********************************************************************/
; 4183 : 	/*  If a file is already open, then don't try to open another one.  */
; 4184 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 4185 : 	/*  an error.                                                       */
; 4186 : 	/********************************************************************/
; 4187 : 	
; 4188 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 4189 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  0117f	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  01185	33 ed		 xor	 ebp, ebp
  01187	3b c5		 cmp	 eax, ebp
  01189	74 0f		 je	 SHORT $L72027
  0118b	83 f8 04	 cmp	 eax, 4
  0118e	74 0a		 je	 SHORT $L72027
  01190	5f		 pop	 edi
  01191	5e		 pop	 esi
  01192	5d		 pop	 ebp

; 4190 : 		return( MMSYSERR_ALLOCATED );

  01193	b8 04 00 00 00	 mov	 eax, 4
  01198	5b		 pop	 ebx

; 4321 : }

  01199	c3		 ret	 0
$L72027:

; 4191 : 	
; 4192 : 	/********************************************************************/
; 4193 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 4194 : 	/*  function have completed.                                        */
; 4195 : 	/********************************************************************/
; 4196 : 	
; 4197 : 	mmStatus = TextToSpeechSync( phTTS );

  0119a	57		 push	 edi
  0119b	e8 00 00 00 00	 call	 _TextToSpeechSync
  011a0	83 c4 04	 add	 esp, 4

; 4198 : 	
; 4199 : 	if ( mmStatus )

  011a3	3b c5		 cmp	 eax, ebp

; 4200 : 		return( mmStatus );

  011a5	0f 85 57 01 00
	00		 jne	 $L72023

; 4201 : 	
; 4202 : 	/********************************************************************/
; 4203 : 	/*  Create the header for the output file                           */
; 4204 : 	/********************************************************************/
; 4205 : 	
; 4206 : 	pWaveFileHdr = (WAVE_FILE_HDR_T *) malloc( sizeof(WAVE_FILE_HDR_T));

  011ab	6a 2c		 push	 44			; 0000002cH
  011ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  011b3	8b f0		 mov	 esi, eax
  011b5	83 c4 04	 add	 esp, 4

; 4207 : 	
; 4208 : 	if ( pWaveFileHdr == NULL )

  011b8	3b f5		 cmp	 esi, ebp
  011ba	75 0a		 jne	 SHORT $L72032
  011bc	5f		 pop	 edi
  011bd	5e		 pop	 esi
  011be	5d		 pop	 ebp

; 4209 : 		return( MMSYSERR_NOMEM );

  011bf	b8 07 00 00 00	 mov	 eax, 7
  011c4	5b		 pop	 ebx

; 4321 : }

  011c5	c3		 ret	 0
$L72032:

; 4210 : 	
; 4211 : 	/* MVP: Initialize the Wave_File_header's common elements for all waveformats.*/
; 4212 : 	/*{ "RIFF", 0, "WAVEfmt ", 16, 1, 1, 11025, 11025, 1, 8, "data", 0 };*/
; 4213 : 	pWaveFileHdr->psRiff[0] = 'R';
; 4214 : 	pWaveFileHdr->psRiff[1] = 'I';
; 4215 : 	pWaveFileHdr->psRiff[2] = 'F';

  011c6	b0 46		 mov	 al, 70			; 00000046H

; 4216 : 	pWaveFileHdr->psRiff[3] = 'F';
; 4217 : 	pWaveFileHdr->dwRiffChunkSize = 0;

  011c8	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  011cb	88 46 02	 mov	 BYTE PTR [esi+2], al
  011ce	88 46 03	 mov	 BYTE PTR [esi+3], al

; 4218 : 	pWaveFileHdr->psWaveFmt[0] = 'W';
; 4219 : 	pWaveFileHdr->psWaveFmt[1] = 'A';
; 4220 : 	pWaveFileHdr->psWaveFmt[2] = 'V';
; 4221 : 	pWaveFileHdr->psWaveFmt[3] = 'E';
; 4222 : 	pWaveFileHdr->psWaveFmt[4] = 'f';
; 4223 : 	pWaveFileHdr->psWaveFmt[5] = 'm';
; 4224 : 	pWaveFileHdr->psWaveFmt[6] = 't';
; 4225 : 	pWaveFileHdr->psWaveFmt[7] = ' ';
; 4226 : 	pWaveFileHdr->dwWaveChunkSize = 16;
; 4227 : 	pWaveFileHdr->wNumberOfChannels = 1;
; 4228 : 	pWaveFileHdr->psData[0] = 'd';
; 4229 : 	pWaveFileHdr->psData[1] = 'a';

  011d1	b0 61		 mov	 al, 97			; 00000061H

; 4230 : 	pWaveFileHdr->psData[2] = 't';
; 4231 : 	pWaveFileHdr->psData[3] = 'a';
; 4232 : 	pWaveFileHdr->dwDataChunkSize = 0;

  011d3	89 6e 28	 mov	 DWORD PTR [esi+40], ebp

; 4233 : 	
; 4234 : 	/********************************************************************/
; 4235 : 	/*  If the dwFormat value is invalid then return an error.          */
; 4236 : 	/********************************************************************/
; 4237 : 	
; 4238 : 	switch( dwFormat )
; 4239 : 	{

  011d6	8b 6c 24 1c	 mov	 ebp, DWORD PTR _dwFormat$[esp+12]
  011da	88 46 25	 mov	 BYTE PTR [esi+37], al
  011dd	88 46 27	 mov	 BYTE PTR [esi+39], al
  011e0	8b c5		 mov	 eax, ebp
  011e2	b1 74		 mov	 cl, 116			; 00000074H
  011e4	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  011e9	bb 01 00 00 00	 mov	 ebx, 1
  011ee	48		 dec	 eax
  011ef	c6 06 52	 mov	 BYTE PTR [esi], 82	; 00000052H
  011f2	c6 46 01 49	 mov	 BYTE PTR [esi+1], 73	; 00000049H
  011f6	c6 46 08 57	 mov	 BYTE PTR [esi+8], 87	; 00000057H
  011fa	c6 46 09 41	 mov	 BYTE PTR [esi+9], 65	; 00000041H
  011fe	c6 46 0a 56	 mov	 BYTE PTR [esi+10], 86	; 00000056H
  01202	c6 46 0b 45	 mov	 BYTE PTR [esi+11], 69	; 00000045H
  01206	c6 46 0c 66	 mov	 BYTE PTR [esi+12], 102	; 00000066H
  0120a	c6 46 0d 6d	 mov	 BYTE PTR [esi+13], 109	; 0000006dH
  0120e	88 4e 0e	 mov	 BYTE PTR [esi+14], cl
  01211	c6 46 0f 20	 mov	 BYTE PTR [esi+15], 32	; 00000020H
  01215	89 56 10	 mov	 DWORD PTR [esi+16], edx
  01218	66 89 5e 16	 mov	 WORD PTR [esi+22], bx
  0121c	c6 46 24 64	 mov	 BYTE PTR [esi+36], 100	; 00000064H
  01220	88 4e 26	 mov	 BYTE PTR [esi+38], cl
  01223	74 4a		 je	 SHORT $L72038
  01225	83 e8 03	 sub	 eax, 3
  01228	74 26		 je	 SHORT $L72037
  0122a	83 e8 03	 sub	 eax, 3
  0122d	74 14		 je	 SHORT $L72039

; 4275 : 		
; 4276 : 	default:
; 4277 : 		
; 4278 : 		free( pWaveFileHdr );

  0122f	56		 push	 esi
  01230	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  01236	83 c4 04	 add	 esp, 4

; 4279 : 		return( MMSYSERR_INVALPARAM );

  01239	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0123e	5f		 pop	 edi
  0123f	5e		 pop	 esi
  01240	5d		 pop	 ebp
  01241	5b		 pop	 ebx

; 4321 : }

  01242	c3		 ret	 0
$L72039:

; 4261 : 		
; 4262 : 		break;
; 4263 : 		
; 4264 : 	case WAVE_FORMAT_08M08:
; 4265 : 		
; 4266 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_MULAW;

  01243	66 c7 46 14 07
	00		 mov	 WORD PTR [esi+20], 7

; 4267 : 		pWaveFileHdr->dwSamplesPerSecond = MULAW_SAMPLE_RATE;

  01249	b8 40 1f 00 00	 mov	 eax, 8000		; 00001f40H

; 4268 : 		pWaveFileHdr->dwAvgBytesPerSecond = MULAW_SAMPLE_RATE;
; 4269 : 		pWaveFileHdr->wNumberBlockAlign = 1;
; 4270 : 		pWaveFileHdr->wBitsPerSample = 8;
; 4271 : 		
; 4272 : 		SetSampleRate( phTTS, MULAW_SAMPLE_RATE );
; 4273 : 		
; 4274 : 		break;

  0124e	eb 28		 jmp	 SHORT $L73261
$L72037:

; 4240 : 	case WAVE_FORMAT_1M16:
; 4241 : 		
; 4242 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_PCM;
; 4243 : 		pWaveFileHdr->dwSamplesPerSecond = PC_SAMPLE_RATE;

  01250	b8 11 2b 00 00	 mov	 eax, 11025		; 00002b11H
  01255	66 89 5e 14	 mov	 WORD PTR [esi+20], bx
  01259	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 4244 : 		pWaveFileHdr->dwAvgBytesPerSecond = PC_SAMPLE_RATE + PC_SAMPLE_RATE;

  0125c	c7 46 1c 22 56
	00 00		 mov	 DWORD PTR [esi+28], 22050 ; 00005622H

; 4245 : 		pWaveFileHdr->wNumberBlockAlign = 2;

  01263	66 c7 46 20 02
	00		 mov	 WORD PTR [esi+32], 2

; 4246 : 		pWaveFileHdr->wBitsPerSample = 16;

  01269	66 89 56 22	 mov	 WORD PTR [esi+34], dx

; 4247 : 		
; 4248 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 4249 : 		
; 4250 : 		break;

  0126d	eb 19		 jmp	 SHORT $L73262
$L72038:

; 4251 : 		
; 4252 : 	case WAVE_FORMAT_1M08:
; 4253 : 		
; 4254 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_PCM;

  0126f	66 89 5e 14	 mov	 WORD PTR [esi+20], bx

; 4255 : 		pWaveFileHdr->dwSamplesPerSecond = PC_SAMPLE_RATE;

  01273	b8 11 2b 00 00	 mov	 eax, 11025		; 00002b11H
$L73261:
  01278	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 4256 : 		pWaveFileHdr->dwAvgBytesPerSecond = PC_SAMPLE_RATE;

  0127b	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 4257 : 		pWaveFileHdr->wNumberBlockAlign = 1;

  0127e	66 89 5e 20	 mov	 WORD PTR [esi+32], bx

; 4258 : 		pWaveFileHdr->wBitsPerSample = 8;

  01282	66 c7 46 22 08
	00		 mov	 WORD PTR [esi+34], 8
$L73262:

; 4259 : 		
; 4260 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );

  01288	50		 push	 eax
  01289	57		 push	 edi
  0128a	e8 00 00 00 00	 call	 _SetSampleRate

; 4280 : 	}
; 4281 : 	
; 4282 : 	phTTS->dwFormat = dwFormat;
; 4283 : 	
; 4284 : 	/********************************************************************/
; 4285 : 	/*  Open the wave output file.                                      */
; 4286 : 	/********************************************************************/
; 4287 : 	
; 4288 : #ifdef UNDER_CE //mfgce
; 4289 :   if((phTTS->pWaveFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL))==NULL)
; 4290 : #else
; 4291 :   if (( phTTS->pWaveFile = fopen(pszFileName, "wb" )) == NULL )

  0128f	8b 44 24 20	 mov	 eax, DWORD PTR _pszFileName$[esp+20]
  01293	83 c4 08	 add	 esp, 8
  01296	89 af 80 00 00
	00		 mov	 DWORD PTR [edi+128], ebp
  0129c	68 00 00 00 00	 push	 OFFSET FLAT:$SG72043
  012a1	50		 push	 eax
  012a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  012a8	83 c4 08	 add	 esp, 8
  012ab	89 87 94 00 00
	00		 mov	 DWORD PTR [edi+148], eax
  012b1	85 c0		 test	 eax, eax
  012b3	75 11		 jne	 SHORT $L72042

; 4292 : #endif
; 4293 : 	{
; 4294 : 		free( pWaveFileHdr );

  012b5	56		 push	 esi
  012b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  012bc	83 c4 04	 add	 esp, 4

; 4295 : 		return( MMSYSERR_ERROR );

  012bf	8b c3		 mov	 eax, ebx
  012c1	5f		 pop	 edi
  012c2	5e		 pop	 esi
  012c3	5d		 pop	 ebp
  012c4	5b		 pop	 ebx

; 4321 : }

  012c5	c3		 ret	 0
$L72042:

; 4296 : 	}
; 4297 : 	
; 4298 : 	/********************************************************************/
; 4299 : 	/*  Write the header to the output file.                            */
; 4300 : 	/********************************************************************/
; 4301 : 	
; 4302 : #ifdef UNDER_CE
; 4303 :   if(WriteFile( phTTS->pWaveFile,pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ), &dwRW, NULL)==0)
; 4304 : #else
; 4305 :   if( 1 != fwrite( (char *)pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ),1,phTTS->pWaveFile ))

  012c6	50		 push	 eax
  012c7	53		 push	 ebx
  012c8	6a 2c		 push	 44			; 0000002cH
  012ca	56		 push	 esi
  012cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  012d1	83 c4 10	 add	 esp, 16			; 00000010H
  012d4	3b c3		 cmp	 eax, ebx
  012d6	74 11		 je	 SHORT $L72046

; 4306 : #endif
; 4307 : 	{
; 4308 : 		free( pWaveFileHdr );

  012d8	56		 push	 esi
  012d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  012df	83 c4 04	 add	 esp, 4

; 4309 : 		return( MMSYSERR_ERROR );

  012e2	8b c3		 mov	 eax, ebx
  012e4	5f		 pop	 edi
  012e5	5e		 pop	 esi
  012e6	5d		 pop	 ebp
  012e7	5b		 pop	 ebx

; 4321 : }

  012e8	c3		 ret	 0
$L72046:

; 4310 : 	}
; 4311 : 	
; 4312 : 	/********************************************************************/
; 4313 : 	/*  Initialize the file sample count.                               */
; 4314 : 	/********************************************************************/
; 4315 : 	
; 4316 : 	phTTS->dwFileSampleCount = 0;

  012e9	c7 47 78 00 00
	00 00		 mov	 DWORD PTR [edi+120], 0

; 4317 : 	phTTS->pWaveFileHdr = pWaveFileHdr;

  012f0	89 b7 9c 00 00
	00		 mov	 DWORD PTR [edi+156], esi

; 4318 : 	phTTS->dwOutputState = STATE_OUTPUT_WAVE_FILE;

  012f6	c7 87 84 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+132], 2

; 4319 : 	
; 4320 : 	return( MMSYSERR_NOERROR );

  01300	33 c0		 xor	 eax, eax
$L72023:
  01302	5f		 pop	 edi
  01303	5e		 pop	 esi
  01304	5d		 pop	 ebp
  01305	5b		 pop	 ebx

; 4321 : }

  01306	c3		 ret	 0
_TextToSpeechOpenWaveOutFile ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechCloseWaveOutFile
EXTRN	__imp__fseek:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechCloseWaveOutFile PROC NEAR

; 4361 : {

  01310	53		 push	 ebx
  01311	55		 push	 ebp
  01312	56		 push	 esi

; 4362 : 	DWORD dwLengthInBytes;
; 4363 : #ifdef UNDER_CE
; 4364 : 	HANDLE * pWaveFile;
; 4365 : 	DWORD dwRW;
; 4366 : #else
; 4367 : 	FILE * pWaveFile;
; 4368 : #endif
; 4369 : 	WAVE_FILE_HDR_T * pWaveFileHdr;
; 4370 : 	MMRESULT mmStatus;
; 4371 : 	
; 4372 : 	/********************************************************************/
; 4373 : 	/*  Return error if invalid handle.                                 */
; 4374 : 	/********************************************************************/
; 4375 : 	
; 4376 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01313	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  01317	57		 push	 edi
  01318	6a 04		 push	 4
  0131a	56		 push	 esi
  0131b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01321	85 c0		 test	 eax, eax
  01323	74 0a		 je	 SHORT $L72054
  01325	5f		 pop	 edi
  01326	5e		 pop	 esi
  01327	5d		 pop	 ebp

; 4377 : 		return( MMSYSERR_INVALHANDLE );

  01328	b8 05 00 00 00	 mov	 eax, 5
  0132d	5b		 pop	 ebx

; 4503 : }

  0132e	c3		 ret	 0
$L72054:

; 4378 : 	
; 4379 : 	/********************************************************************/
; 4380 : 	/*  If a file is not open, then exit.                               */
; 4381 : 	/********************************************************************/
; 4382 : 	
; 4383 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_WAVE_FILE )

  0132f	83 be 84 00 00
	00 02		 cmp	 DWORD PTR [esi+132], 2
  01336	74 0a		 je	 SHORT $L72055
  01338	5f		 pop	 edi
  01339	5e		 pop	 esi
  0133a	5d		 pop	 ebp

; 4384 : 		return( MMSYSERR_ERROR );

  0133b	b8 01 00 00 00	 mov	 eax, 1
  01340	5b		 pop	 ebx

; 4503 : }

  01341	c3		 ret	 0
$L72055:

; 4385 : 	
; 4386 : 	/********************************************************************/
; 4387 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 4388 : 	/*  function have completed.                                        */
; 4389 : 	/********************************************************************/
; 4390 : 	
; 4391 : 	mmStatus = TextToSpeechSync( phTTS );

  01342	56		 push	 esi
  01343	e8 00 00 00 00	 call	 _TextToSpeechSync
  01348	8b d8		 mov	 ebx, eax

; 4392 : 	
; 4393 : 	if ( mmStatus )
; 4394 : 		mmStatus = MMSYSERR_ERROR;
; 4395 : 	else
; 4396 : 		mmStatus = MMSYSERR_NOERROR;
; 4397 : 	
; 4398 : 	/********************************************************************/
; 4399 : 	/*  Set the sample rate to the default value in case the sample     */
; 4400 : 	/*  was changed.                                                    */
; 4401 : 	/********************************************************************/
; 4402 : 	
; 4403 : 	SetSampleRate( phTTS, PC_SAMPLE_RATE );

  0134a	68 11 2b 00 00	 push	 11025			; 00002b11H
  0134f	f7 db		 neg	 ebx
  01351	1b db		 sbb	 ebx, ebx
  01353	56		 push	 esi
  01354	f7 db		 neg	 ebx
  01356	e8 00 00 00 00	 call	 _SetSampleRate

; 4404 : 	
; 4405 : 	/********************************************************************/
; 4406 : 	/*  Update the wave header riff chunk and data chunk lengths.       */
; 4407 : 	/********************************************************************/
; 4408 : 	
; 4409 : 	switch( phTTS->dwFormat )
; 4410 : 	{

  0135b	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  01361	83 c4 0c	 add	 esp, 12			; 0000000cH
  01364	48		 dec	 eax
  01365	74 1b		 je	 SHORT $L72064
  01367	83 e8 03	 sub	 eax, 3
  0136a	74 0f		 je	 SHORT $L72062
  0136c	83 e8 03	 sub	 eax, 3
  0136f	74 11		 je	 SHORT $L72064
  01371	5f		 pop	 edi
  01372	5e		 pop	 esi
  01373	5d		 pop	 ebp

; 4420 : 		break;
; 4421 : 		
; 4422 : 	default:
; 4423 : 		
; 4424 : 		/******************************************************************/
; 4425 : 		/*  It should be impossible to get here so this error message is  */
; 4426 : 		/*  not documented.                                               */
; 4427 : 		/******************************************************************/
; 4428 : 		
; 4429 : 		return( MMSYSERR_INVALPARAM );

  01374	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01379	5b		 pop	 ebx

; 4503 : }

  0137a	c3		 ret	 0
$L72062:

; 4411 : 	case WAVE_FORMAT_1M16:
; 4412 : 		
; 4413 : 		dwLengthInBytes = (DWORD)phTTS->dwFileSampleCount << 1;

  0137b	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0137e	d1 e0		 shl	 eax, 1

; 4414 : 		break;

  01380	eb 03		 jmp	 SHORT $L72059
$L72064:

; 4415 : 		
; 4416 : 	case WAVE_FORMAT_1M08:
; 4417 : 	case WAVE_FORMAT_08M08:
; 4418 : 		
; 4419 : 		dwLengthInBytes = (DWORD)phTTS->dwFileSampleCount;

  01382	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
$L72059:

; 4430 : 	}
; 4431 : 	
; 4432 : 	pWaveFileHdr = (WAVE_FILE_HDR_T *)phTTS->pWaveFileHdr;

  01385	8b be 9c 00 00
	00		 mov	 edi, DWORD PTR [esi+156]

; 4433 : 	
; 4434 : 	pWaveFileHdr->dwDataChunkSize = dwLengthInBytes;
; 4435 : 	
; 4436 : 	pWaveFileHdr->dwRiffChunkSize =
; 4437 : 		pWaveFileHdr->dwDataChunkSize + RIFF_HEADER_OFFSET;
; 4438 : 	
; 4439 : 	/********************************************************************/
; 4440 : 	/*  Seek to the top of the file to write the updated wave header.   */
; 4441 : 	/********************************************************************/
; 4442 : 	
; 4443 : #ifdef UNDER_CE
; 4444 :    pWaveFile = (HANDLE *)phTTS->pWaveFile;
; 4445 : #else
; 4446 :    pWaveFile = (FILE *)phTTS->pWaveFile;
; 4447 : #endif
; 4448 : 
; 4449 : #ifdef UNDER_CE //mfgce fix return value
; 4450 :   SetFilePointer(pWaveFile ,0L ,NULL ,FILE_BEGIN);
; 4451 : #else
; 4452 :   if ( fseek( pWaveFile, 0L, SEEK_SET ))

  0138b	6a 00		 push	 0
  0138d	6a 00		 push	 0
  0138f	89 47 28	 mov	 DWORD PTR [edi+40], eax
  01392	83 c0 24	 add	 eax, 36			; 00000024H
  01395	89 47 04	 mov	 DWORD PTR [edi+4], eax
  01398	8b ae 94 00 00
	00		 mov	 ebp, DWORD PTR [esi+148]
  0139e	55		 push	 ebp
  0139f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  013a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  013a8	85 c0		 test	 eax, eax
  013aa	74 14		 je	 SHORT $L72069

; 4453 :   {
; 4454 : 	free( pWaveFileHdr );

  013ac	57		 push	 edi
  013ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  013b3	83 c4 04	 add	 esp, 4

; 4455 : 	return( MMSYSERR_ERROR );

  013b6	b8 01 00 00 00	 mov	 eax, 1
  013bb	5f		 pop	 edi
  013bc	5e		 pop	 esi
  013bd	5d		 pop	 ebp
  013be	5b		 pop	 ebx

; 4503 : }

  013bf	c3		 ret	 0
$L72069:

; 4456 :   }
; 4457 : #endif
; 4458 : 	
; 4459 : 	/********************************************************************/
; 4460 : 	/*  Write the header to the output file.                            */
; 4461 : 	/********************************************************************/
; 4462 : 	
; 4463 : #ifdef UNDER_CE
; 4464 :   if(WriteFile( phTTS->pWaveFile,pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ), &dwRW, NULL)==0)
; 4465 : #else
; 4466 :   if ( 1 != fwrite( (char *)pWaveFileHdr,sizeof(WAVE_FILE_HDR_T ),1,phTTS->pWaveFile ))

  013c0	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  013c6	50		 push	 eax
  013c7	6a 01		 push	 1
  013c9	6a 2c		 push	 44			; 0000002cH
  013cb	57		 push	 edi
  013cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  013d2	83 c4 10	 add	 esp, 16			; 00000010H
  013d5	83 f8 01	 cmp	 eax, 1

; 4467 : #endif
; 4468 : 	{
; 4469 : 		free( pWaveFileHdr );

  013d8	57		 push	 edi
  013d9	74 13		 je	 SHORT $L72072
  013db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  013e1	83 c4 04	 add	 esp, 4

; 4470 : 		return( MMSYSERR_ERROR );

  013e4	b8 01 00 00 00	 mov	 eax, 1
  013e9	5f		 pop	 edi
  013ea	5e		 pop	 esi
  013eb	5d		 pop	 ebp
  013ec	5b		 pop	 ebx

; 4503 : }

  013ed	c3		 ret	 0
$L72072:

; 4471 : 	}
; 4472 : 	
; 4473 : 	/********************************************************************/
; 4474 : 	/*  Free the wave file header.                                      */
; 4475 : 	/********************************************************************/
; 4476 : 	
; 4477 : 	free( pWaveFileHdr );

  013ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 4478 : 	
; 4479 : 	/********************************************************************/
; 4480 : 	/*  Set the system output state to audio if it is enabled.          */
; 4481 : 	/********************************************************************/
; 4482 : 	
; 4483 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  013f4	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  013f7	83 c4 04	 add	 esp, 4
  013fa	a9 00 00 00 80	 test	 eax, -2147483648	; 80000000H
  013ff	75 17		 jne	 SHORT $L72073

; 4484 : 	{
; 4485 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 4486 : 		TextToSpeechReset(phTTS,FALSE); // tek 29jan99 bats 849: this resets the counters..

  01401	6a 00		 push	 0
  01403	56		 push	 esi
  01404	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  0140e	e8 00 00 00 00	 call	 _TextToSpeechReset
  01413	83 c4 08	 add	 esp, 8

; 4487 : 	}
; 4488 : 	else

  01416	eb 0a		 jmp	 SHORT $L72074
$L72073:

; 4489 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;

  01418	c7 86 84 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+132], 4
$L72074:

; 4490 : 	
; 4491 : 	/********************************************************************/
; 4492 : 	/*  Close the wave file.                                            */
; 4493 : 	/********************************************************************/
; 4494 : 	
; 4495 : #if UNDER_CE
; 4496 : 	if ( CloseHandle( pWaveFile ) == 0)
; 4497 : #else
; 4498 : 	if ( fclose( pWaveFile ))

  01422	55		 push	 ebp
  01423	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  01429	83 c4 04	 add	 esp, 4
  0142c	85 c0		 test	 eax, eax

; 4499 : #endif
; 4500 : 		return( MMSYSERR_ERROR );

  0142e	b8 01 00 00 00	 mov	 eax, 1
  01433	75 02		 jne	 SHORT $L72049

; 4501 : 	
; 4502 : 	return( mmStatus );

  01435	8b c3		 mov	 eax, ebx
$L72049:
  01437	5f		 pop	 edi
  01438	5e		 pop	 esi
  01439	5d		 pop	 ebp
  0143a	5b		 pop	 ebx

; 4503 : }

  0143b	c3		 ret	 0
_TextToSpeechCloseWaveOutFile ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetStatus
EXTRN	_PA_Status:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_dwIdentifierArray$ = 12
_dwStatusArray$ = 16
_dwNumberOfStatusValues$ = 20
_dwIdentifier$ = 8
_dwAudioStatus$ = -4
_TextToSpeechGetStatus PROC NEAR

; 4579 : {

  01440	51		 push	 ecx
  01441	53		 push	 ebx

; 4580 : 	UINT i;
; 4581 : #ifndef OLEDECTALK
; 4582 : 	DWORD dwIdentifier[1];
; 4583 : #endif //OLEDECTALK
; 4584 : 	DWORD dwAudioStatus[1];
; 4585 : 	MMRESULT mmStatus =0;
; 4586 : 	MMRESULT mmStatusReturn;
; 4587 : 	
; 4588 : 	/********************************************************************/
; 4589 : 	/*  Return error if invalid handle.                                 */
; 4590 : 	/********************************************************************/
; 4591 : 	
; 4592 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01442	8b 5c 24 0c	 mov	 ebx, DWORD PTR _phTTS$[esp+4]
  01446	6a 04		 push	 4
  01448	53		 push	 ebx
  01449	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0144f	85 c0		 test	 eax, eax
  01451	74 08		 je	 SHORT $L72090

; 4593 : 		return( MMSYSERR_INVALHANDLE );

  01453	b8 05 00 00 00	 mov	 eax, 5
  01458	5b		 pop	 ebx

; 4686 : }

  01459	59		 pop	 ecx
  0145a	c3		 ret	 0
$L72090:

; 4594 : 	
; 4595 : 	/********************************************************************/
; 4596 : 	/*  Range test the number of status values requested.               */
; 4597 : 	/********************************************************************/
; 4598 : 	
; 4599 : 	if (( dwNumberOfStatusValues == 0 )
; 4600 : 		|| ( dwNumberOfStatusValues > MAXIMUM_STATUS_VALUES ))

  0145b	8b 44 24 18	 mov	 eax, DWORD PTR _dwNumberOfStatusValues$[esp+4]
  0145f	85 c0		 test	 eax, eax
  01461	0f 84 26 01 00
	00		 je	 $L72092
  01467	83 f8 03	 cmp	 eax, 3
  0146a	0f 87 1d 01 00
	00		 ja	 $L72092
  01470	57		 push	 edi

; 4602 : 	
; 4603 : 	mmStatusReturn = MMSYSERR_NOERROR;

  01471	33 ff		 xor	 edi, edi

; 4604 : 	
; 4605 : 	/********************************************************************/
; 4606 : 	/*  Loop and fill in array dwStatusArray[].                             */
; 4607 : 	/********************************************************************/
; 4608 : 	
; 4609 : 	for ( i = 0; i < dwNumberOfStatusValues; i++ )

  01473	85 c0		 test	 eax, eax
  01475	0f 86 0c 01 00
	00		 jbe	 $L72095
  0147b	55		 push	 ebp

; 4677 : 			
; 4678 : 		default:
; 4679 : 			
; 4680 : 			dwStatusArray[i] = 0xFFFFFFFF;

  0147c	8b 6c 24 18	 mov	 ebp, DWORD PTR _dwIdentifierArray$[esp+12]
  01480	56		 push	 esi
  01481	8b 74 24 20	 mov	 esi, DWORD PTR _dwStatusArray$[esp+16]
  01485	2b ee		 sub	 ebp, esi
  01487	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
$L72093:
  0148b	8b 04 2e	 mov	 eax, DWORD PTR [esi+ebp]
  0148e	83 e8 00	 sub	 eax, 0
  01491	0f 84 bd 00 00
	00		 je	 $L72100

; 4610 : 	{
; 4611 : 		switch( dwIdentifierArray[i] )
; 4612 : 		{

  01497	48		 dec	 eax
  01498	74 68		 je	 SHORT $L72101
  0149a	48		 dec	 eax
  0149b	74 10		 je	 SHORT $L72106

; 4677 : 			
; 4678 : 		default:
; 4679 : 			
; 4680 : 			dwStatusArray[i] = 0xFFFFFFFF;

  0149d	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4681 : 			mmStatusReturn = MMSYSERR_INVALPARAM;

  014a3	bf 0b 00 00 00	 mov	 edi, 11			; 0000000bH

; 4682 : 			break;

  014a8	e9 c6 00 00 00	 jmp	 $L72094
$L72106:

; 4648 : 			
; 4649 : 		case WAVE_OUT_DEVICE_ID:
; 4650 : 			
; 4651 : 			if ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE )

  014ad	f7 43 74 00 00
	00 80		 test	 DWORD PTR [ebx+116], -2147483648 ; 80000000H
  014b4	74 10		 je	 SHORT $L72107

; 4652 : 			{
; 4653 : 				dwStatusArray[i] = 0xFFFFFFFF;

  014b6	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4654 : 				mmStatusReturn = MMSYSERR_ERROR;

  014bc	bf 01 00 00 00	 mov	 edi, 1

; 4655 : 			}
; 4656 : 			else

  014c1	e9 ad 00 00 00	 jmp	 $L72094
$L72107:

; 4657 : 			{
; 4658 : #ifndef OLEDECTALK
; 4659 : 				dwIdentifier[0] = PA_DEVICE_ID;
; 4660 : 				
; 4661 : 				mmStatus = PA_Status( phTTS->pAudioHandle,
; 4662 : 					dwIdentifier,
; 4663 : 					dwAudioStatus,
; 4664 : 					1 );

  014c6	8b 93 d4 00 00
	00		 mov	 edx, DWORD PTR [ebx+212]
  014cc	8d 44 24 10	 lea	 eax, DWORD PTR _dwAudioStatus$[esp+20]
  014d0	6a 01		 push	 1
  014d2	8d 4c 24 1c	 lea	 ecx, DWORD PTR _dwIdentifier$[esp+20]
  014d6	50		 push	 eax
  014d7	51		 push	 ecx
  014d8	52		 push	 edx
  014d9	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR _dwIdentifier$[esp+32], 3
  014e1	e8 00 00 00 00	 call	 _PA_Status
  014e6	83 c4 10	 add	 esp, 16			; 00000010H

; 4665 : #endif //OLEDECTALK
; 4666 : 				if ( mmStatus )

  014e9	85 c0		 test	 eax, eax
  014eb	74 0d		 je	 SHORT $L72109

; 4667 : 				{
; 4668 : 					dwStatusArray[i] = 0xFFFFFFFF;

  014ed	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4669 : 					mmStatusReturn = MMSYSERR_ERROR;

  014f3	bf 01 00 00 00	 mov	 edi, 1

; 4670 : 				}
; 4671 : 				else

  014f8	eb 79		 jmp	 SHORT $L72094
$L72109:

; 4672 : 				{
; 4673 : 					dwStatusArray[i] = dwAudioStatus[0];

  014fa	8b 44 24 10	 mov	 eax, DWORD PTR _dwAudioStatus$[esp+20]
  014fe	89 06		 mov	 DWORD PTR [esi], eax

; 4674 : 				}
; 4675 : 			}
; 4676 : 			break;

  01500	eb 71		 jmp	 SHORT $L72094
$L72101:

; 4618 : 			break;
; 4619 : 			
; 4620 : 		case STATUS_SPEAKING:
; 4621 : 			
; 4622 : 			if ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE )

  01502	f7 43 74 00 00
	00 80		 test	 DWORD PTR [ebx+116], -2147483648 ; 80000000H
  01509	74 0d		 je	 SHORT $L72102

; 4623 : 			{
; 4624 : 				dwStatusArray[i] = 0xFFFFFFFF;

  0150b	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4625 : 				mmStatusReturn = MMSYSERR_ERROR;

  01511	bf 01 00 00 00	 mov	 edi, 1

; 4626 : 			}
; 4627 : 			else

  01516	eb 5b		 jmp	 SHORT $L72094
$L72102:

; 4628 : 			{
; 4629 : #ifndef OLEDECTALK
; 4630 : 				dwIdentifier[0] = PA_DEVICE_PLAYING;
; 4631 : 				
; 4632 : 				mmStatus = PA_Status( phTTS->pAudioHandle,
; 4633 : 					dwIdentifier,
; 4634 : 					dwAudioStatus,
; 4635 : 					1 );

  01518	8b 83 d4 00 00
	00		 mov	 eax, DWORD PTR [ebx+212]
  0151e	8d 4c 24 10	 lea	 ecx, DWORD PTR _dwAudioStatus$[esp+20]
  01522	6a 01		 push	 1
  01524	8d 54 24 1c	 lea	 edx, DWORD PTR _dwIdentifier$[esp+20]
  01528	51		 push	 ecx
  01529	52		 push	 edx
  0152a	50		 push	 eax
  0152b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _dwIdentifier$[esp+32], 0
  01533	e8 00 00 00 00	 call	 _PA_Status
  01538	83 c4 10	 add	 esp, 16			; 00000010H

; 4636 : #endif //OLEDECTALK
; 4637 : 				if ( mmStatus )

  0153b	85 c0		 test	 eax, eax
  0153d	74 0d		 je	 SHORT $L72104

; 4638 : 				{
; 4639 : 					dwStatusArray[i] = 0xFFFFFFFF;

  0153f	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4640 : 					mmStatusReturn = MMSYSERR_ERROR;

  01545	bf 01 00 00 00	 mov	 edi, 1

; 4641 : 				}
; 4642 : 				else

  0154a	eb 27		 jmp	 SHORT $L72094
$L72104:

; 4643 : 				{
; 4644 : 					dwStatusArray[i] = dwAudioStatus[0];

  0154c	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwAudioStatus$[esp+20]
  01550	89 0e		 mov	 DWORD PTR [esi], ecx

; 4645 : 				}
; 4646 : 			}
; 4647 : 			break;

  01552	eb 1f		 jmp	 SHORT $L72094
$L72100:

; 4613 : 		case INPUT_CHARACTER_COUNT:
; 4614 : 			
; 4615 : 			EnterCriticalSection( phTTS->pcsQueuedCharacterCount );

  01554	8b 93 c0 00 00
	00		 mov	 edx, DWORD PTR [ebx+192]
  0155a	52		 push	 edx
  0155b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 4616 : 			dwStatusArray[i] = phTTS->uiQueuedCharacterCount;

  01561	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  01564	89 06		 mov	 DWORD PTR [esi], eax

; 4617 : 			LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );

  01566	8b 8b c0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+192]
  0156c	51		 push	 ecx
  0156d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72094:
  01573	8b 44 24 24	 mov	 eax, DWORD PTR 20+[esp+16]
  01577	83 c6 04	 add	 esi, 4
  0157a	48		 dec	 eax
  0157b	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
  0157f	0f 85 06 ff ff
	ff		 jne	 $L72093
  01585	5e		 pop	 esi
  01586	5d		 pop	 ebp
$L72095:

; 4683 : 		}
; 4684 : 	}
; 4685 : 	return( mmStatusReturn );

  01587	8b c7		 mov	 eax, edi
  01589	5f		 pop	 edi
  0158a	5b		 pop	 ebx

; 4686 : }

  0158b	59		 pop	 ecx
  0158c	c3		 ret	 0
$L72092:

; 4601 : 		return( MMSYSERR_INVALPARAM );

  0158d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01592	5b		 pop	 ebx

; 4686 : }

  01593	59		 pop	 ecx
  01594	c3		 ret	 0
_TextToSpeechGetStatus ENDP
_TEXT	ENDS
PUBLIC	_SendBuffer
PUBLIC	_ReturnRemainingBuffers
PUBLIC	_DrainPipes
PUBLIC	_TextToSpeechAddBuffer
PUBLIC	_TextToSpeechCloseLogFile
EXTRN	_EmptyVtmPipe:NEAR
EXTRN	__imp__ResetEvent@4:NEAR
EXTRN	_pipe_count:NEAR
EXTRN	_PA_Reset:NEAR
EXTRN	_cmd_init:NEAR
EXTRN	_ls_util_lts_init:NEAR
EXTRN	_phinit:NEAR
EXTRN	_InitializeVTM:NEAR
EXTRN	_free_index:NEAR
EXTRN	_OP_GetThreadPriority:NEAR
EXTRN	_OP_SetThreadPriority:NEAR
EXTRN	__imp__GetCurrentThread@0:NEAR
_BSS	SEGMENT
$SG72135 DB	01H DUP (?)
	ALIGN	4

$SG72141 DB	01H DUP (?)
	ALIGN	4

$SG72142 DB	01H DUP (?)
	ALIGN	4

$SG72143 DB	01H DUP (?)
	ALIGN	4

$SG72144 DB	01H DUP (?)
	ALIGN	4

$SG72147 DB	01H DUP (?)
	ALIGN	4

$SG72148 DB	01H DUP (?)
	ALIGN	4

$SG72149 DB	01H DUP (?)
	ALIGN	4

$SG72150 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_bReset$ = 12
_mmStatus$ = 8
_tptPriority$ = -4
_LastVoice$72159 = 8
_phone$72160 = 12
_TextToSpeechReset PROC NEAR

; 4738 : {

  015a0	51		 push	 ecx
  015a1	53		 push	 ebx
  015a2	55		 push	 ebp
  015a3	56		 push	 esi

; 4739 :   MMRESULT mmStatus;
; 4740 :   /* Added a varaible to get handle of instance specific Kernel_share_data for MI:MVP */
; 4741 :   PKSD_T pKsd_t;
; 4742 :   LPTTS_BUFFER_T pTTS_Buffer;
; 4743 :   
; 4744 : #ifdef API_DEBUG
; 4745 :   char szTemp[256]="";
; 4746 : #endif //API_DEBUG
; 4747 :   
; 4748 : #ifdef WIN32	
; 4749 : #ifdef TYPING_MODE	// 09jun97 tek
; 4750 :   BOOL	bWasTyping=FALSE;
; 4751 :   
; 4752 :   char szCforce3[] = {  
; 4753 :     (char)((PFASCII<<PSFONT)+0xb),
; 4754 :     /*	(char)(SYNC),					
; 4755 : 	(char)((PFASCII<<PSFONT)+0xb),
; 4756 : 	(char)(SYNC),					
; 4757 :     */
; 4758 :     (char)((PFASCII<<PSFONT)+0xb),
; 4759 :     (char)(SYNC),
; 4760 :     '\0'
; 4761 :   };
; 4762 : #endif //TYPING_MODE
; 4763 :   HANDLE hThisThread=NULL;
; 4764 :   THREAD_PRIORITY_T tptPriority=0;

  015a4	33 ed		 xor	 ebp, ebp
  015a6	57		 push	 edi
  015a7	89 6c 24 10	 mov	 DWORD PTR _tptPriority$[esp+20], ebp

; 4765 :   hThisThread = GetCurrentThread();

  015ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  015b1	8b d8		 mov	 ebx, eax

; 4766 :   if (hThisThread)

  015b3	3b dd		 cmp	 ebx, ebp
  015b5	74 15		 je	 SHORT $L72123

; 4767 :     {
; 4768 : #ifndef UNDER_CE
; 4769 :       tptPriority = OP_GetThreadPriority(hThisThread);

  015b7	53		 push	 ebx
  015b8	e8 00 00 00 00	 call	 _OP_GetThreadPriority

; 4770 :       OP_SetThreadPriority(hThisThread,OP_PRIORITY_HIGHEST);

  015bd	6a 02		 push	 2
  015bf	53		 push	 ebx
  015c0	89 44 24 1c	 mov	 DWORD PTR _tptPriority$[esp+32], eax
  015c4	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  015c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72123:

; 4771 : #endif
; 4772 :     }
; 4773 :   
; 4774 :   
; 4775 : #ifdef API_DEBUG
; 4776 :   // tek 10aug97 (during bats423)
; 4777 :        // fix this for typing/nontyping
; 4778 : #ifdef TYPING_MODE  // tek 10aug97 (during bats423)
; 4779 : 			       // fix this for typing/nontyping
; 4780 : 						       sprintf(szTemp,"TTSreset() at %ld (%d). \n",timeGetTime(),phTTS->bInTypingMode);
; 4781 : #else //TYPING_MODE
; 4782 :   sprintf(szTemp,"TTSreset() at %ld. \n",timeGetTime());
; 4783 : #endif //TYPING_MODE
; 4784 :   OutputDebugString(szTemp);
; 4785 : #endif //API_DEBUG
; 4786 :   
; 4787 :   /********************************************************************/
; 4788 :   /*  Return error if invalid handle.                                 */
; 4789 :   /********************************************************************/
; 4790 :   
; 4791 :   if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  015cc	8b 74 24 18	 mov	 esi, DWORD PTR _phTTS$[esp+16]
  015d0	6a 04		 push	 4
  015d2	56		 push	 esi
  015d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  015d9	85 c0		 test	 eax, eax
  015db	74 1d		 je	 SHORT $L72124

; 4792 :     {
; 4793 : #ifndef UNDER_CE
; 4794 :       if ( hThisThread)	 // tek 09jun97

  015dd	3b dd		 cmp	 ebx, ebp
  015df	74 0e		 je	 SHORT $L72125

; 4795 : 	  {
; 4796 : 	OP_SetThreadPriority(hThisThread,tptPriority);

  015e1	8b 44 24 10	 mov	 eax, DWORD PTR _tptPriority$[esp+20]
  015e5	50		 push	 eax
  015e6	53		 push	 ebx
  015e7	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  015ec	83 c4 08	 add	 esp, 8
$L72125:
  015ef	5f		 pop	 edi
  015f0	5e		 pop	 esi
  015f1	5d		 pop	 ebp

; 4797 :       }
; 4798 : #endif
; 4799 :       return( MMSYSERR_INVALHANDLE );

  015f2	b8 05 00 00 00	 mov	 eax, 5
  015f7	5b		 pop	 ebx

; 5449 : 	  return( MMSYSERR_ERROR );
; 5450 :   
; 5451 :   return( MMSYSERR_NOERROR );
; 5452 : }

  015f8	59		 pop	 ecx
  015f9	c3		 ret	 0
$L72124:

; 4800 :     }
; 4801 : 
; 4802 :   /* 16jun97 tek bats385
; 4803 :      merged 28jul97 tek
; 4804 :      lock up the synthesizer against new speech.. 
; 4805 :      */
; 4806 : #endif /* WIN32 */
; 4807 :   
; 4808 :   /********************************************************************/
; 4809 :   /*   Set the InReset flag                                           */
; 4810 :   /********************************************************************/
; 4811 :  
; 4812 : #if defined __osf__ || defined __linux__
; 4813 :   /********************************************************************/
; 4814 :   /*  Return error if invalid handle.                                 */
; 4815 :   /********************************************************************/
; 4816 :   
; 4817 :   if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 4818 :     { 
; 4819 : //      phTTS->bInReset = FALSE; // this line of code is guaranted to blow up..... MGS
; 4820 :       return( MMSYSERR_INVALHANDLE );
; 4821 :     }
; 4822 : #endif /* osf */
; 4823 :   
; 4824 :   phTTS->bInReset = TRUE;
; 4825 : 
; 4826 :   /********************************************************************/
; 4827 :   /*  Set the halting flag. This will cause the CMD, LTS, PH, VTM,    */
; 4828 :   /*  and SYNC threads to all discard input data and flush the pipes. */
; 4829 :   /********************************************************************/
; 4830 :   /* Get the current instance kernel_share_data : MVP */
; 4831 :   pKsd_t = phTTS->pKernelShareData;

  015fa	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  015fd	b8 01 00 00 00	 mov	 eax, 1
  01602	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax

; 4832 :   
; 4833 :   pKsd_t->halting = TRUE;

  01608	89 87 74 01 00
	00		 mov	 DWORD PTR [edi+372], eax

; 4834 :   
; 4835 :   /* ETT fixme?: why is this only win32? */
; 4836 : #ifdef WIN32
; 4837 : #ifdef API_DEBUG
; 4838 :   OutputDebugString("TTSreset: ->halting is set. \n");
; 4839 : #endif //API_DEBUG
; 4840 :   /********************************************************************/
; 4841 :   /*  Stop the Text To Speech thread if it is queueing text.          */
; 4842 :   /*  The Text-To-Speech thread will queue no text if the message     */
; 4843 :   /*  number is less than phTTS->uiFlushMsgNumber.                    */
; 4844 :   /* this needs to happen before we do too much.. tek 17jun97		  */
; 4845 :   /********************************************************************/
; 4846 :   EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  0160e	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  01614	51		 push	 ecx
  01615	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 4847 :   phTTS->uiFlushMsgNumber = phTTS->uiCurrentMsgNumber;
; 4848 :   LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  0161b	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  01621	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  01624	50		 push	 eax
  01625	89 56 50	 mov	 DWORD PTR [esi+80], edx
  01628	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 4849 :   
; 4850 :   phTTS->uiCurrentMsgNumber++;

  0162e	8b 56 44	 mov	 edx, DWORD PTR [esi+68]

; 4851 :   
; 4852 : #ifdef TYPING_MODE
; 4853 :   bWasTyping = phTTS->bInTypingMode;
; 4854 :   /* tek 15may97
; 4855 :      we set the PH thread's prority up here so that the first burst of
; 4856 :      sound that we need to get out in typing mode is quickly available; 
; 4857 :      after the VTM has processes two speech frames, vtmiont will drop the 
; 4858 :      PH thread back to normal priority so that any user processes can 
; 4859 :      continue running.
; 4860 :      if you change this, make sure the code in vtmiont still makes sense.
; 4861 :      */	
; 4862 :   if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)
; 4863 :     {
; 4864 :       /* tek 19nov97 this needs to be "highest" rather than "above normal";
; 4865 : 	 also, we need to do this for both VTM and PH, and VTM will 
; 4866 : 	 readjust it later for us. (this is all to deal with responsiveness
; 4867 : 	 in the presence of greedy tasks..)
; 4868 : 	 */
; 4869 : #ifndef UNDER_CE
; 4870 :       OP_SetThreadPriority((phTTS->hThread_VTM),OP_PRIORITY_HIGHEST);
; 4871 :       OP_SetThreadPriority((phTTS->hThread_PH),OP_PRIORITY_HIGHEST);
; 4872 : #endif
; 4873 :     }
; 4874 :   
; 4875 : #endif //TYPING_MODE
; 4876 : #endif /* WIN32 */
; 4877 :   
; 4878 :   pKsd_t->cmd_flush=CMD_flush_toss;
; 4879 :   
; 4880 :   /* tek 04sep96   drain the lts and ph pipes, just like on the 
; 4881 :      hardware platforms..
; 4882 :      */  
; 4883 :   DrainPipes(phTTS);

  01631	56		 push	 esi
  01632	42		 inc	 edx
  01633	89 56 44	 mov	 DWORD PTR [esi+68], edx
  01636	c7 87 6c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+364], 1
  01640	e8 00 00 00 00	 call	 _DrainPipes

; 4884 :   
; 4885 : #ifdef WIN32
; 4886 :   EmptyVtmPipe(pKsd_t); /* tek 15may  */

  01645	57		 push	 edi
  01646	e8 00 00 00 00	 call	 _EmptyVtmPipe

; 4887 :   
; 4888 : #ifdef TYPING_MODE /*09jun97 tek */
; 4889 :   if (bWasTyping)
; 4890 :     {
; 4891 :       /* start the pipes clearing out */
; 4892 :       DT_PIPE_T dtpSync = SYNC;
; 4893 :       write_pipe(pKsd_t->ph_pipe,&dtpSync,1);
; 4894 :       /* this WFEP is important for the case where the VTM still has
; 4895 : 	 work to do from above; we need to make sure that the VTM
; 4896 : 	 IO routines get to empty before we clear the halting flag.
; 4897 : 	 */	 
; 4898 :       mmStatus = WaitForEmptyPipes( phTTS,
; 4899 : 				    MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 4900 : 				    TRUE );
; 4901 :     }
; 4902 : #endif /* TYPING_MODE */
; 4903 : #endif /* WIN32 */
; 4904 :   
; 4905 :   /********************************************************************/
; 4906 :   /*  Perform an audio reset to immediately stop audio from playing   */
; 4907 :   /*  and to make sure the VTM thread is not blocked.                 */
; 4908 :   /********************************************************************/
; 4909 :   
; 4910 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  0164b	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01651	83 c4 08	 add	 esp, 8
  01654	3b c5		 cmp	 eax, ebp
  01656	75 0f		 jne	 SHORT $L72126

; 4911 :     {
; 4912 :       PA_Reset( phTTS->pAudioHandle );

  01658	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  0165e	51		 push	 ecx
  0165f	e8 00 00 00 00	 call	 _PA_Reset
  01664	83 c4 04	 add	 esp, 4
$L72126:

; 4913 :     }
; 4914 :   
; 4915 :   // 09jun97tek 
; 4916 :        // at this point, we should be able to drop back to our old priority
; 4917 :        
; 4918 : #ifdef WIN32
; 4919 : #ifndef UNDER_CE
; 4920 : 	if (hThisThread)

  01667	3b dd		 cmp	 ebx, ebp
  01669	74 0e		 je	 SHORT $L72127

; 4921 : 		OP_SetThreadPriority(hThisThread,tptPriority);

  0166b	8b 54 24 10	 mov	 edx, DWORD PTR _tptPriority$[esp+20]
  0166f	52		 push	 edx
  01670	53		 push	 ebx
  01671	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  01676	83 c4 08	 add	 esp, 8
$L72127:

; 4922 : #endif
; 4923 : #endif
; 4924 : 	
; 4925 : 	// tek 19aug96 the same anti-block issue for the memory case..
; 4926 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  01679	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  01680	75 5c		 jne	 SHORT $L73269

; 4927 : 	{     
; 4928 : 		// tek 29aug96 always send back the user's buffers.Do it
; 4929 : 		// now and git them out of the way.
; 4930 : 		ReturnRemainingBuffers(phTTS);

  01682	56		 push	 esi
  01683	e8 00 00 00 00	 call	 _ReturnRemainingBuffers

; 4931 : 		// we could have gotten stuck behind a buffer dump that happened
; 4932 : 		// "just after" the message to the calling loop that got us here;
; 4933 : 		// so, we have to queue up a dummy buffer to make sure we 
; 4934 : 		// survive the get_pipe call..
; 4935 : 		if((pKsd_t->buffer_pipe != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 1) )

  01688	8b 87 e4 00 00
	00		 mov	 eax, DWORD PTR [edi+228]
  0168e	83 c4 04	 add	 esp, 4
  01691	3b c5		 cmp	 eax, ebp
  01693	74 18		 je	 SHORT $L72130
  01695	50		 push	 eax
  01696	e8 00 00 00 00	 call	 _pipe_count
  0169b	83 c4 04	 add	 esp, 4
  0169e	83 f8 01	 cmp	 eax, 1
  016a1	73 0a		 jae	 SHORT $L72130

; 4936 : 			TextToSpeechAddBuffer(phTTS, NULL); //GetBuffer knows how to handle nulls

  016a3	55		 push	 ebp
  016a4	56		 push	 esi
  016a5	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  016aa	83 c4 08	 add	 esp, 8
$L72130:

; 4937 : 
; 4938 : 		EnterCriticalSection(phTTS->pcsMemoryBuffer);

  016ad	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  016b3	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__EnterCriticalSection@4
  016b9	50		 push	 eax
  016ba	ff d3		 call	 ebx

; 4939 : 
; 4940 : 		// if we have an active output buffer, clear it.
; 4941 : 		if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  016bc	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  016c2	3b c5		 cmp	 eax, ebp
  016c4	74 09		 je	 SHORT $L72134

; 4942 : 		{
; 4943 : 			
; 4944 : 			pTTS_Buffer->dwBufferLength = 0;

  016c6	89 68 18	 mov	 DWORD PTR [eax+24], ebp

; 4945 : 			pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  016c9	89 68 1c	 mov	 DWORD PTR [eax+28], ebp

; 4946 : 			pTTS_Buffer->dwNumberOfIndexMarks = 0;

  016cc	89 68 20	 mov	 DWORD PTR [eax+32], ebp
$L72134:

; 4947 : 			
; 4948 : 			
; 4949 : 		} // was not a null buffer
; 4950 : 
; 4951 : 		LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  016cf	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  016d5	51		 push	 ecx
  016d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  016dc	eb 06		 jmp	 SHORT $L72128
$L73269:
  016de	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__EnterCriticalSection@4
$L72128:

; 4952 : 		
; 4953 : 	}
; 4954 : 	
; 4955 : #ifdef TYPING_MODE // tek 09jun97
; 4956 : 	if (bWasTyping)
; 4957 : 	{
; 4958 : 		
; 4959 : 	}
; 4960 : 	else
; 4961 : 	{
; 4962 : #endif //TYPING_MODE
; 4963 : 		/********************************************************************/
; 4964 : 		/*  Stop the Text To Speech thread if it is queueing text.          */
; 4965 : 		/*  The Text-To-Speech thread will queue no text if the message     */
; 4966 : 		/*  number is less than phTTS->uiFlushMsgNumber.                    */
; 4967 : 		/********************************************************************/
; 4968 : 
; 4969 : 		EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  016e4	8b 96 bc 00 00
	00		 mov	 edx, DWORD PTR [esi+188]
  016ea	52		 push	 edx
  016eb	ff d3		 call	 ebx

; 4970 : 		phTTS->uiFlushMsgNumber = phTTS->uiCurrentMsgNumber;

  016ed	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  016f0	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 4971 : 		phTTS->uiCurrentMsgNumber++;

  016f3	40		 inc	 eax
  016f4	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 4972 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  016f7	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  016fd	50		 push	 eax
  016fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 4973 : 
; 4974 : 		// merged 28jul97 tek
; 4975 : 		// tek 16jun97 bats 385 moves the increment inside the CS
; 4976 : 		
; 4977 : 		// tek 19aug96 we now need to force speech, so that everybody
; 4978 : 		// along the way gets cleared out. We do it here, so that the
; 4979 : 		// above setting of FlushMsgNumber will allow this force to
; 4980 : 		// go through.
; 4981 : #ifdef WIN32
; 4982 : 		TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  01704	55		 push	 ebp
  01705	6a 01		 push	 1
  01707	68 00 00 00 00	 push	 OFFSET FLAT:$SG72135
  0170c	56		 push	 esi
  0170d	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 4983 : #endif
; 4984 : #if defined __osf__ || defined __linux__
; 4985 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4986 : #endif
; 4987 : 		/********************************************************************/
; 4988 : 		/*  Wait for the Text thread to complete all text queueing.         */
; 4989 : 		/********************************************************************/
; 4990 : 		WaitForTextQueuingToComplete( phTTS, TRUE );

  01712	6a 01		 push	 1
  01714	56		 push	 esi
  01715	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete

; 4991 : 		
; 4992 : 		
; 4993 : 		/********************************************************************/
; 4994 : 		/*  Clear the halting flag.                                         */
; 4995 : 		/********************************************************************/
; 4996 : 		
; 4997 : 		pKsd_t->halting = FALSE;

  0171a	89 af 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebp

; 4998 : #ifdef TYPING_MODE
; 4999 : 	}
; 5000 : #endif //TYPING_MODE
; 5001 : 	
; 5002 : 	/********************************************************************/
; 5003 : 	/*  If the output state is memory then return all buffers to the    */
; 5004 : 	/*  application.  WIH 3/28/95 Changed order for proper reset.       */
; 5005 : 	/********************************************************************/
; 5006 : 	
; 5007 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  01720	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01726	83 c4 18	 add	 esp, 24			; 00000018H
  01729	83 f8 01	 cmp	 eax, 1
  0172c	0f 85 1e 01 00
	00		 jne	 $L72136

; 5008 : 	{
; 5009 : 		/******************************************************************/
; 5010 : 		/*  If there is nothing to reset then return.                     */
; 5011 : 		/******************************************************************/
; 5012 : 		
; 5013 : 		if (( pipe_count( pKsd_t->cmd_pipe ) == 0 )
; 5014 : 			&& ( pipe_count( pKsd_t->lts_pipe ) == 0 )
; 5015 : 			&& ( pipe_count( pKsd_t->ph_pipe ) == 0 )
; 5016 : 			&& ( pipe_count( pKsd_t->vtm_pipe ) == 0 )
; 5017 : 			&& ( pipe_count( pKsd_t->buffer_pipe) == 0))

  01732	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  01738	51		 push	 ecx
  01739	e8 00 00 00 00	 call	 _pipe_count
  0173e	83 c4 04	 add	 esp, 4
  01741	85 c0		 test	 eax, eax
  01743	75 72		 jne	 SHORT $L72139
  01745	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  0174b	52		 push	 edx
  0174c	e8 00 00 00 00	 call	 _pipe_count
  01751	83 c4 04	 add	 esp, 4
  01754	85 c0		 test	 eax, eax
  01756	75 5f		 jne	 SHORT $L72139
  01758	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  0175e	50		 push	 eax
  0175f	e8 00 00 00 00	 call	 _pipe_count
  01764	83 c4 04	 add	 esp, 4
  01767	85 c0		 test	 eax, eax
  01769	75 4c		 jne	 SHORT $L72139
  0176b	8b 8f dc 00 00
	00		 mov	 ecx, DWORD PTR [edi+220]
  01771	51		 push	 ecx
  01772	e8 00 00 00 00	 call	 _pipe_count
  01777	83 c4 04	 add	 esp, 4
  0177a	85 c0		 test	 eax, eax
  0177c	75 39		 jne	 SHORT $L72139
  0177e	8b 97 e4 00 00
	00		 mov	 edx, DWORD PTR [edi+228]
  01784	52		 push	 edx
  01785	e8 00 00 00 00	 call	 _pipe_count
  0178a	83 c4 04	 add	 esp, 4
  0178d	85 c0		 test	 eax, eax
  0178f	75 26		 jne	 SHORT $L72139

; 5018 : 		{
; 5019 : 			// tek 22aug96 by now, the cmd parser should be well oiled. Let it go*/
; 5020 : 			pKsd_t->cmd_flush = FALSE;

  01791	89 af 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebp

; 5021 : #ifdef API_DEBUG
; 5022 : 			OutputDebugString("TTSReset() exiting1.\n");
; 5023 : #endif //API_DEBUG
; 5024 : 			
; 5025 : 			// 16jun97 tek bats385
; 5026 : 			// merged 28jul97 tek
; 5027 : 			phTTS->bInReset = FALSE;
; 5028 : 			
; 5029 : 			if (pipe_count( phTTS->pKernelShareData->buffer_pipe ))

  01797	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0179a	89 ae d8 00 00
	00		 mov	 DWORD PTR [esi+216], ebp
  017a0	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  017a6	51		 push	 ecx
  017a7	e8 00 00 00 00	 call	 _pipe_count
  017ac	83 c4 04	 add	 esp, 4
  017af	33 c0		 xor	 eax, eax
  017b1	5f		 pop	 edi
  017b2	5e		 pop	 esi
  017b3	5d		 pop	 ebp
  017b4	5b		 pop	 ebx

; 5449 : 	  return( MMSYSERR_ERROR );
; 5450 :   
; 5451 :   return( MMSYSERR_NOERROR );
; 5452 : }

  017b5	59		 pop	 ecx
  017b6	c3		 ret	 0
$L72139:

; 5030 : 			{
; 5031 : #ifdef API_DEBUG
; 5032 : 				OutputDebugString("Reset return: still have buffers.\n");
; 5033 : #endif //API_DEBUG
; 5034 : 				return(MMSYSERR_NOERROR);
; 5035 : 			}
; 5036 : 			else
; 5037 : 				return( MMSYSERR_NOERROR );
; 5038 : 		}
; 5039 : 		
; 5040 : 		/******************************************************************/
; 5041 : 		/*  If the previous reset has not completed then just flush the   */
; 5042 : 		/*  pipes and exit.                                               */
; 5043 : 		/******************************************************************/
; 5044 : 		if ( phTTS->bMemoryReset )

  017b7	39 ae 8c 00 00
	00		 cmp	 DWORD PTR [esi+140], ebp
  017bd	0f 84 83 00 00
	00		 je	 $L72146

; 5045 : 		{
; 5046 : 			// reset the sync event so that we can use it to see when 
; 5047 : 			// this stuff gets through
; 5048 : #ifdef WIN32
; 5049 : 			ResetEvent(phTTS->hSyncEvent);

  017c3	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  017c6	52		 push	 edx
  017c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 5050 : #ifdef	TYPING_MODE // tek 17jun97
; 5051 : 			TextToSpeechSpeakEx( phTTS, szCforce3,TTS_FORCE,FALSE);
; 5052 : #else
; 5053 : 			
; 5054 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  017cd	55		 push	 ebp
  017ce	6a 01		 push	 1
  017d0	68 00 00 00 00	 push	 OFFSET FLAT:$SG72141
  017d5	56		 push	 esi
  017d6	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5055 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  017db	55		 push	 ebp
  017dc	6a 01		 push	 1
  017de	68 00 00 00 00	 push	 OFFSET FLAT:$SG72142
  017e3	56		 push	 esi
  017e4	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5056 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  017e9	55		 push	 ebp
  017ea	6a 01		 push	 1
  017ec	68 00 00 00 00	 push	 OFFSET FLAT:$SG72143
  017f1	56		 push	 esi
  017f2	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5057 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  017f7	55		 push	 ebp
  017f8	6a 01		 push	 1
  017fa	68 00 00 00 00	 push	 OFFSET FLAT:$SG72144
  017ff	56		 push	 esi
  01800	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5058 : 			
; 5059 : #endif //TYPING_MODE
; 5060 : #endif
; 5061 : #if defined __osf__ || defined __linux__
; 5062 : 			OP_ResetEvent(phTTS->hSyncEvent);
; 5063 : 			
; 5064 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5065 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5066 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5067 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5068 : #endif
; 5069 : /****************************************************************/
; 5070 : /*  Wait until the VTM thread is about to send a buffer.        */
; 5071 : /****************************************************************/
; 5072 : /* tek 19aug96 this is probably a bad way to do it; it is 
; 5073 : better to wait for the sync even that we get from those
; 5074 : forces going through..
; 5075 : */
; 5076 : #ifdef API_DEBUG
; 5077 : sprintf(szTemp,"TTSReset wait for sync at %ld \n",timeGetTime());
; 5078 : OutputDebugString(szTemp);
; 5079 : #endif //API_DEBUG
; 5080 : #ifdef WIN32
; 5081 : 			WaitForSingleObject(phTTS->hSyncEvent,INFINITE);

  01805	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  01808	83 c4 40	 add	 esp, 64			; 00000040H
  0180b	6a ff		 push	 -1
  0180d	50		 push	 eax
  0180e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 5082 : #endif
; 5083 : #if defined __osf__ || defined __linux__
; 5084 : 			OP_WaitForEvent(phTTS->hSyncEvent, OP_INFINITE);
; 5085 : #endif
; 5086 : 			//                while ( ! phTTS->bSendingBuffer )
; 5087 : 			//        {
; 5088 : 			//      Sleep( SEND_BUFFER_WAIT_TIME );
; 5089 : 			//        }
; 5090 : #ifdef API_DEBUG
; 5091 : 			sprintf(szTemp,"TTSReset sync'd at %ld\n",timeGetTime());
; 5092 : 			OutputDebugString(szTemp);
; 5093 : #endif //API_DEBUG
; 5094 : 			/****************************************************************/
; 5095 : 			/*  Empty all of the Text-To-Speech pipes.                      */
; 5096 : 			/****************************************************************/
; 5097 : 			
; 5098 : 			pKsd_t->halting = TRUE;
; 5099 : 			mmStatus = WaitForEmptyPipes( phTTS,
; 5100 : 				MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 5101 : 				TRUE );

  01814	6a 01		 push	 1
  01816	68 10 27 00 00	 push	 10000			; 00002710H
  0181b	56		 push	 esi
  0181c	c7 87 74 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+372], 1
  01826	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  0182b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5102 : 			pKsd_t->halting = FALSE;

  0182e	89 af 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebp

; 5103 : 			// tek 29aug96 I'm not clear about the state of cmd_flush
; 5104 : 			// at this point. I don't know if I can clear it, because
; 5105 : 			// I *think* we're nested. But, I'll do it anyway.
; 5106 : 			pKsd_t->cmd_flush = FALSE;

  01834	89 af 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebp

; 5107 : #ifdef API_DEBUG
; 5108 : 			if (pipe_count( pKsd_t->buffer_pipe ))
; 5109 : 			{
; 5110 : 				OutputDebugString("Reset return: still have buffers. \n");
; 5111 : 			}
; 5112 : 			OutputDebugString("TTSReset() exiting 2.\n");
; 5113 : #endif //API_DEBUG
; 5114 : 			
; 5115 : 			// 16jun97 tek bats385
; 5116 : 			// merged 28jul97 tek
; 5117 : 			phTTS->bInReset = FALSE;

  0183a	89 ae d8 00 00
	00		 mov	 DWORD PTR [esi+216], ebp
  01840	5f		 pop	 edi
  01841	5e		 pop	 esi
  01842	5d		 pop	 ebp
  01843	5b		 pop	 ebx

; 5449 : 	  return( MMSYSERR_ERROR );
; 5450 :   
; 5451 :   return( MMSYSERR_NOERROR );
; 5452 : }

  01844	59		 pop	 ecx
  01845	c3		 ret	 0
$L72146:

; 5118 : 			
; 5119 : #ifdef WIN32
; 5120 : 			if (mmStatus)
; 5121 : 				return( mmStatus );
; 5122 : 			else
; 5123 : #endif
; 5124 : 				return(mmStatus);
; 5125 : 		}
; 5126 : 		
; 5127 : 		phTTS->bMemoryReset = TRUE;

  01846	c7 86 8c 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+140], 1
$L72136:

; 5128 :   }
; 5129 :   
; 5130 :   /********************************************************************/
; 5131 :   /*  At this point there may still be a clause stuck in ph. Force    */
; 5132 :   /*  the clause out.                                                 */
; 5133 :   /********************************************************************/
; 5134 :   
; 5135 :   /********************************************************************/
; 5136 :   /*  Set the halting flag. This will cause the CMD, LTS, PH, VTM,    */
; 5137 :   /*  and SYNC threads to all discard input data and flush the pipes. */
; 5138 :   /********************************************************************/
; 5139 : #ifdef TYPING_MODE
; 5140 :   if (!bWasTyping)
; 5141 :   {
; 5142 : #endif //TYPING_MODE
; 5143 : 	  //tek 22aug96
; 5144 : 	  pKsd_t->halting = TRUE;
; 5145 : 	  
; 5146 : 	  
; 5147 : 
; 5148 : #ifdef	TYPING_MODE // tek 17jun97
; 5149 : 	  TextToSpeechSpeakEx( phTTS, szCforce3,TTS_FORCE,FALSE); // bats 385
; 5150 : #else
; 5151 : #ifdef WIN32
; 5152 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  01850	55		 push	 ebp
  01851	6a 01		 push	 1
  01853	68 00 00 00 00	 push	 OFFSET FLAT:$SG72147
  01858	56		 push	 esi
  01859	c7 87 74 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+372], 1
  01863	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5153 : 	  /* MGS made change for SAPI so it wouldn't crash when exiting */
; 5154 : #ifndef OLEDECTALK
; 5155 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  01868	55		 push	 ebp
  01869	6a 01		 push	 1
  0186b	68 00 00 00 00	 push	 OFFSET FLAT:$SG72148
  01870	56		 push	 esi
  01871	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5156 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  01876	55		 push	 ebp
  01877	6a 01		 push	 1
  01879	68 00 00 00 00	 push	 OFFSET FLAT:$SG72149
  0187e	56		 push	 esi
  0187f	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5157 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  01884	55		 push	 ebp
  01885	6a 01		 push	 1
  01887	68 00 00 00 00	 push	 OFFSET FLAT:$SG72150
  0188c	56		 push	 esi
  0188d	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx
  01892	83 c4 40	 add	 esp, 64			; 00000040H

; 5158 : #endif
; 5159 : #endif
; 5160 : #if defined __osf__ || defined __linux__
; 5161 : 	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5162 : 	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5163 : 	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5164 : 	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5165 : #endif
; 5166 : #endif //TYPING_MODE
; 5167 : 	  
; 5168 : 	  /********************************************************************/
; 5169 : 	  /*  Wait for the Text thread to complete all text queueing.         */
; 5170 : 	  /********************************************************************/
; 5171 : 	  // tek 22aug96
; 5172 : 	  WaitForTextQueuingToComplete( phTTS, TRUE );

  01895	6a 01		 push	 1
  01897	56		 push	 esi
  01898	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete

; 5173 : #ifdef TYPING_MODE
; 5174 :   }
; 5175 : #endif //TYPING_MODE
; 5176 :   // tek 22aug96 by now, the cmd parser should be well oiled. Let it go*/
; 5177 :   pKsd_t->cmd_flush = FALSE;

  0189d	89 af 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebp

; 5178 :   
; 5179 :   /********************************************************************/
; 5180 :   /*  Perform an second audio reset to immediately stop audio from    */
; 5181 :   /*  playing and to make sure the VTM thread is not blocked.         */
; 5182 :   /********************************************************************/
; 5183 :   
; 5184 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  018a3	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  018a9	83 c4 08	 add	 esp, 8
  018ac	3b c5		 cmp	 eax, ebp
  018ae	75 0f		 jne	 SHORT $L72151

; 5185 :   {
; 5186 : 	  PA_Reset( phTTS->pAudioHandle );

  018b0	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  018b6	51		 push	 ecx
  018b7	e8 00 00 00 00	 call	 _PA_Reset
  018bc	83 c4 04	 add	 esp, 4
$L72151:

; 5187 :   }
; 5188 :   
; 5189 :   // tek 19aug96 anti-block for the memory case.. 
; 5190 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  018bf	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  018c6	75 4a		 jne	 SHORT $L72152

; 5191 :   {
; 5192 : 	  if (pipe_count( phTTS->pKernelShareData->buffer_pipe ) < 1)

  018c8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  018cb	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  018d1	50		 push	 eax
  018d2	e8 00 00 00 00	 call	 _pipe_count
  018d7	83 c4 04	 add	 esp, 4
  018da	83 f8 01	 cmp	 eax, 1
  018dd	73 0a		 jae	 SHORT $L72153

; 5193 : 		  TextToSpeechAddBuffer(phTTS, NULL); //deadlock avoidance

  018df	55		 push	 ebp
  018e0	56		 push	 esi
  018e1	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  018e6	83 c4 08	 add	 esp, 8
$L72153:

; 5194 : 
; 5195 : 	  EnterCriticalSection(phTTS->pcsMemoryBuffer);

  018e9	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  018ef	51		 push	 ecx
  018f0	ff d3		 call	 ebx

; 5196 : 
; 5197 : 	  // if we have an active output buffer, clear it.
; 5198 : 	  if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  018f2	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  018f8	3b c5		 cmp	 eax, ebp
  018fa	74 09		 je	 SHORT $L72157

; 5199 : 	  {
; 5200 : 		  
; 5201 : 		  pTTS_Buffer->dwBufferLength = 0;

  018fc	89 68 18	 mov	 DWORD PTR [eax+24], ebp

; 5202 : 		  pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  018ff	89 68 1c	 mov	 DWORD PTR [eax+28], ebp

; 5203 : 		  pTTS_Buffer->dwNumberOfIndexMarks = 0;

  01902	89 68 20	 mov	 DWORD PTR [eax+32], ebp
$L72157:

; 5204 : 		  
; 5205 : 		  
; 5206 : 	  } // was not a null buffer
; 5207 : 
; 5208 : 	  LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  01905	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  0190b	52		 push	 edx
  0190c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72152:

; 5209 :   }
; 5210 :   
; 5211 :   /********************************************************************/
; 5212 :   /*  Maximize the queued sample count to release the                 */
; 5213 :   /*  WaitForAudioSampleToPlay() function (in file sync.c).           */
; 5214 :   /********************************************************************/
; 5215 : #ifdef TYPING_MODE
; 5216 :   if (!bWasTyping)
; 5217 :   {
; 5218 : #endif //TYPING_MODE
; 5219 : 
; 5220 : 	  EnterCriticalSection( phTTS->pcsQueuedSampleCount );

  01912	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  01918	50		 push	 eax
  01919	ff d3		 call	 ebx

; 5221 : 	  phTTS->dwQueuedSampleCount = 4294967295;
; 5222 : 	  LeaveCriticalSection( phTTS->pcsQueuedSampleCount );

  0191b	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  01921	c7 46 7c ff ff
	ff ff		 mov	 DWORD PTR [esi+124], -1
  01928	51		 push	 ecx
  01929	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 5223 : 	  
; 5224 : #ifdef TYPING_MODE
; 5225 :   }
; 5226 : #endif //TYPING_MODE
; 5227 :   /********************************************************************/
; 5228 :   /*  Empty all of the Text-To-Speech pipes.                          */
; 5229 :   /********************************************************************/
; 5230 : #ifdef TYPING_MODE
; 5231 :   if (!bWasTyping)
; 5232 : #endif //TYPING_MODE
; 5233 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 5234 : 	  MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 5235 : 	  TRUE );

  0192f	6a 01		 push	 1
  01931	68 10 27 00 00	 push	 10000			; 00002710H
  01936	56		 push	 esi
  01937	e8 00 00 00 00	 call	 _WaitForEmptyPipes

; 5236 :   
; 5237 :   /********************************************************************/
; 5238 :   /*  Initialize the VTM, PH, LTS, and CMD threads.                   */
; 5239 :   /********************************************************************/
; 5240 : #ifdef API_DEBUG
; 5241 : sprintf(szTemp,"TTSReset init threads at %ld\n",timeGetTime());
; 5242 :   OutputDebugString(szTemp);  
; 5243 : #endif //API_DEBUG
; 5244 :   if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  0193c	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01942	83 c4 0c	 add	 esp, 12			; 0000000cH
  01945	83 f8 01	 cmp	 eax, 1
  01948	74 09		 je	 SHORT $L72158

; 5245 :   {
; 5246 : 	  InitializeVTM(phTTS);

  0194a	56		 push	 esi
  0194b	e8 00 00 00 00	 call	 _InitializeVTM
  01950	83 c4 04	 add	 esp, 4
$L72158:

; 5247 :   };
; 5248 :   
; 5249 :   
; 5250 :   phinit( phTTS, bReset );

  01953	8b 5c 24 1c	 mov	 ebx, DWORD PTR _bReset$[esp+16]
  01957	53		 push	 ebx
  01958	56		 push	 esi
  01959	e8 00 00 00 00	 call	 _phinit

; 5251 : #ifdef TYPING_MODE
; 5252 :   if (!bWasTyping)
; 5253 :   {
; 5254 : #endif //TYPING_MODE
; 5255 : 	  
; 5256 : 	  ls_util_lts_init(phTTS->pLTSThreadData);

  0195e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  01961	52		 push	 edx
  01962	e8 00 00 00 00	 call	 _ls_util_lts_init

; 5257 : 	  
; 5258 : 	  
; 5259 : 	  cmd_init( phTTS,bReset );

  01967	53		 push	 ebx
  01968	56		 push	 esi
  01969	e8 00 00 00 00	 call	 _cmd_init

; 5260 : 	  
; 5261 : #ifdef TYPING_MODE
; 5262 :   }
; 5263 : #endif //TYPING_MODE
; 5264 :   
; 5265 :   pKsd_t->halting = FALSE;
; 5266 :   // tek 22aug96 we still need to do a LAST_VOICE to make sure the VTM */
; 5267 :   // is in a nice state..
; 5268 :   {
; 5269 : #if defined __osf__ || defined __linux__
; 5270 : 	  unsigned short LastVoice=LAST_VOICE;
; 5271 : 	  write_pipe( pKsd_t->lts_pipe, &LastVoice, 1 );
; 5272 : #endif
; 5273 : 
; 5274 : #ifdef WIN32
; 5275 : 	  unsigned short LastVoice[2],phone;
; 5276 : 	  LastVoice[0]=LAST_VOICE;
; 5277 : 	  LastVoice[1]=SYNC;
; 5278 : #ifdef TYPING_MODE
; 5279 : 	  //	if (bWasTyping)
; 5280 : 	  //	{
; 5281 : 	  write_pipe( pKsd_t->ph_pipe, &LastVoice, 2 );
; 5282 : 	  //	}
; 5283 : 	  //	else
; 5284 : #else //TYPING_MODE
; 5285 : 	  write_pipe( pKsd_t->lts_pipe, &LastVoice, 2 );

  0196e	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  01974	8d 44 24 2c	 lea	 eax, DWORD PTR _LastVoice$72159[esp+36]
  01978	6a 02		 push	 2
  0197a	50		 push	 eax
  0197b	51		 push	 ecx
  0197c	89 af 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebp
  01982	66 c7 44 24 38
	03 1f		 mov	 WORD PTR _LastVoice$72159[esp+48], 7939 ; 00001f03H
  01989	66 c7 44 24 3a
	0a 1f		 mov	 WORD PTR _LastVoice$72159[esp+50], 7946 ; 00001f0aH
  01990	e8 00 00 00 00	 call	 _write_pipe

; 5286 : 	  /* GL 01/08/98  BATS#547  force a extra space after SYNC, VT/HT to fix the
; 5287 : 	  dropping punctuation problem. */
; 5288 : 	  phone = (PFASCII<<PSFONT) + ' ';
; 5289 : 	  write_pipe( pKsd_t->lts_pipe, &phone, 1 );

  01995	8b 87 d0 00 00
	00		 mov	 eax, DWORD PTR [edi+208]
  0199b	8d 54 24 3c	 lea	 edx, DWORD PTR _phone$72160[esp+48]
  0199f	6a 01		 push	 1
  019a1	52		 push	 edx
  019a2	50		 push	 eax
  019a3	c7 44 24 48 20
	00 00 00	 mov	 DWORD PTR _phone$72160[esp+60], 32 ; 00000020H
  019ab	e8 00 00 00 00	 call	 _write_pipe

; 5290 : #endif //TYPING_MODE
; 5291 : #endif
; 5292 :   }
; 5293 :   
; 5294 :   /********************************************************************/
; 5295 :   /*  Perform a third audio reset to make sure the audio queue is     */
; 5296 :   /*  empty after the pipes were emptied.                             */
; 5297 :   /********************************************************************/
; 5298 :   
; 5299 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  019b0	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  019b6	83 c4 2c	 add	 esp, 44			; 0000002cH
  019b9	3b c5		 cmp	 eax, ebp
  019bb	75 0f		 jne	 SHORT $L72161

; 5300 :   {
; 5301 : 	  PA_Reset( phTTS->pAudioHandle );

  019bd	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  019c3	51		 push	 ecx
  019c4	e8 00 00 00 00	 call	 _PA_Reset
  019c9	83 c4 04	 add	 esp, 4
$L72161:

; 5302 :   }
; 5303 :   // tek 19aug96 anti-block for the memory case.. 
; 5304 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  019cc	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  019d3	75 4e		 jne	 SHORT $L72162

; 5305 :   {     
; 5306 : 	  if (pipe_count( phTTS->pKernelShareData->buffer_pipe ) < 2)

  019d5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  019d8	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  019de	50		 push	 eax
  019df	e8 00 00 00 00	 call	 _pipe_count
  019e4	83 c4 04	 add	 esp, 4
  019e7	83 f8 02	 cmp	 eax, 2
  019ea	73 0a		 jae	 SHORT $L72163

; 5307 : 		  TextToSpeechAddBuffer(phTTS, NULL); // deadlock avoidance

  019ec	55		 push	 ebp
  019ed	56		 push	 esi
  019ee	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  019f3	83 c4 08	 add	 esp, 8
$L72163:

; 5308 : 
; 5309 : 	  EnterCriticalSection(phTTS->pcsMemoryBuffer);

  019f6	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  019fc	51		 push	 ecx
  019fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 5310 : 
; 5311 : 	  // if we have an active output buffer, clear it.
; 5312 : 	  if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  01a03	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  01a09	3b c5		 cmp	 eax, ebp
  01a0b	74 09		 je	 SHORT $L72167

; 5313 : 	  {
; 5314 : 		  
; 5315 : 		  pTTS_Buffer->dwBufferLength = 0;

  01a0d	89 68 18	 mov	 DWORD PTR [eax+24], ebp

; 5316 : 		  pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  01a10	89 68 1c	 mov	 DWORD PTR [eax+28], ebp

; 5317 : 		  pTTS_Buffer->dwNumberOfIndexMarks = 0;

  01a13	89 68 20	 mov	 DWORD PTR [eax+32], ebp
$L72167:

; 5318 : 		  
; 5319 : 		  
; 5320 : 	  } // was not a null buffer
; 5321 : 
; 5322 : 	  LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  01a16	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  01a1c	52		 push	 edx
  01a1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72162:

; 5323 : 
; 5324 :   }
; 5325 : #ifdef TYPING_MODE
; 5326 :   if (bWasTyping)
; 5327 :   {
; 5328 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 5329 : 		  15,
; 5330 : 		  TRUE );
; 5331 :   }
; 5332 :   else
; 5333 : #endif //TYPING_MODE
; 5334 : 	  /********************************************************************/
; 5335 : 	  /*  Empty all of the Text-To-Speech pipes.                          */
; 5336 : 	  /********************************************************************/
; 5337 : 	  //tek 22aug96
; 5338 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 5339 : 	  MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 5340 : 	  TRUE );

  01a23	6a 01		 push	 1
  01a25	68 10 27 00 00	 push	 10000			; 00002710H
  01a2a	56		 push	 esi
  01a2b	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  01a30	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a33	89 44 24 18	 mov	 DWORD PTR _mmStatus$[esp+16], eax

; 5341 :   
; 5342 :   
; 5343 :   /********************************************************************/
; 5344 :   /*  Zero the queued sample count (used for index marks and sync).   */
; 5345 :   /********************************************************************/
; 5346 :   
; 5347 :   EnterCriticalSection( phTTS->pcsQueuedSampleCount );

  01a37	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  01a3d	50		 push	 eax
  01a3e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 5348 :   phTTS->dwQueuedSampleCount = 0;
; 5349 :   LeaveCriticalSection( phTTS->pcsQueuedSampleCount );

  01a44	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  01a4a	89 6e 7c	 mov	 DWORD PTR [esi+124], ebp
  01a4d	51		 push	 ecx
  01a4e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 5350 :   
; 5351 :   /********************************************************************/
; 5352 :   /*  Conditionally reset the state of the Text-To-Speech system.     */
; 5353 :   /********************************************************************/
; 5354 :   
; 5355 :   
; 5356 :   if ( bReset )

  01a54	3b dd		 cmp	 ebx, ebp
  01a56	74 62		 je	 SHORT $L72168

; 5357 :   {
; 5358 : 	  switch( phTTS->dwOutputState )
; 5359 : 	  {

  01a58	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01a5e	48		 dec	 eax
  01a5f	74 16		 je	 SHORT $L72173
  01a61	48		 dec	 eax
  01a62	74 0b		 je	 SHORT $L72174
  01a64	48		 dec	 eax
  01a65	75 19		 jne	 SHORT $L72170

; 5369 : 		  
; 5370 : 	  case STATE_OUTPUT_LOG_FILE:
; 5371 : 		  
; 5372 : 		  TextToSpeechCloseLogFile( phTTS );

  01a67	56		 push	 esi
  01a68	e8 00 00 00 00	 call	 _TextToSpeechCloseLogFile

; 5373 : 		  break;

  01a6d	eb 0e		 jmp	 SHORT $L73270
$L72174:

; 5363 : 		  break;
; 5364 : 		  
; 5365 : 	  case STATE_OUTPUT_WAVE_FILE:
; 5366 : 		  
; 5367 : 		  TextToSpeechCloseWaveOutFile( phTTS );

  01a6f	56		 push	 esi
  01a70	e8 00 00 00 00	 call	 _TextToSpeechCloseWaveOutFile

; 5368 : 		  break;

  01a75	eb 06		 jmp	 SHORT $L73270
$L72173:

; 5360 : 	  case STATE_OUTPUT_MEMORY:
; 5361 : 		  
; 5362 : 		  TextToSpeechCloseInMemory( phTTS );

  01a77	56		 push	 esi
  01a78	e8 00 00 00 00	 call	 _TextToSpeechCloseInMemory
$L73270:
  01a7d	83 c4 04	 add	 esp, 4
$L72170:

; 5374 : 		  
; 5375 : 	  default:
; 5376 : 		  break;
; 5377 : 	  }
; 5378 : 	  
; 5379 : 	  /******************************************************************/
; 5380 : 	  /*  Initialize the Text-To-Speech system state variables.         */
; 5381 : 	  /******************************************************************/
; 5382 : 	  
; 5383 : 	  pKsd_t->cmd_flush = FALSE;

  01a80	89 af 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebp

; 5384 : 	  pKsd_t->spc_flush = FALSE;

  01a86	89 af a4 01 00
	00		 mov	 DWORD PTR [edi+420], ebp

; 5385 : 	  pKsd_t->logflag  = 0;

  01a8c	89 af 04 02 00
	00		 mov	 DWORD PTR [edi+516], ebp

; 5386 : 	  /* GL 11/15/1996 set defaulted Spanish to Latin */
; 5387 : #ifdef SPANISH_LA
; 5388 : 	  pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
; 5389 : #else
; 5390 : 	  pKsd_t->modeflag = MODE_CITATION;

  01a92	c7 87 00 02 00
	00 00 01 00 00	 mov	 DWORD PTR [edi+512], 256 ; 00000100H

; 5391 : #endif //SPANISH_LA
; 5392 : 	  pKsd_t->sayflag = SAY_CLAUSE;

  01a9c	89 af 08 02 00
	00		 mov	 DWORD PTR [edi+520], ebp

; 5393 : 	  pKsd_t->pronflag = 0;

  01aa2	89 af 0c 02 00
	00		 mov	 DWORD PTR [edi+524], ebp

; 5394 : 	  pKsd_t->wbreak = FALSE;

  01aa8	89 af 14 02 00
	00		 mov	 DWORD PTR [edi+532], ebp

; 5395 : 	  pKsd_t->text_flush = FALSE;

  01aae	89 af 70 01 00
	00		 mov	 DWORD PTR [edi+368], ebp

; 5396 : 	  pKsd_t->async_change = FALSE;

  01ab4	89 af 38 02 00
	00		 mov	 DWORD PTR [edi+568], ebp
$L72168:

; 5397 :   }
; 5398 :   
; 5399 :   /********************************************************************/
; 5400 :   /*  Free all allocated index mark memory.                           */
; 5401 :   /********************************************************************/
; 5402 :   
; 5403 :   
; 5404 :   free_index(pKsd_t);

  01aba	57		 push	 edi
  01abb	e8 00 00 00 00	 call	 _free_index

; 5405 :   
; 5406 :   /********************************************************************/
; 5407 :   /*  Enable error messages.                                          */
; 5408 :   /********************************************************************/
; 5409 :   
; 5410 :   phTTS->bEnableErrorMessage = TRUE;
; 5411 :   
; 5412 :   
; 5413 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  01ac0	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  01ac6	b8 01 00 00 00	 mov	 eax, 1
  01acb	83 c4 04	 add	 esp, 4
  01ace	3b c8		 cmp	 ecx, eax
  01ad0	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  01ad6	75 09		 jne	 SHORT $L72177

; 5414 :   {
; 5415 : 	  ReturnRemainingBuffers(phTTS);   //tek 03sep96 make sure..

  01ad8	56		 push	 esi
  01ad9	e8 00 00 00 00	 call	 _ReturnRemainingBuffers
  01ade	83 c4 04	 add	 esp, 4
$L72177:

; 5416 : 	  // tek somehow in here, Q2Mem could have snagged a buffer and
; 5417 : 	  // if so, we have to get rid of it..
; 5418 :   }
; 5419 :   
; 5420 :   if ((pKsd_t->buffer_pipe != NULL) && pipe_count(pKsd_t->buffer_pipe ) )

  01ae1	8b bf e4 00 00
	00		 mov	 edi, DWORD PTR [edi+228]
  01ae7	3b fd		 cmp	 edi, ebp
  01ae9	74 16		 je	 SHORT $L72179
  01aeb	57		 push	 edi
  01aec	e8 00 00 00 00	 call	 _pipe_count
  01af1	83 c4 04	 add	 esp, 4
  01af4	85 c0		 test	 eax, eax
  01af6	74 09		 je	 SHORT $L72179

; 5421 :   {
; 5422 : #ifdef API_DEBUG
; 5423 : 	  OutputDebugString("Reset return: still have buffers. \n");
; 5424 : #endif //API_DEBUG
; 5425 : 	  ReturnRemainingBuffers(phTTS);

  01af8	56		 push	 esi
  01af9	e8 00 00 00 00	 call	 _ReturnRemainingBuffers
  01afe	83 c4 04	 add	 esp, 4
$L72179:

; 5426 :   }
; 5427 :   
; 5428 :   if (phTTS->pTTS_Buffer != NULL)

  01b01	39 ae a0 00 00
	00		 cmp	 DWORD PTR [esi+160], ebp
  01b07	74 09		 je	 SHORT $L72181

; 5429 : 	  SendBuffer(phTTS); // tek 04sep96 get rid of current

  01b09	56		 push	 esi
  01b0a	e8 00 00 00 00	 call	 _SendBuffer
  01b0f	83 c4 04	 add	 esp, 4
$L72181:

; 5430 :   // tek 29aug96 if we got this far, we know that we
; 5431 :   // can clear out MemoryReset.. normally SendBuf() would, 
; 5432 :   // but we've moved teh one that actually returns the buffers 
; 5433 :   // back in time.. 
; 5434 :   // tek 03sep96 now SendBuffer doesn't ever clear MemoryReset..
; 5435 :   phTTS->bMemoryReset = FALSE;
; 5436 :   // 16jun97 tek bats385
; 5437 :   // merged 28jul97 tek
; 5438 :   phTTS->bInReset = FALSE;
; 5439 :   
; 5440 : #ifdef API_DEBUG
; 5441 :   sprintf(szTemp,"TTSReset() exiting 3 at %ld\n",timeGetTime());
; 5442 :   OutputDebugString(szTemp);
; 5443 : #endif //API_DEBUG
; 5444 : #ifdef TYPING_MODE
; 5445 :   if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)
; 5446 : 	  phTTS->bInTypingMode = TRUE;
; 5447 : #endif //TYPING_MODE
; 5448 :   if  ( mmStatus )

  01b12	8b 4c 24 18	 mov	 ecx, DWORD PTR _mmStatus$[esp+16]
  01b16	89 ae 8c 00 00
	00		 mov	 DWORD PTR [esi+140], ebp
  01b1c	89 ae d8 00 00
	00		 mov	 DWORD PTR [esi+216], ebp
  01b22	33 c0		 xor	 eax, eax
  01b24	5f		 pop	 edi
  01b25	3b cd		 cmp	 ecx, ebp
  01b27	5e		 pop	 esi
  01b28	5d		 pop	 ebp
  01b29	0f 95 c0	 setne	 al
  01b2c	5b		 pop	 ebx

; 5449 : 	  return( MMSYSERR_ERROR );
; 5450 :   
; 5451 :   return( MMSYSERR_NOERROR );
; 5452 : }

  01b2d	59		 pop	 ecx
  01b2e	c3		 ret	 0
_TextToSpeechReset ENDP
_TEXT	ENDS
PUBLIC	_PumpModeMessage
EXTRN	__imp__Sleep@4:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_bReset$ = 12
_WaitForTextQueuingToComplete PROC NEAR

; 5490 : {

  01b30	53		 push	 ebx

; 5491 : 	int iLockupCount=0;
; 5492 : #ifdef API_DEBUG
; 5493 : 	char szTemp[256]="";
; 5494 : 	ULONG ulStartTime, ulEndTime;
; 5495 : 	ulStartTime=timeGetTime();
; 5496 : 	sprintf(szTemp, "WFTQTC() at %ld.\n", ulStartTime);
; 5497 : 	OutputDebugString(szTemp);
; 5498 : #endif //API_DEBUG
; 5499 : 	
; 5500 : 	/********************************************************************/
; 5501 : 	/*  Wait for the Text-To-Speech thread to complete text queueing.   */
; 5502 : 	/*  up to all messages numbered uiLastTextMessageNumber.            */
; 5503 : 	/********************************************************************/
; 5504 : 	
; 5505 : 	while ( TRUE )
; 5506 : 	{
; 5507 : 
; 5508 : 		EnterCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );
; 5509 : 
; 5510 : 		if ( phTTS->uiLastQueuedTextMsgNumber < phTTS->uiLastTextMsgNumber )

  01b31	8b 5c 24 0c	 mov	 ebx, DWORD PTR _bReset$[esp]
  01b35	55		 push	 ebp
  01b36	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__LeaveCriticalSection@4
  01b3c	56		 push	 esi
  01b3d	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  01b41	57		 push	 edi
  01b42	33 ff		 xor	 edi, edi
$L72190:
  01b44	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  01b4a	50		 push	 eax
  01b4b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  01b51	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  01b54	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  01b57	3b c8		 cmp	 ecx, eax
  01b59	73 69		 jae	 SHORT $L72192

; 5511 : 		{
; 5512 : 
; 5513 : 			LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  01b5b	8b 96 b8 00 00
	00		 mov	 edx, DWORD PTR [esi+184]
  01b61	52		 push	 edx
  01b62	ff d5		 call	 ebp

; 5514 : 
; 5515 : 			/****************************************************************/
; 5516 : 			/*  Set the sync event in case the cmd thread is blocked in the */
; 5517 : 			/*  cmd_sync() function.                                        */
; 5518 : 			/****************************************************************/
; 5519 : 			
; 5520 : 			if ( bReset )

  01b64	85 db		 test	 ebx, ebx
  01b66	74 23		 je	 SHORT $L72194

; 5521 : 			{
; 5522 : #ifdef WIN32
; 5523 : 				SetEvent( phTTS->hSyncEvent );

  01b68	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  01b6b	50		 push	 eax
  01b6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 5524 : #endif
; 5525 : #if defined __osf__ || defined __linux__
; 5526 : 				OP_SetEvent( phTTS->hSyncEvent );
; 5527 : #endif
; 5528 : 				
; 5529 : 				
; 5530 : 				/**************************************************************/
; 5531 : 				/*  Perform an audio reset to immediately stop audio from     */
; 5532 : 				/*  playing and to make sure the VTM thread is not blocked.   */
; 5533 : 				/**************************************************************/
; 5534 : 				
; 5535 : 				if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01b72	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01b78	85 c0		 test	 eax, eax
  01b7a	75 0f		 jne	 SHORT $L72194

; 5536 : 				{
; 5537 : 					PA_Reset( phTTS->pAudioHandle );

  01b7c	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  01b82	51		 push	 ecx
  01b83	e8 00 00 00 00	 call	 _PA_Reset
  01b88	83 c4 04	 add	 esp, 4
$L72194:

; 5538 : 				}
; 5539 : 			}
; 5540 : 			
; 5541 : 			/****************************************************************/
; 5542 : 			/*  Go to sleep while the text queue empties.                   */
; 5543 : 			/****************************************************************/
; 5544 : 			Sleep( TEXT_QUEUE_WAIT_TIME );

  01b8b	6a 1e		 push	 30			; 0000001eH
  01b8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 5545 : 			PumpModeMessage(phTTS->pAudioHandle);

  01b93	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  01b99	52		 push	 edx
  01b9a	e8 00 00 00 00	 call	 _PumpModeMessage

; 5546 : 			if (( phTTS->dwOutputState == STATE_OUTPUT_MEMORY ) && ( bReset ))

  01b9f	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01ba5	83 c4 04	 add	 esp, 4
  01ba8	83 f8 01	 cmp	 eax, 1
  01bab	75 97		 jne	 SHORT $L72190
  01bad	85 db		 test	 ebx, ebx
  01baf	74 93		 je	 SHORT $L72190

; 5547 : 			{
; 5548 : 				iLockupCount++;

  01bb1	47		 inc	 edi

; 5549 : 				
; 5550 : 				if ( iLockupCount > TEXT_LOCKUP_COUNT )

  01bb2	83 ff 02	 cmp	 edi, 2
  01bb5	7e 8d		 jle	 SHORT $L72190

; 5551 : 				{
; 5552 : 					FixMemoryLockup( phTTS );

  01bb7	56		 push	 esi
  01bb8	e8 00 00 00 00	 call	 _FixMemoryLockup
  01bbd	83 c4 04	 add	 esp, 4

; 5553 : 					
; 5554 : 					iLockupCount = 0;

  01bc0	33 ff		 xor	 edi, edi
  01bc2	eb 80		 jmp	 SHORT $L72190
$L72192:

; 5555 : 				}
; 5556 : 			}
; 5557 : 			
; 5558 : 		}
; 5559 : 		else
; 5560 : 		{
; 5561 : 
; 5562 : 			LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  01bc4	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  01bca	50		 push	 eax
  01bcb	ff d5		 call	 ebp
  01bcd	5f		 pop	 edi
  01bce	5e		 pop	 esi
  01bcf	5d		 pop	 ebp
  01bd0	5b		 pop	 ebx

; 5563 : 
; 5564 : 			break;
; 5565 : 		}
; 5566 : 	}
; 5567 : #ifdef API_DEBUG
; 5568 : 	ulEndTime=timeGetTime();
; 5569 : 	sprintf(szTemp, "WFTQTC() exit %ld ms.\n", ulEndTime-ulStartTime);
; 5570 : 	OutputDebugString(szTemp);
; 5571 : #endif //API_DEBUG
; 5572 : 	
; 5573 : 	return;
; 5574 : }

  01bd1	c3		 ret	 0
_WaitForTextQueuingToComplete ENDP
_TEXT	ENDS
EXTRN	_PA_WaitForPlayToComplete:NEAR
EXTRN	_OP_Sleep:NEAR
_BSS	SEGMENT
	ALIGN	4

$SG72206 DB	01H DUP (?)
	ALIGN	4

$SG72207 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechSync PROC NEAR

; 5615 : {

  01be0	56		 push	 esi

; 5616 : 	MMRESULT mmStatus = MMSYSERR_NOERROR;
; 5617 : 	
; 5618 : 	/********************************************************************/
; 5619 : 	/*  Return error if invalid handle.                                 */
; 5620 : 	/********************************************************************/
; 5621 : 	
; 5622 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01be1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01be5	6a 04		 push	 4
  01be7	56		 push	 esi
  01be8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01bee	85 c0		 test	 eax, eax
  01bf0	74 07		 je	 SHORT $L72202

; 5623 : 		return( MMSYSERR_INVALHANDLE );

  01bf2	b8 05 00 00 00	 mov	 eax, 5
  01bf7	5e		 pop	 esi

; 5726 : }

  01bf8	c3		 ret	 0
$L72202:

; 5624 : 	
; 5625 : 	/********************************************************************/
; 5626 : 	/*  Resume if the text to speech system has been paused or this     */
; 5627 : 	/*  function will block here forever.                               */
; 5628 : 	/********************************************************************/
; 5629 : #ifndef OLEDECTALK
; 5630 : #if defined __osf__ || defined __linux__
; 5631 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 5632 : #endif
; 5633 : #ifdef WIN32
; 5634 : 		if (
; 5635 : 			( ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 5636 : 			&&(!phTTS->bInReset)
; 5637 : 			)

  01bf9	f7 46 74 00 00
	00 80		 test	 DWORD PTR [esi+116], -2147483648 ; 80000000H
  01c00	75 19		 jne	 SHORT $L72203
  01c02	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  01c08	85 c0		 test	 eax, eax
  01c0a	75 6a		 jne	 SHORT $L72211

; 5638 : #endif
; 5639 : 			PA_Resume( phTTS->pAudioHandle );

  01c0c	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  01c12	50		 push	 eax
  01c13	e8 00 00 00 00	 call	 _PA_Resume
  01c18	83 c4 04	 add	 esp, 4
$L72203:

; 5640 : #endif //OLEDECTALK
; 5641 : 		/********************************************************************/
; 5642 : 		/*  Wait for the Text thread to complete all text queueing.         */
; 5643 : 		/********************************************************************/
; 5644 : #ifdef WIN32
; 5645 : 		if (!phTTS->bInReset) // tek bats 385 merged 28jul97

  01c1b	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  01c21	85 c0		 test	 eax, eax
  01c23	75 51		 jne	 SHORT $L72211

; 5646 : #endif
; 5647 : 		{
; 5648 : 			WaitForTextQueuingToComplete( phTTS, FALSE );

  01c25	6a 00		 push	 0
  01c27	56		 push	 esi
  01c28	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete

; 5649 : 		}
; 5650 : 		
; 5651 : 		/********************************************************************/
; 5652 : 		/*  Now that all the text is queued, make sure that it is purged.   */
; 5653 : 		/*  Four TTS_FORCE characters are used because of the way the       */
; 5654 : 		/*  WaitForEmptyPipes() function performs the wait.                 */
; 5655 : 		/********************************************************************/
; 5656 : 		
; 5657 : #ifdef WIN32
; 5658 : 		if (!phTTS->bInReset) // tek bats 385 merged 28jul97

  01c2d	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  01c33	83 c4 08	 add	 esp, 8
  01c36	85 c0		 test	 eax, eax
  01c38	75 3c		 jne	 SHORT $L72211

; 5659 : 		{
; 5660 : #ifdef UNDER_CE
; 5661 : 			TextToSpeechSpeak( phTTS, _T(""), TTS_FORCE );
; 5662 : 			TextToSpeechSpeak( phTTS, _T(""), TTS_FORCE );
; 5663 : #else
; 5664 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  01c3a	6a 01		 push	 1
  01c3c	68 00 00 00 00	 push	 OFFSET FLAT:$SG72206
  01c41	56		 push	 esi
  01c42	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 5665 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE ); /* tek 10jan97 don't need */
; 5666 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5667 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  01c47	6a 01		 push	 1
  01c49	68 00 00 00 00	 push	 OFFSET FLAT:$SG72207
  01c4e	56		 push	 esi
  01c4f	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 5668 : #endif //UNDER_CE
; 5669 : 		}
; 5670 : #endif
; 5671 : #if defined __osf__ || defined __linux__
; 5672 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5673 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5674 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5675 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5676 : #endif
; 5677 : 		
; 5678 : 		/********************************************************************/
; 5679 : 		/*  Now wait for all of the Text-To-Speech pipes to empty.          */
; 5680 : 		/********************************************************************/
; 5681 : 		/*  first, wait for the Text thread to complete all text queueing.  */
; 5682 : 		/*  (tek 10jan97)                                                   */
; 5683 : 		/********************************************************************/
; 5684 : #ifdef WIN32
; 5685 : 		if (!phTTS->bInReset)	// tek bats 385 merged 28jul97

  01c54	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  01c5a	83 c4 18	 add	 esp, 24			; 00000018H
  01c5d	85 c0		 test	 eax, eax
  01c5f	75 15		 jne	 SHORT $L72211

; 5686 : 			WaitForTextQueuingToComplete( phTTS, FALSE );

  01c61	6a 00		 push	 0
  01c63	56		 push	 esi
  01c64	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete

; 5687 : 		
; 5688 : 		// 28jul97 bats 385 merged
; 5689 : 		// this is where we think about exiting if we are in a reset;
; 5690 : 		// there is no need to do any of the subsequent waits, but we
; 5691 : 		// do want to hang here until the reset is done. 
; 5692 : 		if (phTTS->bInReset)

  01c69	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  01c6f	83 c4 08	 add	 esp, 8
  01c72	85 c0		 test	 eax, eax
  01c74	74 18		 je	 SHORT $L72209
$L72211:

; 5693 : 		{
; 5694 : 			while (phTTS->bInReset)
; 5695 : 			{
; 5696 : 				OP_Sleep(SYNC_RESET_CHECK_INTERVAL);

  01c76	6a 1e		 push	 30			; 0000001eH
  01c78	e8 00 00 00 00	 call	 _OP_Sleep
  01c7d	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  01c83	83 c4 04	 add	 esp, 4
  01c86	85 c0		 test	 eax, eax
  01c88	75 ec		 jne	 SHORT $L72211
$L72216:

; 5723 : 			}
; 5724 : 		}
; 5725 : 		return( MMSYSERR_NOERROR );

  01c8a	33 c0		 xor	 eax, eax
  01c8c	5e		 pop	 esi

; 5726 : }

  01c8d	c3		 ret	 0
$L72209:

; 5697 : 			}
; 5698 : 			return (MMSYSERR_NOERROR);
; 5699 : 		}
; 5700 : #endif
; 5701 : 		
; 5702 : 		mmStatus = WaitForEmptyPipes( phTTS,
; 5703 : 			MAXIMUM_SYNC_WAIT_TIME_IN_MSEC,
; 5704 : 			FALSE );

  01c8e	6a 00		 push	 0
  01c90	68 40 77 1b 00	 push	 1800000			; 001b7740H
  01c95	56		 push	 esi
  01c96	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  01c9b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5705 : 		
; 5706 : 		if ( mmStatus )

  01c9e	85 c0		 test	 eax, eax
  01ca0	74 07		 je	 SHORT $L72213

; 5707 : 			return( MMSYSERR_ERROR );

  01ca2	b8 01 00 00 00	 mov	 eax, 1
  01ca7	5e		 pop	 esi

; 5726 : }

  01ca8	c3		 ret	 0
$L72213:

; 5708 : 		
; 5709 : 		/********************************************************************/
; 5710 : 		/*  Now that the pipes are all empty, wait for the audio to         */
; 5711 : 		/*  complete.                                                       */
; 5712 : 		/********************************************************************/
; 5713 : 		
; 5714 : 		if( ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  01ca9	f7 46 74 00 00
	00 80		 test	 DWORD PTR [esi+116], -2147483648 ; 80000000H
  01cb0	75 d8		 jne	 SHORT $L72216

; 5715 : 		{
; 5716 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01cb2	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01cb8	85 c0		 test	 eax, eax
  01cba	75 ce		 jne	 SHORT $L72216

; 5717 : 			{
; 5718 : #ifndef OLEDECTALK
; 5719 : 				mmStatus = PA_WaitForPlayToComplete( phTTS->pAudioHandle );

  01cbc	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  01cc2	51		 push	 ecx
  01cc3	e8 00 00 00 00	 call	 _PA_WaitForPlayToComplete
  01cc8	83 c4 04	 add	 esp, 4

; 5720 : #endif //OLEDECTALK
; 5721 : 				if ( mmStatus )

  01ccb	85 c0		 test	 eax, eax
  01ccd	74 bb		 je	 SHORT $L72216

; 5722 : 					return( MMSYSERR_ERROR );

  01ccf	b8 01 00 00 00	 mov	 eax, 1
  01cd4	5e		 pop	 esi

; 5726 : }

  01cd5	c3		 ret	 0
_TextToSpeechSync ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetRate
_TEXT	SEGMENT
_phTTS$ = 8
_pdwRate$ = 12
_TextToSpeechGetRate PROC NEAR

; 5764 : {

  01ce0	56		 push	 esi

; 5765 : 	/********************************************************************/
; 5766 : 	/*  Return error if invalid handle.                                 */
; 5767 : 	/********************************************************************/
; 5768 : 	
; 5769 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01ce1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01ce5	6a 04		 push	 4
  01ce7	56		 push	 esi
  01ce8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01cee	85 c0		 test	 eax, eax
  01cf0	74 07		 je	 SHORT $L72222

; 5770 : 		return( MMSYSERR_INVALHANDLE );

  01cf2	b8 05 00 00 00	 mov	 eax, 5
  01cf7	5e		 pop	 esi

; 5783 : }

  01cf8	c3		 ret	 0
$L72222:

; 5771 : 	
; 5772 : 	*pdwRate = (DWORD) phTTS->pKernelShareData->sprate ;

  01cf9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01cfc	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pdwRate$[esp]
  01d00	0f bf 80 22 02
	00 00		 movsx	 eax, WORD PTR [eax+546]

; 5773 : 	
; 5774 : 	/********************************************************************/
; 5775 : 	/*  The following range test should never fail, so the error return */
; 5776 : 	/*  is undocumented.                                                */
; 5777 : 	/********************************************************************/
; 5778 : 	
; 5779 : 	if (( *pdwRate < MIN_SPEAKING_RATE ) || ( *pdwRate > MAX_SPEAKING_RATE ))

  01d07	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  01d0a	89 01		 mov	 DWORD PTR [ecx], eax
  01d0c	72 0b		 jb	 SHORT $L72225
  01d0e	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  01d13	77 04		 ja	 SHORT $L72225

; 5781 : 	
; 5782 : 	return( MMSYSERR_NOERROR );

  01d15	33 c0		 xor	 eax, eax
  01d17	5e		 pop	 esi

; 5783 : }

  01d18	c3		 ret	 0
$L72225:

; 5780 : 		return( MMSYSERR_ERROR );

  01d19	b8 01 00 00 00	 mov	 eax, 1
  01d1e	5e		 pop	 esi

; 5783 : }

  01d1f	c3		 ret	 0
_TextToSpeechGetRate ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetRate
_TEXT	SEGMENT
_phTTS$ = 8
_dwRate$ = 12
_TextToSpeechSetRate PROC NEAR

; 5821 : {

  01d20	56		 push	 esi

; 5822 : 	/********************************************************************/
; 5823 : 	/*  Return error if invalid handle.                                 */
; 5824 : 	/********************************************************************/
; 5825 : 	
; 5826 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01d21	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01d25	6a 04		 push	 4
  01d27	56		 push	 esi
  01d28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01d2e	85 c0		 test	 eax, eax
  01d30	74 07		 je	 SHORT $L72231

; 5827 : 		return( MMSYSERR_INVALHANDLE );

  01d32	b8 05 00 00 00	 mov	 eax, 5
  01d37	5e		 pop	 esi

; 5839 : }

  01d38	c3		 ret	 0
$L72231:

; 5828 : 	
; 5829 : 	/********************************************************************/
; 5830 : 	/*  Range test the speaking rate.                                   */
; 5831 : 	/********************************************************************/
; 5832 : 	
; 5833 : 	if (( dwRate < MIN_SPEAKING_RATE ) || ( dwRate > MAX_SPEAKING_RATE ))

  01d39	8b 44 24 0c	 mov	 eax, DWORD PTR _dwRate$[esp]
  01d3d	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  01d40	72 15		 jb	 SHORT $L72233
  01d42	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  01d47	77 0e		 ja	 SHORT $L72233

; 5835 : 	
; 5836 : 	phTTS->pKernelShareData->sprate = (short)dwRate;

  01d49	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01d4c	5e		 pop	 esi
  01d4d	66 89 81 22 02
	00 00		 mov	 WORD PTR [ecx+546], ax

; 5837 : 	
; 5838 : 	return( MMSYSERR_NOERROR );

  01d54	33 c0		 xor	 eax, eax

; 5839 : }

  01d56	c3		 ret	 0
$L72233:

; 5834 : 		return( MMSYSERR_INVALPARAM );

  01d57	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01d5c	5e		 pop	 esi

; 5839 : }

  01d5d	c3		 ret	 0
_TextToSpeechSetRate ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetSpeaker
_TEXT	SEGMENT
_phTTS$ = 8
_pSpeaker$ = 12
_TextToSpeechGetSpeaker PROC NEAR

; 5876 : {

  01d60	56		 push	 esi

; 5877 : 	/********************************************************************/
; 5878 : 	/*  Return error if invalid handle.                                 */
; 5879 : 	/********************************************************************/
; 5880 : 	
; 5881 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01d61	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01d65	6a 04		 push	 4
  01d67	56		 push	 esi
  01d68	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01d6e	85 c0		 test	 eax, eax
  01d70	74 07		 je	 SHORT $L72240

; 5882 : 		return( MMSYSERR_INVALHANDLE );

  01d72	b8 05 00 00 00	 mov	 eax, 5
  01d77	5e		 pop	 esi

; 5894 : 		return( MMSYSERR_ERROR );
; 5895 : 	
; 5896 : 	return( MMSYSERR_NOERROR );
; 5897 : }

  01d78	c3		 ret	 0
$L72240:

; 5883 : 	/* Also initialized new element in KSD for MI : MVP */
; 5884 : 	/* MGS 11/20/1998 BATS #571 Fixed TextToSpeechGetSpeaker */
; 5885 : 	//*pSpeaker = (SPEAKER_T)(phTTS->pKernelShareData->uiCurrentSpeaker);
; 5886 : 	*pSpeaker = (SPEAKER_T)(phTTS->pKernelShareData->last_voice);

  01d79	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01d7c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pSpeaker$[esp]

; 5887 : 	
; 5888 : 	/********************************************************************/
; 5889 : 	/*  The following range test should never fail, so the error return */
; 5890 : 	/*  is undocumented.                                                */
; 5891 : 	/********************************************************************/
; 5892 : 	
; 5893 : 	if ( *pSpeaker > WENDY + 1 )

  01d80	ba 09 00 00 00	 mov	 edx, 9
  01d85	5e		 pop	 esi
  01d86	0f bf 80 20 02
	00 00		 movsx	 eax, WORD PTR [eax+544]
  01d8d	3b d0		 cmp	 edx, eax
  01d8f	89 01		 mov	 DWORD PTR [ecx], eax
  01d91	1b c0		 sbb	 eax, eax
  01d93	f7 d8		 neg	 eax

; 5894 : 		return( MMSYSERR_ERROR );
; 5895 : 	
; 5896 : 	return( MMSYSERR_NOERROR );
; 5897 : }

  01d95	c3		 ret	 0
_TextToSpeechGetSpeaker ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetSpeaker
_TEXT	SEGMENT
_phTTS$ = 8
_Speaker$ = 12
_TextToSpeechSetSpeaker PROC NEAR

; 5935 : {

  01da0	56		 push	 esi

; 5936 : 	/********************************************************************/
; 5937 : 	/*  Return error if invalid handle.                                 */
; 5938 : 	/********************************************************************/
; 5939 : 	
; 5940 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01da1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01da5	6a 04		 push	 4
  01da7	56		 push	 esi
  01da8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01dae	85 c0		 test	 eax, eax
  01db0	74 07		 je	 SHORT $L72248

; 5941 : 		return( MMSYSERR_INVALHANDLE );

  01db2	b8 05 00 00 00	 mov	 eax, 5
  01db7	5e		 pop	 esi

; 5957 : }

  01db8	c3		 ret	 0
$L72248:

; 5942 : 	
; 5943 : 	/********************************************************************/
; 5944 : 	/*  Range test the speaker voice.                                   */
; 5945 : 	/********************************************************************/
; 5946 : 	
; 5947 : 	if (( Speaker < PAUL ) || ( Speaker > WENDY ))

  01db9	8b 44 24 0c	 mov	 eax, DWORD PTR _Speaker$[esp]
  01dbd	83 f8 08	 cmp	 eax, 8
  01dc0	77 0e		 ja	 SHORT $L72250

; 5949 : 	
; 5950 : 	/********************************************************************/
; 5951 : 	/*  Set voice change flag for phmain.c in the PH thread.            */
; 5952 : 	/********************************************************************/
; 5953 : 	
; 5954 : 	SetSpeaker( phTTS , Speaker );

  01dc2	50		 push	 eax
  01dc3	56		 push	 esi
  01dc4	e8 00 00 00 00	 call	 _SetSpeaker
  01dc9	83 c4 08	 add	 esp, 8

; 5955 : 	
; 5956 : 	return( MMSYSERR_NOERROR );

  01dcc	33 c0		 xor	 eax, eax
  01dce	5e		 pop	 esi

; 5957 : }

  01dcf	c3		 ret	 0
$L72250:

; 5948 : 		return( MMSYSERR_INVALPARAM );

  01dd0	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01dd5	5e		 pop	 esi

; 5957 : }

  01dd6	c3		 ret	 0
_TextToSpeechSetSpeaker ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetLanguage
_TEXT	SEGMENT
_phTTS$ = 8
_pLanguage$ = 12
_TextToSpeechGetLanguage PROC NEAR

; 5995 : 	/********************************************************************/
; 5996 : 	/*  Return error if invalid handle.                                 */
; 5997 : 	/********************************************************************/
; 5998 : 	
; 5999 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01de0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01de4	6a 04		 push	 4
  01de6	50		 push	 eax
  01de7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01ded	85 c0		 test	 eax, eax
  01def	74 06		 je	 SHORT $L72256

; 6000 : 		return( MMSYSERR_INVALHANDLE );

  01df1	b8 05 00 00 00	 mov	 eax, 5

; 6005 : }

  01df6	c3		 ret	 0
$L72256:

; 6001 : 	
; 6002 : 	*pLanguage = TTS_AMERICAN_ENGLISH;

  01df7	8b 4c 24 08	 mov	 ecx, DWORD PTR _pLanguage$[esp-4]

; 6003 : 	
; 6004 : 	return( MMSYSERR_NOERROR );

  01dfb	33 c0		 xor	 eax, eax
  01dfd	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 6005 : }

  01e03	c3		 ret	 0
_TextToSpeechGetLanguage ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetLanguage
_TEXT	SEGMENT
_phTTS$ = 8
_Language$ = 12
_TextToSpeechSetLanguage PROC NEAR

; 6045 : 	/********************************************************************/
; 6046 : 	/*  Return error if invalid handle.                                 */
; 6047 : 	/********************************************************************/
; 6048 : 	
; 6049 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01e10	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01e14	6a 04		 push	 4
  01e16	50		 push	 eax
  01e17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01e1d	85 c0		 test	 eax, eax
  01e1f	74 06		 je	 SHORT $L72262

; 6050 : 		return( MMSYSERR_INVALHANDLE );

  01e21	b8 05 00 00 00	 mov	 eax, 5

; 6053 : 		return( MMSYSERR_INVALPARAM );
; 6054 : 	
; 6055 : 	return( MMSYSERR_NOERROR );
; 6056 : }

  01e26	c3		 ret	 0
$L72262:

; 6051 : 	
; 6052 : 	if ( Language != TTS_AMERICAN_ENGLISH )

  01e27	8b 44 24 08	 mov	 eax, DWORD PTR _Language$[esp-4]
  01e2b	48		 dec	 eax
  01e2c	f7 d8		 neg	 eax
  01e2e	1b c0		 sbb	 eax, eax
  01e30	83 e0 0b	 and	 eax, 11			; 0000000bH

; 6053 : 		return( MMSYSERR_INVALPARAM );
; 6054 : 	
; 6055 : 	return( MMSYSERR_NOERROR );
; 6056 : }

  01e33	c3		 ret	 0
_TextToSpeechSetLanguage ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetCaps
_TEXT	SEGMENT
_pTTScaps$ = 8
_TextToSpeechGetCaps PROC NEAR

; 6096 : 	if ( pTTScaps == NULL )

  01e40	8b 44 24 04	 mov	 eax, DWORD PTR _pTTScaps$[esp-4]
  01e44	85 c0		 test	 eax, eax
  01e46	75 06		 jne	 SHORT $L72269

; 6097 : 		return( MMSYSERR_ERROR );

  01e48	b8 01 00 00 00	 mov	 eax, 1

; 6113 : }

  01e4d	c3		 ret	 0
$L72269:

; 6098 : 	
; 6099 : 	LanguageParamsArray[0].dwLanguage = TTS_AMERICAN_ENGLISH;

  01e4e	b9 01 00 00 00	 mov	 ecx, 1
  01e53	89 0d 00 00 00
	00		 mov	 DWORD PTR _LanguageParamsArray, ecx

; 6100 : 	LanguageParamsArray[0].dwLanguageAttributes = PROPER_NAME_PRONUNCIATION;

  01e59	89 0d 04 00 00
	00		 mov	 DWORD PTR _LanguageParamsArray+4, ecx

; 6101 : 	
; 6102 : 	pTTScaps->dwNumberOfLanguages = 1;

  01e5f	89 08		 mov	 DWORD PTR [eax], ecx

; 6103 : 	pTTScaps->lpLanguageParamsArray = LanguageParamsArray;

  01e61	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:_LanguageParamsArray

; 6104 : 	pTTScaps->dwSampleRate = 11025;

  01e68	c7 40 08 11 2b
	00 00		 mov	 DWORD PTR [eax+8], 11025 ; 00002b11H

; 6105 : 	pTTScaps->dwMinimumSpeakingRate = MIN_SPEAKING_RATE;

  01e6f	c7 40 0c 4b 00
	00 00		 mov	 DWORD PTR [eax+12], 75	; 0000004bH

; 6106 : 	pTTScaps->dwMaximumSpeakingRate = MAX_SPEAKING_RATE;

  01e76	c7 40 10 58 02
	00 00		 mov	 DWORD PTR [eax+16], 600	; 00000258H

; 6107 : 	pTTScaps->dwNumberOfPredefinedSpeakers = WENDY + 1;

  01e7d	c7 40 14 09 00
	00 00		 mov	 DWORD PTR [eax+20], 9

; 6108 : 	pTTScaps->dwCharacterSet = TTS_ASCII;

  01e84	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 6109 : 	/* GL 11/19/1998  BATS#827 use correct version number set in coop.h */
; 6110 : 	pTTScaps->Version = DTALK_MAJ_VERSION*100 + DTALK_MIN_VERSION;

  01e8b	c7 40 1c cc 01
	00 00		 mov	 DWORD PTR [eax+28], 460	; 000001ccH

; 6111 : 	
; 6112 : 	return( MMSYSERR_NOERROR );

  01e92	33 c0		 xor	 eax, eax

; 6113 : }

  01e94	c3		 ret	 0
_TextToSpeechGetCaps ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechLoadUserDictionary
EXTRN	_load_dictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_szFileName$ = 12
_TextToSpeechLoadUserDictionary PROC NEAR

; 6162 : {

  01ea0	56		 push	 esi
  01ea1	57		 push	 edi

; 6163 : 	// Added a local varaible to get the handle of current kernel_share_data handle :MVP
; 6164 : 	PKSD_T pKsd_t;
; 6165 : 
; 6166 : #ifdef UNDER_CE	//29oct99 mfg convert unicode string to char string for Windows CE
; 6167 : char chFileName[128];
; 6168 : WideStringtoAsciiString(chFileName, szFileName, 128);
; 6169 : #endif
; 6170 : 	
; 6171 : 	// Initialize with the pointer stored in phTTS :MVP */
; 6172 : 	pKsd_t = phTTS->pKernelShareData ;

  01ea2	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]

; 6173 : 	
; 6174 : 	
; 6175 : 	/********************************************************************/
; 6176 : 	/*  Return error if invalid handle.                                 */
; 6177 : 	/********************************************************************/
; 6178 : 	
; 6179 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01ea6	6a 04		 push	 4
  01ea8	57		 push	 edi
  01ea9	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  01eac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01eb2	85 c0		 test	 eax, eax
  01eb4	74 08		 je	 SHORT $L72276
  01eb6	5f		 pop	 edi

; 6180 : 		return( MMSYSERR_INVALHANDLE );

  01eb7	b8 05 00 00 00	 mov	 eax, 5
  01ebc	5e		 pop	 esi

; 6218 : #endif
; 6219 : }

  01ebd	c3		 ret	 0
$L72276:

; 6181 : 	
; 6182 : 	/********************************************************************/
; 6183 : 	/*  Return error if a user dictionary is already loaded.            */
; 6184 : 	/********************************************************************/
; 6185 : 	/* Changed KS to pKsd_t :MVP */
; 6186 : 	/* GL 11/05/1997  for BATS#510 */
; 6187 : 	if ( pKsd_t->udic_entries[pKsd_t->lang_curr] != 0 )

  01ebe	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  01ec4	8b 54 86 54	 mov	 edx, DWORD PTR [esi+eax*4+84]
  01ec8	8d 4c 86 54	 lea	 ecx, DWORD PTR [esi+eax*4+84]
  01ecc	85 d2		 test	 edx, edx
  01ece	74 08		 je	 SHORT $L72277
  01ed0	5f		 pop	 edi

; 6188 : 		return( MMSYSERR_ERROR );

  01ed1	b8 01 00 00 00	 mov	 eax, 1
  01ed6	5e		 pop	 esi

; 6218 : #endif
; 6219 : }

  01ed7	c3		 ret	 0
$L72277:

; 6189 : 	
; 6190 : 	/********************************************************************/
; 6191 : 	/*  Load the user dictionary.                                       */
; 6192 : 	/********************************************************************/
; 6193 : 	
; 6194 : 	// this is very broken; should be phTTS not phTTS->hWnd!?!
; 6195 : 	/* GL 11/05/1997  for BATS#510 */
; 6196 : 	// ETT: fixme? why is the linux one different?????!
; 6197 : 
; 6198 : #if defined __osf__ || defined __linux__
; 6199 : 	return( load_dictionary((void **)&(pKsd_t->udic[pKsd_t->lang_curr]),
; 6200 : 				(unsigned int *)&(pKsd_t->udic_entries[pKsd_t->lang_curr]),
; 6201 : 				szFileName, 1));
; 6202 : #endif
; 6203 : #ifdef WIN32
; 6204 : 	return( load_dictionary( phTTS,
; 6205 : //#endif
; 6206 : //#if defined __osf__
; 6207 : //	return( load_dictionary( phTTS->hWnd,
; 6208 : //#endif
; 6209 : 		(void **)&(pKsd_t->udic[pKsd_t->lang_curr]),
; 6210 : 		(unsigned int *)&(pKsd_t->udic_entries[pKsd_t->lang_curr]),
; 6211 : #ifdef	UNDER_CE
; 6212 : 		chFileName,
; 6213 : #else
; 6214 : 		szFileName,
; 6215 : #endif
; 6216 : 		TRUE,
; 6217 : 		FALSE ));

  01ed8	8b 54 24 10	 mov	 edx, DWORD PTR _szFileName$[esp+4]
  01edc	6a 00		 push	 0
  01ede	6a 01		 push	 1
  01ee0	52		 push	 edx
  01ee1	8d 44 86 38	 lea	 eax, DWORD PTR [esi+eax*4+56]
  01ee5	51		 push	 ecx
  01ee6	50		 push	 eax
  01ee7	57		 push	 edi
  01ee8	e8 00 00 00 00	 call	 _load_dictionary
  01eed	83 c4 18	 add	 esp, 24			; 00000018H
  01ef0	5f		 pop	 edi
  01ef1	5e		 pop	 esi

; 6218 : #endif
; 6219 : }

  01ef2	c3		 ret	 0
_TextToSpeechLoadUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechUnloadUserDictionary
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechUnloadUserDictionary PROC NEAR

; 6252 : {

  01f00	56		 push	 esi

; 6253 : 	/********************************************************************/
; 6254 : 	/*  Return error if invalid handle.                                 */
; 6255 : 	/********************************************************************/
; 6256 : 	
; 6257 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01f01	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01f05	6a 04		 push	 4
  01f07	56		 push	 esi
  01f08	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01f0e	85 c0		 test	 eax, eax
  01f10	74 07		 je	 SHORT $L72283

; 6258 : 		return( MMSYSERR_INVALHANDLE );

  01f12	b8 05 00 00 00	 mov	 eax, 5
  01f17	5e		 pop	 esi

; 6265 : #ifdef WIN32
; 6266 : 	UNREFERENCED_PARAMETER( phTTS );
; 6267 : #endif
; 6268 : }

  01f18	c3		 ret	 0
$L72283:

; 6259 : 	
; 6260 : 	/* GL 11/05/1997  for BATS#510 */
; 6261 : 	unload_dictionary((void **)&(phTTS->pKernelShareData->udic[phTTS->pKernelShareData->lang_curr]),
; 6262 : 		(unsigned int *)&(phTTS->pKernelShareData->udic_entries[phTTS->pKernelShareData->lang_curr]));

  01f19	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01f1c	8b 88 f8 00 00
	00		 mov	 ecx, DWORD PTR [eax+248]
  01f22	8d 54 88 54	 lea	 edx, DWORD PTR [eax+ecx*4+84]
  01f26	8d 44 88 38	 lea	 eax, DWORD PTR [eax+ecx*4+56]
  01f2a	52		 push	 edx
  01f2b	50		 push	 eax
  01f2c	e8 00 00 00 00	 call	 _unload_dictionary
  01f31	83 c4 08	 add	 esp, 8

; 6263 : 	
; 6264 : 	return( MMSYSERR_NOERROR );

  01f34	33 c0		 xor	 eax, eax
  01f36	5e		 pop	 esi

; 6265 : #ifdef WIN32
; 6266 : 	UNREFERENCED_PARAMETER( phTTS );
; 6267 : #endif
; 6268 : }

  01f37	c3		 ret	 0
_TextToSpeechUnloadUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenInMemory
_DATA	SEGMENT
	ORG $+1
$SG72311 DB	'DECtalkBufferMessage', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_dwFormat$ = 12
_TextToSpeechOpenInMemory PROC NEAR

; 6317 : {

  01f40	56		 push	 esi

; 6318 : 	P_PIPE buffer_pipe = NULL_PIPE;
; 6319 : #ifdef WIN32
; 6320 : 	// tek bats385
; 6321 : 	// we need the "buffer delay pipe" to make sure that we 
; 6322 : 	// don't get stuck forever returning buffers if the
; 6323 : 	// user buffer callback routine immediately returns buffers
; 6324 : 	// during a reset.
; 6325 : 	P_PIPE buffer_delay_pipe = NULL_PIPE;
; 6326 : #endif
; 6327 : 	MMRESULT mmStatus;
; 6328 : 	
; 6329 : 	/********************************************************************/
; 6330 : 	/*  Return error if invalid handle.                                 */
; 6331 : 	/********************************************************************/
; 6332 : 	
; 6333 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01f41	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01f45	57		 push	 edi
  01f46	6a 04		 push	 4
  01f48	56		 push	 esi
  01f49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01f4f	85 c0		 test	 eax, eax
  01f51	74 08		 je	 SHORT $L72296
  01f53	5f		 pop	 edi

; 6334 : 		return( MMSYSERR_INVALHANDLE );

  01f54	b8 05 00 00 00	 mov	 eax, 5
  01f59	5e		 pop	 esi

; 6457 : }

  01f5a	c3		 ret	 0
$L72296:

; 6335 : 	
; 6336 : 	/********************************************************************/
; 6337 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 6338 : 	/*  an error.                                                       */
; 6339 : 	/********************************************************************/
; 6340 : 	
; 6341 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 6342 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  01f5b	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01f61	85 c0		 test	 eax, eax
  01f63	74 0d		 je	 SHORT $L72297
  01f65	83 f8 04	 cmp	 eax, 4
  01f68	74 08		 je	 SHORT $L72297
  01f6a	5f		 pop	 edi

; 6343 : 		return( MMSYSERR_ERROR );

  01f6b	b8 01 00 00 00	 mov	 eax, 1
  01f70	5e		 pop	 esi

; 6457 : }

  01f71	c3		 ret	 0
$L72297:

; 6344 : 	
; 6345 : 	/********************************************************************/
; 6346 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 6347 : 	/*  function have completed.                                        */
; 6348 : 	/********************************************************************/
; 6349 : 	
; 6350 : 	mmStatus = TextToSpeechSync( phTTS );

  01f72	56		 push	 esi
  01f73	e8 00 00 00 00	 call	 _TextToSpeechSync
  01f78	83 c4 04	 add	 esp, 4

; 6351 : 	
; 6352 : 	if ( mmStatus )

  01f7b	85 c0		 test	 eax, eax

; 6353 : 		return( mmStatus );

  01f7d	0f 85 db 00 00
	00		 jne	 $L72290

; 6354 : 	
; 6355 : 	/********************************************************************/
; 6356 : 	/*  If the dwFormat value is invalid then return an error.          */
; 6357 : 	/********************************************************************/
; 6358 : 	
; 6359 : 	switch( dwFormat )
; 6360 : 	{

  01f83	8b 7c 24 10	 mov	 edi, DWORD PTR _dwFormat$[esp+4]
  01f87	8b c7		 mov	 eax, edi
  01f89	48		 dec	 eax
  01f8a	74 19		 je	 SHORT $L72303
  01f8c	83 e8 03	 sub	 eax, 3
  01f8f	74 14		 je	 SHORT $L72303
  01f91	83 e8 03	 sub	 eax, 3
  01f94	74 08		 je	 SHORT $L72305
  01f96	5f		 pop	 edi

; 6378 : 		
; 6379 : 	default:
; 6380 : 		
; 6381 : 		return( MMSYSERR_INVALPARAM );

  01f97	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01f9c	5e		 pop	 esi

; 6457 : }

  01f9d	c3		 ret	 0
$L72305:

; 6370 : 		
; 6371 : 		break;
; 6372 : 		
; 6373 : 	case WAVE_FORMAT_08M08:
; 6374 : 		
; 6375 : 		SetSampleRate( phTTS, MULAW_SAMPLE_RATE );

  01f9e	68 40 1f 00 00	 push	 8000			; 00001f40H

; 6376 : 		
; 6377 : 		break;

  01fa3	eb 05		 jmp	 SHORT $L73290
$L72303:

; 6361 : 	case WAVE_FORMAT_1M16:
; 6362 : 		
; 6363 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 6364 : 		
; 6365 : 		break;
; 6366 : 		
; 6367 : 	case WAVE_FORMAT_1M08:
; 6368 : 		
; 6369 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );

  01fa5	68 11 2b 00 00	 push	 11025			; 00002b11H
$L73290:
  01faa	56		 push	 esi
  01fab	e8 00 00 00 00	 call	 _SetSampleRate
  01fb0	83 c4 08	 add	 esp, 8

; 6382 : 	}
; 6383 : 	
; 6384 : 	phTTS->dwFormat = dwFormat;

  01fb3	89 be 80 00 00
	00		 mov	 DWORD PTR [esi+128], edi

; 6385 : 	
; 6386 : 	/********************************************************************/
; 6387 : 	/*  Create a pipe to send the buffer addresses to the VTM thread.   */
; 6388 : 	/********************************************************************/
; 6389 : 	
; 6390 : 	buffer_pipe = create_pipe( VOID_PTR_PIPE, BUFFER_PIPE_LENGTH );

  01fb9	68 00 01 00 00	 push	 256			; 00000100H
  01fbe	6a 06		 push	 6
  01fc0	e8 00 00 00 00	 call	 _create_pipe
  01fc5	83 c4 08	 add	 esp, 8

; 6391 : 	
; 6392 : 	if ( buffer_pipe == NULL )

  01fc8	85 c0		 test	 eax, eax
  01fca	75 08		 jne	 SHORT $L72308
  01fcc	5f		 pop	 edi

; 6393 : 	{
; 6394 : 		return( MMSYSERR_NOMEM );

  01fcd	b8 07 00 00 00	 mov	 eax, 7
  01fd2	5e		 pop	 esi

; 6457 : }

  01fd3	c3		 ret	 0
$L72308:

; 6395 : 	}
; 6396 : 	
; 6397 : 	phTTS->pKernelShareData->buffer_pipe = buffer_pipe;

  01fd4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 6398 : 	
; 6399 : #ifdef WIN32
; 6400 : 	// 16jun97 tek bats 385 (buffer delay)
; 6401 : 	
; 6402 : 	/********************************************************************/
; 6403 : 	/*  Create a pipe to send the buffer addresses to the VTM thread.   */
; 6404 : 	/********************************************************************/
; 6405 : 	
; 6406 : 	buffer_delay_pipe = create_pipe( VOID_PTR_PIPE, BUFFER_PIPE_LENGTH );

  01fd7	68 00 01 00 00	 push	 256			; 00000100H
  01fdc	6a 06		 push	 6
  01fde	89 81 e4 00 00
	00		 mov	 DWORD PTR [ecx+228], eax
  01fe4	e8 00 00 00 00	 call	 _create_pipe
  01fe9	83 c4 08	 add	 esp, 8

; 6407 : 	
; 6408 : 	if ( buffer_delay_pipe == NULL )

  01fec	85 c0		 test	 eax, eax
  01fee	75 08		 jne	 SHORT $L72310
  01ff0	5f		 pop	 edi

; 6409 : 	{
; 6410 : 		return( MMSYSERR_NOMEM );

  01ff1	b8 07 00 00 00	 mov	 eax, 7
  01ff6	5e		 pop	 esi

; 6457 : }

  01ff7	c3		 ret	 0
$L72310:

; 6411 : 	}
; 6412 : 	
; 6413 : 	phTTS->pKernelShareData->buffer_delay_pipe = buffer_delay_pipe;

  01ff8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 6414 : 	
; 6415 : 	/********************************************************************/
; 6416 : 	/*  Get the DECtalk error message.                                  */
; 6417 : 	/********************************************************************/
; 6418 : 	
; 6419 : 	phTTS->uiID_Buffer_Message =
; 6420 : 		RegisterWindowMessage("DECtalkBufferMessage");

  01ffb	68 00 00 00 00	 push	 OFFSET FLAT:$SG72311
  02000	89 82 e8 00 00
	00		 mov	 DWORD PTR [edx+232], eax
  02006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4

; 6421 : 	
; 6422 : 	if ( phTTS->uiID_Buffer_Message == 0 )

  0200c	85 c0		 test	 eax, eax
  0200e	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  02011	75 08		 jne	 SHORT $L72312
  02013	5f		 pop	 edi

; 6423 : 		return( MMSYSERR_ERROR );

  02014	b8 01 00 00 00	 mov	 eax, 1
  02019	5e		 pop	 esi

; 6457 : }

  0201a	c3		 ret	 0
$L72312:

; 6424 : 	
; 6425 : #endif
; 6426 : 	/********************************************************************/
; 6427 : 	/*  Create the memory buffer critical section.                      */
; 6428 : 	/********************************************************************/
; 6429 : 	
; 6430 : #ifdef WIN32
; 6431 : 	phTTS->pcsMemoryBuffer =
; 6432 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  0201b	6a 18		 push	 24			; 00000018H
  0201d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  02023	83 c4 04	 add	 esp, 4
  02026	89 86 b0 00 00
	00		 mov	 DWORD PTR [esi+176], eax

; 6433 : #endif
; 6434 : #if defined __osf__ || defined __linux__
; 6435 : 	phTTS->pcsMemoryBuffer = OP_CreateMutex();
; 6436 : #endif
; 6437 : 	
; 6438 : 	if ( phTTS->pcsMemoryBuffer == NULL )

  0202c	85 c0		 test	 eax, eax
  0202e	75 11		 jne	 SHORT $L72316

; 6439 : 	{
; 6440 : 		DeleteTextToSpeechObjects( phTTS );

  02030	56		 push	 esi
  02031	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  02036	83 c4 04	 add	 esp, 4

; 6441 : 		return( MMSYSERR_NOMEM );

  02039	b8 07 00 00 00	 mov	 eax, 7
  0203e	5f		 pop	 edi
  0203f	5e		 pop	 esi

; 6457 : }

  02040	c3		 ret	 0
$L72316:

; 6442 : 	}
; 6443 : 	
; 6444 : #ifdef WIN32
; 6445 : 	InitializeCriticalSection( phTTS->pcsMemoryBuffer );

  02041	50		 push	 eax
  02042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 6446 : #endif
; 6447 : 	
; 6448 : 	/********************************************************************/
; 6449 : 	/*  Initialize the handle objects for memory output.                */
; 6450 : 	/********************************************************************/
; 6451 : 	
; 6452 : 	phTTS->pTTS_Buffer = NULL;

  02048	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0

; 6453 : 	
; 6454 : 	phTTS->dwOutputState = STATE_OUTPUT_MEMORY;

  02052	c7 86 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+132], 1

; 6455 : 	
; 6456 : 	return( MMSYSERR_NOERROR );

  0205c	33 c0		 xor	 eax, eax
$L72290:
  0205e	5f		 pop	 edi
  0205f	5e		 pop	 esi

; 6457 : }

  02060	c3		 ret	 0
_TextToSpeechOpenInMemory ENDP
_phTTS$ = 8
_TextToSpeechCloseInMemory PROC NEAR

; 6493 : {

  02070	56		 push	 esi

; 6494 : 	/********************************************************************/
; 6495 : 	/*  Return error if invalid handle.                                 */
; 6496 : 	/********************************************************************/
; 6497 : 	
; 6498 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02071	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02075	6a 04		 push	 4
  02077	56		 push	 esi
  02078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0207e	85 c0		 test	 eax, eax
  02080	74 07		 je	 SHORT $L72321

; 6499 : 		return( MMSYSERR_INVALHANDLE );

  02082	b8 05 00 00 00	 mov	 eax, 5
  02087	5e		 pop	 esi

; 6580 : }

  02088	c3		 ret	 0
$L72321:

; 6500 : 	
; 6501 : 	/********************************************************************/
; 6502 : 	/*  If not in MEMORY output state then return an error.             */
; 6503 : 	/********************************************************************/
; 6504 : 	
; 6505 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  02089	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  0208f	b8 01 00 00 00	 mov	 eax, 1
  02094	3b c8		 cmp	 ecx, eax

; 6506 : 		return( MMSYSERR_ERROR );

  02096	0f 85 a4 00 00
	00		 jne	 $L72320

; 6507 : 	
; 6508 : #ifdef WIN32
; 6509 : 	// merged 28jul97 tek
; 6510 : 	// 16jun97 tek bats 385 sync will hang forever if we don't clear
; 6511 : 	// bInReset..
; 6512 : 
; 6513 : 	// MGS change this code.  if we are in reset, don't call Sync
; 6514 : //	phTTS->bInReset = FALSE;
; 6515 : 	if (!phTTS->bInReset)

  0209c	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  020a2	85 c0		 test	 eax, eax
  020a4	75 09		 jne	 SHORT $L72323

; 6516 : #endif
; 6517 : 	
; 6518 : 	/********************************************************************/
; 6519 : 	/*  Halt the system and flush all data.                             */
; 6520 : 	/********************************************************************/
; 6521 : 	
; 6522 : 	TextToSpeechSync( phTTS );

  020a6	56		 push	 esi
  020a7	e8 00 00 00 00	 call	 _TextToSpeechSync
  020ac	83 c4 04	 add	 esp, 4
$L72323:

; 6523 : 	
; 6524 : 	// MGS moved this code up so that the rescources would not be in use
; 6525 : 	// when freed below
; 6526 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  020af	8b 46 74	 mov	 eax, DWORD PTR [esi+116]

; 6527 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 6528 : 	else
; 6529 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 6530 : 
; 6531 : 	EnterCriticalSection(phTTS->pcsBufferPipe);	

  020b2	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  020b8	c1 e8 1d	 shr	 eax, 29			; 0000001dH
  020bb	83 e0 04	 and	 eax, 4
  020be	51		 push	 ecx
  020bf	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  020c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 6532 : 	
; 6533 : 	/********************************************************************/
; 6534 : 	/*  Delete the memory buffer critical section.                      */
; 6535 : 	/********************************************************************/
; 6536 : 	
; 6537 : 	if ( phTTS->pcsMemoryBuffer != NULL )

  020cb	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  020d1	85 c0		 test	 eax, eax
  020d3	74 17		 je	 SHORT $L72327

; 6538 : 	{
; 6539 : #ifdef WIN32
; 6540 : 		DeleteCriticalSection( phTTS->pcsMemoryBuffer );

  020d5	50		 push	 eax
  020d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 6541 : 		
; 6542 : 		free( phTTS->pcsMemoryBuffer );

  020dc	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  020e2	52		 push	 edx
  020e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  020e9	83 c4 04	 add	 esp, 4
$L72327:

; 6543 : #endif
; 6544 : #if defined __osf__ || defined __linux__
; 6545 : 		OP_DestroyMutex( phTTS->pcsMemoryBuffer );
; 6546 : #endif
; 6547 : 	}
; 6548 : 	
; 6549 : 	/********************************************************************/
; 6550 : 	/*  Delete the memory buffer pipe.                                  */
; 6551 : 	/********************************************************************/
; 6552 : 	
; 6553 : 	destroy_pipe( phTTS->pKernelShareData->buffer_pipe );

  020ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  020ef	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  020f5	51		 push	 ecx
  020f6	e8 00 00 00 00	 call	 _destroy_pipe

; 6554 : 	// tek 30aug96 null the pointer.
; 6555 : 	phTTS->pKernelShareData->buffer_pipe = NULL;

  020fb	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  020fe	c7 82 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+228], 0

; 6556 : 	
; 6557 : #ifdef WIN32
; 6558 : 	// merged 28jul97 tek
; 6559 : 	// 16jun97 tek bats 385 (buffer delay)
; 6560 : 	destroy_pipe( phTTS->pKernelShareData->buffer_delay_pipe );

  02108	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0210b	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  02111	51		 push	 ecx
  02112	e8 00 00 00 00	 call	 _destroy_pipe

; 6561 : 	phTTS->pKernelShareData->buffer_delay_pipe = NULL;

  02117	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0211a	83 c4 08	 add	 esp, 8
  0211d	c7 82 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+232], 0

; 6562 : #endif
; 6563 : 	
; 6564 : 	/********************************************************************/
; 6565 : 	/*  Set the system output state to audio if it is enabled.          */
; 6566 : 	/********************************************************************/
; 6567 : 	
; 6568 : 	LeaveCriticalSection(phTTS->pcsBufferPipe);

  02127	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  0212d	50		 push	 eax
  0212e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6569 : 
; 6570 : 	phTTS->pTTS_Buffer = NULL;

  02134	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0

; 6571 : 	
; 6572 : #ifdef MOVED_CODE_UP
; 6573 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 6574 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 6575 : 	else
; 6576 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 6577 : #endif
; 6578 : 	
; 6579 : 	return( MMSYSERR_NOERROR );

  0213e	33 c0		 xor	 eax, eax
$L72320:
  02140	5e		 pop	 esi

; 6580 : }

  02141	c3		 ret	 0
_TextToSpeechCloseInMemory ENDP
_TEXT	ENDS
EXTRN	_OP_LockMutex:NEAR
EXTRN	_OP_UnlockMutex:NEAR
_BSS	SEGMENT
	ALIGN	4

$SG72339 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pTTS_Buffer$ = 12
_pPipeArray$ = 8
_TextToSpeechAddBuffer PROC NEAR

; 6617 : {

  02150	56		 push	 esi

; 6618 : 	LPTTS_BUFFER_T pPipeArray[1];
; 6619 : 	unsigned int uiI;
; 6620 : 	char szTemp[256]="";
; 6621 : 	
; 6622 : #ifdef API_DEBUG
; 6623 : 	OutputDebugString("TTSAddBuffer().\n");
; 6624 : 	
; 6625 : 	if (pTTS_Buffer == NULL)
; 6626 : 	{
; 6627 : 		OutputDebugString("  ..adding null buffer.\n");
; 6628 : 	}
; 6629 : 	else
; 6630 : 	{
; 6631 : 		OutputDebugString("  ..adding user buffer.\n");
; 6632 : 	}
; 6633 : #endif //API_DEBUG
; 6634 : 	
; 6635 : 	/********************************************************************/
; 6636 : 	/*  Return error if invalid handle.                                 */
; 6637 : 	/********************************************************************/
; 6638 : 	
; 6639 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02151	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02155	6a 04		 push	 4
  02157	56		 push	 esi
  02158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0215e	85 c0		 test	 eax, eax
  02160	74 07		 je	 SHORT $L72340

; 6640 : 		return( MMSYSERR_INVALHANDLE );

  02162	b8 05 00 00 00	 mov	 eax, 5
  02167	5e		 pop	 esi

; 6686 : }

  02168	c3		 ret	 0
$L72340:

; 6641 : 	
; 6642 : 	/********************************************************************/
; 6643 : 	/*  If not in MEMORY output state then return an error.             */
; 6644 : 	/********************************************************************/
; 6645 : 	
; 6646 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  02169	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  02170	74 07		 je	 SHORT $L72341

; 6647 : 		return( MMSYSERR_ERROR );

  02172	b8 01 00 00 00	 mov	 eax, 1
  02177	5e		 pop	 esi

; 6686 : }

  02178	c3		 ret	 0
$L72341:

; 6648 : 	
; 6649 : 	/********************************************************************/
; 6650 : 	/*  Send the wave header to the VTM thread.                         */
; 6651 : 	/********************************************************************/
; 6652 : 	
; 6653 : 	pPipeArray[0] = pTTS_Buffer;
; 6654 : 	
; 6655 : 	// tek 03sep96 add some debugging info here..
; 6656 : #ifdef WIN32
; 6657 : 	//LockPipe( phTTS->pKernelShareData->buffer_pipe );
; 6658 : 	OP_LockMutex( phTTS->pcsBufferPipe);

  02179	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  0217f	8b 44 24 0c	 mov	 eax, DWORD PTR _pTTS_Buffer$[esp]
  02183	51		 push	 ecx
  02184	89 44 24 0c	 mov	 DWORD PTR _pPipeArray$[esp+4], eax
  02188	e8 00 00 00 00	 call	 _OP_LockMutex

; 6659 : #endif
; 6660 : #if defined __osf__ || defined __linux__
; 6661 : 	OP_LockMutex( phTTS->pcsBufferPipe);
; 6662 : #endif
; 6663 : 	// check the state again as this could have been waiting on the mutex
; 6664 : 	// and it was locked by TextToSpeechCloseInMemory
; 6665 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  0218d	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  02193	83 c4 04	 add	 esp, 4
  02196	83 f8 01	 cmp	 eax, 1
  02199	74 16		 je	 SHORT $L72342

; 6666 : 	{
; 6667 : 		OP_UnlockMutex( phTTS->pcsBufferPipe );

  0219b	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  021a1	52		 push	 edx
  021a2	e8 00 00 00 00	 call	 _OP_UnlockMutex
  021a7	83 c4 04	 add	 esp, 4

; 6668 : 		return( MMSYSERR_ERROR );

  021aa	b8 01 00 00 00	 mov	 eax, 1
  021af	5e		 pop	 esi

; 6686 : }

  021b0	c3		 ret	 0
$L72342:

; 6669 : 	}
; 6670 : 
; 6671 : 	write_pipe( phTTS->pKernelShareData->buffer_pipe, pPipeArray, 1 );

  021b1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  021b4	8d 44 24 08	 lea	 eax, DWORD PTR _pPipeArray$[esp]
  021b8	6a 01		 push	 1
  021ba	50		 push	 eax
  021bb	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  021c1	52		 push	 edx
  021c2	e8 00 00 00 00	 call	 _write_pipe

; 6672 : 	uiI = pipe_count( phTTS->pKernelShareData->buffer_pipe );

  021c7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  021ca	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  021d0	51		 push	 ecx
  021d1	e8 00 00 00 00	 call	 _pipe_count

; 6673 : #ifdef WIN32
; 6674 : #ifdef API_DEBUG
; 6675 : 	sprintf(szTemp,"Added buffer %08lx, count now %d\n",
; 6676 : 		pPipeArray[0], uiI);
; 6677 : 	OutputDebugString(szTemp);
; 6678 : #endif //API_DEBUG
; 6679 : 	OP_UnlockMutex( phTTS->pcsBufferPipe );

  021d6	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  021dc	52		 push	 edx
  021dd	e8 00 00 00 00	 call	 _OP_UnlockMutex
  021e2	83 c4 14	 add	 esp, 20			; 00000014H

; 6680 : //	UnlockPipe( phTTS->pKernelShareData->buffer_pipe );
; 6681 : #endif
; 6682 : #if defined __osf__ || defined __linux__
; 6683 : 	OP_UnlockMutex( phTTS->pcsBufferPipe );
; 6684 : #endif
; 6685 : 	return( MMSYSERR_NOERROR );

  021e5	33 c0		 xor	 eax, eax
  021e7	5e		 pop	 esi

; 6686 : }

  021e8	c3		 ret	 0
_TextToSpeechAddBuffer ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReturnBuffer
_TEXT	SEGMENT
_phTTS$ = 8
_ppTTS_Buffer$ = 12
_TextToSpeechReturnBuffer PROC NEAR

; 6725 : {

  021f0	56		 push	 esi

; 6726 : 	/********************************************************************/
; 6727 : 	/*  Return error if invalid handle.                                 */
; 6728 : 	/********************************************************************/
; 6729 : #ifdef API_DEBUG
; 6730 : 	OutputDebugString("TTSReturnBuffer() ?? \n");
; 6731 : #endif //API_DEBUG
; 6732 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  021f1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  021f5	6a 04		 push	 4
  021f7	56		 push	 esi
  021f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  021fe	85 c0		 test	 eax, eax
  02200	74 07		 je	 SHORT $L72348

; 6733 : 		return( MMSYSERR_INVALHANDLE );

  02202	b8 05 00 00 00	 mov	 eax, 5
  02207	5e		 pop	 esi

; 6759 : }

  02208	c3		 ret	 0
$L72348:

; 6734 : 	
; 6735 : 	/********************************************************************/
; 6736 : 	/*  If not in MEMORY output state then return an error.             */
; 6737 : 	/********************************************************************/
; 6738 : 	
; 6739 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  02209	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  0220f	b8 01 00 00 00	 mov	 eax, 1
  02214	3b c8		 cmp	 ecx, eax

; 6740 : 		return( MMSYSERR_ERROR );

  02216	75 32		 jne	 SHORT $L72347

; 6741 : 	
; 6742 : 	/********************************************************************/
; 6743 : 	/*  Return the last buffer to the application.                      */
; 6744 : 	/*  Block if the buffer is busy.                                    */
; 6745 : 	/********************************************************************/
; 6746 : 
; 6747 : 	EnterCriticalSection( phTTS->pcsMemoryBuffer );

  02218	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0221e	50		 push	 eax
  0221f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 6748 : 
; 6749 : 	*ppTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  02225	8b 54 24 0c	 mov	 edx, DWORD PTR _ppTTS_Buffer$[esp]
  02229	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  0222f	89 0a		 mov	 DWORD PTR [edx], ecx

; 6750 : 	phTTS->pTTS_Buffer = NULL;
; 6751 : 	
; 6752 : 	/********************************************************************/
; 6753 : 	/*  Release the buffer.                                             */
; 6754 : 	/********************************************************************/
; 6755 : 
; 6756 : 	LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02231	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  02237	50		 push	 eax
  02238	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0
  02242	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6757 : 
; 6758 : 	return( MMSYSERR_NOERROR );

  02248	33 c0		 xor	 eax, eax
$L72347:
  0224a	5e		 pop	 esi

; 6759 : }

  0224b	c3		 ret	 0
_TextToSpeechReturnBuffer ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenLogFile
_DATA	SEGMENT
	ORG $+3
$SG72367 DB	'w', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pszFileName$ = 12
_dwFlags$ = 16
_TextToSpeechOpenLogFile PROC NEAR

; 6821 : {

  02250	53		 push	 ebx
  02251	56		 push	 esi

; 6822 : 	MMRESULT mmStatus;
; 6823 : 	
; 6824 : 	/********************************************************************/
; 6825 : 	/*  Return error if invalid handle.                                 */
; 6826 : 	/********************************************************************/
; 6827 : 	
; 6828 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02252	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  02256	57		 push	 edi
  02257	6a 04		 push	 4
  02259	56		 push	 esi
  0225a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  02260	85 c0		 test	 eax, eax
  02262	74 09		 je	 SHORT $L72360
  02264	5f		 pop	 edi
  02265	5e		 pop	 esi

; 6829 : 		return( MMSYSERR_INVALHANDLE );

  02266	b8 05 00 00 00	 mov	 eax, 5
  0226b	5b		 pop	 ebx

; 6913 : }

  0226c	c3		 ret	 0
$L72360:

; 6830 : 	
; 6831 : 	/********************************************************************/
; 6832 : 	/*  If a file is already open, then don't try to open another one.  */
; 6833 : 	/********************************************************************/
; 6834 : 	
; 6835 : 
; 6836 : 	EnterCriticalSection( phTTS->pcsLogFile );

  0226d	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  02273	50		 push	 eax
  02274	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 6837 : 
; 6838 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE )

  0227a	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  02280	83 f8 03	 cmp	 eax, 3
  02283	75 16		 jne	 SHORT $L72361

; 6839 : 	{
; 6840 : 
; 6841 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  02285	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  0228b	51		 push	 ecx
  0228c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02292	5f		 pop	 edi
  02293	5e		 pop	 esi

; 6842 : 
; 6843 : 		return( MMSYSERR_ALLOCATED );

  02294	b8 04 00 00 00	 mov	 eax, 4
  02299	5b		 pop	 ebx

; 6913 : }

  0229a	c3		 ret	 0
$L72361:

; 6844 : 	}
; 6845 : 	
; 6846 : 	/********************************************************************/
; 6847 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 6848 : 	/*  an error.                                                       */
; 6849 : 	/********************************************************************/
; 6850 : 	
; 6851 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 6852 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  0229b	85 c0		 test	 eax, eax
  0229d	74 1b		 je	 SHORT $L72362
  0229f	83 f8 04	 cmp	 eax, 4
  022a2	74 16		 je	 SHORT $L72362

; 6853 : 	{
; 6854 : 
; 6855 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  022a4	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  022aa	52		 push	 edx
  022ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  022b1	5f		 pop	 edi
  022b2	5e		 pop	 esi

; 6856 : 
; 6857 : 		return( MMSYSERR_ERROR );

  022b3	b8 01 00 00 00	 mov	 eax, 1
  022b8	5b		 pop	 ebx

; 6913 : }

  022b9	c3		 ret	 0
$L72362:

; 6858 : 	}
; 6859 : 	
; 6860 : 	/********************************************************************/
; 6861 : 	/*  Make sure the arguments are valid.                              */
; 6862 : 	/********************************************************************/
; 6863 : 	
; 6864 : 	if ( dwFlags & ~( LOG_TEXT | LOG_PHONEMES | LOG_SYLLABLES ))

  022ba	8b 5c 24 18	 mov	 ebx, DWORD PTR _dwFlags$[esp+8]
  022be	f7 c3 ec ff ff
	ff		 test	 ebx, -20		; ffffffecH
  022c4	74 16		 je	 SHORT $L72363

; 6865 : 	{
; 6866 : 
; 6867 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  022c6	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  022cc	50		 push	 eax
  022cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  022d3	5f		 pop	 edi
  022d4	5e		 pop	 esi

; 6868 : 
; 6869 : 		return( MMSYSERR_INVALPARAM );

  022d5	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  022da	5b		 pop	 ebx

; 6913 : }

  022db	c3		 ret	 0
$L72363:

; 6870 : 	}
; 6871 : 	
; 6872 : 	/********************************************************************/
; 6873 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 6874 : 	/*  function have completed.                                        */
; 6875 : 	/********************************************************************/
; 6876 : 	
; 6877 : 	mmStatus = TextToSpeechSync( phTTS );

  022dc	56		 push	 esi
  022dd	e8 00 00 00 00	 call	 _TextToSpeechSync
  022e2	8b f8		 mov	 edi, eax
  022e4	83 c4 04	 add	 esp, 4

; 6878 : 	
; 6879 : 	if ( mmStatus )

  022e7	85 ff		 test	 edi, edi
  022e9	74 13		 je	 SHORT $L72364

; 6880 : 	{
; 6881 : 
; 6882 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  022eb	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  022f1	51		 push	 ecx
  022f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6883 : 
; 6884 : 		return( mmStatus );

  022f8	8b c7		 mov	 eax, edi
  022fa	5f		 pop	 edi
  022fb	5e		 pop	 esi
  022fc	5b		 pop	 ebx

; 6913 : }

  022fd	c3		 ret	 0
$L72364:

; 6885 : 	}
; 6886 : 	
; 6887 : 	/********************************************************************/
; 6888 : 	/*  Open the log file.                                              */
; 6889 : 	/********************************************************************/
; 6890 : 	
; 6891 : #ifdef UNDER_CE
; 6892 : 	if (( phTTS->pLogFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)) == NULL )
; 6893 : #else
; 6894 : 	if (( phTTS->pLogFile = fopen( pszFileName, "w" )) == NULL )

  022fe	8b 54 24 14	 mov	 edx, DWORD PTR _pszFileName$[esp+8]
  02302	68 00 00 00 00	 push	 OFFSET FLAT:$SG72367
  02307	52		 push	 edx
  02308	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0230e	83 c4 08	 add	 esp, 8
  02311	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  02317	85 c0		 test	 eax, eax
  02319	75 16		 jne	 SHORT $L72366

; 6895 : #endif
; 6896 : 	{
; 6897 : 
; 6898 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  0231b	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  02321	50		 push	 eax
  02322	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02328	5f		 pop	 edi
  02329	5e		 pop	 esi

; 6899 : 
; 6900 : 		return( MMSYSERR_ERROR );

  0232a	b8 01 00 00 00	 mov	 eax, 1
  0232f	5b		 pop	 ebx

; 6913 : }

  02330	c3		 ret	 0
$L72366:

; 6901 : 	}
; 6902 : 	
; 6903 : 	/********************************************************************/
; 6904 : 	/*  Set the log file control variables.                             */
; 6905 : 	/********************************************************************/
; 6906 : 	
; 6907 : 	phTTS->pKernelShareData->logflag = dwFlags;

  02331	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02334	89 99 04 02 00
	00		 mov	 DWORD PTR [ecx+516], ebx

; 6908 : 	phTTS->dwOutputState = STATE_OUTPUT_LOG_FILE;
; 6909 : 	
; 6910 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  0233a	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  02340	52		 push	 edx
  02341	c7 86 84 00 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+132], 3
  0234b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02351	5f		 pop	 edi
  02352	5e		 pop	 esi

; 6911 : 
; 6912 : 	return( MMSYSERR_NOERROR );

  02353	33 c0		 xor	 eax, eax
  02355	5b		 pop	 ebx

; 6913 : }

  02356	c3		 ret	 0
_TextToSpeechOpenLogFile ENDP
_phTTS$ = 8
_TextToSpeechCloseLogFile PROC NEAR

; 6949 : {

  02360	56		 push	 esi

; 6950 : 	MMRESULT mmStatus;
; 6951 : 	
; 6952 : 	/********************************************************************/
; 6953 : 	/*  Return error if invalid handle.                                 */
; 6954 : 	/********************************************************************/
; 6955 : 	
; 6956 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02361	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02365	57		 push	 edi
  02366	6a 04		 push	 4
  02368	56		 push	 esi
  02369	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0236f	85 c0		 test	 eax, eax
  02371	74 08		 je	 SHORT $L72372
  02373	5f		 pop	 edi

; 6957 : 		return( MMSYSERR_INVALHANDLE );

  02374	b8 05 00 00 00	 mov	 eax, 5
  02379	5e		 pop	 esi

; 7036 : }

  0237a	c3		 ret	 0
$L72372:

; 6958 : 
; 6959 : 	/********************************************************************/
; 6960 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 6961 : 	/*  function have completed.                                        */
; 6962 : 	/********************************************************************/
; 6963 : 	// tek 29jan99 bats 849: this must be done before the logflag is cleared.
; 6964 : 	mmStatus = TextToSpeechSync( phTTS );

  0237b	56		 push	 esi
  0237c	e8 00 00 00 00	 call	 _TextToSpeechSync
  02381	8b f8		 mov	 edi, eax

; 6965 : 	
; 6966 : 	if ( mmStatus )
; 6967 : 		mmStatus = MMSYSERR_ERROR;
; 6968 : 	else
; 6969 : 		mmStatus = MMSYSERR_NOERROR;
; 6970 : 		
; 6971 : #ifdef WIN32
; 6972 : 	/********************************************************************/
; 6973 : 	/*  Disable writing to the log file.                                */
; 6974 : 	/********************************************************************/
; 6975 : 	
; 6976 : 	phTTS->pKernelShareData->logflag = 0;       /* BATS#120 FIX TK & JL */

  02383	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02386	83 c4 04	 add	 esp, 4
  02389	f7 df		 neg	 edi
  0238b	c7 80 04 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+516], 0

; 6977 : #endif
; 6978 : 	
; 6979 : 	/********************************************************************/
; 6980 : 	/*  If a file is not open, then exit.                               */
; 6981 : 	/********************************************************************/
; 6982 : 	
; 6983 : 
; 6984 : 	EnterCriticalSection( phTTS->pcsLogFile );

  02395	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  0239b	1b ff		 sbb	 edi, edi
  0239d	51		 push	 ecx
  0239e	f7 df		 neg	 edi
  023a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 6985 : 
; 6986 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_LOG_FILE )

  023a6	83 be 84 00 00
	00 03		 cmp	 DWORD PTR [esi+132], 3
  023ad	74 15		 je	 SHORT $L72375

; 6987 : 	{
; 6988 : 
; 6989 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  023af	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  023b5	52		 push	 edx
  023b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  023bc	5f		 pop	 edi

; 6990 : 
; 6991 : 		return( MMSYSERR_ERROR );

  023bd	b8 01 00 00 00	 mov	 eax, 1
  023c2	5e		 pop	 esi

; 7036 : }

  023c3	c3		 ret	 0
$L72375:

; 6992 : 	}
; 6993 : 	
; 6994 : 
; 6995 : #ifdef WIN32
; 6996 : 	/********************************************************************/
; 6997 : 	/*  Make sure data has been written to the file.                    */
; 6998 : 	/********************************************************************/
; 6999 : 	
; 7000 : 	_flushall;
; 7001 : #endif
; 7002 : #if defined __osf__ || defined __linux__
; 7003 : 	/********************************************************************/
; 7004 : 	/*  Disable writing to the log file.                                */
; 7005 : 	/********************************************************************/
; 7006 : 	
; 7007 : 	phTTS->pKernelShareData->logflag = 0;
; 7008 : #endif
; 7009 : 	
; 7010 : 	/********************************************************************/
; 7011 : 	/*  Set the system output state to audio if it is enabled.          */
; 7012 : 	/********************************************************************/
; 7013 : 	
; 7014 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  023c4	f7 46 74 00 00
	00 80		 test	 DWORD PTR [esi+116], -2147483648 ; 80000000H
  023cb	75 17		 jne	 SHORT $L72376

; 7015 : 	{
; 7016 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 7017 : 		TextToSpeechReset(phTTS,FALSE); // tek 28jan99 bats 849: this resets the counters..

  023cd	6a 00		 push	 0
  023cf	56		 push	 esi
  023d0	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  023da	e8 00 00 00 00	 call	 _TextToSpeechReset
  023df	83 c4 08	 add	 esp, 8

; 7018 : 	}
; 7019 : 	else

  023e2	eb 0a		 jmp	 SHORT $L72377
$L72376:

; 7020 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;

  023e4	c7 86 84 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+132], 4
$L72377:

; 7021 : 	
; 7022 : 	/********************************************************************/
; 7023 : 	/*  Close the log file.                                             */
; 7024 : 	/********************************************************************/
; 7025 : 	
; 7026 : #ifdef UNDER_CE
; 7027 : 	if ( CloseHandle( phTTS->pLogFile)==0)
; 7028 : #else
; 7029 : 	if ( fclose( phTTS->pLogFile ))

  023ee	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  023f4	50		 push	 eax
  023f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  023fb	83 c4 04	 add	 esp, 4
  023fe	85 c0		 test	 eax, eax
  02400	74 05		 je	 SHORT $L72378

; 7030 : #endif
; 7031 : 		mmStatus = MMSYSERR_ERROR;

  02402	bf 01 00 00 00	 mov	 edi, 1
$L72378:

; 7032 : 	
; 7033 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  02407	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  0240d	51		 push	 ecx
  0240e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7034 : 	
; 7035 : 	return( mmStatus );

  02414	8b c7		 mov	 eax, edi
  02416	5f		 pop	 edi
  02417	5e		 pop	 esi

; 7036 : }

  02418	c3		 ret	 0
_TextToSpeechCloseLogFile ENDP
_TEXT	ENDS
PUBLIC	_QueueToMemory
_TEXT	SEGMENT
_phTTS$ = 8
_pSamples$ = 12
_dwNumberOfSamples$ = 16
_QueueToMemory PROC NEAR

; 7077 : 	unsigned int i;                        /*MVP : Not a static */
; 7078 : 	DWORD dwBytesLeft;             /*MVP : Not a static */
; 7079 : 	DWORD dwWordsLeft;             /*MVP : Not a static */
; 7080 : 	unsigned char * pBuffer;       /*MVP : Not a static */
; 7081 : 	short * pShort;                /*tek/bh 29jul96 */
; 7082 : 	LPTTS_BUFFER_T pTTS_Buffer;/*MVP : Not a static */
; 7083 : 	
; 7084 : 	/********************************************************************/
; 7085 : 	/*  Loop until all samples have been moved into buffers.            */
; 7086 : 	/********************************************************************/
; 7087 : 	
; 7088 : 	while( dwNumberOfSamples )

  02420	8b 44 24 0c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp-4]
  02424	53		 push	 ebx
  02425	55		 push	 ebp
  02426	56		 push	 esi
  02427	85 c0		 test	 eax, eax
  02429	57		 push	 edi
  0242a	0f 84 4a 02 00
	00		 je	 $L72394

; 7110 : 		}
; 7111 : 		
; 7112 : 		/******************************************************************/
; 7113 : 		/*  Move as many samples as possible into the buffer.             */
; 7114 : 		/*  Get the current buffer pointer and the number of bytes left   */
; 7115 : 		/*  in the buffer.                                                */
; 7116 : 		/******************************************************************/
; 7117 : 		
; 7118 : 		pTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  02430	8b 7c 24 18	 mov	 edi, DWORD PTR _pSamples$[esp+12]
$L72393:

; 7089 : 	{
; 7090 : 		/******************************************************************/
; 7091 : 		/*  Block if the TextToSpeechReturnBuffer() function is returning */
; 7092 : 		/*  the current buffer.                                           */
; 7093 : 		/******************************************************************/
; 7094 : 
; 7095 : 		EnterCriticalSection( phTTS->pcsMemoryBuffer );

  02434	8b 74 24 14	 mov	 esi, DWORD PTR _phTTS$[esp+12]
  02438	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0243e	50		 push	 eax
  0243f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7096 : 		
; 7097 : 		/******************************************************************/
; 7098 : 		/*  If a new Text-To-Speech buffer is needed then get one from    */
; 7099 : 		/*  the application. Block if one is not available.               */
; 7100 : 		/******************************************************************/
; 7101 : 		
; 7102 : 		if ( (phTTS->pTTS_Buffer == NULL )
; 7103 : 			&& !(phTTS->bMemoryReset) 
; 7104 : 			&& !(phTTS->pKernelShareData->halting) )

  02445	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0244b	85 c0		 test	 eax, eax
  0244d	75 26		 jne	 SHORT $L72396
  0244f	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  02455	85 c0		 test	 eax, eax
  02457	75 1c		 jne	 SHORT $L72396
  02459	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0245c	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  02462	85 c0		 test	 eax, eax
  02464	75 0f		 jne	 SHORT $L72396

; 7105 : 		{
; 7106 : #ifdef API_DEBUG
; 7107 : 			OutputDebugString("Q2M getting buffer.\n");
; 7108 : #endif //API_DEBUG
; 7109 : 			phTTS->pTTS_Buffer = GetBuffer( phTTS );

  02466	56		 push	 esi
  02467	e8 00 00 00 00	 call	 _GetBuffer
  0246c	83 c4 04	 add	 esp, 4
  0246f	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
$L72396:

; 7110 : 		}
; 7111 : 		
; 7112 : 		/******************************************************************/
; 7113 : 		/*  Move as many samples as possible into the buffer.             */
; 7114 : 		/*  Get the current buffer pointer and the number of bytes left   */
; 7115 : 		/*  in the buffer.                                                */
; 7116 : 		/******************************************************************/
; 7117 : 		
; 7118 : 		pTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  02475	8b ae a0 00 00
	00		 mov	 ebp, DWORD PTR [esi+160]

; 7119 : 		
; 7120 : 		/******************************************************************/
; 7121 : 		/*  NULL buffers sent by reset to fix hang. WIH 3/27/95           */
; 7122 : 		/******************************************************************/
; 7123 : 		
; 7124 : 		/* tek 19aug96 Also, we should bail out here if we're doing a     */
; 7125 : 		/* reset.                                                         */
; 7126 : 		if ( (pTTS_Buffer == NULL))

  0247b	85 ed		 test	 ebp, ebp
  0247d	0f 84 b4 01 00
	00		 je	 $L73304

; 7130 : 	
; 7131 : #ifdef API_DEBUG
; 7132 : 			OutputDebugString("Q2M null bailout.\n");
; 7133 : #endif //API_DEBUG
; 7134 : 			return;
; 7135 : 		}
; 7136 : 		
; 7137 : 		if (phTTS->bMemoryReset)

  02483	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  02489	85 c0		 test	 eax, eax
  0248b	0f 85 b8 01 00
	00		 jne	 $L73305

; 7141 : 
; 7142 : 			SendBuffer(phTTS); //tek 03sep96
; 7143 : #ifdef API_DEBUG
; 7144 : 			OutputDebugString("Q2M reset bailout.\n");
; 7145 : #endif //API_DEBUG
; 7146 : 			return;
; 7147 : 		}       
; 7148 : 		
; 7149 : 		if  (phTTS->pKernelShareData->halting)

  02491	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02494	8b 82 74 01 00
	00		 mov	 eax, DWORD PTR [edx+372]
  0249a	85 c0		 test	 eax, eax
  0249c	0f 85 c2 01 00
	00		 jne	 $L73306

; 7155 : #ifdef API_DEBUG
; 7156 : 			OutputDebugString("Q2M halt bailout.\n");
; 7157 : #endif //API_DEBUG
; 7158 : 			return;
; 7159 : 		}
; 7160 : 		
; 7161 : 		pBuffer = (unsigned char *) pTTS_Buffer->lpData + pTTS_Buffer->dwBufferLength;

  024a2	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  024a5	8b 75 00	 mov	 esi, DWORD PTR [ebp]

; 7162 : 		
; 7163 : 		dwBytesLeft =
; 7164 : 			pTTS_Buffer->dwMaximumBufferLength - pTTS_Buffer->dwBufferLength;

  024a8	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]
  024ab	03 f0		 add	 esi, eax
  024ad	2b d8		 sub	 ebx, eax

; 7165 : 		
; 7166 : 		/******************************************************************/
; 7167 : 		/*  Put the samples into the buffer in the proper format.         */
; 7168 : 		/******************************************************************/
; 7169 : 		
; 7170 : 		switch( phTTS->dwFormat )
; 7171 : 		{

  024af	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  024b3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [eax+128]
  024b9	48		 dec	 eax
  024ba	0f 84 cd 00 00
	00		 je	 $L72417
  024c0	83 e8 03	 sub	 eax, 3
  024c3	74 74		 je	 SHORT $L72407
  024c5	83 e8 03	 sub	 eax, 3
  024c8	0f 85 12 01 00
	00		 jne	 $L72423

; 7221 : 			}
; 7222 : 			
; 7223 : 			break;
; 7224 : 			
; 7225 : 			/******************************************************************/
; 7226 : 			/*  Output 8 bit mu-law samples.                                  */
; 7227 : 			/******************************************************************/
; 7228 : 			
; 7229 : 		case WAVE_FORMAT_08M08:
; 7230 : 			
; 7231 : 			if ( dwNumberOfSamples >= dwBytesLeft )

  024ce	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
  024d2	3b c3		 cmp	 eax, ebx
  024d4	72 3c		 jb	 SHORT $L72429

; 7232 : 			{
; 7233 : 				for ( i = 0; i < dwBytesLeft; i++ )

  024d6	85 db		 test	 ebx, ebx
  024d8	76 25		 jbe	 SHORT $L72432
  024da	89 5c 24 18	 mov	 DWORD PTR 12+[esp+12], ebx
$L72430:

; 7234 : 					*pBuffer++ = LinearToMuLaw( *pSamples++ );

  024de	66 8b 07	 mov	 ax, WORD PTR [edi]
  024e1	83 c7 02	 add	 edi, 2
  024e4	50		 push	 eax
  024e5	e8 00 00 00 00	 call	 _LinearToMuLaw
  024ea	88 06		 mov	 BYTE PTR [esi], al
  024ec	8b 44 24 1c	 mov	 eax, DWORD PTR 12+[esp+16]
  024f0	83 c4 04	 add	 esp, 4
  024f3	46		 inc	 esi
  024f4	48		 dec	 eax
  024f5	89 44 24 18	 mov	 DWORD PTR 12+[esp+12], eax
  024f9	75 e3		 jne	 SHORT $L72430

; 7232 : 			{
; 7233 : 				for ( i = 0; i < dwBytesLeft; i++ )

  024fb	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
$L72432:

; 7235 : 				
; 7236 : 				pTTS_Buffer->dwBufferLength += dwBytesLeft;

  024ff	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  02502	03 d3		 add	 edx, ebx

; 7237 : 				dwNumberOfSamples = dwNumberOfSamples - dwBytesLeft;

  02504	2b c3		 sub	 eax, ebx
  02506	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  02509	89 44 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], eax

; 7238 : 			}
; 7239 : 			else

  0250d	e9 ce 00 00 00	 jmp	 $L72423
$L72429:

; 7240 : 			{
; 7241 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  02512	85 c0		 test	 eax, eax
  02514	76 1b		 jbe	 SHORT $L72436
  02516	8b d8		 mov	 ebx, eax
$L72434:

; 7242 : 					*pBuffer++ = LinearToMuLaw( *pSamples++ );

  02518	66 8b 07	 mov	 ax, WORD PTR [edi]
  0251b	83 c7 02	 add	 edi, 2
  0251e	50		 push	 eax
  0251f	e8 00 00 00 00	 call	 _LinearToMuLaw
  02524	83 c4 04	 add	 esp, 4
  02527	88 06		 mov	 BYTE PTR [esi], al
  02529	46		 inc	 esi
  0252a	4b		 dec	 ebx
  0252b	75 eb		 jne	 SHORT $L72434

; 7240 : 			{
; 7241 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  0252d	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
$L72436:

; 7243 : 				
; 7244 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples;

  02531	01 45 18	 add	 DWORD PTR [ebp+24], eax

; 7245 : 				dwNumberOfSamples = 0;
; 7246 : 			}
; 7247 : 			
; 7248 : 			break;

  02534	e9 9f 00 00 00	 jmp	 $L73314
$L72407:

; 7172 : 			/******************************************************************/
; 7173 : 			/*  Output 16 bit samples.                                        */
; 7174 : 			/******************************************************************/
; 7175 : 			
; 7176 : 		case WAVE_FORMAT_1M16:
; 7177 : 			
; 7178 : 			dwWordsLeft = dwBytesLeft >> 1;
; 7179 : 			pShort = (short *)pBuffer;      
; 7180 : 			
; 7181 : 			if ( dwNumberOfSamples >= dwWordsLeft )

  02539	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwNumberOfSamples$[esp+12]
  0253d	d1 eb		 shr	 ebx, 1
  0253f	3b cb		 cmp	 ecx, ebx
  02541	72 28		 jb	 SHORT $L72409

; 7182 : 			{
; 7183 : 				for ( i = 0; i < dwWordsLeft; i++ )

  02543	85 db		 test	 ebx, ebx
  02545	76 11		 jbe	 SHORT $L72412
  02547	8b c3		 mov	 eax, ebx
$L72410:

; 7184 : 					*pShort++ = *pSamples++;

  02549	66 8b 17	 mov	 dx, WORD PTR [edi]
  0254c	83 c7 02	 add	 edi, 2
  0254f	66 89 16	 mov	 WORD PTR [esi], dx
  02552	83 c6 02	 add	 esi, 2
  02555	48		 dec	 eax
  02556	75 f1		 jne	 SHORT $L72410
$L72412:

; 7185 : 				
; 7186 : 				pTTS_Buffer->dwBufferLength += dwWordsLeft << 1;

  02558	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  0255b	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0255e	03 d0		 add	 edx, eax

; 7187 : 				dwNumberOfSamples = dwNumberOfSamples - dwWordsLeft;

  02560	2b cb		 sub	 ecx, ebx
  02562	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  02565	89 4c 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], ecx

; 7188 : 			}
; 7189 : 			else

  02569	eb 75		 jmp	 SHORT $L72423
$L72409:

; 7190 : 			{
; 7191 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  0256b	85 c9		 test	 ecx, ecx
  0256d	76 11		 jbe	 SHORT $L72416
  0256f	8b c1		 mov	 eax, ecx
$L72414:

; 7192 : 					*pShort++ = *pSamples++;

  02571	66 8b 17	 mov	 dx, WORD PTR [edi]
  02574	83 c7 02	 add	 edi, 2
  02577	66 89 16	 mov	 WORD PTR [esi], dx
  0257a	83 c6 02	 add	 esi, 2
  0257d	48		 dec	 eax
  0257e	75 f1		 jne	 SHORT $L72414
$L72416:

; 7193 : 				
; 7194 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples << 1;

  02580	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  02583	8b 4d 18	 mov	 ecx, DWORD PTR [ebp+24]
  02586	03 c8		 add	 ecx, eax
  02588	89 4d 18	 mov	 DWORD PTR [ebp+24], ecx

; 7195 : 				dwNumberOfSamples = 0;
; 7196 : 			}
; 7197 : 			
; 7198 : 			break;

  0258b	eb 4b		 jmp	 SHORT $L73314
$L72417:

; 7199 : 			
; 7200 : 			/******************************************************************/
; 7201 : 			/*  Output 8 bit samples.                                         */
; 7202 : 			/******************************************************************/
; 7203 : 			
; 7204 : 		case WAVE_FORMAT_1M08:
; 7205 : 			
; 7206 : 			if ( dwNumberOfSamples >= dwBytesLeft )

  0258d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwNumberOfSamples$[esp+12]
  02591	3b cb		 cmp	 ecx, ebx
  02593	72 28		 jb	 SHORT $L72418

; 7207 : 			{
; 7208 : 				for ( i = 0; i < dwBytesLeft; i++ )

  02595	85 db		 test	 ebx, ebx
  02597	76 14		 jbe	 SHORT $L72421
  02599	8b c3		 mov	 eax, ebx
$L72419:

; 7209 : 					*pBuffer++ = ((unsigned char)((*pSamples++) >> 8)) ^ 0x80;

  0259b	66 8b 17	 mov	 dx, WORD PTR [edi]
  0259e	83 c7 02	 add	 edi, 2
  025a1	c1 fa 08	 sar	 edx, 8
  025a4	80 f2 80	 xor	 dl, 128			; 00000080H
  025a7	88 16		 mov	 BYTE PTR [esi], dl
  025a9	46		 inc	 esi
  025aa	48		 dec	 eax
  025ab	75 ee		 jne	 SHORT $L72419
$L72421:

; 7210 : 				
; 7211 : 				pTTS_Buffer->dwBufferLength += dwBytesLeft;

  025ad	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  025b0	03 d3		 add	 edx, ebx

; 7212 : 				dwNumberOfSamples = dwNumberOfSamples - dwBytesLeft;

  025b2	2b cb		 sub	 ecx, ebx
  025b4	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  025b7	89 4c 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], ecx

; 7213 : 			}
; 7214 : 			else

  025bb	eb 23		 jmp	 SHORT $L72423
$L72418:

; 7215 : 			{
; 7216 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  025bd	85 c9		 test	 ecx, ecx
  025bf	76 14		 jbe	 SHORT $L72426
  025c1	8b c1		 mov	 eax, ecx
$L72424:

; 7217 : 					*pBuffer++ = ((unsigned char)((*pSamples++) >> 8)) ^ 0x80;

  025c3	66 8b 17	 mov	 dx, WORD PTR [edi]
  025c6	83 c7 02	 add	 edi, 2
  025c9	c1 fa 08	 sar	 edx, 8
  025cc	80 f2 80	 xor	 dl, 128			; 00000080H
  025cf	88 16		 mov	 BYTE PTR [esi], dl
  025d1	46		 inc	 esi
  025d2	48		 dec	 eax
  025d3	75 ee		 jne	 SHORT $L72424
$L72426:

; 7218 : 				
; 7219 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples;

  025d5	01 4d 18	 add	 DWORD PTR [ebp+24], ecx
$L73314:

; 7220 : 				dwNumberOfSamples = 0;

  025d8	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], 0
$L72423:

; 7249 : 			
; 7250 : 		default:
; 7251 : 			
; 7252 : 			break;
; 7253 : 		}
; 7254 : 		
; 7255 : 		/******************************************************************/
; 7256 : 		/*  The buffer is full. Return it to the application.             */
; 7257 : 		/******************************************************************/
; 7258 : 		
; 7259 : 		if ( pTTS_Buffer->dwBufferLength >= pTTS_Buffer->dwMaximumBufferLength )

  025e0	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  025e3	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  025e6	3b c1		 cmp	 eax, ecx

; 7260 : 		{
; 7261 : 			/****************************************************************/
; 7262 : 			/*  Release the buffer.                                         */
; 7263 : 			/****************************************************************/
; 7264 : 	
; 7265 : 
; 7266 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  025e8	8b 4c 24 14	 mov	 ecx, DWORD PTR _phTTS$[esp+12]
  025ec	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  025f2	52		 push	 edx
  025f3	72 0d		 jb	 SHORT $L72438
  025f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7267 : 		
; 7268 : 			SendBuffer( phTTS );

  025fb	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  025ff	50		 push	 eax

; 7269 : 		}
; 7270 : 		else

  02600	eb 1c		 jmp	 SHORT $L73315
$L72438:

; 7271 : 		{
; 7272 : 
; 7273 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02602	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7274 : 			
; 7275 : 			/****************************************************************/
; 7276 : 			/*  tek 19aug96 if halting, release the buffer.                 */
; 7277 : 			/****************************************************************/
; 7278 : 			if (phTTS->pKernelShareData-> halting)

  02608	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  0260c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0260f	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  02615	85 c0		 test	 eax, eax
  02617	74 0d		 je	 SHORT $L72440

; 7279 : 				SendBuffer(phTTS);

  02619	8b 54 24 14	 mov	 edx, DWORD PTR _phTTS$[esp+12]
  0261d	52		 push	 edx
$L73315:
  0261e	e8 00 00 00 00	 call	 _SendBuffer
  02623	83 c4 04	 add	 esp, 4
$L72440:
  02626	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
  0262a	85 c0		 test	 eax, eax
  0262c	0f 85 02 fe ff
	ff		 jne	 $L72393
  02632	5f		 pop	 edi
  02633	5e		 pop	 esi
  02634	5d		 pop	 ebp
  02635	5b		 pop	 ebx

; 7280 : 			
; 7281 : 		}
; 7282 :   }
; 7283 :   
; 7284 :   return;
; 7285 : }

  02636	c3		 ret	 0
$L73304:

; 7127 : 		{ // tek I think we have to do a leaveCS here.. 
; 7128 : 	
; 7129 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02637	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0263d	50		 push	 eax
  0263e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02644	5f		 pop	 edi
  02645	5e		 pop	 esi
  02646	5d		 pop	 ebp
  02647	5b		 pop	 ebx

; 7280 : 			
; 7281 : 		}
; 7282 :   }
; 7283 :   
; 7284 :   return;
; 7285 : }

  02648	c3		 ret	 0
$L73305:

; 7138 : 		{ // tek I think we have to do a leaveCS here.. 
; 7139 : 
; 7140 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02649	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  0264f	51		 push	 ecx

; 7150 : 		{ // tek I think we have to do a leaveCS here.. 
; 7151 : 
; 7152 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02650	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7153 : 
; 7154 : 			SendBuffer(phTTS); //tek 03sep96

  02656	56		 push	 esi
  02657	e8 00 00 00 00	 call	 _SendBuffer
  0265c	83 c4 04	 add	 esp, 4
  0265f	5f		 pop	 edi
  02660	5e		 pop	 esi
  02661	5d		 pop	 ebp
  02662	5b		 pop	 ebx

; 7280 : 			
; 7281 : 		}
; 7282 :   }
; 7283 :   
; 7284 :   return;
; 7285 : }

  02663	c3		 ret	 0
$L73306:

; 7150 : 		{ // tek I think we have to do a leaveCS here.. 
; 7151 : 
; 7152 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02664	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  0266a	52		 push	 edx
  0266b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7153 : 
; 7154 : 			SendBuffer(phTTS); //tek 03sep96

  02671	56		 push	 esi
  02672	e8 00 00 00 00	 call	 _SendBuffer
  02677	83 c4 04	 add	 esp, 4
$L72394:
  0267a	5f		 pop	 edi
  0267b	5e		 pop	 esi
  0267c	5d		 pop	 ebp
  0267d	5b		 pop	 ebx

; 7280 : 			
; 7281 : 		}
; 7282 :   }
; 7283 :   
; 7284 :   return;
; 7285 : }

  0267e	c3		 ret	 0
_QueueToMemory ENDP
_TEXT	ENDS
EXTRN	_read_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pTTS_BufferArray$ = 8
_GetBuffer PROC NEAR

; 7314 : {

  02680	56		 push	 esi

; 7315 : 	LPTTS_BUFFER_T pTTS_BufferArray[1];  /*MVP : Not a static */
; 7316 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 7317 : 	
; 7318 : 	read_pipe( phTTS->pKernelShareData->buffer_pipe, &pTTS_BufferArray[0], 1 );

  02681	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02685	8d 44 24 08	 lea	 eax, DWORD PTR _pTTS_BufferArray$[esp]
  02689	6a 01		 push	 1
  0268b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0268e	50		 push	 eax
  0268f	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  02695	52		 push	 edx
  02696	e8 00 00 00 00	 call	 _read_pipe

; 7319 : 	
; 7320 : 	pTTS_Buffer = pTTS_BufferArray[0];

  0269b	8b 44 24 14	 mov	 eax, DWORD PTR _pTTS_BufferArray$[esp+12]

; 7321 : 	
; 7322 : 	if ( pTTS_Buffer != NULL )

  0269f	33 c9		 xor	 ecx, ecx
  026a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  026a4	3b c1		 cmp	 eax, ecx
  026a6	74 18		 je	 SHORT $L72448

; 7323 : 	{
; 7324 : 		pTTS_Buffer->dwBufferLength = 0;

  026a8	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 7325 : 		pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  026ab	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 7326 : 		pTTS_Buffer->dwNumberOfIndexMarks = 0;

  026ae	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 7327 : 		
; 7328 : 		if ( phTTS->dwFormat == WAVE_FORMAT_1M16 )

  026b1	8b 8e 80 00 00
	00		 mov	 ecx, DWORD PTR [esi+128]
  026b7	83 f9 04	 cmp	 ecx, 4
  026ba	75 04		 jne	 SHORT $L72448

; 7329 : 			pTTS_Buffer->dwMaximumBufferLength &= 0xFFFFFFFE;

  026bc	83 60 0c fe	 and	 DWORD PTR [eax+12], -2	; fffffffeH
$L72448:
  026c0	5e		 pop	 esi

; 7330 : 	}
; 7331 : 	return( pTTS_Buffer );
; 7332 : }

  026c1	c3		 ret	 0
_GetBuffer ENDP
_TEXT	ENDS
PUBLIC	_Report_TTS_Status
_TEXT	SEGMENT
_phTTS$ = 8
_SendBuffer PROC NEAR

; 7360 : {

  026d0	53		 push	 ebx
  026d1	56		 push	 esi

; 7361 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 7362 : #ifdef API_DEBUG
; 7363 : 	OutputDebugString("SendBuffer().\n");
; 7364 : #endif //API_DEBUG
; 7365 : 	if ( (! phTTS->bMemoryReset)
; 7366 : 		&& (! phTTS->pKernelShareData->halting))

  026d2	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  026d6	33 db		 xor	 ebx, ebx
  026d8	39 9e 8c 00 00
	00		 cmp	 DWORD PTR [esi+140], ebx
  026de	75 60		 jne	 SHORT $L72453
  026e0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  026e3	39 98 74 01 00
	00		 cmp	 DWORD PTR [eax+372], ebx
  026e9	75 55		 jne	 SHORT $L72453

; 7367 : 	{
; 7368 : #ifdef API_DEBUG
; 7369 : 		OutputDebugString(" SB (!reset).\n");
; 7370 : #endif //API_DEBUG
; 7371 : 		if ( phTTS->pTTS_Buffer != NULL )

  026eb	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  026f1	3b c3		 cmp	 eax, ebx
  026f3	0f 84 da 00 00
	00		 je	 $L72463

; 7372 : 		{
; 7373 : 			pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;
; 7374 : 			
; 7375 : 			/****************************************************************/
; 7376 : 			/*  NULL buffers sent by reset to fix hang. WIH 3/27/95         */
; 7377 : 			/****************************************************************/
; 7378 : 			
; 7379 : 			if ( pTTS_Buffer != NULL )
; 7380 : 			{
; 7381 : 				
; 7382 : 				
; 7383 : 				/****************************************************************/
; 7384 : 				/*  It is possible to get here with nothing in the buffer if    */
; 7385 : 				/*  a force caused the buffer to be returned. Check the buffer  */
; 7386 : 				/*  to see if it has any sections full.                         */
; 7387 : 				/****************************************************************/
; 7388 : 				
; 7389 : 				if (( pTTS_Buffer->dwBufferLength > 0 )
; 7390 : 					|| ( pTTS_Buffer->dwNumberOfIndexMarks > 0 )
; 7391 : 					|| ( pTTS_Buffer->dwNumberOfPhonemeChanges > 0 ))

  026f9	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  026fc	77 0e		 ja	 SHORT $L72460
  026fe	39 58 20	 cmp	 DWORD PTR [eax+32], ebx
  02701	77 09		 ja	 SHORT $L72460
  02703	39 58 1c	 cmp	 DWORD PTR [eax+28], ebx
  02706	0f 86 c7 00 00
	00		 jbe	 $L72463
$L72460:

; 7392 : 				{
; 7393 : 					phTTS->bSendingBuffer = TRUE;
; 7394 : 					/*
; 7395 : 					SendMessage( phTTS->hWnd,
; 7396 : 					phTTS->uiID_Buffer_Message,
; 7397 : 					0,
; 7398 : 					(LPARAM)phTTS->pTTS_Buffer );
; 7399 : 					*/
; 7400 : 					//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 7401 : #ifdef API_DEBUG
; 7402 : 					OutputDebugString("returning partial buffer.\n");
; 7403 : #endif //API_DEBUG
; 7404 : 					
; 7405 : 					Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)phTTS->pTTS_Buffer);

  0270c	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  0270f	50		 push	 eax
  02710	53		 push	 ebx
  02711	51		 push	 ecx
  02712	56		 push	 esi
  02713	c7 86 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+144], 1
  0271d	e8 00 00 00 00	 call	 _Report_TTS_Status

; 7406 : 					phTTS->pTTS_Buffer = NULL;
; 7407 : 					
; 7408 : 					phTTS->bSendingBuffer = FALSE;
; 7409 : 					
; 7410 : #ifdef WIN32
; 7411 : 					WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  02722	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  02725	83 c4 10	 add	 esp, 16			; 00000010H
  02728	89 9e a0 00 00
	00		 mov	 DWORD PTR [esi+160], ebx
  0272e	89 9e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ebx
  02734	6a ff		 push	 -1
  02736	52		 push	 edx
  02737	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0273d	5e		 pop	 esi
  0273e	5b		 pop	 ebx

; 7497 : #endif
; 7498 : #if defined __osf__ || defined __linux__
; 7499 : 		OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 7500 : #endif
; 7501 : 	}
; 7502 : #ifdef API_DEBUG
; 7503 : 	OutputDebugString("SB done.\n");
; 7504 : #endif //API_DEBUG
; 7505 : 	return;
; 7506 : }

  0273f	c3		 ret	 0
$L72453:

; 7412 : #endif
; 7413 : #if defined __osf__ || defined __linux__
; 7414 : 					OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 7415 : #endif
; 7416 : 				}
; 7417 : 			}
; 7418 : 		}
; 7419 : 	}
; 7420 : 	else
; 7421 : 	{
; 7422 : #ifdef API_DEBUG
; 7423 : 		OutputDebugString("SB (reset)\n");
; 7424 : 		if (phTTS->pKernelShareData->halting)
; 7425 : 			OutputDebugString("SB halting.. \n");
; 7426 : 		if (phTTS->bMemoryReset)
; 7427 : 			OutputDebugString("SB memreset.. \n");
; 7428 : #endif //API_DEBUG
; 7429 : 		
; 7430 : 		/******************************************************************/
; 7431 : 		/*  Send the current buffer back.                                 */
; 7432 : 		/******************************************************************/
; 7433 : 		EnterCriticalSection( phTTS->pcsMemoryBuffer );

  02740	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  02746	57		 push	 edi
  02747	50		 push	 eax
  02748	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7434 : 		
; 7435 : 		pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;
; 7436 : 		phTTS->pTTS_Buffer=NULL;
; 7437 : 		
; 7438 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  0274e	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  02754	8b be a0 00 00
	00		 mov	 edi, DWORD PTR [esi+160]
  0275a	51		 push	 ecx
  0275b	89 9e a0 00 00
	00		 mov	 DWORD PTR [esi+160], ebx
  02761	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7439 : 		
; 7440 : 		if ( pTTS_Buffer != NULL )

  02767	3b fb		 cmp	 edi, ebx
  02769	74 2b		 je	 SHORT $L72467

; 7441 : 		{
; 7442 : #ifdef API_DEBUG
; 7443 : 			OutputDebugString("SB return current buf. \n");
; 7444 : #endif //API_DEBUG
; 7445 : 			
; 7446 : 			/****************************************************************/
; 7447 : 			/*  NULL buffers sent by reset to fix hang. WIH 3/27/95         */
; 7448 : 			/*  This is needed in spite of previous "if" statement because  */
; 7449 : 			/*  the app is multip-threaded.                                 */
; 7450 : 			/****************************************************************/
; 7451 : 			
; 7452 : 				phTTS->bSendingBuffer = TRUE;
; 7453 : 				/*
; 7454 : 				SendMessage( phTTS->hWnd,
; 7455 : 				phTTS->uiID_Buffer_Message,
; 7456 : 				0,
; 7457 : 				(LPARAM)pTTS_Buffer );
; 7458 : 				*/
; 7459 : 				//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 7460 : #ifdef API_DEBUG
; 7461 : 				OutputDebugString(" returning a buffer.. \n");
; 7462 : #endif //API_DEBUG
; 7463 : 				
; 7464 : 				Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)pTTS_Buffer);

  0276b	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  0276e	57		 push	 edi
  0276f	53		 push	 ebx
  02770	52		 push	 edx
  02771	56		 push	 esi
  02772	c7 86 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+144], 1
  0277c	e8 00 00 00 00	 call	 _Report_TTS_Status

; 7465 : 				
; 7466 : 				phTTS->bSendingBuffer = FALSE;
; 7467 : 				
; 7468 : #ifdef WIN32
; 7469 : 				WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  02781	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  02784	83 c4 10	 add	 esp, 16			; 00000010H
  02787	89 9e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ebx
  0278d	6a ff		 push	 -1
  0278f	50		 push	 eax
  02790	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$L72467:

; 7470 : #endif
; 7471 : #if defined __osf__ || defined __linux__
; 7472 : 				OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 7473 : #endif
; 7474 : 			
; 7475 : 		}
; 7476 : 		
; 7477 : 		// tek 03sep96 moved the return of remaining buffers out to 
; 7478 : 		// a separate routine.
; 7479 : 		ReturnRemainingBuffers(phTTS);

  02796	56		 push	 esi
  02797	e8 00 00 00 00	 call	 _ReturnRemainingBuffers

; 7480 : 		
; 7481 : 		// tek 29aug96 if we're in a flusg, put in another null buffer.. 
; 7482 : 		if (phTTS->pKernelShareData->halting  && phTTS->dwOutputState == STATE_OUTPUT_MEMORY)

  0279c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0279f	83 c4 04	 add	 esp, 4
  027a2	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  027a8	5f		 pop	 edi
  027a9	3b c3		 cmp	 eax, ebx
  027ab	74 13		 je	 SHORT $L72469
  027ad	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  027b4	75 0a		 jne	 SHORT $L72469

; 7483 : 			TextToSpeechAddBuffer(phTTS, NULL); // a dummy buffer.

  027b6	53		 push	 ebx
  027b7	56		 push	 esi
  027b8	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  027bd	83 c4 08	 add	 esp, 8
$L72469:

; 7484 : 		/******************************************************************/
; 7485 : 		/*  Empty the VTM pipe in case there is still any data in it      */
; 7486 : 		/******************************************************************/
; 7487 : 		
; 7488 : 		InitializeVTM(phTTS);

  027c0	56		 push	 esi
  027c1	e8 00 00 00 00	 call	 _InitializeVTM

; 7489 : 		
; 7490 : 		//phTTS->pTTS_Buffer = NULL;
; 7491 : 		//tek 03sep96 we can't clear this flag here, because  vtm writes
; 7492 : 		// that sneak in at the 'right' time could prematurely clear it.
; 7493 : 		//phTTS->bMemoryReset = FALSE;
; 7494 : 		
; 7495 : #ifdef WIN32
; 7496 : 		SetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  027c6	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  027c9	83 c4 04	 add	 esp, 4
  027cc	52		 push	 edx
  027cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L72463:
  027d3	5e		 pop	 esi
  027d4	5b		 pop	 ebx

; 7497 : #endif
; 7498 : #if defined __osf__ || defined __linux__
; 7499 : 		OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 7500 : #endif
; 7501 : 	}
; 7502 : #ifdef API_DEBUG
; 7503 : 	OutputDebugString("SB done.\n");
; 7504 : #endif //API_DEBUG
; 7505 : 	return;
; 7506 : }

  027d5	c3		 ret	 0
_SendBuffer ENDP
_phTTS$ = 8
_pPipeArray$ = 8
_ReturnRemainingBuffers PROC NEAR

; 7518 : {

  027e0	53		 push	 ebx
  027e1	55		 push	 ebp
  027e2	56		 push	 esi

; 7519 : 	LPTTS_BUFFER_T pPipeArray[1];        /*MVP : Not a static */
; 7520 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 7521 : #ifdef WIN32
; 7522 : 	UINT	uiPipeCount=0;				// 16jun97 tek bats 385 merged 28jul97
; 7523 : 	
; 7524 : #ifdef API_DEBUG
; 7525 : 	OutputDebugString("ReturnRemainingBuffers()\n");
; 7526 : #endif //API_DEBUG
; 7527 : #endif
; 7528 : 	
; 7529 :     /******************************************************************/
; 7530 : 	/*  Send all the remaining buffers back.                          */
; 7531 : 	/******************************************************************/
; 7532 : 	
; 7533 : 	// tek 03sep96 we need to lock the pipe to make sure nothing arrives
; 7534 :     // while we're dumping.. 
; 7535 : #ifdef WIN32
; 7536 : 	// 16jun97 tek bats 385: (merged 28jul97)
; 7537 : 	// the user callback may be coded to just return buffers, and that 
; 7538 : 	// would result in an infinite loop if we just tried to drain the pipe.
; 7539 : 	// Soooo.. we empty the pipe into an cache, and then return the buffers
; 7540 : 	// from the cache; this means the user callback is filling a different
; 7541 : 	// pipe and thus we won't loop forever.
; 7542 :     //LockPipe(phTTS->pKernelShareData->buffer_pipe);
; 7543 :     OP_LockMutex(phTTS->pcsBufferPipe);

  027e3	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  027e7	57		 push	 edi
  027e8	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  027ee	50		 push	 eax
  027ef	e8 00 00 00 00	 call	 _OP_LockMutex

; 7544 : #endif
; 7545 : #if defined __osf__ || defined __linux__
; 7546 :     OP_LockMutex(phTTS->pcsBufferPipe);
; 7547 : #endif
; 7548 : 	
; 7549 : 	while (pipe_count( phTTS->pKernelShareData->buffer_pipe )  && phTTS->dwOutputState == STATE_OUTPUT_MEMORY)

  027f4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  027f7	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  027fd	52		 push	 edx
  027fe	e8 00 00 00 00	 call	 _pipe_count
  02803	83 c4 08	 add	 esp, 8
  02806	bb 01 00 00 00	 mov	 ebx, 1
  0280b	85 c0		 test	 eax, eax
  0280d	74 48		 je	 SHORT $L73323
$L72478:
  0280f	39 9e 84 00 00
	00		 cmp	 DWORD PTR [esi+132], ebx
  02815	75 40		 jne	 SHORT $L73323

; 7550 : 	{
; 7551 : 		read_pipe( phTTS->pKernelShareData->buffer_pipe, &pPipeArray, 1 );

  02817	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0281a	8d 44 24 14	 lea	 eax, DWORD PTR _pPipeArray$[esp+12]
  0281e	53		 push	 ebx
  0281f	50		 push	 eax
  02820	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  02826	52		 push	 edx
  02827	e8 00 00 00 00	 call	 _read_pipe

; 7552 : #ifdef WIN32
; 7553 : 		write_pipe(phTTS->pKernelShareData->buffer_delay_pipe, pPipeArray, 1 );

  0282c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0282f	8d 44 24 20	 lea	 eax, DWORD PTR _pPipeArray$[esp+24]
  02833	53		 push	 ebx
  02834	50		 push	 eax
  02835	8b 91 e8 00 00
	00		 mov	 edx, DWORD PTR [ecx+232]
  0283b	52		 push	 edx
  0283c	e8 00 00 00 00	 call	 _write_pipe
  02841	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02844	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  0284a	51		 push	 ecx
  0284b	e8 00 00 00 00	 call	 _pipe_count
  02850	83 c4 1c	 add	 esp, 28			; 0000001cH
  02853	85 c0		 test	 eax, eax
  02855	75 b8		 jne	 SHORT $L72478
$L73323:

; 7554 : 	}
; 7555 : //	OP_UnlockMutex(phTTS->pcsBufferPipe);
; 7556 : 	//UnlockPipe(phTTS->pKernelShareData->buffer_pipe);
; 7557 : 	
; 7558 : 	while (pipe_count( phTTS->pKernelShareData->buffer_delay_pipe ) && phTTS->dwOutputState == STATE_OUTPUT_MEMORY)

  02857	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0285a	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  02860	50		 push	 eax
  02861	e8 00 00 00 00	 call	 _pipe_count
  02866	83 c4 04	 add	 esp, 4
  02869	85 c0		 test	 eax, eax
  0286b	0f 84 8e 00 00
	00		 je	 $L72482
  02871	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__WaitForSingleObject@8
  02877	33 ff		 xor	 edi, edi
$L72481:
  02879	39 9e 84 00 00
	00		 cmp	 DWORD PTR [esi+132], ebx
  0287f	75 7e		 jne	 SHORT $L72482

; 7559 : 	{
; 7560 : 		read_pipe( phTTS->pKernelShareData->buffer_delay_pipe, &pPipeArray, 1 );

  02881	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02884	8d 4c 24 14	 lea	 ecx, DWORD PTR _pPipeArray$[esp+12]
  02888	53		 push	 ebx
  02889	51		 push	 ecx
  0288a	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  02890	50		 push	 eax
  02891	e8 00 00 00 00	 call	 _read_pipe

; 7561 : 		
; 7562 : #endif
; 7563 : //#if defined __osf__ || defined __linux__
; 7564 : 		OP_UnlockMutex(phTTS->pcsBufferPipe);

  02896	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  0289c	51		 push	 ecx
  0289d	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7565 : //#endif
; 7566 : 		pTTS_Buffer = pPipeArray[0];

  028a2	8b 44 24 24	 mov	 eax, DWORD PTR _pPipeArray$[esp+28]
  028a6	83 c4 10	 add	 esp, 16			; 00000010H

; 7567 : 		
; 7568 : 		if ( pTTS_Buffer != NULL )

  028a9	3b c7		 cmp	 eax, edi
  028ab	74 2c		 je	 SHORT $L72484

; 7569 : 		{
; 7570 : 			pTTS_Buffer->dwBufferLength = 0;

  028ad	89 78 18	 mov	 DWORD PTR [eax+24], edi

; 7571 : 			pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  028b0	89 78 1c	 mov	 DWORD PTR [eax+28], edi

; 7572 : 			pTTS_Buffer->dwNumberOfIndexMarks = 0;

  028b3	89 78 20	 mov	 DWORD PTR [eax+32], edi

; 7573 : 			
; 7574 : 			phTTS->bSendingBuffer = TRUE;
; 7575 : 			/*
; 7576 : 			SendMessage( phTTS->hWnd,
; 7577 : 			phTTS->uiID_Buffer_Message,
; 7578 : 			0,
; 7579 : 			(LPARAM)pTTS_Buffer );
; 7580 : 			*/
; 7581 : 			//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 7582 : #ifdef API_DEBUG
; 7583 : 			OutputDebugString(" returning a remaining buffer.. \n");
; 7584 : #endif //API_DEBUG
; 7585 : 			Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)pTTS_Buffer);

  028b6	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  028b9	50		 push	 eax
  028ba	57		 push	 edi
  028bb	52		 push	 edx
  028bc	56		 push	 esi
  028bd	89 9e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ebx
  028c3	e8 00 00 00 00	 call	 _Report_TTS_Status

; 7586 : 			
; 7587 : 			phTTS->bSendingBuffer = FALSE;
; 7588 : #ifdef WIN32
; 7589 : 			WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  028c8	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  028cb	83 c4 10	 add	 esp, 16			; 00000010H
  028ce	89 be 90 00 00
	00		 mov	 DWORD PTR [esi+144], edi
  028d4	6a ff		 push	 -1
  028d6	50		 push	 eax
  028d7	ff d5		 call	 ebp
$L72484:

; 7590 : #endif
; 7591 : #if defined __osf__ || defined __linux__
; 7592 : 			OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 7593 : #endif
; 7594 : 		}
; 7595 : 		// relock the pipe to atomically get a count and a buffer.
; 7596 : 		// LockPipe(phTTS->pKernelShareData->buffer_pipe);
; 7597 : //#if defined __osf__ || defined __linux__
; 7598 : 		OP_LockMutex(phTTS->pcsBufferPipe);

  028d9	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  028df	51		 push	 ecx
  028e0	e8 00 00 00 00	 call	 _OP_LockMutex
  028e5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  028e8	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  028ee	50		 push	 eax
  028ef	e8 00 00 00 00	 call	 _pipe_count
  028f4	83 c4 08	 add	 esp, 8
  028f7	85 c0		 test	 eax, eax
  028f9	0f 85 7a ff ff
	ff		 jne	 $L72481
$L72482:

; 7599 : //#endif
; 7600 : 	}
; 7601 : 	//  UnlockPipe(phTTS->pKernelShareData->buffer_pipe);
; 7602 : //#if defined __osf__ || defined __linux__
; 7603 : 	OP_UnlockMutex(phTTS->pcsBufferPipe);

  028ff	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  02905	51		 push	 ecx
  02906	e8 00 00 00 00	 call	 _OP_UnlockMutex
  0290b	83 c4 04	 add	 esp, 4
  0290e	5f		 pop	 edi
  0290f	5e		 pop	 esi
  02910	5d		 pop	 ebp
  02911	5b		 pop	 ebx

; 7604 : //#endif
; 7605 : } // ReturnRemainingBuffers()

  02912	c3		 ret	 0
_ReturnRemainingBuffers ENDP
_TEXT	ENDS
PUBLIC	_PutIndexMarkInBuffer
_BSS	SEGMENT
	ALIGN	4

_?pIndexArray@?1??PutIndexMarkInBuffer@@9@9 DD 01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_dwIndexValue$ = 12
_dwSampleNumber$ = 16
_PutIndexMarkInBuffer PROC NEAR

; 7642 : {

  02920	56		 push	 esi

; 7643 : 	UINT uiIndex;                                                      /*MVP : Not a static */
; 7644 : 	/*static LPTTS_BUFFER_T pPipeArray[1];*/               /*MVP : Never Used   */
; 7645 : 	LPTTS_BUFFER_T pTTS_Buffer;                                    /*MVP : Not a static */
; 7646 : 	static LPTTS_INDEX_T pIndexArray;                              /*MVP : Not a static */
; 7647 : 	
; 7648 : //#if defined __osf__ || defined __linux__ // remove this ifdef as all code should be checking this
; 7649 : 	/********************************************************************/
; 7650 : 	/*   If current in the Reset code, no need to continue              */
; 7651 : 	/********************************************************************/
; 7652 : 	if ( phTTS->bInReset )

  02921	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02925	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  0292b	85 c0		 test	 eax, eax
  0292d	0f 85 a9 00 00
	00		 jne	 $L72509

; 7653 : 		return;
; 7654 : //#endif
; 7655 : 	
; 7656 : 	/********************************************************************/
; 7657 : 	/*  Block if the TextToSpeechReturnBuffer() function is returning   */
; 7658 : 	/*  the current buffer.                                             */
; 7659 : 	/********************************************************************/
; 7660 : 
; 7661 : 		EnterCriticalSection( phTTS->pcsMemoryBuffer );

  02933	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  02939	50		 push	 eax
  0293a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7662 : 	
; 7663 : 	/********************************************************************/
; 7664 : 	/*  If a new Text-To-Speech buffer is needed then get one from      */
; 7665 : 	/*  the application. Block if one is not available.                 */
; 7666 : 	/********************************************************************/
; 7667 : 	
; 7668 : 	if ( phTTS->pTTS_Buffer == NULL )

  02940	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  02946	85 c0		 test	 eax, eax
  02948	75 0f		 jne	 SHORT $L72500

; 7669 : 	{
; 7670 : 		phTTS->pTTS_Buffer = GetBuffer( phTTS );

  0294a	56		 push	 esi
  0294b	e8 00 00 00 00	 call	 _GetBuffer
  02950	83 c4 04	 add	 esp, 4
  02953	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
$L72500:

; 7671 : 	}
; 7672 : 	
; 7673 : 	pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

  02959	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]

; 7674 : 	
; 7675 : 	/********************************************************************/
; 7676 : 	/*  NULL buffers sent by reset to fix hang. WIH 3/27/95             */
; 7677 : 	/********************************************************************/
; 7678 : 	
; 7679 : 	if ( pTTS_Buffer == NULL )

  0295f	85 c0		 test	 eax, eax

; 7680 : 	{
; 7681 : 
; 7682 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );
; 7683 : 
; 7684 : 		return;

  02961	74 6c		 je	 SHORT $L72505

; 7685 : 	}
; 7686 : 	
; 7687 : 	/********************************************************************/
; 7688 : 	/*  Put the index mark into the current buffer.                     */
; 7689 : 	/********************************************************************/
; 7690 : 	
; 7691 : 	pIndexArray = pTTS_Buffer->lpIndexArray;

  02963	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 7692 : 	
; 7693 : 	if ( pIndexArray != NULL )

  02966	85 d2		 test	 edx, edx
  02968	89 15 00 00 00
	00		 mov	 DWORD PTR _?pIndexArray@?1??PutIndexMarkInBuffer@@9@9, edx
  0296e	74 5f		 je	 SHORT $L72505

; 7694 : 	{
; 7695 : 		uiIndex = pTTS_Buffer->dwNumberOfIndexMarks;

  02970	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02973	57		 push	 edi

; 7696 : 		
; 7697 : 		if ( pTTS_Buffer->dwMaximumNumberOfIndexMarks > 0 )

  02974	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  02977	85 ff		 test	 edi, edi
  02979	76 22		 jbe	 SHORT $L72506

; 7698 : 		{
; 7699 : 			(pIndexArray+uiIndex)->dwIndexValue = dwIndexValue;

  0297b	8b 7c 24 10	 mov	 edi, DWORD PTR _dwIndexValue$[esp+4]
  0297f	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  02982	c1 e1 02	 shl	 ecx, 2
  02985	89 3c 11	 mov	 DWORD PTR [ecx+edx], edi

; 7700 : 			(pIndexArray+uiIndex)->dwIndexSampleNumber = dwSampleNumber;

  02988	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _?pIndexArray@?1??PutIndexMarkInBuffer@@9@9
  0298e	8b 54 24 14	 mov	 edx, DWORD PTR _dwSampleNumber$[esp+4]
  02992	89 54 39 04	 mov	 DWORD PTR [ecx+edi+4], edx

; 7701 : 			pTTS_Buffer->dwNumberOfIndexMarks++;

  02996	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02999	41		 inc	 ecx
  0299a	89 48 20	 mov	 DWORD PTR [eax+32], ecx
$L72506:

; 7702 : 		}
; 7703 : 		
; 7704 : 		/******************************************************************/
; 7705 : 		/*  If the index mark array is full then return it to the         */
; 7706 : 		/*  application.                                                  */
; 7707 : 		/******************************************************************/
; 7708 : 		
; 7709 : 		if ( pTTS_Buffer->dwNumberOfIndexMarks
; 7710 : 			>= pTTS_Buffer->dwMaximumNumberOfIndexMarks )

  0299d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  029a0	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  029a3	3b ca		 cmp	 ecx, edx
  029a5	5f		 pop	 edi
  029a6	72 18		 jb	 SHORT $L72507

; 7711 : 		{
; 7712 : 			/****************************************************************/
; 7713 : 			/*  Release the buffer.                                         */
; 7714 : 			/****************************************************************/
; 7715 : 			
; 7716 : 
; 7717 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  029a8	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  029ae	52		 push	 edx
  029af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7718 : 			
; 7719 : 			SendBuffer( phTTS );

  029b5	56		 push	 esi
  029b6	e8 00 00 00 00	 call	 _SendBuffer
  029bb	83 c4 04	 add	 esp, 4
  029be	5e		 pop	 esi

; 7739 : 
; 7740 : 	}
; 7741 : 	return;
; 7742 : }

  029bf	c3		 ret	 0
$L72507:

; 7720 : 		}
; 7721 : 		else
; 7722 : 		{
; 7723 : 			/****************************************************************/
; 7724 : 			/*  Release the buffer.                                         */
; 7725 : 			/****************************************************************/
; 7726 : 			
; 7727 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  029c0	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  029c6	50		 push	 eax

; 7728 : 
; 7729 : 		}
; 7730 : 	}
; 7731 : 	else
; 7732 : 	{
; 7733 : 		/******************************************************************/
; 7734 : 		/*  Release the buffer.                                           */
; 7735 : 		/******************************************************************/
; 7736 : 		
; 7737 : 
; 7738 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  029c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  029cd	5e		 pop	 esi

; 7739 : 
; 7740 : 	}
; 7741 : 	return;
; 7742 : }

  029ce	c3		 ret	 0
$L72505:

; 7728 : 
; 7729 : 		}
; 7730 : 	}
; 7731 : 	else
; 7732 : 	{
; 7733 : 		/******************************************************************/
; 7734 : 		/*  Release the buffer.                                           */
; 7735 : 		/******************************************************************/
; 7736 : 		
; 7737 : 
; 7738 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  029cf	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  029d5	51		 push	 ecx
  029d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72509:
  029dc	5e		 pop	 esi

; 7739 : 
; 7740 : 	}
; 7741 : 	return;
; 7742 : }

  029dd	c3		 ret	 0
_PutIndexMarkInBuffer ENDP
_TEXT	ENDS
PUBLIC	_PutPhonemeInBuffer
_TEXT	SEGMENT
_phTTS$ = 8
_dwPhoneme$ = 12
_dwPhonemeDuration$ = 16
_dwSampleNumber$ = 20
_PutPhonemeInBuffer PROC NEAR

; 7779 : {

  029e0	56		 push	 esi

; 7780 : 	UINT uiIndex;                                                     /* MVP : Not a static */
; 7781 : 	/*static LPTTS_BUFFER_T pPipeArray[1];*/  /* MVP : Never Used   */
; 7782 : 	LPTTS_BUFFER_T pTTS_Buffer;                           /* MVP : Not a static */
; 7783 : 	LPTTS_PHONEME_T pPhonemeArray;                        /* MVP : Not a static */
; 7784 : 	
; 7785 : //#ifdef WIN32 // remove this ifdef as all code should be checking this
; 7786 : 	/********************************************************************/
; 7787 : 	/*   If current in the Reset code, no need to continue              */
; 7788 : 	/********************************************************************/
; 7789 : 	if ( phTTS->bInReset )

  029e1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  029e5	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  029eb	85 c0		 test	 eax, eax
  029ed	0f 85 a1 00 00
	00		 jne	 $L72534

; 7790 : 		return;
; 7791 : //#endif
; 7792 : 	
; 7793 : 	
; 7794 : 	/********************************************************************/
; 7795 : 	/*  Block if the TextToSpeechReturnBuffer() function is returning   */
; 7796 : 	/*  the current buffer.                                             */
; 7797 : 	/********************************************************************/
; 7798 : 
; 7799 : 	EnterCriticalSection( phTTS->pcsMemoryBuffer );

  029f3	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  029f9	50		 push	 eax
  029fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7800 : 	
; 7801 : 	/********************************************************************/
; 7802 : 	/*  If a new Text-To-Speech buffer is needed then get one from      */
; 7803 : 	/*  the application. Block if one is not available.                 */
; 7804 : 	/********************************************************************/
; 7805 : 	
; 7806 : 	if ( phTTS->pTTS_Buffer == NULL )

  02a00	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  02a06	85 c0		 test	 eax, eax
  02a08	75 0f		 jne	 SHORT $L72525

; 7807 : 	{
; 7808 : 		phTTS->pTTS_Buffer = GetBuffer( phTTS );

  02a0a	56		 push	 esi
  02a0b	e8 00 00 00 00	 call	 _GetBuffer
  02a10	83 c4 04	 add	 esp, 4
  02a13	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
$L72525:

; 7809 : 	}
; 7810 : 	
; 7811 : 	/********************************************************************/
; 7812 : 	/*  Put the index mark into the current buffer.                     */
; 7813 : 	/********************************************************************/
; 7814 : 	
; 7815 : 	pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

  02a19	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]

; 7816 : 	
; 7817 : 	/********************************************************************/
; 7818 : 	/*  NULL buffers sent by reset to fix hang. WIH 3/27/95             */
; 7819 : 	/********************************************************************/
; 7820 : 	
; 7821 : 	if ( pTTS_Buffer == NULL )

  02a1f	85 c0		 test	 eax, eax

; 7822 : 	{
; 7823 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );
; 7824 : 		return;

  02a21	74 64		 je	 SHORT $L72530

; 7825 : 	}
; 7826 : 	
; 7827 : 	pPhonemeArray = pTTS_Buffer->lpPhonemeArray;

  02a23	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 7828 : 	
; 7829 : 	if ( pPhonemeArray != NULL )

  02a26	85 d2		 test	 edx, edx
  02a28	74 5d		 je	 SHORT $L72530

; 7830 : 	{
; 7831 : 		uiIndex = pTTS_Buffer->dwNumberOfPhonemeChanges;

  02a2a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02a2d	57		 push	 edi

; 7832 : 		
; 7833 : 		if ( pTTS_Buffer->dwMaximumNumberOfPhonemeChanges > 0 )

  02a2e	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  02a31	85 ff		 test	 edi, edi
  02a33	5f		 pop	 edi
  02a34	76 20		 jbe	 SHORT $L72531

; 7834 : 		{
; 7835 : 			(pPhonemeArray+uiIndex)->dwPhoneme = dwPhoneme;

  02a36	c1 e1 04	 shl	 ecx, 4
  02a39	03 ca		 add	 ecx, edx
  02a3b	8b 54 24 0c	 mov	 edx, DWORD PTR _dwPhoneme$[esp]
  02a3f	89 11		 mov	 DWORD PTR [ecx], edx

; 7836 : 			(pPhonemeArray+uiIndex)->dwPhonemeSampleNumber = dwSampleNumber;

  02a41	8b 54 24 14	 mov	 edx, DWORD PTR _dwSampleNumber$[esp]
  02a45	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 7837 : 			(pPhonemeArray+uiIndex)->dwPhonemeDuration = dwPhonemeDuration;

  02a48	8b 54 24 10	 mov	 edx, DWORD PTR _dwPhonemeDuration$[esp]
  02a4c	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 7838 : 			pTTS_Buffer->dwNumberOfPhonemeChanges++;

  02a4f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02a52	41		 inc	 ecx
  02a53	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L72531:

; 7839 : 		}
; 7840 : 		
; 7841 : 		/******************************************************************/
; 7842 : 		/*  If the phoneme array is full then return it to the            */
; 7843 : 		/*  application.                                                  */
; 7844 : 		/******************************************************************/
; 7845 : 		
; 7846 : 		if ( pTTS_Buffer->dwNumberOfPhonemeChanges
; 7847 : 			>= pTTS_Buffer->dwMaximumNumberOfPhonemeChanges )

  02a56	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02a59	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  02a5c	3b ca		 cmp	 ecx, edx
  02a5e	72 18		 jb	 SHORT $L72532

; 7848 : 		{
; 7849 : 			/****************************************************************/
; 7850 : 			/*  Release the buffer.                                         */
; 7851 : 			/****************************************************************/
; 7852 : 
; 7853 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02a60	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  02a66	52		 push	 edx
  02a67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7854 : 			SendBuffer( phTTS );

  02a6d	56		 push	 esi
  02a6e	e8 00 00 00 00	 call	 _SendBuffer
  02a73	83 c4 04	 add	 esp, 4
  02a76	5e		 pop	 esi

; 7871 : 	}
; 7872 : 	return;
; 7873 : }

  02a77	c3		 ret	 0
$L72532:

; 7855 : 		}
; 7856 : 		else
; 7857 : 		{
; 7858 : 			/****************************************************************/
; 7859 : 			/*  Release the buffer.                                         */
; 7860 : 			/****************************************************************/
; 7861 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02a78	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  02a7e	50		 push	 eax

; 7862 : 		}
; 7863 : 	}
; 7864 : 	else
; 7865 : 	{
; 7866 : 		/******************************************************************/
; 7867 : 		/*  Release the buffer.                                           */
; 7868 : 		/******************************************************************/
; 7869 : 
; 7870 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02a7f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02a85	5e		 pop	 esi

; 7871 : 	}
; 7872 : 	return;
; 7873 : }

  02a86	c3		 ret	 0
$L72530:

; 7862 : 		}
; 7863 : 	}
; 7864 : 	else
; 7865 : 	{
; 7866 : 		/******************************************************************/
; 7867 : 		/*  Release the buffer.                                           */
; 7868 : 		/******************************************************************/
; 7869 : 
; 7870 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02a87	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  02a8d	51		 push	 ecx
  02a8e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72534:
  02a94	5e		 pop	 esi

; 7871 : 	}
; 7872 : 	return;
; 7873 : }

  02a95	c3		 ret	 0
_PutPhonemeInBuffer ENDP
_phTTS$ = 8
_Speaker$ = 12
_SetSpeaker PROC NEAR

; 7903 : 	/********************************************************************/
; 7904 : 	/*  Set voice change flag for phmain.c in the PH thread.            */
; 7905 : 	/********************************************************************/
; 7906 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  02aa0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 7907 : 	
; 7908 : 	pKsd_t->async_voice = Speaker;

  02aa4	8b 4c 24 08	 mov	 ecx, DWORD PTR _Speaker$[esp-4]
  02aa8	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  02aab	89 88 3c 02 00
	00		 mov	 DWORD PTR [eax+572], ecx

; 7909 : 	pKsd_t->last_voice = (short)Speaker;

  02ab1	66 89 88 20 02
	00 00		 mov	 WORD PTR [eax+544], cx

; 7910 : 	pKsd_t->async_change |= ASYNC_voice;

  02ab8	83 88 38 02 00
	00 01		 or	 DWORD PTR [eax+568], 1

; 7911 : 	
; 7912 : }

  02abf	c3		 ret	 0
_SetSpeaker ENDP
_TEXT	ENDS
EXTRN	__imp___endthreadex:NEAR
EXTRN	__imp__GetMessageA@16:NEAR
EXTRN	__imp__DispatchMessageA@4:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_msg$ = -28
_TextToSpeechThreadMain@4 PROC NEAR

; 7933 : {

  02ac0	83 ec 1c	 sub	 esp, 28			; 0000001cH
  02ac3	56		 push	 esi

; 7934 : 	MSG msg;
; 7935 : 	
; 7936 : 	/********************************************************************/
; 7937 : 	/*  Create the TextToSpeech window.                                 */
; 7938 : 	/********************************************************************/
; 7939 : 	
; 7940 : 	phTTS->hTextToSpeechWnd = InitTextToSpeechWindow( phTTS );

  02ac4	8b 74 24 24	 mov	 esi, DWORD PTR _phTTS$[esp+28]
  02ac8	56		 push	 esi
  02ac9	e8 00 00 00 00	 call	 _InitTextToSpeechWindow
  02ace	83 c4 04	 add	 esp, 4
  02ad1	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 7941 : 	
; 7942 : 	if(phTTS->hTextToSpeechWnd == NULL)

  02ad4	85 c0		 test	 eax, eax
  02ad6	75 0c		 jne	 SHORT $L72547

; 7943 : 		return(MMSYSERR_ERROR);

  02ad8	b8 01 00 00 00	 mov	 eax, 1
  02add	5e		 pop	 esi

; 7954 : }

  02ade	83 c4 1c	 add	 esp, 28			; 0000001cH
  02ae1	c2 04 00	 ret	 4
$L72547:

; 7944 : 	SetEvent(phTTS->hMallocSuccessEvent);    /*Got a hTextToSpeechWnd now */

  02ae4	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  02ae7	57		 push	 edi
  02ae8	50		 push	 eax
  02ae9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 7945 : 	
; 7946 : 	while( GetMessage( &msg,
; 7947 : 		phTTS->hTextToSpeechWnd,
; 7948 : 		0L,
; 7949 : 		ID_TTS_Destroy ))

  02aef	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02af2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetMessageA@16
  02af8	68 01 04 00 00	 push	 1025			; 00000401H
  02afd	6a 00		 push	 0
  02aff	8d 54 24 10	 lea	 edx, DWORD PTR _msg$[esp+44]
  02b03	51		 push	 ecx
  02b04	52		 push	 edx
  02b05	ff d7		 call	 edi
  02b07	85 c0		 test	 eax, eax
  02b09	74 25		 je	 SHORT $L72550
  02b0b	53		 push	 ebx
  02b0c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DispatchMessageA@4
$L72549:

; 7950 : 		DispatchMessage( &msg );

  02b12	8d 44 24 0c	 lea	 eax, DWORD PTR _msg$[esp+40]
  02b16	50		 push	 eax
  02b17	ff d3		 call	 ebx
  02b19	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02b1c	68 01 04 00 00	 push	 1025			; 00000401H
  02b21	6a 00		 push	 0
  02b23	8d 54 24 14	 lea	 edx, DWORD PTR _msg$[esp+48]
  02b27	51		 push	 ecx
  02b28	52		 push	 edx
  02b29	ff d7		 call	 edi
  02b2b	85 c0		 test	 eax, eax
  02b2d	75 e3		 jne	 SHORT $L72549
  02b2f	5b		 pop	 ebx
$L72550:

; 7951 : 	
; 7952 : 	_endthreadex(msg.wParam);

  02b30	8b 44 24 10	 mov	 eax, DWORD PTR _msg$[esp+44]
  02b34	50		 push	 eax
  02b35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___endthreadex
  02b3b	83 c4 04	 add	 esp, 4

; 7953 : 	return( FALSE );

  02b3e	33 c0		 xor	 eax, eax
  02b40	5f		 pop	 edi
  02b41	5e		 pop	 esi

; 7954 : }

  02b42	83 c4 1c	 add	 esp, 28			; 0000001cH
  02b45	c2 04 00	 ret	 4
_TextToSpeechThreadMain@4 ENDP
_TEXT	ENDS
EXTRN	__imp__LoadIconA@8:NEAR
EXTRN	__imp__RegisterClassA@4:NEAR
EXTRN	__imp__SetWindowLongA@12:NEAR
EXTRN	__imp__CreateWindowExA@48:NEAR
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__LoadCursorA@8:NEAR
_DATA	SEGMENT
	ORG $+2
$SG72560 DB	'TextToSpeechWndClass', 00H
	ORG $+3
$SG72561 DB	'%s_%08X', 00H
$SG72575 DB	'TextToSpeech Output, v1.0', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_wc$ = -296
_wndclass$ = -256
_InitTextToSpeechWindow PROC NEAR

; 8123 : {

  02b50	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  02b56	56		 push	 esi
  02b57	57		 push	 edi

; 8124 : 	WNDCLASS wc;
; 8125 : 	HWND hWnd;
; 8126 : 	HINSTANCE hInstance;
; 8127 : 	char wndclass[255];
; 8128 : 	
; 8129 : 	/********************************************************************/
; 8130 : 	/*  Register a TextToSpeech Window Class.                           */
; 8131 : 	/*  Get the hInstance for the new Window.                           */
; 8132 : 	/********************************************************************/
; 8133 : 	
; 8134 : 	// tek 13nov97 why do we think the phTTS->hWnd is anything useful??
; 8135 : 	hInstance = NULL;
; 8136 : 	//hInstance = (HINSTANCE)GetWindowLong( phTTS->hWnd,
; 8137 : 	//					GWL_HINSTANCE );
; 8138 : 	
; 8139 : 	/********************************************************************/
; 8140 : 	/*  Register a TextToSpeech window class.                           */
; 8141 : 	/********************************************************************/
; 8142 : 	
; 8143 : 	sprintf(wndclass,"%s_%08X",TEXTTOSPEECHWNDCLASS,(unsigned long int) phTTS);

  02b58	8b bc 24 34 01
	00 00		 mov	 edi, DWORD PTR _phTTS$[esp+300]
  02b5f	8d 44 24 30	 lea	 eax, DWORD PTR _wndclass$[esp+304]
  02b63	57		 push	 edi
  02b64	68 00 00 00 00	 push	 OFFSET FLAT:$SG72560
  02b69	68 00 00 00 00	 push	 OFFSET FLAT:$SG72561
  02b6e	50		 push	 eax
  02b6f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  02b75	83 c4 10	 add	 esp, 16			; 00000010H

; 8144 : 	wc.lpszClassName = wndclass;

  02b78	8d 4c 24 30	 lea	 ecx, DWORD PTR _wndclass$[esp+304]
  02b7c	89 4c 24 2c	 mov	 DWORD PTR _wc$[esp+340], ecx

; 8145 : 	wc.lpfnWndProc =   TextToSpeechWndProc;

  02b80	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+308], OFFSET FLAT:_TextToSpeechWndProc@16

; 8146 : 	wc.hInstance =     hInstance;
; 8147 : #ifndef UNDER_CE
; 8148 : 	wc.hCursor =       LoadCursor( 0, IDC_ARROW );

  02b88	68 00 7f 00 00	 push	 32512			; 00007f00H
  02b8d	6a 00		 push	 0
  02b8f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+328], 0
  02b97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8

; 8149 : 	wc.hIcon =         LoadIcon( 0, IDI_APPLICATION );

  02b9d	68 00 7f 00 00	 push	 32512			; 00007f00H
  02ba2	6a 00		 push	 0
  02ba4	89 44 24 28	 mov	 DWORD PTR _wc$[esp+336], eax
  02ba8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8

; 8150 : #else
; 8151 : 	wc.hCursor =       NULL;
; 8152 : 	wc.hIcon =         NULL;
; 8153 : #endif
; 8154 : 	wc.hbrBackground = (HBRUSH)( COLOR_APPWORKSPACE+1 );
; 8155 : 	wc.lpszMenuName =  NULL;
; 8156 : #ifndef UNDER_CE
; 8157 : 	wc.style =         CS_OWNDC;
; 8158 : #else
; 8159 : 	wc.style =         NULL;
; 8160 : #endif
; 8161 : 	wc.cbClsExtra =    0;
; 8162 : 	wc.cbWndExtra =    8;         /* MVP :To store phTTS through SetWindowLong */
; 8163 : 	
; 8164 : 	RegisterClass( &wc );

  02bae	8d 54 24 08	 lea	 edx, DWORD PTR _wc$[esp+304]
  02bb2	89 44 24 1c	 mov	 DWORD PTR _wc$[esp+324], eax
  02bb6	52		 push	 edx
  02bb7	c7 44 24 28 0d
	00 00 00	 mov	 DWORD PTR _wc$[esp+336], 13 ; 0000000dH
  02bbf	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+340], 0
  02bc7	c7 44 24 0c 20
	00 00 00	 mov	 DWORD PTR _wc$[esp+308], 32 ; 00000020H
  02bcf	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+316], 0
  02bd7	c7 44 24 18 08
	00 00 00	 mov	 DWORD PTR _wc$[esp+320], 8
  02bdf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4

; 8165 : 	
; 8166 : 	/********************************************************************/
; 8167 : 	/*  Create an Invisible TextToSpeech Window.                        */
; 8168 : 	/********************************************************************/
; 8169 : 	
; 8170 : #ifndef UNDER_CE
; 8171 : 	hWnd = CreateWindow( wndclass,
; 8172 : 		"TextToSpeech Output, v1.0",
; 8173 : 		WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW,
; 8174 : 		CW_USEDEFAULT,
; 8175 : 		CW_USEDEFAULT,
; 8176 : 		CW_USEDEFAULT,
; 8177 : 		CW_USEDEFAULT,
; 8178 : 		0,
; 8179 : 		0,
; 8180 : 		hInstance,
; 8181 : 		NULL);      /*MVP : was (LPVOID)phTTS ,This is changed to avoid

  02be5	6a 00		 push	 0
  02be7	6a 00		 push	 0
  02be9	6a 00		 push	 0
  02beb	6a 00		 push	 0
  02bed	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02bf2	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02bf7	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02bfc	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02c01	68 00 00 cf 02	 push	 47120384		; 02cf0000H
  02c06	8d 44 24 54	 lea	 eax, DWORD PTR _wndclass$[esp+340]
  02c0a	68 00 00 00 00	 push	 OFFSET FLAT:$SG72575
  02c0f	50		 push	 eax
  02c10	6a 00		 push	 0
  02c12	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  02c18	8b f0		 mov	 esi, eax

; 8182 : 					static declaration of this handle in TextToSpeechWndProc
; 8183 : 					Now this handle will be available through call to
; 8184 : 	GetWindowLong */
; 8185 : #else
; 8186 : 	hWnd = CreateWindow( wndclass,
; 8187 : 		"TextToSpeech Output, v1.0",
; 8188 : 		WS_CLIPCHILDREN | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
; 8189 : 		CW_USEDEFAULT,
; 8190 : 		CW_USEDEFAULT,
; 8191 : 		CW_USEDEFAULT,
; 8192 : 		CW_USEDEFAULT,
; 8193 : 		0,
; 8194 : 		0,
; 8195 : 		hInstance,
; 8196 : 		NULL);      /*MVP : was (LPVOID)phTTS ,This is changed to avoid
; 8197 : 					static declaration of this handle in TextToSpeechWndProc
; 8198 : 					Now this handle will be available through call to
; 8199 : 	GetWindowLong */
; 8200 : #endif
; 8201 : 	
; 8202 : 	if( ! hWnd )

  02c1a	85 f6		 test	 esi, esi
  02c1c	75 09		 jne	 SHORT $L72576
  02c1e	5f		 pop	 edi
  02c1f	5e		 pop	 esi

; 8211 : }

  02c20	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  02c26	c3		 ret	 0
$L72576:

; 8203 : 		return( NULL );
; 8204 : 	
; 8205 : 	/*MVP : Store phTTS in Window extra memory for later use in Wndproc */
; 8206 : 	SetWindowLong(hWnd,GWL_USERDATA,(LONG)phTTS);

  02c27	57		 push	 edi
  02c28	6a eb		 push	 -21			; ffffffebH
  02c2a	56		 push	 esi
  02c2b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 8207 : 	
; 8208 : 	ShowWindow( hWnd, SW_HIDE );

  02c31	6a 00		 push	 0
  02c33	56		 push	 esi
  02c34	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 8209 : 	
; 8210 : 	return( hWnd );

  02c3a	8b c6		 mov	 eax, esi
  02c3c	5f		 pop	 edi
  02c3d	5e		 pop	 esi

; 8211 : }

  02c3e	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  02c44	c3		 ret	 0
_InitTextToSpeechWindow ENDP
_TEXT	ENDS
EXTRN	__imp__DefWindowProcA@16:NEAR
EXTRN	__imp__PostQuitMessage@4:NEAR
EXTRN	__imp__GetWindowLongA@8:NEAR
EXTRN	__imp__DestroyWindow@4:NEAR
_TEXT	SEGMENT
_hWnd$ = 8
_message$ = 12
_wParam$ = 16
_lParam$ = 20
_TextToSpeechWndProc@16 PROC NEAR

; 8229 : {

  02c50	56		 push	 esi
  02c51	57		 push	 edi

; 8230 : 	
; 8231 : LPTTS_HANDLE_T phTTS;                    /* MVP : Avoided static behaviour through
; 8232 : 										 using GetWindowLong to retrieve the handle 
; 8233 : 										 from window extra memory,which was set
; 8234 : when window was created */
; 8235 : 
; 8236 : phTTS = (LPTTS_HANDLE_T)GetWindowLong(hWnd,GWL_USERDATA);

  02c52	8b 7c 24 0c	 mov	 edi, DWORD PTR _hWnd$[esp+4]
  02c56	6a eb		 push	 -21			; ffffffebH
  02c58	57		 push	 edi
  02c59	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8

; 8237 : 
; 8238 : switch( message )
; 8239 : {

  02c5f	8b 74 24 10	 mov	 esi, DWORD PTR _message$[esp+4]
  02c63	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  02c69	77 33		 ja	 SHORT $L73336
  02c6b	74 19		 je	 SHORT $L72595
  02c6d	8b c6		 mov	 eax, esi
  02c6f	48		 dec	 eax
  02c70	74 0d		 je	 SHORT $L72594
  02c72	48		 dec	 eax
  02c73	75 38		 jne	 SHORT $L72591

; 8263 : 	
; 8264 : case ID_TTS_Destroy:
; 8265 : 	
; 8266 : 	DestroyWindow( hWnd );
; 8267 : 	
; 8268 : 	break;
; 8269 : 	
; 8270 : 	/********************************************************************/
; 8271 : 	/*  The WM_DESTROY message is used to destroy a window.             */
; 8272 : 	/********************************************************************/
; 8273 : 	
; 8274 : case WM_DESTROY:
; 8275 : 	
; 8276 : 	PostQuitMessage(0);

  02c75	6a 00		 push	 0
  02c77	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 8277 : 	
; 8278 : 	break;

  02c7d	eb 2e		 jmp	 SHORT $L72591
$L72594:
  02c7f	5f		 pop	 edi

; 8240 : 	/********************************************************************/
; 8241 : 	/*  TextToSpeech intialization occurs here.                         */
; 8242 : 	/********************************************************************/
; 8243 : 	
; 8244 : case WM_CREATE:
; 8245 : 	
; 8246 : 	/******************************************************************/
; 8247 : 	/*  Initialize pointer to the TextToSpeech parameter structure.   */
; 8248 : 	/******************************************************************/
; 8249 : 	/*MVP : Commented out, Value is retreived Through GetWindowLong */
; 8250 : 	/*phTTS = (LPTTS_HANDLE_T)(((LPCREATESTRUCT)lParam)->lpCreateParams);*/
; 8251 : 	
; 8252 : 	return( FALSE );

  02c80	33 c0		 xor	 eax, eax
  02c82	5e		 pop	 esi

; 8284 : }

  02c83	c2 10 00	 ret	 16			; 00000010H
$L72595:

; 8253 : 	
; 8254 : 	/********************************************************************/
; 8255 : 	/*  Process the TextToSpeech message.                               */
; 8256 : 	/********************************************************************/
; 8257 : 	
; 8258 : case ID_TTS_Queue_Text:
; 8259 : 	
; 8260 : 	Process_TTS_Message( phTTS, lParam );

  02c86	8b 4c 24 18	 mov	 ecx, DWORD PTR _lParam$[esp+4]
  02c8a	51		 push	 ecx
  02c8b	50		 push	 eax
  02c8c	e8 00 00 00 00	 call	 _Process_TTS_Message
  02c91	83 c4 08	 add	 esp, 8

; 8261 : 	
; 8262 : 	return( TRUE );

  02c94	b8 01 00 00 00	 mov	 eax, 1
  02c99	5f		 pop	 edi
  02c9a	5e		 pop	 esi

; 8284 : }

  02c9b	c2 10 00	 ret	 16			; 00000010H
$L73336:

; 8237 : 
; 8238 : switch( message )
; 8239 : {

  02c9e	81 fe 01 04 00
	00		 cmp	 esi, 1025		; 00000401H

; 8279 : 	
; 8280 : default:
; 8281 : 	break;

  02ca4	75 07		 jne	 SHORT $L72591
  02ca6	57		 push	 edi
  02ca7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$L72591:

; 8282 : }
; 8283 : return( DefWindowProc( hWnd, message, wParam, lParam ));

  02cad	8b 54 24 18	 mov	 edx, DWORD PTR _lParam$[esp+4]
  02cb1	8b 44 24 14	 mov	 eax, DWORD PTR _wParam$[esp+4]
  02cb5	52		 push	 edx
  02cb6	50		 push	 eax
  02cb7	56		 push	 esi
  02cb8	57		 push	 edi
  02cb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  02cbf	5f		 pop	 edi
  02cc0	5e		 pop	 esi

; 8284 : }

  02cc1	c2 10 00	 ret	 16			; 00000010H
_TextToSpeechWndProc@16 ENDP
_phTTS$ = 8
_lParam$ = 12
_Process_TTS_Message PROC NEAR

; 8316 : {

  02cd0	53		 push	 ebx
  02cd1	55		 push	 ebp
  02cd2	56		 push	 esi

; 8317 : 	UINT uiLength;
; 8318 : 	unsigned char * pText;
; 8319 : 	TEXT_MSG_T * pTextMsg;
; 8320 : 	
; 8321 : 	pTextMsg = (TEXT_MSG_T *)lParam;
; 8322 : 	//OutputDebugString("	Process_TTS_Message().\n");
; 8323 : #ifdef API_DEBUG //tek 12aug97
; 8324 : 	{
; 8325 : 		char szTemp[256]="";
; 8326 : 		sprintf(szTemp,"Process_TTS_Message #%u at %lu\n",
; 8327 : 			pTextMsg->uiMsgNumber,
; 8328 : 			timeGetTime());
; 8329 : 		OutputDebugString(szTemp);
; 8330 : 	}
; 8331 : #endif //API_DEBUG
; 8332 : 	
; 8333 : 	/********************************************************************/
; 8334 : 	/*  If the posted Text-To-Speech message number is less than the    */
; 8335 : 	/*  message number of the last flush message, then throw the        */
; 8336 : 	/*  Text-To-Speech message away.                                    */
; 8337 : 	/********************************************************************/
; 8338 : 	
; 8339 : 	EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  02cd3	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  02cd7	57		 push	 edi
  02cd8	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  02cde	50		 push	 eax
  02cdf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 8340 : 	
; 8341 : 	if ( pTextMsg->uiMsgNumber > phTTS->uiFlushMsgNumber )

  02ce5	8b 5c 24 18	 mov	 ebx, DWORD PTR _lParam$[esp+12]
  02ce9	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  02cec	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02cee	3b c8		 cmp	 ecx, eax
  02cf0	76 61		 jbe	 SHORT $L72608

; 8342 : 	{
; 8343 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  02cf2	8b 96 bc 00 00
	00		 mov	 edx, DWORD PTR [esi+188]
  02cf8	52		 push	 edx
  02cf9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 8344 : #ifdef API_DEBUG
; 8345 : 		OutputDebugString("  .. TTSMessage processing.\n");
; 8346 : #endif //API_DEBUG
; 8347 : 		uiLength = pTextMsg->uiLength;

  02cff	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 8348 : #ifdef TYPING_MODE // tek 17jun97
; 8349 : 		if (uiLength>0)
; 8350 : 			phTTS->bInTypingMode = FALSE;
; 8351 : #endif //TYPING_MODE
; 8352 : 		pText = pTextMsg->pText;

  02d02	8b 6b 08	 mov	 ebp, DWORD PTR [ebx+8]

; 8353 : 		
; 8354 : 		/******************************************************************/
; 8355 : 		/*  Queue the text unless a TextToSpeechReset() forces an abort   */
; 8356 : 		/*  by setting the KS.halting flag.                               */
; 8357 : 		/******************************************************************/
; 8358 : 		/* we have to check for halting inside the loop, else we will hang */
; 8359 : 		/* if we have a lot of text to speak. We should probably also block*/
; 8360 : 		/* here, rather than in write_pipe(), on the pipe full condition, */
; 8361 : 		/* but that's probably chrome.. it would let us respond to a flush*/
; 8362 : 		/* a little faster. (tek 08jan97) */
; 8363 : 		
; 8364 : 		while (( uiLength > MAX_TEXT_WRITE_LENGTH ) 
; 8365 : 			&& ( ! (phTTS->pKernelShareData->halting))   // tek 08jan97
; 8366 : 			//      && ( ! (phTTS->pKernelShareData->halting))
; 8367 : 			)

  02d05	83 ff 10	 cmp	 edi, 16			; 00000010H
  02d08	76 2a		 jbe	 SHORT $L72611
$L72610:
  02d0a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02d0d	8b 88 74 01 00
	00		 mov	 ecx, DWORD PTR [eax+372]
  02d13	85 c9		 test	 ecx, ecx
  02d15	75 1d		 jne	 SHORT $L72611

; 8368 : 		{
; 8369 : 			//OutputDebugString(" .. text to write_pipe \n");
; 8370 : 			write_pipe( phTTS->pKernelShareData->cmd_pipe, pText, MAX_TEXT_WRITE_LENGTH );

  02d17	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [eax+216]
  02d1d	6a 10		 push	 16			; 00000010H
  02d1f	55		 push	 ebp
  02d20	50		 push	 eax
  02d21	e8 00 00 00 00	 call	 _write_pipe

; 8371 : 			uiLength -= MAX_TEXT_WRITE_LENGTH;

  02d26	83 ef 10	 sub	 edi, 16			; 00000010H
  02d29	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8372 : 			pText += MAX_TEXT_WRITE_LENGTH;

  02d2c	83 c5 10	 add	 ebp, 16			; 00000010H
  02d2f	83 ff 10	 cmp	 edi, 16			; 00000010H
  02d32	77 d6		 ja	 SHORT $L72610
$L72611:

; 8373 : 		}
; 8374 : 		
; 8375 : 		if (( uiLength > 0 ) 
; 8376 : 			&& (uiLength <= MAX_TEXT_WRITE_LENGTH)	/* tek 08jan97 */
; 8377 : 			//      && ( ! phTTS->pKernelShareData->halting )
; 8378 : 			)

  02d34	85 ff		 test	 edi, edi
  02d36	76 28		 jbe	 SHORT $L72613
  02d38	83 ff 10	 cmp	 edi, 16			; 00000010H
  02d3b	77 23		 ja	 SHORT $L72613

; 8379 : 		{
; 8380 : 			//OutputDebugString(" .. .. Text to write_pipe \n");
; 8381 : 			write_pipe( phTTS->pKernelShareData->cmd_pipe, pText, uiLength );

  02d3d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02d40	57		 push	 edi
  02d41	55		 push	 ebp
  02d42	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [ecx+216]
  02d48	52		 push	 edx
  02d49	e8 00 00 00 00	 call	 _write_pipe
  02d4e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8382 : 		}
; 8383 : 	}
; 8384 : 	else

  02d51	eb 0d		 jmp	 SHORT $L72613
$L72608:

; 8385 : 	{
; 8386 : #ifdef API_DEBUG
; 8387 : 		OutputDebugString(" .. tossing textmsg due to flush.\n");
; 8388 : #endif //API_DEBUG
; 8389 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  02d53	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  02d59	50		 push	 eax
  02d5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72613:

; 8390 : 	}
; 8391 : 	
; 8392 : 	/********************************************************************/
; 8393 : 	/*  Subtract the characters queued from the queued character count. */
; 8394 : 	/********************************************************************/
; 8395 : 	
; 8396 : 	EnterCriticalSection( phTTS->pcsQueuedCharacterCount );

  02d60	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  02d66	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__EnterCriticalSection@4
  02d6c	51		 push	 ecx
  02d6d	ff d5		 call	 ebp

; 8397 : 	phTTS->uiQueuedCharacterCount -= pTextMsg->uiLength;

  02d6f	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  02d72	8b 7e 40	 mov	 edi, DWORD PTR [esi+64]

; 8398 : 	LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );

  02d75	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  02d7b	2b fa		 sub	 edi, edx
  02d7d	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  02d80	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LeaveCriticalSection@4
  02d86	50		 push	 eax
  02d87	ff d7		 call	 edi

; 8399 : 	
; 8400 : 	/********************************************************************/
; 8401 : 	/*  Update the last queued message parameter for the                */
; 8402 : 	/*  TextToSpeechSync() function.                                    */
; 8403 : 	/********************************************************************/
; 8404 : 	
; 8405 : 	EnterCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  02d89	8b 8e b8 00 00
	00		 mov	 ecx, DWORD PTR [esi+184]
  02d8f	51		 push	 ecx
  02d90	ff d5		 call	 ebp

; 8406 : 	phTTS->uiLastQueuedTextMsgNumber = pTextMsg->uiMsgNumber;
; 8407 : 	LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  02d92	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  02d98	8b 13		 mov	 edx, DWORD PTR [ebx]
  02d9a	50		 push	 eax
  02d9b	89 56 4c	 mov	 DWORD PTR [esi+76], edx
  02d9e	ff d7		 call	 edi

; 8408 : 	
; 8409 : 	/********************************************************************/
; 8410 : 	/*  Free the text buffer and the text message structure.            */
; 8411 : 	/*  These were allocated in the TextToSpeechSpeak() function which  */
; 8412 : 	/*  runs in the applications thread !                               */
; 8413 : 	/********************************************************************/
; 8414 : 	
; 8415 : 	free( pTextMsg->pText );

  02da0	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  02da3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  02da9	51		 push	 ecx
  02daa	ff d6		 call	 esi

; 8416 : 	free( pTextMsg );

  02dac	53		 push	 ebx
  02dad	ff d6		 call	 esi
  02daf	83 c4 08	 add	 esp, 8
  02db2	5f		 pop	 edi
  02db3	5e		 pop	 esi
  02db4	5d		 pop	 ebp
  02db5	5b		 pop	 ebx

; 8417 : 	
; 8418 : 	return;
; 8419 : }

  02db6	c3		 ret	 0
_Process_TTS_Message ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechErrorHandler
_TEXT	SEGMENT
_phTTS$ = 8
_uiErrorCode$ = 12
_mmStatus$ = 16
_TextToSpeechErrorHandler PROC NEAR

; 8456 : 	if ( phTTS->bEnableErrorMessage )

  02dc0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  02dc4	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  02dca	85 c9		 test	 ecx, ecx
  02dcc	74 21		 je	 SHORT $L72621

; 8457 : 	{
; 8458 : 		phTTS->bEnableErrorMessage = FALSE;
; 8459 : 		/*
; 8460 : 		SendMessage( phTTS->hWnd,
; 8461 : 		phTTS->uiID_Error_Message,
; 8462 : 		(WPARAM)uiErrorCode,
; 8463 : 		(LPARAM)mmStatus );
; 8464 : 		*/
; 8465 : 		//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code:
; 8466 : #ifdef API_DEBUG
; 8467 : 		OutputDebugString("returning error message. \n");
; 8468 : #endif //API_DEBUG
; 8469 : 		Report_TTS_Status(phTTS,phTTS->uiID_Error_Message,(WPARAM)uiErrorCode,(LPARAM)mmStatus);

  02dce	8b 4c 24 0c	 mov	 ecx, DWORD PTR _mmStatus$[esp-4]
  02dd2	8b 54 24 08	 mov	 edx, DWORD PTR _uiErrorCode$[esp-4]
  02dd6	51		 push	 ecx
  02dd7	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  02dda	52		 push	 edx
  02ddb	51		 push	 ecx
  02ddc	50		 push	 eax
  02ddd	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], 0
  02de7	e8 00 00 00 00	 call	 _Report_TTS_Status
  02dec	83 c4 10	 add	 esp, 16			; 00000010H
$L72621:

; 8470 : 		
; 8471 : 	}
; 8472 : 	return;
; 8473 : }

  02def	c3		 ret	 0
_TextToSpeechErrorHandler ENDP
_TEXT	ENDS
PUBLIC	_WriteAudioToFile
_TEXT	SEGMENT
_phTTS$ = 8
_pBuffer$ = 12
_uiLength$ = 16
_WriteAudioToFile PROC NEAR

; 8541 : {

  02df0	53		 push	 ebx

; 8542 : 	UINT i;
; 8543 : 	unsigned char * pByteDest;
; 8544 : 	LPSAMPLE_T pSource;
; 8545 : 	size_t Size;
; 8546 : 	
; 8547 : 	/********************************************************************/
; 8548 : 	/*  Convert the 16 bit samples to the desired output format.        */
; 8549 : 	/********************************************************************/
; 8550 : 	
; 8551 : 	switch( phTTS->dwFormat )
; 8552 : 	{

  02df1	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  02df5	55		 push	 ebp
  02df6	8b 6c 24 14	 mov	 ebp, DWORD PTR _uiLength$[esp+4]
  02dfa	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [ebx+128]
  02e00	56		 push	 esi
  02e01	48		 dec	 eax
  02e02	74 48		 je	 SHORT $L72642
  02e04	83 e8 03	 sub	 eax, 3
  02e07	74 3c		 je	 SHORT $L72640
  02e09	83 e8 03	 sub	 eax, 3
  02e0c	74 09		 je	 SHORT $L72649
  02e0e	5e		 pop	 esi
  02e0f	5d		 pop	 ebp

; 8582 : 		
; 8583 : 	default:
; 8584 : 		
; 8585 : 		return( MMSYSERR_INVALHANDLE );

  02e10	b8 05 00 00 00	 mov	 eax, 5
  02e15	5b		 pop	 ebx

; 8601 : }

  02e16	c3		 ret	 0
$L72649:

; 8568 : 		
; 8569 : 		break;
; 8570 : 		
; 8571 : 	case WAVE_FORMAT_08M08:
; 8572 : 		
; 8573 : 		pSource = pBuffer;

  02e17	8b 74 24 14	 mov	 esi, DWORD PTR _pBuffer$[esp+8]
  02e1b	57		 push	 edi

; 8574 : 		pByteDest = (unsigned char *)pBuffer;
; 8575 : 		
; 8576 : 		for ( i = 0; i < uiLength; i++ )

  02e1c	85 ed		 test	 ebp, ebp
  02e1e	8b fe		 mov	 edi, esi
  02e20	76 1b		 jbe	 SHORT $L72653

; 8568 : 		
; 8569 : 		break;
; 8570 : 		
; 8571 : 	case WAVE_FORMAT_08M08:
; 8572 : 		
; 8573 : 		pSource = pBuffer;

  02e22	8b dd		 mov	 ebx, ebp
$L72651:

; 8577 : 			*pByteDest++ = LinearToMuLaw( *pSource++ );

  02e24	66 8b 06	 mov	 ax, WORD PTR [esi]
  02e27	83 c6 02	 add	 esi, 2
  02e2a	50		 push	 eax
  02e2b	e8 00 00 00 00	 call	 _LinearToMuLaw
  02e30	83 c4 04	 add	 esp, 4
  02e33	88 07		 mov	 BYTE PTR [edi], al
  02e35	47		 inc	 edi
  02e36	4b		 dec	 ebx
  02e37	75 eb		 jne	 SHORT $L72651

; 8574 : 		pByteDest = (unsigned char *)pBuffer;
; 8575 : 		
; 8576 : 		for ( i = 0; i < uiLength; i++ )

  02e39	8b 5c 24 14	 mov	 ebx, DWORD PTR _phTTS$[esp+12]
$L72653:

; 8578 : 		
; 8579 : 		Size = sizeof( unsigned char );

  02e3d	b8 01 00 00 00	 mov	 eax, 1
  02e42	5f		 pop	 edi

; 8580 : 		
; 8581 : 		break;

  02e43	eb 2a		 jmp	 SHORT $L72637
$L72640:

; 8553 : 	case WAVE_FORMAT_1M16:
; 8554 : 		
; 8555 : 		Size = sizeof( short );

  02e45	b8 02 00 00 00	 mov	 eax, 2

; 8556 : 		
; 8557 : 		break;

  02e4a	eb 23		 jmp	 SHORT $L72637
$L72642:

; 8558 : 		
; 8559 : 	case WAVE_FORMAT_1M08:
; 8560 : 		
; 8561 : 		pSource = pBuffer;

  02e4c	8b 44 24 14	 mov	 eax, DWORD PTR _pBuffer$[esp+8]

; 8562 : 		pByteDest = (unsigned char *)pBuffer;
; 8563 : 		
; 8564 : 		for ( i = 0; i < uiLength; i++ )

  02e50	85 ed		 test	 ebp, ebp
  02e52	8b c8		 mov	 ecx, eax
  02e54	76 14		 jbe	 SHORT $L72646

; 8558 : 		
; 8559 : 	case WAVE_FORMAT_1M08:
; 8560 : 		
; 8561 : 		pSource = pBuffer;

  02e56	8b f5		 mov	 esi, ebp
$L72644:

; 8565 : 			*pByteDest++ = ((unsigned char)((*pSource++) >> 8)) ^ 0x80;

  02e58	66 8b 11	 mov	 dx, WORD PTR [ecx]
  02e5b	83 c1 02	 add	 ecx, 2
  02e5e	c1 fa 08	 sar	 edx, 8
  02e61	80 f2 80	 xor	 dl, 128			; 00000080H
  02e64	88 10		 mov	 BYTE PTR [eax], dl
  02e66	40		 inc	 eax
  02e67	4e		 dec	 esi
  02e68	75 ee		 jne	 SHORT $L72644
$L72646:

; 8566 : 		
; 8567 : 		Size = sizeof( unsigned char );

  02e6a	b8 01 00 00 00	 mov	 eax, 1
$L72637:

; 8586 : 	}
; 8587 : 	
; 8588 : 	/********************************************************************/
; 8589 : 	/*  Write the audio samples to the output file.                     */
; 8590 : 	/********************************************************************/
; 8591 : 	
; 8592 : 	if ( uiLength != fwrite( (char *)pBuffer,
; 8593 : 		Size,
; 8594 : 		(size_t)uiLength,
; 8595 : 		phTTS->pWaveFile ))

  02e6f	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [ebx+148]
  02e75	8b 54 24 14	 mov	 edx, DWORD PTR _pBuffer$[esp+8]
  02e79	51		 push	 ecx
  02e7a	55		 push	 ebp
  02e7b	50		 push	 eax
  02e7c	52		 push	 edx
  02e7d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  02e83	83 c4 10	 add	 esp, 16			; 00000010H
  02e86	3b e8		 cmp	 ebp, eax
  02e88	74 09		 je	 SHORT $L72658
  02e8a	5e		 pop	 esi
  02e8b	5d		 pop	 ebp

; 8596 : 		return( MMSYSERR_ERROR );

  02e8c	b8 01 00 00 00	 mov	 eax, 1
  02e91	5b		 pop	 ebx

; 8601 : }

  02e92	c3		 ret	 0
$L72658:

; 8597 : 	
; 8598 : 	phTTS->dwFileSampleCount += uiLength;

  02e93	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  02e96	5e		 pop	 esi
  02e97	03 c5		 add	 eax, ebp
  02e99	5d		 pop	 ebp
  02e9a	89 43 78	 mov	 DWORD PTR [ebx+120], eax

; 8599 : 	
; 8600 : 	return( MMSYSERR_NOERROR );

  02e9d	33 c0		 xor	 eax, eax
  02e9f	5b		 pop	 ebx

; 8601 : }

  02ea0	c3		 ret	 0
_WriteAudioToFile ENDP
_wSample$ = 8
_LinearToMuLaw PROC NEAR

; 8640 : 	static short wExponentLut[256] = { 0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
; 8641 : 		4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
; 8642 : 		5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
; 8643 : 		5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
; 8644 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 8645 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 8646 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 8647 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 8648 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8649 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8650 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8651 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8652 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8653 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8654 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8655 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 };
; 8656 : 	short wSign;
; 8657 : 	short wExponent;
; 8658 : 	short wMantissa;
; 8659 : 	unsigned char cMuLawByte;
; 8660 : 	
; 8661 : 	/********************************************************************/
; 8662 : 	/*  Get the sample into sign-magnitude.                             */
; 8663 : 	/*  First save the sign.                                            */
; 8664 : 	/********************************************************************/
; 8665 : 	
; 8666 : 	wSign = ( wSample >> 8 ) & 0x80;

  02eb0	8b 44 24 04	 mov	 eax, DWORD PTR _wSample$[esp-4]
  02eb4	53		 push	 ebx
  02eb5	8b d8		 mov	 ebx, eax
  02eb7	c1 fb 08	 sar	 ebx, 8
  02eba	81 e3 80 00 00
	00		 and	 ebx, 128		; 00000080H

; 8667 : 	
; 8668 : 	/********************************************************************/
; 8669 : 	/*  Get magnitude.                                                  */
; 8670 : 	/********************************************************************/
; 8671 : 	
; 8672 : 	if ( wSign != 0 )

  02ec0	66 85 db	 test	 bx, bx
  02ec3	74 02		 je	 SHORT $L72668

; 8673 : 		wSample = - wSample;

  02ec5	f7 d8		 neg	 eax
$L72668:

; 8674 : 	
; 8675 : 	/********************************************************************/
; 8676 : 	/*  Clip the magnitude.                                             */
; 8677 : 	/********************************************************************/
; 8678 : 	
; 8679 : 	if ( wSample > MULAW_CLIP_LEVEL )

  02ec7	66 3d 7b 7f	 cmp	 ax, 32635		; 00007f7bH
  02ecb	7e 05		 jle	 SHORT $L72669

; 8680 : 		wSample = MULAW_CLIP_LEVEL;

  02ecd	b8 7b 7f 00 00	 mov	 eax, 32635		; 00007f7bH
$L72669:

; 8681 : 	
; 8682 : 	/********************************************************************/
; 8683 : 	/*  Convert from 16 bit linear to mu-law.                           */
; 8684 : 	/********************************************************************/
; 8685 : 	
; 8686 : 	wSample = wSample + MULAW_BIAS;

  02ed2	05 84 00 00 00	 add	 eax, 132		; 00000084H

; 8687 : 	wExponent = wExponentLut[ ( wSample >> 7 ) & 0xFF ];

  02ed7	8b c8		 mov	 ecx, eax
  02ed9	c1 f9 07	 sar	 ecx, 7
  02edc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02ee2	66 8b 14 4d 00
	00 00 00	 mov	 dx, WORD PTR _?wExponentLut@?1??LinearToMuLaw@@9@9[ecx*2]

; 8688 : 	wMantissa = ( wSample >> ( wExponent + 3 ) ) & 0x0F;

  02eea	66 8b ca	 mov	 cx, dx
  02eed	66 83 c1 03	 add	 cx, 3
  02ef1	66 d3 f8	 sar	 ax, cl

; 8689 : 	cMuLawByte = ~ ( wSign | ( wExponent << 4 ) | wMantissa );

  02ef4	c0 e2 04	 shl	 dl, 4
  02ef7	24 0f		 and	 al, 15			; 0000000fH

; 8690 : 	
; 8691 : 	/********************************************************************/
; 8692 : 	/*  Optional CCITT trap                                             */
; 8693 : 	/********************************************************************/
; 8694 : 	
; 8695 : #ifdef ZEROTRAP
; 8696 : 	if ( cMuLawByte == 0 )
; 8697 : 		cMuLawByte = 0x02;
; 8698 : #endif //ZEROTRAP
; 8699 : 	
; 8700 : 	return( cMuLawByte );

  02ef9	0a c2		 or	 al, dl
  02efb	0a c3		 or	 al, bl
  02efd	5b		 pop	 ebx
  02efe	f6 d0		 not	 al

; 8701 : }

  02f00	c3		 ret	 0
_LinearToMuLaw ENDP
_TEXT	ENDS
PUBLIC	_WaitForLtsFlush
_TEXT	SEGMENT
_phTTS$ = 8
_dwWaitTimeInMsec$ = 12
_dwTotalTimeInMsec$ = -4
_WaitForLtsFlush PROC NEAR

; 8745 : {

  02f10	51		 push	 ecx

; 8746 : 	BOOL bPipesNotEmpty;
; 8747 : 	UINT uiSyncCount;
; 8748 : 	UINT uiVtmCount;
; 8749 : 	UINT uiPhCount;
; 8750 : 	UINT uiLtsCount;
; 8751 : #ifdef WIN32
; 8752 : 	UINT	uiSleepTime;
; 8753 : #endif
; 8754 : 	DWORD dwTotalTimeInMsec;
; 8755 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 8756 : 	* and initialize from phTTS structure
; 8757 : 	*/
; 8758 : 	PKSD_T pKsd_t = NULL;
; 8759 : 	
; 8760 : 	pKsd_t = phTTS->pKernelShareData;

  02f11	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  02f15	53		 push	 ebx
  02f16	55		 push	 ebp
  02f17	56		 push	 esi
  02f18	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  02f1b	57		 push	 edi

; 8761 : #ifdef TYPING_MODE
; 8762 : 	if (phTTS->bInTypingMode)
; 8763 : 		uiSleepTime=1; // just reschedule
; 8764 : 	else
; 8765 : #endif //TYPING_MODE
; 8766 : #ifdef WIN32
; 8767 : 		uiSleepTime=WAIT_PIPE_SLEEP_TIME;
; 8768 : #endif
; 8769 : 	/********************************************************************/
; 8770 : 	/*  Wait for all the pipes to empty.                                */
; 8771 : 	/*  If the pipes are not empty then sleep for 100 msec. and check   */
; 8772 : 	/*  them again.                                                     */
; 8773 : 	/********************************************************************/
; 8774 : 	
; 8775 : 	dwTotalTimeInMsec = 0;

  02f1c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+20], 0
$L72685:

; 8776 : 	bPipesNotEmpty = TRUE;
; 8777 : 	
; 8778 : 	while ( bPipesNotEmpty )
; 8779 : 	{
; 8780 : 		bPipesNotEmpty = FALSE;
; 8781 : 		
; 8782 : 		uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  02f24	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  02f2a	51		 push	 ecx
  02f2b	e8 00 00 00 00	 call	 _pipe_count

; 8783 : 		uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  02f30	8b 96 dc 00 00
	00		 mov	 edx, DWORD PTR [esi+220]
  02f36	8b f8		 mov	 edi, eax
  02f38	52		 push	 edx
  02f39	e8 00 00 00 00	 call	 _pipe_count
  02f3e	8b d8		 mov	 ebx, eax

; 8784 : 		uiPhCount = pipe_count( pKsd_t->ph_pipe );

  02f40	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  02f46	50		 push	 eax
  02f47	e8 00 00 00 00	 call	 _pipe_count

; 8785 : 		uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  02f4c	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  02f52	8b e8		 mov	 ebp, eax
  02f54	51		 push	 ecx
  02f55	e8 00 00 00 00	 call	 _pipe_count
  02f5a	83 c4 10	 add	 esp, 16			; 00000010H

; 8786 : 		
; 8787 : 		if  (( uiSyncCount != 0 )
; 8788 : 			|| ( uiVtmCount != 0 )
; 8789 : 			|| ( uiPhCount != 0 )
; 8790 : 			|| ( uiLtsCount != 0 ))

  02f5d	85 ff		 test	 edi, edi
  02f5f	75 55		 jne	 SHORT $L72691
  02f61	85 db		 test	 ebx, ebx
  02f63	75 51		 jne	 SHORT $L72691
  02f65	85 ed		 test	 ebp, ebp
  02f67	75 4d		 jne	 SHORT $L72691
  02f69	85 c0		 test	 eax, eax

; 8791 : 			bPipesNotEmpty = TRUE;
; 8792 : 		
; 8793 : 		/******************************************************************/
; 8794 : 		/*  If bPipesNotEmpty is still FALSE here then the pipes are      */
; 8795 : 		/*  probably empty. It is possible that there is still data in    */
; 8796 : 		/*  the pipes, but that it moved out of a pipe we are about to    */
; 8797 : 		/*  check into a pipe we have we just checked. We now check the   */
; 8798 : 		/*  pipes in the reverse order.                                   */
; 8799 : 		/******************************************************************/
; 8800 : 		
; 8801 : 		if ( ! bPipesNotEmpty )

  02f6b	75 49		 jne	 SHORT $L72691

; 8802 : 		{
; 8803 : 		/*
; 8804 : 		kernel_disable(pKsd_t);
; 8805 : 			*/
; 8806 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  02f6d	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  02f73	52		 push	 edx
  02f74	e8 00 00 00 00	 call	 _pipe_count
  02f79	8b e8		 mov	 ebp, eax

; 8807 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  02f7b	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  02f81	50		 push	 eax
  02f82	e8 00 00 00 00	 call	 _pipe_count

; 8808 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  02f87	8b 8e dc 00 00
	00		 mov	 ecx, DWORD PTR [esi+220]
  02f8d	8b d8		 mov	 ebx, eax
  02f8f	51		 push	 ecx
  02f90	e8 00 00 00 00	 call	 _pipe_count

; 8809 : 			uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  02f95	8b 96 e0 00 00
	00		 mov	 edx, DWORD PTR [esi+224]
  02f9b	8b f8		 mov	 edi, eax
  02f9d	52		 push	 edx
  02f9e	e8 00 00 00 00	 call	 _pipe_count
  02fa3	83 c4 10	 add	 esp, 16			; 00000010H

; 8810 : 			/*
; 8811 : 			kernel_enable( pKsd_t, uiDummy );
; 8812 : 			*/
; 8813 : 			if  (( uiSyncCount != 0 )
; 8814 : 				|| ( uiVtmCount != 0 )
; 8815 : 				|| ( uiPhCount != 0 )
; 8816 : 				|| ( uiLtsCount != 0 ))

  02fa6	85 c0		 test	 eax, eax
  02fa8	75 0c		 jne	 SHORT $L72691
  02faa	85 ff		 test	 edi, edi
  02fac	75 08		 jne	 SHORT $L72691
  02fae	85 db		 test	 ebx, ebx
  02fb0	75 04		 jne	 SHORT $L72691
  02fb2	85 ed		 test	 ebp, ebp
  02fb4	74 3d		 je	 SHORT $L72686
$L72691:

; 8817 : 				bPipesNotEmpty = TRUE;
; 8818 : 			else
; 8819 : 				bPipesNotEmpty = FALSE;
; 8820 : 		}
; 8821 : 		
; 8822 : 		/******************************************************************/
; 8823 : 		/*  Go to sleep for WAIT_PIPE_SLEEP_TIME msec.                    */
; 8824 : 		/******************************************************************/
; 8825 : 		
; 8826 : 		if ( bPipesNotEmpty )
; 8827 : 		{
; 8828 : #ifdef WIN32
; 8829 : 			PumpModeMessage(phTTS->pAudioHandle);

  02fb6	8b 44 24 18	 mov	 eax, DWORD PTR _phTTS$[esp+16]
  02fba	8b 88 d4 00 00
	00		 mov	 ecx, DWORD PTR [eax+212]
  02fc0	51		 push	 ecx
  02fc1	e8 00 00 00 00	 call	 _PumpModeMessage
  02fc6	83 c4 04	 add	 esp, 4

; 8830 : 			Sleep( uiSleepTime );

  02fc9	6a 32		 push	 50			; 00000032H
  02fcb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 8831 : 			dwTotalTimeInMsec += uiSleepTime;

  02fd1	8b 44 24 10	 mov	 eax, DWORD PTR _dwTotalTimeInMsec$[esp+20]

; 8832 : #endif
; 8833 : #if defined __osf__ || defined __linux__
; 8834 : 			OP_Sleep( WAIT_PIPE_SLEEP_TIME );
; 8835 : 			dwTotalTimeInMsec += WAIT_PIPE_SLEEP_TIME;
; 8836 : #endif
; 8837 : 			
; 8838 : 			if ( dwTotalTimeInMsec > dwWaitTimeInMsec )

  02fd5	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwWaitTimeInMsec$[esp+16]
  02fd9	83 c0 32	 add	 eax, 50			; 00000032H
  02fdc	3b c1		 cmp	 eax, ecx
  02fde	89 44 24 10	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+20], eax
  02fe2	0f 86 3c ff ff
	ff		 jbe	 $L72685
  02fe8	5f		 pop	 edi
  02fe9	5e		 pop	 esi
  02fea	5d		 pop	 ebp

; 8839 : 			{
; 8840 : 				return( MMSYSERR_ERROR );

  02feb	b8 01 00 00 00	 mov	 eax, 1
  02ff0	5b		 pop	 ebx

; 8845 : }

  02ff1	59		 pop	 ecx
  02ff2	c3		 ret	 0
$L72686:
  02ff3	5f		 pop	 edi
  02ff4	5e		 pop	 esi
  02ff5	5d		 pop	 ebp

; 8841 : 			}
; 8842 : 		}
; 8843 : 	}
; 8844 : 	return( MMSYSERR_NOERROR );

  02ff6	33 c0		 xor	 eax, eax
  02ff8	5b		 pop	 ebx

; 8845 : }

  02ff9	59		 pop	 ecx
  02ffa	c3		 ret	 0
_WaitForLtsFlush ENDP
_uiOldVtmCount$ = -20
_uiOldPhCount$ = -16
_uiOldLtsCount$ = -12
_uiOldCmdCount$ = -8
_phTTS$ = 8
_uiLockedUpCount$ = -24
_uiLtsCount$ = 8
_uiCmdCount$ = -4
_FixMemoryLockup PROC NEAR

; 8878 : {

  03000	83 ec 18	 sub	 esp, 24			; 00000018H
  03003	53		 push	 ebx

; 8879 : 	BOOL bPipesNotChanging;
; 8880 : 	UINT uiLockedUpCount;
; 8881 : 	UINT uiVtmCount;
; 8882 : 	UINT uiPhCount;
; 8883 : 	UINT uiLtsCount;
; 8884 : 	UINT uiCmdCount;
; 8885 : 	UINT uiOldVtmCount;
; 8886 : 	UINT uiOldPhCount;
; 8887 : 	UINT uiOldLtsCount;
; 8888 : 	UINT uiOldCmdCount;
; 8889 : #ifdef API_DEBUG
; 8890 : 	char szTemp[256]="";
; 8891 : 	ULONG ulStartTime, ulEndTime;
; 8892 : #endif //API_DEBUG
; 8893 : 	
; 8894 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 8895 : 	* and initialize from phTTS structure
; 8896 : 	*/
; 8897 : 	PKSD_T pKsd_t = NULL;
; 8898 : 	
; 8899 : #ifdef API_DEBUG
; 8900 : 	ulStartTime=timeGetTime();
; 8901 : 	sprintf(szTemp,"FixMemoryLockup() at %ld",ulStartTime);
; 8902 : 	OutputDebugString(szTemp);
; 8903 : #endif //API_DEBUG
; 8904 : 	
; 8905 : 	pKsd_t = phTTS->pKernelShareData;

  03004	8b 5c 24 20	 mov	 ebx, DWORD PTR _phTTS$[esp+24]
  03008	55		 push	 ebp
  03009	56		 push	 esi

; 8906 : 	
; 8907 : 	/********************************************************************/
; 8908 : 	/*  Wait for all the pipes to change.                               */
; 8909 : 	/*  If the pipes are not changing then go to sleep                  */
; 8910 : 	/********************************************************************/
; 8911 : #ifdef WIN32
; 8912 : 	SetEvent( phTTS->hSyncEvent );

  0300a	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  0300d	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  03010	57		 push	 edi
  03011	50		 push	 eax
  03012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 8913 : #endif
; 8914 : #if defined __osf__ || defined __linux__
; 8915 : 	OP_SetEvent( phTTS->hSyncEvent );
; 8916 : #endif
; 8917 : 	
; 8918 : 	uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  03018	8b 8e dc 00 00
	00		 mov	 ecx, DWORD PTR [esi+220]
  0301e	51		 push	 ecx
  0301f	e8 00 00 00 00	 call	 _pipe_count

; 8919 : 	uiPhCount = pipe_count( pKsd_t->ph_pipe );

  03024	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  0302a	8b f8		 mov	 edi, eax
  0302c	52		 push	 edx
  0302d	e8 00 00 00 00	 call	 _pipe_count
  03032	8b e8		 mov	 ebp, eax

; 8920 : 	uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03034	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  0303a	50		 push	 eax
  0303b	e8 00 00 00 00	 call	 _pipe_count

; 8921 : 	uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  03040	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]
  03046	89 44 24 38	 mov	 DWORD PTR _uiLtsCount$[esp+48], eax
  0304a	51		 push	 ecx
  0304b	e8 00 00 00 00	 call	 _pipe_count

; 8922 : 	
; 8923 : 	uiOldVtmCount = uiVtmCount;
; 8924 : 	uiOldPhCount = uiPhCount;
; 8925 : 	uiOldLtsCount = uiLtsCount;

  03050	8b 4c 24 3c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+52]
  03054	83 c4 10	 add	 esp, 16			; 00000010H

; 8926 : 	uiOldCmdCount = uiCmdCount;
; 8927 : 	
; 8928 : 	uiLockedUpCount = 0;
; 8929 : 	bPipesNotChanging = TRUE;
; 8930 : 	
; 8931 : 	if (
; 8932 : 		(uiVtmCount) || (uiPhCount) 
; 8933 : 		|| (uiLtsCount) || (uiCmdCount) 
; 8934 : 		)

  03057	85 ff		 test	 edi, edi
  03059	89 7c 24 14	 mov	 DWORD PTR _uiOldVtmCount$[esp+40], edi
  0305d	89 6c 24 18	 mov	 DWORD PTR _uiOldPhCount$[esp+40], ebp
  03061	89 4c 24 1c	 mov	 DWORD PTR _uiOldLtsCount$[esp+40], ecx
  03065	89 44 24 20	 mov	 DWORD PTR _uiOldCmdCount$[esp+40], eax
  03069	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _uiLockedUpCount$[esp+40], 0
  03071	75 10		 jne	 SHORT $L72713
  03073	85 ed		 test	 ebp, ebp
  03075	75 0c		 jne	 SHORT $L72713
  03077	85 c9		 test	 ecx, ecx
  03079	75 08		 jne	 SHORT $L72713
  0307b	85 c0		 test	 eax, eax
  0307d	0f 84 0c 01 00
	00		 je	 $L72715
$L72713:

; 8935 : 	{ 
; 8936 : 		while ( bPipesNotChanging )
; 8937 : 		{
; 8938 : 
; 8939 : 			PumpModeMessage(phTTS->pAudioHandle);

  03083	8b 93 d4 00 00
	00		 mov	 edx, DWORD PTR [ebx+212]
  03089	52		 push	 edx
  0308a	e8 00 00 00 00	 call	 _PumpModeMessage
  0308f	83 c4 04	 add	 esp, 4

; 8940 : 			Sleep( MEMORY_LOCKUP_SLEEP_TIME );

  03092	6a 14		 push	 20			; 00000014H
  03094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 8941 : 			
; 8942 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  0309a	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  030a0	50		 push	 eax
  030a1	e8 00 00 00 00	 call	 _pipe_count

; 8943 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  030a6	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  030ac	8b f8		 mov	 edi, eax
  030ae	51		 push	 ecx
  030af	e8 00 00 00 00	 call	 _pipe_count

; 8944 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  030b4	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  030ba	8b e8		 mov	 ebp, eax
  030bc	52		 push	 edx
  030bd	e8 00 00 00 00	 call	 _pipe_count
  030c2	89 44 24 38	 mov	 DWORD PTR _uiLtsCount$[esp+48], eax

; 8945 : 			uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  030c6	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  030cc	50		 push	 eax
  030cd	e8 00 00 00 00	 call	 _pipe_count
  030d2	83 c4 10	 add	 esp, 16			; 00000010H
  030d5	89 44 24 24	 mov	 DWORD PTR _uiCmdCount$[esp+40], eax

; 8946 : 			
; 8947 : 			/******************************************************************/
; 8948 : 			/*  Are any of the the pipes changing ?                           */
; 8949 : 			/******************************************************************/
; 8950 : 			
; 8951 : 			if (
; 8952 : 				(
; 8953 : 				(uiVtmCount) || (uiPhCount) 
; 8954 : 				|| (uiLtsCount) || (uiCmdCount) 
; 8955 : 				)
; 8956 : 				&&
; 8957 : 				(   ( uiVtmCount == uiOldVtmCount )
; 8958 : 				&& ( uiPhCount == uiOldPhCount )
; 8959 : 				&& ( uiLtsCount == uiOldLtsCount )
; 8960 : 				&& ( uiCmdCount == uiOldCmdCount )
; 8961 : 				)
; 8962 : 				)

  030d9	85 ff		 test	 edi, edi
  030db	75 14		 jne	 SHORT $L72716
  030dd	85 ed		 test	 ebp, ebp
  030df	75 10		 jne	 SHORT $L72716
  030e1	8b 4c 24 2c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+36]
  030e5	85 c9		 test	 ecx, ecx
  030e7	75 08		 jne	 SHORT $L72716
  030e9	85 c0		 test	 eax, eax
  030eb	0f 84 9e 00 00
	00		 je	 $L72715
$L72716:
  030f1	3b 7c 24 14	 cmp	 edi, DWORD PTR _uiOldVtmCount$[esp+40]
  030f5	0f 85 94 00 00
	00		 jne	 $L72715
  030fb	3b 6c 24 18	 cmp	 ebp, DWORD PTR _uiOldPhCount$[esp+40]
  030ff	0f 85 8a 00 00
	00		 jne	 $L72715
  03105	8b 4c 24 2c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+36]
  03109	8b 54 24 1c	 mov	 edx, DWORD PTR _uiOldLtsCount$[esp+40]
  0310d	3b ca		 cmp	 ecx, edx
  0310f	75 7e		 jne	 SHORT $L72715
  03111	3b 44 24 20	 cmp	 eax, DWORD PTR _uiOldCmdCount$[esp+40]
  03115	75 78		 jne	 SHORT $L72715

; 8963 : 			{
; 8964 : 				bPipesNotChanging = TRUE;
; 8965 : 				// tek 29aug96make sure we didn't somehow end up with no place
; 8966 : 				// to go..
; 8967 : 				if((pKsd_t->buffer_pipe != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 2) )

  03117	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  0311d	85 c0		 test	 eax, eax
  0311f	74 19		 je	 SHORT $L72718
  03121	50		 push	 eax
  03122	e8 00 00 00 00	 call	 _pipe_count
  03127	83 c4 04	 add	 esp, 4
  0312a	83 f8 02	 cmp	 eax, 2
  0312d	73 0b		 jae	 SHORT $L72718

; 8968 : 					TextToSpeechAddBuffer(phTTS, NULL);

  0312f	6a 00		 push	 0
  03131	53		 push	 ebx
  03132	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  03137	83 c4 08	 add	 esp, 8
$L72718:

; 8969 : 				uiLockedUpCount++;

  0313a	8b 44 24 10	 mov	 eax, DWORD PTR _uiLockedUpCount$[esp+40]
  0313e	40		 inc	 eax

; 8970 : 				
; 8971 : 				if ( uiLockedUpCount > MEMORY_LOCKUP_COUNT )

  0313f	83 f8 02	 cmp	 eax, 2
  03142	89 44 24 10	 mov	 DWORD PTR _uiLockedUpCount$[esp+40], eax
  03146	76 2a		 jbe	 SHORT $L72720

; 8972 : 				{
; 8973 : 					/**************************************************************/
; 8974 : 					/*  Test to see if the vtm thread is blocked by a call to     */
; 8975 : 					/*  SendMessage().                                            */
; 8976 : 					/**************************************************************/
; 8977 : 					
; 8978 : #ifdef WIN32
; 8979 : 					ResetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  03148	8b 53 3c	 mov	 edx, DWORD PTR [ebx+60]
  0314b	52		 push	 edx
  0314c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 8980 : #endif
; 8981 : #if defined __osf__ || defined __linux__
; 8982 : 					OP_ResetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 8983 : #endif
; 8984 : 					
; 8985 : 					if ( phTTS->bSendingBuffer )

  03152	8b 83 90 00 00
	00		 mov	 eax, DWORD PTR [ebx+144]
  03158	85 c0		 test	 eax, eax
  0315a	74 0c		 je	 SHORT $L72721

; 8986 : 					{
; 8987 : 						EmptyVtmPipe(phTTS->pKernelShareData);

  0315c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0315f	50		 push	 eax
  03160	e8 00 00 00 00	 call	 _EmptyVtmPipe
  03165	83 c4 04	 add	 esp, 4
$L72721:

; 8988 : 					}
; 8989 : #ifdef WIN32
; 8990 : 					SetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  03168	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  0316b	51		 push	 ecx
  0316c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L72720:

; 8991 : #endif
; 8992 : #if defined __osf__ || defined __linux__
; 8993 : 					OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 8994 : #endif
; 8995 : 				}
; 8996 : 				
; 8997 : 				uiOldVtmCount = uiVtmCount;
; 8998 : 				uiOldPhCount = uiPhCount;
; 8999 : 				uiOldLtsCount = uiLtsCount;

  03172	8b 54 24 2c	 mov	 edx, DWORD PTR _uiLtsCount$[esp+36]

; 9000 : 				uiOldCmdCount = uiCmdCount;

  03176	8b 44 24 24	 mov	 eax, DWORD PTR _uiCmdCount$[esp+40]
  0317a	89 7c 24 14	 mov	 DWORD PTR _uiOldVtmCount$[esp+40], edi
  0317e	89 6c 24 18	 mov	 DWORD PTR _uiOldPhCount$[esp+40], ebp
  03182	89 54 24 1c	 mov	 DWORD PTR _uiOldLtsCount$[esp+40], edx
  03186	89 44 24 20	 mov	 DWORD PTR _uiOldCmdCount$[esp+40], eax

; 9001 : 			}
; 9002 : 			else

  0318a	e9 f4 fe ff ff	 jmp	 $L72713
$L72715:
  0318f	5f		 pop	 edi
  03190	5e		 pop	 esi
  03191	5d		 pop	 ebp
  03192	5b		 pop	 ebx

; 9003 : 			{
; 9004 : 				bPipesNotChanging = FALSE;
; 9005 : 			}
; 9006 : 		}
; 9007 : 	} // if pipes not empty
; 9008 : #ifdef API_DEBUG
; 9009 : 	ulEndTime=timeGetTime();
; 9010 : 	sprintf(szTemp,"FixMemoryLockup() exit %ld ms",ulEndTime-ulStartTime);
; 9011 : 	OutputDebugString(szTemp);
; 9012 : #endif //API_DEBUG
; 9013 : 	
; 9014 : 	return;
; 9015 : }

  03193	83 c4 18	 add	 esp, 24			; 00000018H
  03196	c3		 ret	 0
_FixMemoryLockup ENDP
_phTTS$ = 8
_dwWaitTimeInMsec$ = 12
_bReset$ = 16
_bPipesNotEmpty$ = -28
_uiLockedUpCount$ = -32
_uiVtmCount$ = -40
_uiPhCount$ = -36
_uiOldSyncCount$ = -20
_uiOldVtmCount$ = -16
_uiOldPhCount$ = -12
_uiOldLtsCount$ = -8
_uiOldCmdCount$ = -4
_dwTotalTimeInMsec$ = -24
_WaitForEmptyPipes PROC NEAR

; 9058 : {

  031a0	83 ec 28	 sub	 esp, 40			; 00000028H

; 9059 : 	BOOL bPipesNotEmpty;
; 9060 : 	UINT uiLockedUpCount;
; 9061 : 	UINT uiSyncCount;
; 9062 : 	UINT uiVtmCount;
; 9063 : 	UINT uiPhCount;
; 9064 : 	UINT uiLtsCount;
; 9065 : 	UINT uiCmdCount;
; 9066 : 	UINT uiOldSyncCount;
; 9067 : 	UINT uiOldVtmCount;
; 9068 : 	UINT uiOldPhCount;
; 9069 : 	UINT uiOldLtsCount;
; 9070 : 	UINT uiOldCmdCount;
; 9071 : 	UINT	uiSleepTime;
; 9072 : 	DWORD dwTotalTimeInMsec;
; 9073 : #ifdef API_DEBUG
; 9074 : 	char szTemp[256]="";
; 9075 : 	ULONG ulStartTime, ulEndTime;
; 9076 : #endif //API_DEBUG
; 9077 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 9078 : 	* and initialize from phTTS structure
; 9079 : 	*/
; 9080 : 	PKSD_T pKsd_t = NULL;
; 9081 : #ifdef API_DEBUG
; 9082 : 	ulStartTime=timeGetTime();
; 9083 : 	sprintf(szTemp,"WaitForEmptyPipes at %ld\n",ulStartTime);
; 9084 : 	OutputDebugString(szTemp);
; 9085 : #endif //API_DEBUG
; 9086 : 	
; 9087 : 	pKsd_t = phTTS->pKernelShareData;

  031a3	8b 44 24 2c	 mov	 eax, DWORD PTR _phTTS$[esp+36]
  031a7	53		 push	 ebx
  031a8	55		 push	 ebp
  031a9	56		 push	 esi
  031aa	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 9088 : #ifdef TYPING_MODE
; 9089 : 	if (phTTS->bInTypingMode)
; 9090 : 		uiSleepTime=1;	// just reschedule
; 9091 : 	// Well, actually, we have to sleep
; 9092 : 	// a little.. otherwise PH and VTM won't get
; 9093 : 	// to run..
; 9094 : 	else
; 9095 : #endif //TYPING_MODE
; 9096 : 		uiSleepTime=WAIT_PIPE_SLEEP_TIME;
; 9097 : 	/********************************************************************/
; 9098 : 	/*  Wait for all the pipes to empty.                                */
; 9099 : 	/*  If the pipes are not empty then sleep for 100 msec. and check   */
; 9100 : 	/*  them again.                                                     */
; 9101 : 	/********************************************************************/
; 9102 : 	
; 9103 : 	dwTotalTimeInMsec = 0;

  031ad	33 c9		 xor	 ecx, ecx

; 9104 : 	
; 9105 : 	uiOldSyncCount = 0xFFFFFFFF;

  031af	83 c8 ff	 or	 eax, -1
  031b2	57		 push	 edi
  031b3	89 4c 24 20	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+56], ecx
  031b7	89 44 24 24	 mov	 DWORD PTR _uiOldSyncCount$[esp+56], eax

; 9106 : 	uiOldVtmCount = 0xFFFFFFFF;

  031bb	89 44 24 28	 mov	 DWORD PTR _uiOldVtmCount$[esp+56], eax

; 9107 : 	uiOldPhCount = 0xFFFFFFFF;

  031bf	89 44 24 2c	 mov	 DWORD PTR _uiOldPhCount$[esp+56], eax

; 9108 : 	uiOldLtsCount = 0xFFFFFFFF;

  031c3	89 44 24 30	 mov	 DWORD PTR _uiOldLtsCount$[esp+56], eax

; 9109 : 	uiOldCmdCount = 0xFFFFFFFF;

  031c7	89 44 24 34	 mov	 DWORD PTR _uiOldCmdCount$[esp+56], eax

; 9110 : 	uiLockedUpCount = 0;

  031cb	89 4c 24 18	 mov	 DWORD PTR _uiLockedUpCount$[esp+56], ecx
$L72747:

; 9111 : 	bPipesNotEmpty = TRUE;
; 9112 : 	
; 9113 : 	while ( bPipesNotEmpty )
; 9114 : 	{
; 9115 : 		bPipesNotEmpty = FALSE;
; 9116 : 		
; 9117 : 		if ( bReset )

  031cf	8b 44 24 44	 mov	 eax, DWORD PTR _bReset$[esp+52]
  031d3	85 c0		 test	 eax, eax
  031d5	74 0e		 je	 SHORT $L72749

; 9118 : #ifdef WIN32
; 9119 : 			SetEvent( phTTS->hSyncEvent );

  031d7	8b 4c 24 3c	 mov	 ecx, DWORD PTR _phTTS$[esp+52]
  031db	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  031de	52		 push	 edx
  031df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L72749:

; 9120 : #endif
; 9121 : #if defined __osf__ || defined __linux__
; 9122 : 		OP_SetEvent( phTTS->hSyncEvent );
; 9123 : #endif
; 9124 : 		
; 9125 : 		uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  031e5	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  031eb	50		 push	 eax
  031ec	e8 00 00 00 00	 call	 _pipe_count

; 9126 : 		uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  031f1	8b 8e dc 00 00
	00		 mov	 ecx, DWORD PTR [esi+220]
  031f7	8b f8		 mov	 edi, eax
  031f9	51		 push	 ecx
  031fa	e8 00 00 00 00	 call	 _pipe_count

; 9127 : 		uiPhCount = pipe_count( pKsd_t->ph_pipe );

  031ff	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  03205	89 44 24 18	 mov	 DWORD PTR _uiVtmCount$[esp+64], eax
  03209	52		 push	 edx
  0320a	e8 00 00 00 00	 call	 _pipe_count
  0320f	89 44 24 20	 mov	 DWORD PTR _uiPhCount$[esp+68], eax

; 9128 : 		uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03213	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  03219	50		 push	 eax
  0321a	e8 00 00 00 00	 call	 _pipe_count

; 9129 : 		uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  0321f	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]
  03225	8b e8		 mov	 ebp, eax
  03227	51		 push	 ecx
  03228	e8 00 00 00 00	 call	 _pipe_count
  0322d	83 c4 14	 add	 esp, 20			; 00000014H
  03230	8b d8		 mov	 ebx, eax

; 9130 : 		
; 9131 : 		if  (( uiSyncCount != 0 )
; 9132 : 			|| ( uiVtmCount != 0 )
; 9133 : 			|| ( uiPhCount != 0 )
; 9134 : 			|| ( uiLtsCount != 0 )
; 9135 : 			|| ( uiCmdCount != 0 ))

  03232	85 ff		 test	 edi, edi
  03234	0f 85 87 00 00
	00		 jne	 $L72751
  0323a	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+56]
  0323e	85 c0		 test	 eax, eax
  03240	75 7f		 jne	 SHORT $L72751
  03242	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+56]
  03246	85 c0		 test	 eax, eax
  03248	75 77		 jne	 SHORT $L72751
  0324a	85 ed		 test	 ebp, ebp
  0324c	75 73		 jne	 SHORT $L72751
  0324e	85 db		 test	 ebx, ebx

; 9136 : 			bPipesNotEmpty = TRUE;
; 9137 : 		
; 9138 : 		/******************************************************************/
; 9139 : 		/*  If bPipesNotEmpty is still FALSE here then the pipes are      */
; 9140 : 		/*  probably empty. It is possible that there is still data in    */
; 9141 : 		/*  the pipes, but that it moved out of a pipe we are about to    */
; 9142 : 		/*  check into a pipe we have we just checked. We now check the   */
; 9143 : 		/*  pipes in the reverse order.                                   */
; 9144 : 		/******************************************************************/
; 9145 : 		
; 9146 : 		if ( ! bPipesNotEmpty )

  03250	75 6f		 jne	 SHORT $L72751

; 9147 : 		{
; 9148 : 		/*
; 9149 : 		kernel_disable(pKsd_t);
; 9150 : 			*/
; 9151 : 			uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  03252	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  03258	52		 push	 edx
  03259	e8 00 00 00 00	 call	 _pipe_count
  0325e	8b d8		 mov	 ebx, eax

; 9152 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03260	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  03266	50		 push	 eax
  03267	e8 00 00 00 00	 call	 _pipe_count

; 9153 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  0326c	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  03272	8b e8		 mov	 ebp, eax
  03274	51		 push	 ecx
  03275	e8 00 00 00 00	 call	 _pipe_count

; 9154 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  0327a	8b 96 dc 00 00
	00		 mov	 edx, DWORD PTR [esi+220]
  03280	89 44 24 20	 mov	 DWORD PTR _uiPhCount$[esp+68], eax
  03284	52		 push	 edx
  03285	e8 00 00 00 00	 call	 _pipe_count
  0328a	89 44 24 20	 mov	 DWORD PTR _uiVtmCount$[esp+72], eax

; 9155 : 			uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  0328e	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  03294	50		 push	 eax
  03295	e8 00 00 00 00	 call	 _pipe_count
  0329a	8b f8		 mov	 edi, eax
  0329c	83 c4 14	 add	 esp, 20			; 00000014H

; 9156 : 			/*
; 9157 : 			kernel_enable( pKsd_t, uiDummy );
; 9158 : 			*/
; 9159 : 			if  (( uiSyncCount != 0 )
; 9160 : 				|| ( uiVtmCount != 0 )
; 9161 : 				|| ( uiPhCount != 0 )
; 9162 : 				|| ( uiLtsCount != 0 )
; 9163 : 				|| ( uiCmdCount != 0 ))

  0329f	85 ff		 test	 edi, edi
  032a1	75 1e		 jne	 SHORT $L72751
  032a3	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+56]
  032a7	85 c0		 test	 eax, eax
  032a9	75 16		 jne	 SHORT $L72751
  032ab	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+56]
  032af	85 c0		 test	 eax, eax
  032b1	75 0e		 jne	 SHORT $L72751
  032b3	85 ed		 test	 ebp, ebp
  032b5	75 0a		 jne	 SHORT $L72751
  032b7	85 db		 test	 ebx, ebx
  032b9	75 06		 jne	 SHORT $L72751

; 9164 : 				bPipesNotEmpty = TRUE;
; 9165 : 			else
; 9166 : 				bPipesNotEmpty = FALSE;

  032bb	89 5c 24 1c	 mov	 DWORD PTR _bPipesNotEmpty$[esp+56], ebx
  032bf	eb 61		 jmp	 SHORT $L72760
$L72751:

; 9167 : 		}
; 9168 : 		
; 9169 : 		/******************************************************************/
; 9170 : 		/*  Go to sleep for WAIT_PIPE_SLEEP_TIME msec.                    */
; 9171 : 		/******************************************************************/
; 9172 : 		
; 9173 : 		if ( bPipesNotEmpty )
; 9174 : 		{
; 9175 : 			// tek 29aug96make sure we didn't somehow end up with no place
; 9176 : 			// to go.
; 9177 : 			if((pKsd_t->buffer_pipe  != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 1) )

  032c1	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  032c7	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bPipesNotEmpty$[esp+56], 1
  032cf	85 c0		 test	 eax, eax
  032d1	74 1d		 je	 SHORT $L72758
  032d3	50		 push	 eax
  032d4	e8 00 00 00 00	 call	 _pipe_count
  032d9	83 c4 04	 add	 esp, 4
  032dc	83 f8 01	 cmp	 eax, 1
  032df	73 0f		 jae	 SHORT $L72758

; 9178 : 				TextToSpeechAddBuffer(phTTS, NULL);

  032e1	8b 4c 24 3c	 mov	 ecx, DWORD PTR _phTTS$[esp+52]
  032e5	6a 00		 push	 0
  032e7	51		 push	 ecx
  032e8	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  032ed	83 c4 08	 add	 esp, 8
$L72758:

; 9179 : 			
; 9180 : #ifdef API_DEBUG
; 9181 : 			sprintf(szTemp,"WaitForEmptyPipes: c:%d l:%d p:%d v:%d s:%d at %ld\n",
; 9182 : 				uiCmdCount,
; 9183 : 				uiLtsCount,
; 9184 : 				uiPhCount,
; 9185 : 				uiVtmCount,
; 9186 : 				uiSyncCount,
; 9187 : 				timeGetTime());
; 9188 : 			OutputDebugString(szTemp);
; 9189 : #endif //API_DEBUG
; 9190 : 			
; 9191 : #ifdef WIN32
; 9192 : 
; 9193 : 			PumpModeMessage(phTTS->pAudioHandle);

  032f0	8b 54 24 3c	 mov	 edx, DWORD PTR _phTTS$[esp+52]
  032f4	8b 82 d4 00 00
	00		 mov	 eax, DWORD PTR [edx+212]
  032fa	50		 push	 eax
  032fb	e8 00 00 00 00	 call	 _PumpModeMessage
  03300	83 c4 04	 add	 esp, 4

; 9194 : 			Sleep( uiSleepTime );

  03303	6a 32		 push	 50			; 00000032H
  03305	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 9195 : 			
; 9196 : 			dwTotalTimeInMsec += (uiSleepTime);

  0330b	8b 44 24 20	 mov	 eax, DWORD PTR _dwTotalTimeInMsec$[esp+56]

; 9197 : #endif
; 9198 : #if defined __osf__ || defined __linux__
; 9199 : 			OP_Sleep( WAIT_PIPE_SLEEP_TIME );
; 9200 : 			
; 9201 : 			dwTotalTimeInMsec += WAIT_PIPE_SLEEP_TIME;
; 9202 : #endif
; 9203 : 			
; 9204 : 			if ( dwTotalTimeInMsec > dwWaitTimeInMsec )

  0330f	8b 4c 24 40	 mov	 ecx, DWORD PTR _dwWaitTimeInMsec$[esp+52]
  03313	83 c0 32	 add	 eax, 50			; 00000032H
  03316	3b c1		 cmp	 eax, ecx
  03318	89 44 24 20	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+56], eax
  0331c	0f 87 c7 00 00
	00		 ja	 $L73367
$L72760:

; 9205 : 			{
; 9206 : #ifdef API_DEBUG
; 9207 : 				OutputDebugString("  ..WFPE() timed out!\n");
; 9208 : #endif //API_DEBUG
; 9209 : 				return( MMSYSERR_ERROR );
; 9210 : 			}
; 9211 : 		}
; 9212 : 		
; 9213 : 		/******************************************************************/
; 9214 : 		/*  If this is a reset then check to see if nothing is happening. */
; 9215 : 		/*  If any of the threads block then the pipe state may not       */
; 9216 : 		/*  change.                                                       */
; 9217 : 		/******************************************************************/
; 9218 : 		
; 9219 : 		if  (( bReset )
; 9220 : 			&& ( uiSyncCount && (uiSyncCount == uiOldSyncCount) )
; 9221 : 			&& ( uiVtmCount && (uiVtmCount == uiOldVtmCount) )
; 9222 : 			&& ( uiPhCount && (uiPhCount == uiOldPhCount) )
; 9223 : 			&& ( uiLtsCount && (uiLtsCount == uiOldLtsCount) )
; 9224 : 			&& ( uiCmdCount && (uiCmdCount == uiOldCmdCount) ))

  03322	8b 44 24 44	 mov	 eax, DWORD PTR _bReset$[esp+52]
  03326	85 c0		 test	 eax, eax
  03328	74 7a		 je	 SHORT $L72761
  0332a	85 ff		 test	 edi, edi
  0332c	74 76		 je	 SHORT $L72761
  0332e	3b 7c 24 24	 cmp	 edi, DWORD PTR _uiOldSyncCount$[esp+56]
  03332	75 70		 jne	 SHORT $L72761
  03334	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+56]
  03338	85 c0		 test	 eax, eax
  0333a	74 68		 je	 SHORT $L72761
  0333c	3b 44 24 28	 cmp	 eax, DWORD PTR _uiOldVtmCount$[esp+56]
  03340	75 62		 jne	 SHORT $L72761
  03342	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+56]
  03346	85 c0		 test	 eax, eax
  03348	74 5a		 je	 SHORT $L72761
  0334a	3b 44 24 2c	 cmp	 eax, DWORD PTR _uiOldPhCount$[esp+56]
  0334e	75 54		 jne	 SHORT $L72761
  03350	85 ed		 test	 ebp, ebp
  03352	74 50		 je	 SHORT $L72761
  03354	3b 6c 24 30	 cmp	 ebp, DWORD PTR _uiOldLtsCount$[esp+56]
  03358	75 4a		 jne	 SHORT $L72761
  0335a	85 db		 test	 ebx, ebx
  0335c	74 46		 je	 SHORT $L72761
  0335e	3b 5c 24 34	 cmp	 ebx, DWORD PTR _uiOldCmdCount$[esp+56]
  03362	75 40		 jne	 SHORT $L72761

; 9225 : 		{
; 9226 : 			/****************************************************************/
; 9227 : 			/*  Perform an audio reset to immediately stop audio from       */
; 9228 : 			/*  playing and to make sure the VTM thread is not blocked.     */
; 9229 : 			/****************************************************************/
; 9230 : 			
; 9231 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  03364	8b 44 24 3c	 mov	 eax, DWORD PTR _phTTS$[esp+52]
  03368	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0336e	85 c9		 test	 ecx, ecx
  03370	75 13		 jne	 SHORT $L72762

; 9232 : 			{
; 9233 : 				PA_Reset( phTTS->pAudioHandle );

  03372	8b 88 d4 00 00
	00		 mov	 ecx, DWORD PTR [eax+212]
  03378	51		 push	 ecx
  03379	e8 00 00 00 00	 call	 _PA_Reset
  0337e	8b 44 24 40	 mov	 eax, DWORD PTR _phTTS$[esp+56]
  03382	83 c4 04	 add	 esp, 4
$L72762:

; 9234 : 			}
; 9235 : 			
; 9236 : 			uiLockedUpCount++;

  03385	8b 54 24 18	 mov	 edx, DWORD PTR _uiLockedUpCount$[esp+56]

; 9237 : 			
; 9238 : 			/****************************************************************/
; 9239 : 			/*  Fix hang when using speech-to-memory. WIH 4/6/95            */
; 9240 : 			/****************************************************************/
; 9241 : 			
; 9242 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  03389	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0338f	42		 inc	 edx
  03390	83 f9 01	 cmp	 ecx, 1
  03393	89 54 24 18	 mov	 DWORD PTR _uiLockedUpCount$[esp+56], edx
  03397	75 13		 jne	 SHORT $L72764

; 9243 : 			{
; 9244 : 				FixMemoryLockup( phTTS );

  03399	50		 push	 eax
  0339a	e8 00 00 00 00	 call	 _FixMemoryLockup
  0339f	83 c4 04	 add	 esp, 4

; 9245 : 			}
; 9246 : 		}
; 9247 : 		else

  033a2	eb 08		 jmp	 SHORT $L72764
$L72761:

; 9248 : 		{
; 9249 : 			uiLockedUpCount = 0;

  033a4	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _uiLockedUpCount$[esp+56], 0
$L72764:

; 9250 : 		}
; 9251 : 		
; 9252 : 		uiOldSyncCount = uiSyncCount;
; 9253 : 		uiOldVtmCount = uiVtmCount;
; 9254 : 		uiOldPhCount = uiPhCount;

  033ac	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+56]
  033b0	8b 54 24 10	 mov	 edx, DWORD PTR _uiVtmCount$[esp+56]
  033b4	89 44 24 2c	 mov	 DWORD PTR _uiOldPhCount$[esp+56], eax

; 9255 : 		uiOldLtsCount = uiLtsCount;
; 9256 : 		uiOldCmdCount = uiCmdCount;
; 9257 : 		
; 9258 : 		if ( uiLockedUpCount >= WAIT_PIPE_ABORT_COUNT )

  033b8	8b 44 24 18	 mov	 eax, DWORD PTR _uiLockedUpCount$[esp+56]
  033bc	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  033c1	89 7c 24 24	 mov	 DWORD PTR _uiOldSyncCount$[esp+56], edi
  033c5	89 54 24 28	 mov	 DWORD PTR _uiOldVtmCount$[esp+56], edx
  033c9	89 6c 24 30	 mov	 DWORD PTR _uiOldLtsCount$[esp+56], ebp
  033cd	89 5c 24 34	 mov	 DWORD PTR _uiOldCmdCount$[esp+56], ebx
  033d1	73 16		 jae	 SHORT $L73367
  033d3	8b 44 24 1c	 mov	 eax, DWORD PTR _bPipesNotEmpty$[esp+56]
  033d7	85 c0		 test	 eax, eax
  033d9	0f 85 f0 fd ff
	ff		 jne	 $L72747
  033df	5f		 pop	 edi
  033e0	5e		 pop	 esi
  033e1	5d		 pop	 ebp

; 9264 : 		}
; 9265 :   }
; 9266 : #ifdef API_DEBUG
; 9267 :   ulEndTime=timeGetTime();
; 9268 :   sprintf(szTemp,"WaitForEmptyPipes exit at %ld (%ld) ms\n",
; 9269 : 	  ulEndTime, ulEndTime - ulStartTime);
; 9270 :   OutputDebugString(szTemp);
; 9271 : #endif //API_DEBUG
; 9272 :   
; 9273 :   return( MMSYSERR_NOERROR );

  033e2	33 c0		 xor	 eax, eax
  033e4	5b		 pop	 ebx

; 9274 : }

  033e5	83 c4 28	 add	 esp, 40			; 00000028H
  033e8	c3		 ret	 0
$L73367:
  033e9	5f		 pop	 edi
  033ea	5e		 pop	 esi
  033eb	5d		 pop	 ebp

; 9259 : 		{
; 9260 : #ifdef API_DEBUG
; 9261 : 			OutputDebugString("  ..WFPE() lockup failure?\n");
; 9262 : #endif //API_DEBUG
; 9263 : 			return( MMSYSERR_ERROR );

  033ec	b8 01 00 00 00	 mov	 eax, 1
  033f1	5b		 pop	 ebx

; 9274 : }

  033f2	83 c4 28	 add	 esp, 40			; 00000028H
  033f5	c3		 ret	 0
_WaitForEmptyPipes ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG72776 DB	'DECtalkErrorMessage', 00H
_DATA	ENDS
_TEXT	SEGMENT
_aInstance$ = 12
_aMessage$ = 16
_aParam$ = 20
_PlayAudioCallbackRoutine PROC NEAR

; 9287 : 	// get the dectalk error mesage ID.. 
; 9288 : 	UINT uiID_Error_Msg;
; 9289 : 	
; 9290 : #ifdef API_DEBUG
; 9291 : 	OutputDebugString("PlayAudioCallbackRoutine().\n");
; 9292 : #endif //API_DEBUG
; 9293 : 	/********************************************************************/
; 9294 : 	/*  Get the DECtalk error message.                                  */
; 9295 : 	/********************************************************************/
; 9296 : #if defined __osf__ || defined __linux__
; 9297 : 	uiID_Error_Msg = ((LPTTS_HANDLE_T)aInstance)->uiID_Error_Message;
; 9298 : #endif
; 9299 : 	
; 9300 : #ifdef WIN32
; 9301 : #ifdef UNDER_CE
; 9302 :    uiID_Error_Msg = RegisterWindowMessage(_T("DECtalkErrorMessage"));
; 9303 : #else
; 9304 :     uiID_Error_Msg = RegisterWindowMessage("DECtalkErrorMessage");

  03400	68 00 00 00 00	 push	 OFFSET FLAT:$SG72776
  03405	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4

; 9305 : #endif
; 9306 : #endif
; 9307 :     switch ( aMessage )
; 9308 : 	{

  0340b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aMessage$[esp-4]
  0340f	49		 dec	 ecx
  03410	83 f9 06	 cmp	 ecx, 6
  03413	77 7c		 ja	 SHORT $L72793
  03415	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L73375[ecx*4]
$L72781:

; 9344 : 		break;
; 9345 : 		
; 9346 : 	case PA_GET_CAPS_ERROR:
; 9347 : 		
; 9348 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9349 : 			uiID_Error_Msg,
; 9350 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 9351 : 			aParam );

  0341c	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  03420	6a 00		 push	 0
  03422	6a 0c		 push	 12			; 0000000cH
  03424	50		 push	 eax
  03425	52		 push	 edx
  03426	e8 00 00 00 00	 call	 _Report_TTS_Status
  0342b	83 c4 10	 add	 esp, 16			; 00000010H

; 9352 : 		break;
; 9353 : 		
; 9354 : 	default:
; 9355 : 		
; 9356 : 		break;
; 9357 : 	}
; 9358 : 	
; 9359 : 	return FALSE;

  0342e	33 c0		 xor	 eax, eax

; 9360 : }

  03430	c3		 ret	 0
$L72783:

; 9309 : 		
; 9310 : 	case PA_PLAY_START:
; 9311 : 		
; 9312 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9313 : 			uiID_Error_Msg,
; 9314 : 			TTS_AUDIO_PLAY_START,
; 9315 : 			MMSYSERR_NOERROR );
; 9316 : 		break;
; 9317 : 		
; 9318 : 	case PA_PLAY_STOP:
; 9319 : 		
; 9320 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9321 : 			uiID_Error_Msg,
; 9322 : 			TTS_AUDIO_PLAY_STOP,
; 9323 : 			MMSYSERR_NOERROR );

  03431	6a 00		 push	 0
  03433	6a 0d		 push	 13			; 0000000dH
  03435	50		 push	 eax
  03436	8b 44 24 14	 mov	 eax, DWORD PTR _aInstance$[esp+8]
  0343a	50		 push	 eax

; 9344 : 		break;
; 9345 : 		
; 9346 : 	case PA_GET_CAPS_ERROR:
; 9347 : 		
; 9348 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9349 : 			uiID_Error_Msg,
; 9350 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 9351 : 			aParam );

  0343b	e8 00 00 00 00	 call	 _Report_TTS_Status
  03440	83 c4 10	 add	 esp, 16			; 00000010H

; 9352 : 		break;
; 9353 : 		
; 9354 : 	default:
; 9355 : 		
; 9356 : 		break;
; 9357 : 	}
; 9358 : 	
; 9359 : 	return FALSE;

  03443	33 c0		 xor	 eax, eax

; 9360 : }

  03445	c3		 ret	 0
$L72785:

; 9324 : 		
; 9325 : 		break;
; 9326 : 		
; 9327 : 	case PA_DEVICE_OPEN_FAILURE:
; 9328 : 		
; 9329 : 		if (((LPTTS_HANDLE_T)aInstance)->dwDeviceOptions & REPORT_OPEN_ERROR )

  03446	8b 4c 24 08	 mov	 ecx, DWORD PTR _aInstance$[esp-4]
  0344a	f6 41 74 02	 test	 BYTE PTR [ecx+116], 2
  0344e	74 41		 je	 SHORT $L72793

; 9330 : 		{
; 9331 : 			Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9332 : 				uiID_Error_Msg,
; 9333 : 				ERROR_OPENING_WAVE_OUTPUT_DEVICE,
; 9334 : 				aParam );

  03450	8b 54 24 10	 mov	 edx, DWORD PTR _aParam$[esp-4]
  03454	52		 push	 edx
  03455	6a 02		 push	 2
  03457	50		 push	 eax
  03458	51		 push	 ecx

; 9344 : 		break;
; 9345 : 		
; 9346 : 	case PA_GET_CAPS_ERROR:
; 9347 : 		
; 9348 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9349 : 			uiID_Error_Msg,
; 9350 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 9351 : 			aParam );

  03459	e8 00 00 00 00	 call	 _Report_TTS_Status
  0345e	83 c4 10	 add	 esp, 16			; 00000010H

; 9352 : 		break;
; 9353 : 		
; 9354 : 	default:
; 9355 : 		
; 9356 : 		break;
; 9357 : 	}
; 9358 : 	
; 9359 : 	return FALSE;

  03461	33 c0		 xor	 eax, eax

; 9360 : }

  03463	c3		 ret	 0
$L72789:

; 9335 : 		}
; 9336 : 		break;
; 9337 : 		
; 9338 : 	case PA_WRITE_ERROR:
; 9339 : 		
; 9340 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9341 : 			uiID_Error_Msg,
; 9342 : 			ERROR_IN_AUDIO_WRITE,
; 9343 : 			aParam );

  03464	8b 4c 24 10	 mov	 ecx, DWORD PTR _aParam$[esp-4]

; 9344 : 		break;
; 9345 : 		
; 9346 : 	case PA_GET_CAPS_ERROR:
; 9347 : 		
; 9348 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9349 : 			uiID_Error_Msg,
; 9350 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 9351 : 			aParam );

  03468	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  0346c	51		 push	 ecx
  0346d	6a 01		 push	 1
  0346f	50		 push	 eax
  03470	52		 push	 edx
  03471	e8 00 00 00 00	 call	 _Report_TTS_Status
  03476	83 c4 10	 add	 esp, 16			; 00000010H

; 9352 : 		break;
; 9353 : 		
; 9354 : 	default:
; 9355 : 		
; 9356 : 		break;
; 9357 : 	}
; 9358 : 	
; 9359 : 	return FALSE;

  03479	33 c0		 xor	 eax, eax

; 9360 : }

  0347b	c3		 ret	 0
$L72791:

; 9344 : 		break;
; 9345 : 		
; 9346 : 	case PA_GET_CAPS_ERROR:
; 9347 : 		
; 9348 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9349 : 			uiID_Error_Msg,
; 9350 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 9351 : 			aParam );

  0347c	8b 4c 24 10	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  03480	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  03484	51		 push	 ecx
  03485	6a 03		 push	 3
  03487	50		 push	 eax
  03488	52		 push	 edx
  03489	e8 00 00 00 00	 call	 _Report_TTS_Status
  0348e	83 c4 10	 add	 esp, 16			; 00000010H
$L72793:

; 9352 : 		break;
; 9353 : 		
; 9354 : 	default:
; 9355 : 		
; 9356 : 		break;
; 9357 : 	}
; 9358 : 	
; 9359 : 	return FALSE;

  03491	33 c0		 xor	 eax, eax

; 9360 : }

  03493	c3		 ret	 0
$L73375:
  03494	00 00 00 00	 DD	 $L72781
  03498	00 00 00 00	 DD	 $L72783
  0349c	00 00 00 00	 DD	 $L72785
  034a0	00 00 00 00	 DD	 $L72793
  034a4	00 00 00 00	 DD	 $L72793
  034a8	00 00 00 00	 DD	 $L72791
  034ac	00 00 00 00	 DD	 $L72789
_PlayAudioCallbackRoutine ENDP
_ttsHandle$ = 8
_uiMsg$ = 12
_lParam1$ = 16
_lParam2$ = 20
_Report_TTS_Status PROC NEAR

; 9375 : {

  034b0	56		 push	 esi

; 9376 : 	if (lParam1 == TTS_AUDIO_PLAY_START)	ttsHandle->IsSpeaking = TRUE;	// KSB - Used for start of speech

  034b1	8b 74 24 08	 mov	 esi, DWORD PTR _ttsHandle$[esp]
  034b5	57		 push	 edi
  034b6	8b 7c 24 14	 mov	 edi, DWORD PTR _lParam1$[esp+4]
  034ba	83 ff 0c	 cmp	 edi, 12			; 0000000cH
  034bd	75 0c		 jne	 SHORT $L72803
  034bf	c7 86 cc 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+204], 1

; 9377 : 	if (lParam1 == TTS_AUDIO_PLAY_STOP)	ttsHandle->IsSpeaking = FALSE;	// KSB - Used for end of speech

  034c9	eb 0f		 jmp	 SHORT $L72804
$L72803:
  034cb	83 ff 0d	 cmp	 edi, 13			; 0000000dH
  034ce	75 0a		 jne	 SHORT $L72804
  034d0	c7 86 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+204], 0
$L72804:

; 9378 : 	
; 9379 : 	if (ttsHandle->DtCallbackRoutine != NULL)

  034da	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  034e0	85 c0		 test	 eax, eax
  034e2	74 33		 je	 SHORT $L72806

; 9380 : 	{
; 9381 : #ifdef API_DEBUG
; 9382 : 		char szTemp[256]="";
; 9383 : 		sprintf(szTemp,"RTTSStatus(%08lx %08lx)\n",
; 9384 : 			lParam1, lParam2);
; 9385 : 		OutputDebugString(szTemp);
; 9386 : #endif //API_DEBUG
; 9387 : 		
; 9388 : 		OP_LockMutex( ttsHandle->hmxCallback );

  034e4	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  034ea	50		 push	 eax
  034eb	e8 00 00 00 00	 call	 _OP_LockMutex

; 9389 : 		(*ttsHandle->DtCallbackRoutine)( lParam1,
; 9390 : 			lParam2,
; 9391 : 			ttsHandle->dwTTSInstanceParameter,
; 9392 : 			uiMsg);

  034f0	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiMsg$[esp+8]
  034f4	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  034fa	8b 44 24 1c	 mov	 eax, DWORD PTR _lParam2$[esp+8]
  034fe	51		 push	 ecx
  034ff	52		 push	 edx
  03500	50		 push	 eax
  03501	57		 push	 edi
  03502	ff 96 a4 00 00
	00		 call	 DWORD PTR [esi+164]

; 9393 : 		
; 9394 : 		OP_UnlockMutex( ttsHandle->hmxCallback );

  03508	8b 8e ac 00 00
	00		 mov	 ecx, DWORD PTR [esi+172]
  0350e	51		 push	 ecx
  0350f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  03514	83 c4 18	 add	 esp, 24			; 00000018H
$L72806:
  03517	5f		 pop	 edi
  03518	5e		 pop	 esi

; 9395 : 	}
; 9396 : 	return;
; 9397 : }

  03519	c3		 ret	 0
_Report_TTS_Status ENDP
_TEXT	ENDS
EXTRN	_SWFlushPipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_DrainPipes PROC NEAR

; 9421 : {

  03520	56		 push	 esi

; 9422 : 	// empty the CMD, LTS and PH pipes..
; 9423 : 	SWFlushPipe(phTTS->pKernelShareData->cmd_pipe);

  03521	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  03525	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  03528	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  0352e	51		 push	 ecx
  0352f	e8 00 00 00 00	 call	 _SWFlushPipe

; 9424 : 	SWFlushPipe(phTTS->pKernelShareData->lts_pipe);

  03534	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  03537	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  0353d	50		 push	 eax
  0353e	e8 00 00 00 00	 call	 _SWFlushPipe

; 9425 : 	SWFlushPipe(phTTS->pKernelShareData->ph_pipe);

  03543	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  03546	8b 91 d4 00 00
	00		 mov	 edx, DWORD PTR [ecx+212]
  0354c	52		 push	 edx
  0354d	e8 00 00 00 00	 call	 _SWFlushPipe
  03552	83 c4 0c	 add	 esp, 12			; 0000000cH
  03555	5e		 pop	 esi

; 9426 : 	
; 9427 : }

  03556	c3		 ret	 0
_DrainPipes ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechVersion
_BSS	SEGMENT
_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9 DB 032H DUP (?)
	ALIGN	4

$SG72815 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG72816 DB	'v4.60 R011 NORMAL', 00H
	ORG $+2
$SG72817 DB	'%s %s', 00H
_DATA	ENDS
_TEXT	SEGMENT
_VersionStr$ = 8
_TextToSpeechVersion PROC NEAR

; 9436 : 	//removed unsigned form next line 11/12/96 cjl
; 9437 : 	static char   DECtalk_Version_String[50];
; 9438 : 	
; 9439 : 	sprintf(DECtalk_Version_String,"%s %s",DTALK_STR_VERSION, CUSTR_STR_VERSION);

  03560	68 00 00 00 00	 push	 OFFSET FLAT:$SG72815
  03565	68 00 00 00 00	 push	 OFFSET FLAT:$SG72816
  0356a	68 00 00 00 00	 push	 OFFSET FLAT:$SG72817
  0356f	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9
  03574	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 9440 : 	if (VersionStr != NULL) *VersionStr = DECtalk_Version_String;

  0357a	8b 44 24 14	 mov	 eax, DWORD PTR _VersionStr$[esp+12]
  0357e	83 c4 10	 add	 esp, 16			; 00000010H
  03581	85 c0		 test	 eax, eax
  03583	74 06		 je	 SHORT $L73379
  03585	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9
$L73379:

; 9441 : 	// Add in dbg_version. NCS KSB
; 9442 : #ifdef WIN32
; 9443 : 	return (DTALK_DBG_VERSION << 31) + (DTALK_MAJ_VERSION << 24) + (DTALK_MIN_VERSION << 16) + (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;

  0358b	b8 09 01 3c 04	 mov	 eax, 71041289		; 043c0109H

; 9444 : #endif
; 9445 : #if defined __osf__ || defined __linux__
; 9446 : 	return (DTALK_MAJ_VERSION << 24) + (DTALK_MIN_VERSION << 16) + (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;
; 9447 : #endif
; 9448 : }

  03590	c3		 ret	 0
_TextToSpeechVersion ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechControlPanel
_TEXT	SEGMENT
_TextToSpeechControlPanel PROC NEAR

; 9452 : #ifdef DTALK50
; 9453 : 	if (ttsHandle == NULL)	return;
; 9454 : 	CPShow(ttsHandle->CPanelThread);
; 9455 : #else
; 9456 : 	/* This function not supported in 4.4 */
; 9457 : #endif
; 9458 : 	return;
; 9459 : }

  035a0	c3		 ret	 0
_TextToSpeechControlPanel ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetLastError
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechGetLastError PROC NEAR

; 9468 : 	return phTTS->LastError;

  035b0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  035b4	8b 80 d0 00 00
	00		 mov	 eax, DWORD PTR [eax+208]

; 9469 : }

  035ba	c3		 ret	 0
_TextToSpeechGetLastError ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechTyping
_TEXT	SEGMENT
_TextToSpeechTyping PROC NEAR

; 9492 : 	unsigned short str[20];
; 9493 : #ifdef API_DEBUG
; 9494 : 	char szTemp[256]="";
; 9495 : 	ULONG ulStartTime,ulEndTime;
; 9496 : #endif //API_DEBUG
; 9497 : 	
; 9498 : 	
; 9499 : #ifdef TYPING_MODE
; 9500 : #define TYPE_MAXPHONES (256)
; 9501 : 	HANDLE hThisThread=NULL;
; 9502 : 	THREAD_PRIORITY_T tptPriority=0;
; 9503 : 	hThisThread = GetCurrentThread();
; 9504 : 	if (hThisThread)
; 9505 : 	{
; 9506 : #ifndef UNDER_CE
; 9507 : 		tptPriority = OP_GetThreadPriority(hThisThread);
; 9508 : 		OP_SetThreadPriority(hThisThread,OP_PRIORITY_HIGHEST);
; 9509 : #endif
; 9510 : 	}
; 9511 : #ifdef API_DEBUG
; 9512 : 	ulStartTime=timeGetTime();
; 9513 : 	sprintf(szTemp, "TTSTyping(%c) at %ld.\n", key, ulStartTime);
; 9514 : 	OutputDebugString(szTemp);
; 9515 : #endif //API_DEBUG
; 9516 : 	TextToSpeechReset(phTTS,FALSE);
; 9517 : 	/**/
; 9518 : 	// this is the type_out code from cm_util_type_out, modified to
; 9519 : 	// do what we need here.
; 9520 : 	{
; 9521 : 		unsigned char _far *tp;
; 9522 : 		DT_PIPE_T phone[TYPE_MAXPHONES];
; 9523 : 		unsigned int i=0;
; 9524 : 		PKSD_T pKsd_t = phTTS->pKernelShareData;
; 9525 : 		
; 9526 : 		for(tp = (unsigned char _far *)pKsd_t->typing_table[key];*tp;tp++)
; 9527 : 		{
; 9528 : 			phone[i++] = pKsd_t->reverse_ascky[(*tp) & 0xff];
; 9529 : 		}
; 9530 : 		//phone[i++] = (PFUSA<<PSFONT) | COMMA;		
; 9531 : 		phone[i++] = SYNC;
; 9532 : 		write_pipe(pKsd_t->ph_pipe,phone,i);
; 9533 : 	}
; 9534 : 	// end of type_out code
; 9535 : 	
; 9536 : 	
; 9537 : #ifdef API_DEBUG
; 9538 : 	ulEndTime=timeGetTime();
; 9539 : 	sprintf(szTemp, "TTSTyping() exit %ld (%ld)\n", 
; 9540 : 		ulEndTime, ulEndTime-ulStartTime);
; 9541 : 	OutputDebugString(szTemp);
; 9542 : #endif //API_DEBUG	
; 9543 : #ifndef UNDER_CE
; 9544 : 	if (hThisThread)
; 9545 : 		OP_SetThreadPriority(hThisThread,tptPriority);
; 9546 : #endif
; 9547 : #endif TYPING_MODE
; 9548 : 	return;
; 9549 : }

  035c0	c3		 ret	 0
_TextToSpeechTyping ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved1
EXTRN	_paul_8:BYTE
EXTRN	_betty_8:BYTE
EXTRN	_harry_8:BYTE
EXTRN	_frank_8:BYTE
EXTRN	_kit_8:BYTE
EXTRN	_ursula_8:BYTE
EXTRN	_rita_8:BYTE
EXTRN	_wendy_8:BYTE
EXTRN	_dennis_8:BYTE
EXTRN	_paul:BYTE
EXTRN	_betty:BYTE
EXTRN	_harry:BYTE
EXTRN	_frank:BYTE
EXTRN	_kit:BYTE
EXTRN	_ursula:BYTE
EXTRN	_rita:BYTE
EXTRN	_wendy:BYTE
EXTRN	_dennis:BYTE
_TEXT	SEGMENT
_voices$ = 8
_voice$ = 12
_bEightk$ = 16
_bReadData$ = 20
_TextToSpeechReserved1 PROC NEAR

; 9553 : 	short *sdef;
; 9554 : 	
; 9555 : 	if (bEightk == FALSE) {	// High-quality

  035d0	8b 44 24 0c	 mov	 eax, DWORD PTR _bEightk$[esp-4]
  035d4	85 c0		 test	 eax, eax

; 9556 : 		
; 9557 : 		switch (voice) {

  035d6	8b 44 24 08	 mov	 eax, DWORD PTR _voice$[esp-4]
  035da	75 5a		 jne	 SHORT $L72843
  035dc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  035e1	83 f8 08	 cmp	 eax, 8
  035e4	0f 87 21 01 00
	00		 ja	 $L72857
  035ea	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L73384[eax*4]
$L72848:

; 9558 : 		case 0:	sdef = paul;	break;

  035f1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_paul
  035f6	e9 8d 00 00 00	 jmp	 $L72860
$L72849:

; 9559 : 		case 1:	sdef = betty;	break;

  035fb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_betty
  03600	e9 83 00 00 00	 jmp	 $L72860
$L72850:

; 9560 : 		case 2:	sdef = harry;	break;

  03605	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_harry
  0360a	eb 7c		 jmp	 SHORT $L72860
$L72851:

; 9561 : 		case 3:	sdef = frank;	break;

  0360c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_frank
  03611	eb 75		 jmp	 SHORT $L72860
$L72852:

; 9562 : 		case 4:	sdef = dennis;	break;

  03613	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_dennis
  03618	eb 6e		 jmp	 SHORT $L72860
$L72853:

; 9563 : 		case 5:	sdef = kit;		break;

  0361a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_kit
  0361f	eb 67		 jmp	 SHORT $L72860
$L72854:

; 9564 : 		case 6:	sdef = ursula;	break;

  03621	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ursula
  03626	eb 60		 jmp	 SHORT $L72860
$L72855:

; 9565 : 		case 7:	sdef = rita;	break;

  03628	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_rita
  0362d	eb 59		 jmp	 SHORT $L72860
$L72856:

; 9566 : 		case 8:	sdef = wendy;	break;

  0362f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wendy

; 9567 : 		default:	return 0;
; 9568 : 		}
; 9569 : 	} else {

  03634	eb 52		 jmp	 SHORT $L72860
$L72843:

; 9570 : 		switch (voice) {

  03636	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0363b	83 f8 08	 cmp	 eax, 8
  0363e	0f 87 c7 00 00
	00		 ja	 $L72857
  03644	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L73385[eax*4]
$L72863:

; 9571 : 		case 0:	sdef = paul_8;		break;

  0364b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_paul_8
  03650	eb 36		 jmp	 SHORT $L72860
$L72864:

; 9572 : 		case 1:	sdef = betty_8;		break;

  03652	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_betty_8
  03657	eb 2f		 jmp	 SHORT $L72860
$L72865:

; 9573 : 		case 2:	sdef = harry_8;		break;

  03659	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_harry_8
  0365e	eb 28		 jmp	 SHORT $L72860
$L72866:

; 9574 : 		case 3:	sdef = frank_8;		break;

  03660	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_frank_8
  03665	eb 21		 jmp	 SHORT $L72860
$L72867:

; 9575 : 		case 4:	sdef = dennis_8;	break;

  03667	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_dennis_8
  0366c	eb 1a		 jmp	 SHORT $L72860
$L72868:

; 9576 : 		case 5:	sdef = kit_8;		break;

  0366e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_kit_8
  03673	eb 13		 jmp	 SHORT $L72860
$L72869:

; 9577 : 		case 6:	sdef = ursula_8;	break;

  03675	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ursula_8
  0367a	eb 0c		 jmp	 SHORT $L72860
$L72870:

; 9578 : 		case 7:	sdef = rita_8;		break;

  0367c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_rita_8
  03681	eb 05		 jmp	 SHORT $L72860
$L72871:

; 9579 : 		case 8:	sdef = wendy_8;		break;

  03683	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wendy_8
$L72860:

; 9581 : 		}
; 9582 : 	}
; 9583 : 	
; 9584 : 	if (bReadData) {

  03688	8b 4c 24 10	 mov	 ecx, DWORD PTR _bReadData$[esp-4]
  0368c	85 c9		 test	 ecx, ecx
  0368e	74 33		 je	 SHORT $L72873

; 9585 : 		voices[0] = sdef[SP_GV];

  03690	8b 4c 24 04	 mov	 ecx, DWORD PTR _voices$[esp-4]
  03694	8a 50 24	 mov	 dl, BYTE PTR [eax+36]
  03697	88 11		 mov	 BYTE PTR [ecx], dl

; 9586 : 		voices[1] = sdef[SP_GN];

  03699	8a 50 26	 mov	 dl, BYTE PTR [eax+38]
  0369c	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 9587 : 		voices[2] = sdef[SP_G1];

  0369f	8a 50 28	 mov	 dl, BYTE PTR [eax+40]
  036a2	88 51 02	 mov	 BYTE PTR [ecx+2], dl

; 9588 : 		voices[3] = sdef[SP_G2];

  036a5	8a 50 2a	 mov	 dl, BYTE PTR [eax+42]
  036a8	88 51 03	 mov	 BYTE PTR [ecx+3], dl

; 9589 : 		voices[4] = sdef[SP_G3];

  036ab	8a 50 2c	 mov	 dl, BYTE PTR [eax+44]
  036ae	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 9590 : 		voices[5] = sdef[SP_G4];

  036b1	8a 50 2e	 mov	 dl, BYTE PTR [eax+46]
  036b4	88 51 05	 mov	 BYTE PTR [ecx+5], dl

; 9591 : 		voices[6] = sdef[SP_LO];

  036b7	8a 40 30	 mov	 al, BYTE PTR [eax+48]
  036ba	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 9600 : 	}
; 9601 : 	return 7;

  036bd	b8 07 00 00 00	 mov	 eax, 7

; 9602 : }

  036c2	c3		 ret	 0
$L72873:

; 9592 : 	} else {
; 9593 : 		sdef[SP_GV] = voices[0];

  036c3	8b 4c 24 04	 mov	 ecx, DWORD PTR _voices$[esp-4]
  036c7	66 0f b6 11	 movzx	 dx, BYTE PTR [ecx]
  036cb	66 89 50 24	 mov	 WORD PTR [eax+36], dx

; 9594 : 		sdef[SP_GN] = voices[1];

  036cf	66 0f b6 51 01	 movzx	 dx, BYTE PTR [ecx+1]
  036d4	66 89 50 26	 mov	 WORD PTR [eax+38], dx

; 9595 : 		sdef[SP_G1] = voices[2];

  036d8	66 0f b6 51 02	 movzx	 dx, BYTE PTR [ecx+2]
  036dd	66 89 50 28	 mov	 WORD PTR [eax+40], dx

; 9596 : 		sdef[SP_G2] = voices[3];

  036e1	66 0f b6 51 03	 movzx	 dx, BYTE PTR [ecx+3]
  036e6	66 89 50 2a	 mov	 WORD PTR [eax+42], dx

; 9597 : 		sdef[SP_G3] = voices[4];

  036ea	66 0f b6 51 04	 movzx	 dx, BYTE PTR [ecx+4]
  036ef	66 89 50 2c	 mov	 WORD PTR [eax+44], dx

; 9598 : 		sdef[SP_G4] = voices[5];

  036f3	66 0f b6 51 05	 movzx	 dx, BYTE PTR [ecx+5]
  036f8	66 89 50 2e	 mov	 WORD PTR [eax+46], dx

; 9599 : 		sdef[SP_LO] = voices[6];

  036fc	66 0f b6 49 06	 movzx	 cx, BYTE PTR [ecx+6]
  03701	66 89 48 30	 mov	 WORD PTR [eax+48], cx

; 9600 : 	}
; 9601 : 	return 7;

  03705	b8 07 00 00 00	 mov	 eax, 7

; 9602 : }

  0370a	c3		 ret	 0
$L72857:

; 9580 : 		default:	return 0;

  0370b	33 c0		 xor	 eax, eax

; 9602 : }

  0370d	c3		 ret	 0
  0370e	8b ff		 npad	 2
$L73384:
  03710	00 00 00 00	 DD	 $L72848
  03714	00 00 00 00	 DD	 $L72849
  03718	00 00 00 00	 DD	 $L72850
  0371c	00 00 00 00	 DD	 $L72851
  03720	00 00 00 00	 DD	 $L72852
  03724	00 00 00 00	 DD	 $L72853
  03728	00 00 00 00	 DD	 $L72854
  0372c	00 00 00 00	 DD	 $L72855
  03730	00 00 00 00	 DD	 $L72856
$L73385:
  03734	00 00 00 00	 DD	 $L72863
  03738	00 00 00 00	 DD	 $L72864
  0373c	00 00 00 00	 DD	 $L72865
  03740	00 00 00 00	 DD	 $L72866
  03744	00 00 00 00	 DD	 $L72867
  03748	00 00 00 00	 DD	 $L72868
  0374c	00 00 00 00	 DD	 $L72869
  03750	00 00 00 00	 DD	 $L72870
  03754	00 00 00 00	 DD	 $L72871
_TextToSpeechReserved1 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved2
_TEXT	SEGMENT
_TextToSpeechReserved2 PROC NEAR

; 9605 : #ifdef API_DEBUG
; 9606 : 	PVTM_T pVtm_t = phTTS->pVTMThreadData;
; 9607 : 	int i;
; 9608 : 	
; 9609 : 	for (i = 0; i < 7; i++)	gains[i] = pVtm_t->TunerData[i];
; 9610 : 	return 7;
; 9611 : #else
; 9612 : 	return 0;

  03760	33 c0		 xor	 eax, eax

; 9613 : #endif
; 9614 : }

  03762	c3		 ret	 0
_TextToSpeechReserved2 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetFeatures
PUBLIC	_TextToSpeechVersionEx
_BSS	SEGMENT
	ALIGN	4

_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9 DB 032H DUP (?)
	ALIGN	4

_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9 DB 032H DUP (?)
	ALIGN	4

$SG72888 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+2
$SG72889 DB	'v4.60 R011 NORMAL', 00H
	ORG $+2
$SG72890 DB	'%s %s', 00H
	ORG $+2
$SG72891 DB	'ER: Error', 00H
	ORG $+2
$SG72892 DB	'US: American English', 00H
_DATA	ENDS
_TEXT	SEGMENT
_ver$ = 8
_TextToSpeechVersionEx PROC NEAR

; 9623 : {

  03770	56		 push	 esi

; 9624 : 				static char DECtalk_Language_String[50];
; 9625 : 				static char DECtalk_Version_String[50];
; 9626 : 				
; 9627 : 				sprintf(DECtalk_Version_String,"%s %s",DTALK_STR_VERSION, CUSTR_STR_VERSION);

  03771	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__sprintf
  03777	68 00 00 00 00	 push	 OFFSET FLAT:$SG72888
  0377c	68 00 00 00 00	 push	 OFFSET FLAT:$SG72889
  03781	68 00 00 00 00	 push	 OFFSET FLAT:$SG72890
  03786	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9
  0378b	ff d6		 call	 esi

; 9628 : 				sprintf(DECtalk_Language_String, "ER: Error");

  0378d	68 00 00 00 00	 push	 OFFSET FLAT:$SG72891
  03792	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9
  03797	ff d6		 call	 esi

; 9629 : #ifdef ENGLISH_US
; 9630 : 				sprintf(DECtalk_Language_String, "US: American English");

  03799	68 00 00 00 00	 push	 OFFSET FLAT:$SG72892
  0379e	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9
  037a3	ff d6		 call	 esi

; 9631 : #endif
; 9632 : #ifdef SPANISH_LA
; 9633 : 				sprintf(DECtalk_Language_String, "LA: Latin American Spanish");
; 9634 : #endif
; 9635 : #ifdef SPANISH_SP
; 9636 : 				sprintf(DECtalk_Language_String, "SP: Castillian Spanish");
; 9637 : #endif
; 9638 : #ifdef GERMAN
; 9639 : 				sprintf(DECtalk_Language_String, "GR: German");
; 9640 : #endif
; 9641 : #ifdef FRENCH
; 9642 : 				sprintf(DECtalk_Language_String, "FR: French");
; 9643 : #endif
; 9644 : #ifdef SWAHILI
; 9645 : 				sprintf(DECtalk_Language_String, "SW: Swahili");
; 9646 : #endif
; 9647 : #ifdef ENGLISH_UK
; 9648 : 				sprintf(DECtalk_Language_String, "UK: British English");
; 9649 : #endif
; 9650 : 
; 9651 : 				if ((*ver = malloc(sizeof(VERSION_INFO))) == NULL)	return 0;

  037a5	6a 18		 push	 24			; 00000018H
  037a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  037ad	8b 74 24 2c	 mov	 esi, DWORD PTR _ver$[esp+36]
  037b1	83 c4 24	 add	 esp, 36			; 00000024H
  037b4	85 c0		 test	 eax, eax
  037b6	89 06		 mov	 DWORD PTR [esi], eax
  037b8	75 02		 jne	 SHORT $L72895
  037ba	5e		 pop	 esi

; 9660 : }

  037bb	c3		 ret	 0
$L72895:

; 9652 : 				(*ver)->StructSize = sizeof(VERSION_INFO);

  037bc	c7 00 18 00 00
	00		 mov	 DWORD PTR [eax], 24	; 00000018H

; 9653 : 				(*ver)->StructVersion = VERSION_STRUCT_VER;

  037c2	8b 06		 mov	 eax, DWORD PTR [esi]
  037c4	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 9654 : 				(*ver)->DLLVersion = (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;

  037cb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  037cd	66 c7 41 08 09
	01		 mov	 WORD PTR [ecx+8], 265	; 00000109H

; 9655 : 				(*ver)->DTalkVersion = (DTALK_DBG_VERSION << 15) + (DTALK_MAJ_VERSION << 8) + DTALK_MIN_VERSION;

  037d3	8b 16		 mov	 edx, DWORD PTR [esi]
  037d5	66 c7 42 0a 3c
	04		 mov	 WORD PTR [edx+10], 1084	; 0000043cH

; 9656 : 				(*ver)->VerString = DECtalk_Version_String;

  037db	8b 06		 mov	 eax, DWORD PTR [esi]
  037dd	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9

; 9657 : 				(*ver)->Language = DECtalk_Language_String;

  037e4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  037e6	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9

; 9658 : 				(*ver)->Features = TextToSpeechGetFeatures();

  037ed	e8 00 00 00 00	 call	 _TextToSpeechGetFeatures
  037f2	8b 16		 mov	 edx, DWORD PTR [esi]
  037f4	5e		 pop	 esi
  037f5	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 9659 : 				return (sizeof(VERSION_INFO));

  037f8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H

; 9660 : }

  037fd	c3		 ret	 0
_TextToSpeechVersionEx ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechStartLang
_TEXT	SEGMENT
_TextToSpeechStartLang PROC NEAR

; 9669 : 				return TTS_NOT_SUPPORTED;

  03800	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 9670 : }

  03805	c3		 ret	 0
_TextToSpeechStartLang ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechCloseLang
_TEXT	SEGMENT
_TextToSpeechCloseLang PROC NEAR

; 9672 : 				return FALSE;

  03810	33 c0		 xor	 eax, eax

; 9673 : }

  03812	c3		 ret	 0
_TextToSpeechCloseLang ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSelectLang
_TEXT	SEGMENT
_TextToSpeechSelectLang PROC NEAR

; 9687 : 				return FALSE;

  03820	33 c0		 xor	 eax, eax

; 9688 : }

  03822	c3		 ret	 0
_TextToSpeechSelectLang ENDP
_TextToSpeechGetFeatures PROC NEAR

; 9699 : 	unsigned long int feats;
; 9700 : 	
; 9701 : #ifdef ACCESS32
; 9702 : 	feats = TTS_FEATS_TYPINGMODE;
; 9703 : #else
; 9704 : 	feats = 0;
; 9705 : #endif
; 9706 : 	return feats;

  03830	33 c0		 xor	 eax, eax

; 9707 : }

  03832	c3		 ret	 0
_TextToSpeechGetFeatures ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechEnumLangs
_TEXT	SEGMENT
_langs$ = 8
_verinfo$ = -4
_TextToSpeechEnumLangs PROC NEAR

; 9736 : U32 TextToSpeechEnumLangs(LPLANG_ENUM *langs) {

  03840	51		 push	 ecx
  03841	56		 push	 esi

; 9737 : 	LPVERSION_INFO verinfo;
; 9738 : 	
; 9739 : 	if (((*langs) = malloc(sizeof(LANG_ENUM))) == NULL)	return 0;

  03842	6a 0c		 push	 12			; 0000000cH
  03844	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0384a	8b 74 24 10	 mov	 esi, DWORD PTR _langs$[esp+8]
  0384e	83 c4 04	 add	 esp, 4
  03851	85 c0		 test	 eax, eax
  03853	89 06		 mov	 DWORD PTR [esi], eax
  03855	74 4b		 je	 SHORT $L73394

; 9740 : 	(*langs)->Languages = 1;

  03857	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 9741 : 	(*langs)->MultiLang = FALSE;

  0385d	8b 06		 mov	 eax, DWORD PTR [esi]

; 9742 : 	if (((*langs)->Entries = calloc(1, sizeof(LANG_ENTRY))) == NULL) {

  0385f	6a 2b		 push	 43			; 0000002bH
  03861	6a 01		 push	 1
  03863	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0386a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  03870	8b 0e		 mov	 ecx, DWORD PTR [esi]
  03872	83 c4 08	 add	 esp, 8
  03875	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  03878	8b 16		 mov	 edx, DWORD PTR [esi]
  0387a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0387d	85 c0		 test	 eax, eax

; 9743 : 		free(langs);
; 9744 : 		(*langs) = NULL;
; 9745 : 		return 0;

  0387f	74 11		 je	 SHORT $L73393

; 9746 : 	}
; 9747 : 	if (TextToSpeechVersionEx(&verinfo) == 0) {

  03881	8d 44 24 04	 lea	 eax, DWORD PTR _verinfo$[esp+8]
  03885	50		 push	 eax
  03886	e8 00 00 00 00	 call	 _TextToSpeechVersionEx
  0388b	83 c4 04	 add	 esp, 4
  0388e	85 c0		 test	 eax, eax
  03890	75 15		 jne	 SHORT $L72923
$L73393:

; 9748 : 		free(langs);

  03892	56		 push	 esi
  03893	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  03899	83 c4 04	 add	 esp, 4

; 9749 : 		(*langs) = NULL;

  0389c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$L73394:

; 9750 : 		return 0;

  038a2	33 c0		 xor	 eax, eax
  038a4	5e		 pop	 esi

; 9756 : }

  038a5	59		 pop	 ecx
  038a6	c3		 ret	 0
$L72923:

; 9751 : 	}
; 9752 : 	memcpy((*langs)->Entries[0].lang_code,verinfo->Language,2);

  038a7	8b 4c 24 04	 mov	 ecx, DWORD PTR _verinfo$[esp+8]
  038ab	8b 06		 mov	 eax, DWORD PTR [esi]
  038ad	57		 push	 edi
  038ae	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  038b1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  038b4	66 8b 12	 mov	 dx, WORD PTR [edx]
  038b7	66 89 11	 mov	 WORD PTR [ecx], dx

; 9753 : 	(*langs)->Entries[0].lang_code[2] = '\0';

  038ba	8b 06		 mov	 eax, DWORD PTR [esi]
  038bc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  038bf	c6 41 02 00	 mov	 BYTE PTR [ecx+2], 0

; 9754 : 	strcpy((*langs)->Entries[0].lang_name,verinfo->Language+4);

  038c3	8b 54 24 08	 mov	 edx, DWORD PTR _verinfo$[esp+12]
  038c7	8b 06		 mov	 eax, DWORD PTR [esi]
  038c9	83 c9 ff	 or	 ecx, -1
  038cc	8b 7a 10	 mov	 edi, DWORD PTR [edx+16]
  038cf	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  038d2	83 c7 04	 add	 edi, 4
  038d5	33 c0		 xor	 eax, eax
  038d7	83 c2 03	 add	 edx, 3
  038da	f2 ae		 repne scasb
  038dc	f7 d1		 not	 ecx
  038de	2b f9		 sub	 edi, ecx
  038e0	8b c1		 mov	 eax, ecx
  038e2	8b f7		 mov	 esi, edi
  038e4	8b fa		 mov	 edi, edx
  038e6	c1 e9 02	 shr	 ecx, 2
  038e9	f3 a5		 rep movsd
  038eb	8b c8		 mov	 ecx, eax

; 9755 : 	return (sizeof(LANG_ENUM));

  038ed	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  038f2	83 e1 03	 and	 ecx, 3
  038f5	f3 a4		 rep movsb
  038f7	5f		 pop	 edi
  038f8	5e		 pop	 esi

; 9756 : }

  038f9	59		 pop	 ecx
  038fa	c3		 ret	 0
_TextToSpeechEnumLangs ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved3
EXTRN	_GetNumUserEntries:NEAR
EXTRN	_GetUserEntry:NEAR
EXTRN	_UserDictionaryHit:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_type$ = 12
_data$ = 16
_max_size$ = 20
_entry$ = -132
_TextToSpeechReserved3 PROC NEAR

; 9768 : 	struct dic_entry entry; /* used to find a user dictionary entry's index, JAW 8/7/98 */
; 9769 : 	
; 9770 : 	PKSD_T  pKsd_t;
; 9771 : 	pKsd_t = phTTS->pKernelShareData;
; 9772 : 	
; 9773 : 	switch (type)
; 9774 : 	{

  03900	8b 44 24 08	 mov	 eax, DWORD PTR _type$[esp-4]
  03904	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  0390a	48		 dec	 eax
  0390b	53		 push	 ebx
  0390c	8b 9c 24 8c 00
	00 00		 mov	 ebx, DWORD PTR _phTTS$[esp+132]
  03913	56		 push	 esi
  03914	83 f8 06	 cmp	 eax, 6
  03917	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0391a	57		 push	 edi
  0391b	0f 87 12 01 00
	00		 ja	 $L72960
  03921	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L73396[eax*4]
$L72964:

; 9775 : 	case 1: 
; 9776 : 		/* return the size of the arpabet table */
; 9777 : 		return(pKsd_t->arpa_size);
; 9778 : 	case 2:
; 9779 : 		/* return the arpabet table */
; 9780 : 		if (max_size<pKsd_t->arpa_size)

  03928	8b 82 68 04 00
	00		 mov	 eax, DWORD PTR [edx+1128]
  0392e	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  03935	3b c8		 cmp	 ecx, eax
  03937	7d 0c		 jge	 SHORT $L72965
  03939	5f		 pop	 edi
  0393a	5e		 pop	 esi

; 9781 : 		{
; 9782 : 			return(-pKsd_t->arpa_size);

  0393b	f7 d8		 neg	 eax
  0393d	5b		 pop	 ebx

; 9818 : }

  0393e	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03944	c3		 ret	 0
$L72965:

; 9783 : 		}
; 9784 : 		else
; 9785 : 		{
; 9786 : 			memcpy(data,pKsd_t->arpabet,pKsd_t->arpa_size);

  03945	8b b2 64 04 00
	00		 mov	 esi, DWORD PTR [edx+1124]
  0394b	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  03952	8b c8		 mov	 ecx, eax
  03954	c1 e9 02	 shr	 ecx, 2
  03957	f3 a5		 rep movsd
  03959	8b c8		 mov	 ecx, eax
  0395b	83 e1 03	 and	 ecx, 3
  0395e	f3 a4		 rep movsb
$L72963:

; 9787 : 			return(pKsd_t->arpa_size);

  03960	8b 82 68 04 00
	00		 mov	 eax, DWORD PTR [edx+1128]
  03966	5f		 pop	 edi
  03967	5e		 pop	 esi
  03968	5b		 pop	 ebx

; 9818 : }

  03969	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  0396f	c3		 ret	 0
$L72966:
  03970	5f		 pop	 edi
  03971	5e		 pop	 esi

; 9788 : 		}
; 9789 : 	case 3:
; 9790 : 		/* return the number of entries the the asky conversion table */
; 9791 : 		return(sizeof(ptab));

  03972	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  03977	5b		 pop	 ebx

; 9818 : }

  03978	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  0397e	c3		 ret	 0
$L72968:

; 9792 : 	case 4:
; 9793 : 		/* return the asky conversion table */
; 9794 : 		if (max_size<sizeof(ptab))

  0397f	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  03986	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  0398b	3b c8		 cmp	 ecx, eax
  0398d	73 0f		 jae	 SHORT $L72969
  0398f	5f		 pop	 edi
  03990	5e		 pop	 esi

; 9795 : 		{
; 9796 : 			return(-(int)sizeof(ptab));

  03991	b8 7e ff ff ff	 mov	 eax, -130		; ffffff7eH
  03996	5b		 pop	 ebx

; 9818 : }

  03997	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  0399d	c3		 ret	 0
$L72969:

; 9797 : 		}
; 9798 : 		else
; 9799 : 		{
; 9800 : 			memcpy(data,(char *)ptab,sizeof(ptab));

  0399e	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  039a5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  039aa	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_ptab
  039af	f3 a5		 rep movsd
  039b1	66 a5		 movsw
  039b3	5f		 pop	 edi
  039b4	5e		 pop	 esi
  039b5	5b		 pop	 ebx

; 9818 : }

  039b6	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  039bc	c3		 ret	 0
$L72971:

; 9801 : 			return(sizeof(ptab));
; 9802 : 		}
; 9803 : 	case 5:
; 9804 : 		/* return number of user dictionary entries */
; 9805 : 		return GetNumUserEntries(phTTS); /* GetNumUserEntries is defined in ls_dict.c */

  039bd	53		 push	 ebx
  039be	e8 00 00 00 00	 call	 _GetNumUserEntries
  039c3	83 c4 04	 add	 esp, 4
  039c6	5f		 pop	 edi
  039c7	5e		 pop	 esi
  039c8	5b		 pop	 ebx

; 9818 : }

  039c9	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  039cf	c3		 ret	 0
$L72974:

; 9806 : 	case 6:
; 9807 : 		/* return the grapheme/phoneme string for the user dictionary entry at max_size in data 
; 9808 : 		   (don't let the variable name confuse you; max_size is simply being used as an index)
; 9809 : 		   */
; 9810 : 		return GetUserEntry(phTTS, data, max_size); /* GetUserEntry is defined in ls_dict.c,

  039d0	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  039d7	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR _data$[esp+140]
  039de	51		 push	 ecx
  039df	52		 push	 edx
  039e0	53		 push	 ebx
  039e1	e8 00 00 00 00	 call	 _GetUserEntry
  039e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  039e9	5f		 pop	 edi
  039ea	5e		 pop	 esi
  039eb	5b		 pop	 ebx

; 9818 : }

  039ec	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  039f2	c3		 ret	 0
$L72975:

; 9811 : 													   and it returns the starting index of the
; 9812 : 													   phoneme. */
; 9813 : 	case 7:
; 9814 : 		strcpy(entry.text, data);

  039f3	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  039fa	83 c9 ff	 or	 ecx, -1
  039fd	33 c0		 xor	 eax, eax
  039ff	8d 54 24 10	 lea	 edx, DWORD PTR _entry$[esp+148]
  03a03	f2 ae		 repne scasb
  03a05	f7 d1		 not	 ecx
  03a07	2b f9		 sub	 edi, ecx
  03a09	8b c1		 mov	 eax, ecx
  03a0b	8b f7		 mov	 esi, edi
  03a0d	8b fa		 mov	 edi, edx
  03a0f	c1 e9 02	 shr	 ecx, 2
  03a12	f3 a5		 rep movsd
  03a14	8b c8		 mov	 ecx, eax
  03a16	83 e1 03	 and	 ecx, 3
  03a19	f3 a4		 rep movsb

; 9815 : 		return UserDictionaryHit(phTTS, &entry); /* returns the index of the entry */

  03a1b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _entry$[esp+144]
  03a1f	51		 push	 ecx
  03a20	53		 push	 ebx
  03a21	e8 00 00 00 00	 call	 _UserDictionaryHit
  03a26	83 c4 08	 add	 esp, 8
  03a29	5f		 pop	 edi
  03a2a	5e		 pop	 esi
  03a2b	5b		 pop	 ebx

; 9818 : }

  03a2c	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03a32	c3		 ret	 0
$L72960:
  03a33	5f		 pop	 edi
  03a34	5e		 pop	 esi

; 9816 : 	}
; 9817 : 	return(-1);

  03a35	83 c8 ff	 or	 eax, -1
  03a38	5b		 pop	 ebx

; 9818 : }

  03a39	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03a3f	c3		 ret	 0
$L73396:
  03a40	00 00 00 00	 DD	 $L72963
  03a44	00 00 00 00	 DD	 $L72964
  03a48	00 00 00 00	 DD	 $L72966
  03a4c	00 00 00 00	 DD	 $L72968
  03a50	00 00 00 00	 DD	 $L72971
  03a54	00 00 00 00	 DD	 $L72974
  03a58	00 00 00 00	 DD	 $L72975
_TextToSpeechReserved3 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetPhVdefParams
EXTRN	_GetPhVdefParams:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_index$ = 12
_TextToSpeechGetPhVdefParams PROC NEAR

; 9835 : 	return GetPhVdefParams(phTTS, index);

  03a60	8b 44 24 08	 mov	 eax, DWORD PTR _index$[esp-4]
  03a64	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]
  03a68	50		 push	 eax
  03a69	51		 push	 ecx
  03a6a	e8 00 00 00 00	 call	 _GetPhVdefParams
  03a6f	83 c4 08	 add	 esp, 8

; 9836 : }

  03a72	c3		 ret	 0
_TextToSpeechGetPhVdefParams ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetSpeakerParams
EXTRN	_GetSpeakerParams:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_uiIndex$ = 12
_ppspCur$ = 16
_ppspLoLimit$ = 20
_ppspHiLimit$ = 24
_ppspDefault$ = 28
_TextToSpeechGetSpeakerParams PROC NEAR

; 9858 : 	return GetSpeakerParams(phTTS, uiIndex, ppspCur, ppspLoLimit, ppspHiLimit, ppspDefault);

  03a80	8b 44 24 18	 mov	 eax, DWORD PTR _ppspDefault$[esp-4]
  03a84	8b 4c 24 14	 mov	 ecx, DWORD PTR _ppspHiLimit$[esp-4]
  03a88	8b 54 24 10	 mov	 edx, DWORD PTR _ppspLoLimit$[esp-4]
  03a8c	50		 push	 eax
  03a8d	8b 44 24 10	 mov	 eax, DWORD PTR _ppspCur$[esp]
  03a91	51		 push	 ecx
  03a92	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiIndex$[esp+4]
  03a96	52		 push	 edx
  03a97	8b 54 24 10	 mov	 edx, DWORD PTR _phTTS$[esp+8]
  03a9b	50		 push	 eax
  03a9c	51		 push	 ecx
  03a9d	52		 push	 edx
  03a9e	e8 00 00 00 00	 call	 _GetSpeakerParams
  03aa3	83 c4 18	 add	 esp, 24			; 00000018H

; 9859 : }

  03aa6	c3		 ret	 0
_TextToSpeechGetSpeakerParams ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetSpeakerParams
EXTRN	_SetSpeakerParams:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pspSet$ = 12
_TextToSpeechSetSpeakerParams PROC NEAR

; 9876 : 	return SetSpeakerParams(phTTS, pspSet);

  03ab0	8b 44 24 08	 mov	 eax, DWORD PTR _pspSet$[esp-4]
  03ab4	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]
  03ab8	50		 push	 eax
  03ab9	51		 push	 ecx
  03aba	e8 00 00 00 00	 call	 _SetSpeakerParams
  03abf	83 c4 08	 add	 esp, 8

; 9877 : }

  03ac2	c3		 ret	 0
_TextToSpeechSetSpeakerParams ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDictionaryHit
EXTRN	_DictionaryHit:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechDictionaryHit PROC NEAR

; 9893 : 	long i;
; 9894 : 	
; 9895 : 	
; 9896 : 	if (phTTS == NULL)

  03ad0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03ad4	85 c0		 test	 eax, eax
  03ad6	75 04		 jne	 SHORT $L73065

; 9897 : 		return -1;

  03ad8	83 c8 ff	 or	 eax, -1

; 9901 : 		return 0;
; 9902 : 	return 1;
; 9903 : }

  03adb	c3		 ret	 0
$L73065:

; 9898 : 	
; 9899 : 	i = DictionaryHit(phTTS, entry);

  03adc	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03ae0	51		 push	 ecx
  03ae1	50		 push	 eax
  03ae2	e8 00 00 00 00	 call	 _DictionaryHit
  03ae7	83 c4 08	 add	 esp, 8

; 9900 : 	if (i == -1)

  03aea	33 d2		 xor	 edx, edx
  03aec	83 f8 ff	 cmp	 eax, -1
  03aef	0f 95 c2	 setne	 dl
  03af2	8b c2		 mov	 eax, edx

; 9901 : 		return 0;
; 9902 : 	return 1;
; 9903 : }

  03af4	c3		 ret	 0
_TextToSpeechDictionaryHit ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDumpDictionary
EXTRN	_DumpDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechDumpDictionary PROC NEAR

; 9908 : 	if (phTTS == NULL)

  03b00	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b04	85 c0		 test	 eax, eax
  03b06	75 06		 jne	 SHORT $L73073

; 9909 : 		return MMSYSERR_INVALHANDLE;

  03b08	b8 05 00 00 00	 mov	 eax, 5

; 9912 : }

  03b0d	c3		 ret	 0
$L73073:

; 9910 : 	
; 9911 : 	return DumpDictionary(phTTS, filename);

  03b0e	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03b12	51		 push	 ecx
  03b13	50		 push	 eax
  03b14	e8 00 00 00 00	 call	 _DumpDictionary
  03b19	83 c4 08	 add	 esp, 8

; 9912 : }

  03b1c	c3		 ret	 0
_TextToSpeechDumpDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechUserDictionaryHit
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechUserDictionaryHit PROC NEAR

; 9917 : 	long i;
; 9918 : 	
; 9919 : 	
; 9920 : 	if (phTTS == NULL)

  03b20	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b24	85 c0		 test	 eax, eax
  03b26	75 04		 jne	 SHORT $L73081

; 9921 : 		return -1;

  03b28	83 c8 ff	 or	 eax, -1

; 9925 : 		return 0;
; 9926 : 	return 1;
; 9927 : }

  03b2b	c3		 ret	 0
$L73081:

; 9922 : 	
; 9923 : 	i = UserDictionaryHit(phTTS, entry);

  03b2c	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03b30	51		 push	 ecx
  03b31	50		 push	 eax
  03b32	e8 00 00 00 00	 call	 _UserDictionaryHit
  03b37	83 c4 08	 add	 esp, 8

; 9924 : 	if (i == -1)

  03b3a	33 d2		 xor	 edx, edx
  03b3c	83 f8 ff	 cmp	 eax, -1
  03b3f	0f 95 c2	 setne	 dl
  03b42	8b c2		 mov	 eax, edx

; 9925 : 		return 0;
; 9926 : 	return 1;
; 9927 : }

  03b44	c3		 ret	 0
_TextToSpeechUserDictionaryHit ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDumpUserDictionary
EXTRN	_DumpUserDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechDumpUserDictionary PROC NEAR

; 9932 : 	if (phTTS == NULL)

  03b50	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b54	85 c0		 test	 eax, eax
  03b56	75 06		 jne	 SHORT $L73089

; 9933 : 		return MMSYSERR_INVALHANDLE;

  03b58	b8 05 00 00 00	 mov	 eax, 5

; 9936 : }

  03b5d	c3		 ret	 0
$L73089:

; 9934 : 	
; 9935 : 	return DumpUserDictionary(phTTS, filename);

  03b5e	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03b62	51		 push	 ecx
  03b63	50		 push	 eax
  03b64	e8 00 00 00 00	 call	 _DumpUserDictionary
  03b69	83 c4 08	 add	 esp, 8

; 9936 : }

  03b6c	c3		 ret	 0
_TextToSpeechDumpUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechAddUserEntry
EXTRN	_AddUserEntry:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechAddUserEntry PROC NEAR

; 9941 : 	if (phTTS == NULL)

  03b70	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b74	85 c0		 test	 eax, eax
  03b76	75 06		 jne	 SHORT $L73096

; 9942 : 		return MMSYSERR_INVALHANDLE;

  03b78	b8 05 00 00 00	 mov	 eax, 5

; 9945 : }

  03b7d	c3		 ret	 0
$L73096:

; 9943 : 	
; 9944 : 	return AddUserEntry(phTTS, entry);

  03b7e	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03b82	51		 push	 ecx
  03b83	50		 push	 eax
  03b84	e8 00 00 00 00	 call	 _AddUserEntry
  03b89	83 c4 08	 add	 esp, 8

; 9945 : }

  03b8c	c3		 ret	 0
_TextToSpeechAddUserEntry ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDeleteUserEntry
EXTRN	_DeleteUserEntry:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechDeleteUserEntry PROC NEAR

; 9950 : 	if (phTTS == NULL)

  03b90	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b94	85 c0		 test	 eax, eax
  03b96	75 06		 jne	 SHORT $L73103

; 9951 : 		return MMSYSERR_INVALHANDLE;																

  03b98	b8 05 00 00 00	 mov	 eax, 5

; 9954 : }

  03b9d	c3		 ret	 0
$L73103:

; 9952 : 	
; 9953 : 	return DeleteUserEntry(phTTS, entry);

  03b9e	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03ba2	51		 push	 ecx
  03ba3	50		 push	 eax
  03ba4	e8 00 00 00 00	 call	 _DeleteUserEntry
  03ba9	83 c4 08	 add	 esp, 8

; 9954 : }

  03bac	c3		 ret	 0
_TextToSpeechDeleteUserEntry ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechChangeUserPhoneme
EXTRN	_ChangeUserPhoneme:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_new_phoneme$ = 16
_TextToSpeechChangeUserPhoneme PROC NEAR

; 9960 : 	if (phTTS == NULL)

  03bb0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03bb4	85 c0		 test	 eax, eax
  03bb6	75 06		 jne	 SHORT $L73112

; 9961 : 		return MMSYSERR_INVALHANDLE;

  03bb8	b8 05 00 00 00	 mov	 eax, 5

; 9964 : }

  03bbd	c3		 ret	 0
$L73112:

; 9962 : 	
; 9963 : 	return ChangeUserPhoneme(phTTS, entry, new_phoneme);

  03bbe	8b 4c 24 0c	 mov	 ecx, DWORD PTR _new_phoneme$[esp-4]
  03bc2	8b 54 24 08	 mov	 edx, DWORD PTR _entry$[esp-4]
  03bc6	51		 push	 ecx
  03bc7	52		 push	 edx
  03bc8	50		 push	 eax
  03bc9	e8 00 00 00 00	 call	 _ChangeUserPhoneme
  03bce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9964 : }

  03bd1	c3		 ret	 0
_TextToSpeechChangeUserPhoneme ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSaveUserDictionary
EXTRN	_SaveUserDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechSaveUserDictionary PROC NEAR

; 9980 : 	if (phTTS == NULL)

  03be0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03be4	85 c0		 test	 eax, eax
  03be6	75 06		 jne	 SHORT $L73124

; 9981 : 		return MMSYSERR_INVALHANDLE;

  03be8	b8 05 00 00 00	 mov	 eax, 5

; 9984 : }

  03bed	c3		 ret	 0
$L73124:

; 9982 : 
; 9983 : 	return SaveUserDictionary(phTTS, filename);

  03bee	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03bf2	51		 push	 ecx
  03bf3	50		 push	 eax
  03bf4	e8 00 00 00 00	 call	 _SaveUserDictionary
  03bf9	83 c4 08	 add	 esp, 8

; 9984 : }

  03bfc	c3		 ret	 0
_TextToSpeechSaveUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechConvertToPhonemes
EXTRN	__imp__IsBadReadPtr@8:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_szPhonemeBuf$ = 12
_dwBufSize$ = 16
_szText$ = 24
_dwCvtFlags$ = 32
_TextToSpeechConvertToPhonemes PROC NEAR

; 9994 : {

  03c00	53		 push	 ebx
  03c01	55		 push	 ebp
  03c02	56		 push	 esi

; 9995 : 	if (phTTS == NULL)

  03c03	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  03c07	33 db		 xor	 ebx, ebx
  03c09	57		 push	 edi
  03c0a	3b f3		 cmp	 esi, ebx
  03c0c	75 0a		 jne	 SHORT $L73141
  03c0e	5f		 pop	 edi
  03c0f	5e		 pop	 esi
  03c10	5d		 pop	 ebp

; 9996 : 		return MMSYSERR_INVALHANDLE;

  03c11	b8 05 00 00 00	 mov	 eax, 5
  03c16	5b		 pop	 ebx

; 10027: }

  03c17	c3		 ret	 0
$L73141:

; 9997 : 	if (   IsBadReadPtr(szText,1)
; 9998 : 		|| IsBadReadPtr(dwBufSize,1)
; 9999 : 		|| IsBadWritePtr(szPhonemeBuf,*dwBufSize) )

  03c18	8b 44 24 24	 mov	 eax, DWORD PTR _szText$[esp+12]
  03c1c	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__IsBadReadPtr@8
  03c22	6a 01		 push	 1
  03c24	50		 push	 eax
  03c25	ff d5		 call	 ebp
  03c27	85 c0		 test	 eax, eax
  03c29	0f 85 94 00 00
	00		 jne	 $L73143
  03c2f	8b 7c 24 1c	 mov	 edi, DWORD PTR _dwBufSize$[esp+12]
  03c33	6a 01		 push	 1
  03c35	57		 push	 edi
  03c36	ff d5		 call	 ebp
  03c38	85 c0		 test	 eax, eax
  03c3a	0f 85 83 00 00
	00		 jne	 $L73143
  03c40	8b 0f		 mov	 ecx, DWORD PTR [edi]
  03c42	8b 6c 24 18	 mov	 ebp, DWORD PTR _szPhonemeBuf$[esp+12]
  03c46	51		 push	 ecx
  03c47	55		 push	 ebp
  03c48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  03c4e	85 c0		 test	 eax, eax
  03c50	75 71		 jne	 SHORT $L73143

; 10002: 	}
; 10003: 
; 10004: 	// come to a complete stop;
; 10005: 	TextToSpeechSync(phTTS);

  03c52	56		 push	 esi
  03c53	e8 00 00 00 00	 call	 _TextToSpeechSync

; 10006: 	// Set up to log phonemes
; 10007: 	phTTS->dwPhonemeBufferPtr = 0;
; 10008: 	phTTS->dwPhonemeBufferSize = *dwBufSize;
; 10009: 	phTTS->dwPhonemeCvtFlags = dwCvtFlags;
; 10010: 	phTTS->szPhonemeBuffer = szPhonemeBuf;
; 10011: 
; 10012: 	// send along the text
; 10013: 	TextToSpeechSpeak( phTTS, szText, TTS_FORCE);

  03c58	8b 4c 24 28	 mov	 ecx, DWORD PTR _szText$[esp+16]
  03c5c	8b 44 24 30	 mov	 eax, DWORD PTR _dwCvtFlags$[esp+16]
  03c60	89 9e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ebx
  03c66	8b 17		 mov	 edx, DWORD PTR [edi]
  03c68	6a 01		 push	 1
  03c6a	51		 push	 ecx
  03c6b	56		 push	 esi
  03c6c	89 96 e0 00 00
	00		 mov	 DWORD PTR [esi+224], edx
  03c72	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax
  03c78	89 ae dc 00 00
	00		 mov	 DWORD PTR [esi+220], ebp
  03c7e	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 10014: 	// wait for completion
; 10015: 	TextToSpeechSync(phTTS);

  03c83	56		 push	 esi
  03c84	e8 00 00 00 00	 call	 _TextToSpeechSync

; 10016: 	// clear the flags to the VTM
; 10017: 	phTTS->dwPhonemeCvtFlags = 0;
; 10018: 	// vtmiont leaves enough space for a terminating null..
; 10019: 	phTTS->szPhonemeBuffer[phTTS->dwPhonemeBufferPtr++]='\0';

  03c89	8b 96 e4 00 00
	00		 mov	 edx, DWORD PTR [esi+228]
  03c8f	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  03c95	89 9e e8 00 00
	00		 mov	 DWORD PTR [esi+232], ebx
  03c9b	83 c4 14	 add	 esp, 20			; 00000014H
  03c9e	88 1c 02	 mov	 BYTE PTR [edx+eax], bl
  03ca1	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  03ca7	40		 inc	 eax
  03ca8	89 86 e4 00 00
	00		 mov	 DWORD PTR [esi+228], eax

; 10020: 	// return the count in the BufSize arg
; 10021: 	*dwBufSize = phTTS->dwPhonemeBufferPtr;

  03cae	89 07		 mov	 DWORD PTR [edi], eax

; 10022: 	// stop logging
; 10023: 	phTTS->szPhonemeBuffer = NULL;

  03cb0	89 9e dc 00 00
	00		 mov	 DWORD PTR [esi+220], ebx

; 10024: 	phTTS->dwPhonemeBufferSize = 0;

  03cb6	89 9e e0 00 00
	00		 mov	 DWORD PTR [esi+224], ebx
  03cbc	5f		 pop	 edi
  03cbd	5e		 pop	 esi
  03cbe	5d		 pop	 ebp

; 10025: 
; 10026: 	return MMSYSERR_NOERROR;

  03cbf	33 c0		 xor	 eax, eax
  03cc1	5b		 pop	 ebx

; 10027: }

  03cc2	c3		 ret	 0
$L73143:
  03cc3	5f		 pop	 edi
  03cc4	5e		 pop	 esi
  03cc5	5d		 pop	 ebp

; 10000: 	{
; 10001: 		return MMSYSERR_INVALPARAM;

  03cc6	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  03ccb	5b		 pop	 ebx

; 10027: }

  03ccc	c3		 ret	 0
_TextToSpeechConvertToPhonemes ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechTuning
_TEXT	SEGMENT
_phTTS$ = 8
_iFunction$ = 12
_pvtdArg$ = 16
_TextToSpeechTuning PROC NEAR

; 10043: 	PVTM_T pVtm_t = phTTS->pVTMThreadData;

  03cd0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03cd4	53		 push	 ebx

; 10044: 
; 10045: 	// make sure we haven't been handed junk..
; 10046: 	if (IsBadWritePtr(phTTS, sizeof(LPTTS_HANDLE_T)))

  03cd5	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__IsBadWritePtr@8
  03cdb	56		 push	 esi
  03cdc	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  03cdf	57		 push	 edi
  03ce0	6a 04		 push	 4
  03ce2	50		 push	 eax
  03ce3	ff d3		 call	 ebx
  03ce5	85 c0		 test	 eax, eax
  03ce7	74 09		 je	 SHORT $L73155
  03ce9	5f		 pop	 edi
  03cea	5e		 pop	 esi

; 10047: 	{
; 10048: 		// bad handle
; 10049: 		return MMSYSERR_INVALHANDLE;

  03ceb	b8 05 00 00 00	 mov	 eax, 5
  03cf0	5b		 pop	 ebx

; 10101: 
; 10102: } // TextToSpeechTuning

  03cf1	c3		 ret	 0
$L73155:

; 10050: 	}
; 10051: 
; 10052: 	// decide what to do..
; 10053: 	switch (iFunction)
; 10054: 	{

  03cf2	8b 44 24 14	 mov	 eax, DWORD PTR _iFunction$[esp+8]
  03cf6	48		 dec	 eax
  03cf7	74 48		 je	 SHORT $L73160
  03cf9	48		 dec	 eax
  03cfa	74 35		 je	 SHORT $L73161
  03cfc	48		 dec	 eax
  03cfd	74 09		 je	 SHORT $L73162
  03cff	5f		 pop	 edi
  03d00	5e		 pop	 esi

; 10094: 		break;
; 10095: 
; 10096: 	default:
; 10097: 		return MMSYSERR_INVALPARAM; // bad function request.

  03d01	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  03d06	5b		 pop	 ebx

; 10101: 
; 10102: } // TextToSpeechTuning

  03d07	c3		 ret	 0
$L73162:

; 10083: 		break;
; 10084: 
; 10085: 	case TTSTUNING_GET_RESULTS:
; 10086: 		// tek 01dec98
; 10087: 		if (IsBadWritePtr(pvtdArg, sizeof(VTM_TUNER_DATA)))

  03d08	8b 7c 24 18	 mov	 edi, DWORD PTR _pvtdArg$[esp+8]
  03d0c	6a 34		 push	 52			; 00000034H
  03d0e	57		 push	 edi
  03d0f	ff d3		 call	 ebx
  03d11	85 c0		 test	 eax, eax
  03d13	74 09		 je	 SHORT $L73164
  03d15	5f		 pop	 edi
  03d16	5e		 pop	 esi

; 10088: 		{
; 10089: 			// bad handle
; 10090: 			return MMSYSERR_INVALPARAM;

  03d17	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  03d1c	5b		 pop	 ebx

; 10101: 
; 10102: } // TextToSpeechTuning

  03d1d	c3		 ret	 0
$L73164:

; 10091: 		}
; 10092: 		// do the copy
; 10093: 		memcpy(pvtdArg, &pVtm_t->vtdTuneResults, sizeof(VTM_TUNER_DATA));

  03d1e	81 c6 70 01 00
	00		 add	 esi, 368		; 00000170H
  03d24	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  03d29	f3 a5		 rep movsd
  03d2b	5f		 pop	 edi
  03d2c	5e		 pop	 esi

; 10098: 
; 10099: 	} // switch (iFunction)
; 10100: 	return MMSYSERR_NOERROR; 

  03d2d	33 c0		 xor	 eax, eax
  03d2f	5b		 pop	 ebx

; 10101: 
; 10102: } // TextToSpeechTuning

  03d30	c3		 ret	 0
$L73161:

; 10078: 		break;
; 10079: 
; 10080: 	case TTSTUNING_DISABLE:
; 10081: 		// clear the switch
; 10082: 		pVtm_t->bDoTuning = FALSE;

  03d31	c7 86 28 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+552], 0
  03d3b	5f		 pop	 edi
  03d3c	5e		 pop	 esi

; 10098: 
; 10099: 	} // switch (iFunction)
; 10100: 	return MMSYSERR_NOERROR; 

  03d3d	33 c0		 xor	 eax, eax
  03d3f	5b		 pop	 ebx

; 10101: 
; 10102: } // TextToSpeechTuning

  03d40	c3		 ret	 0
$L73160:

; 10055: 	case TTSTUNING_ENABLE:
; 10056: 		// clear all the old data
; 10057: 		pVtm_t->vtdTuneResults.rnpmax=0;      /*maximum value within filter of casade rnp*/

  03d41	33 c0		 xor	 eax, eax

; 10058: 		pVtm_t->vtdTuneResults.rnzmax=0;      /*maximum value within filter of casade rnz*/
; 10059: 		pVtm_t->vtdTuneResults.c1max=0;       /*maximum value within filter of casade 1*/
; 10060: 		pVtm_t->vtdTuneResults.c2max=0;       /*maximum value within filter of casade 2*/
; 10061: 		pVtm_t->vtdTuneResults.c3max=0;       /*maximum value within filter of casade 3*/
; 10062: 		pVtm_t->vtdTuneResults.c4max=0;       /*maximum value within filter of casade 4*/
; 10063: 		pVtm_t->vtdTuneResults.c5max=0;       /*maximum value within filter of casade 5*/
; 10064: 		pVtm_t->vtdTuneResults.purevmax=0;    /*maximum value of downsampled voice */
; 10065: 		pVtm_t->vtdTuneResults.dwThisPhoneme=0;	/* the phoneme we overloaded on */
; 10066: 		pVtm_t->vtdTuneResults.dwLastPhoneme=0;	/* the phoneme we overloaded on */
; 10067: 
; 10068: 		pVtm_t->vtdTuneResults.r1cd2=0;
; 10069: 		pVtm_t->vtdTuneResults.r2cd2=0;
; 10070: 		pVtm_t->vtdTuneResults.r3cd2=0;
; 10071: 		pVtm_t->vtdTuneResults.r4cd2=0;
; 10072: 		pVtm_t->vtdTuneResults.r5cd2=0;
; 10073: 		pVtm_t->vtdTuneResults.rnpd2=0;
; 10074: 		pVtm_t->vtdTuneResults.rnzd2=0;
; 10075: 		pVtm_t->vtdTuneResults.rlpd2=0;
; 10076: 		// set the enable bit 
; 10077: 		pVtm_t->bDoTuning = TRUE;

  03d43	c7 86 28 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+552], 1
  03d4d	66 89 86 70 01
	00 00		 mov	 WORD PTR [esi+368], ax
  03d54	66 89 86 72 01
	00 00		 mov	 WORD PTR [esi+370], ax
  03d5b	66 89 86 74 01
	00 00		 mov	 WORD PTR [esi+372], ax
  03d62	66 89 86 76 01
	00 00		 mov	 WORD PTR [esi+374], ax
  03d69	66 89 86 78 01
	00 00		 mov	 WORD PTR [esi+376], ax
  03d70	66 89 86 7a 01
	00 00		 mov	 WORD PTR [esi+378], ax
  03d77	66 89 86 7c 01
	00 00		 mov	 WORD PTR [esi+380], ax
  03d7e	66 89 86 7e 01
	00 00		 mov	 WORD PTR [esi+382], ax
  03d85	89 86 8c 01 00
	00		 mov	 DWORD PTR [esi+396], eax
  03d8b	89 86 90 01 00
	00		 mov	 DWORD PTR [esi+400], eax
  03d91	66 89 86 94 01
	00 00		 mov	 WORD PTR [esi+404], ax
  03d98	66 89 86 96 01
	00 00		 mov	 WORD PTR [esi+406], ax
  03d9f	66 89 86 98 01
	00 00		 mov	 WORD PTR [esi+408], ax
  03da6	66 89 86 9a 01
	00 00		 mov	 WORD PTR [esi+410], ax
  03dad	66 89 86 9c 01
	00 00		 mov	 WORD PTR [esi+412], ax
  03db4	66 89 86 9e 01
	00 00		 mov	 WORD PTR [esi+414], ax
  03dbb	66 89 86 a0 01
	00 00		 mov	 WORD PTR [esi+416], ax
  03dc2	66 89 86 a2 01
	00 00		 mov	 WORD PTR [esi+418], ax
  03dc9	5f		 pop	 edi
  03dca	5e		 pop	 esi
  03dcb	5b		 pop	 ebx

; 10101: 
; 10102: } // TextToSpeechTuning

  03dcc	c3		 ret	 0
_TextToSpeechTuning ENDP
_PumpModeMessage PROC NEAR

; 10122: 	return(TRUE);

  03dd0	b8 01 00 00 00	 mov	 eax, 1

; 10123: }

  03dd5	c3		 ret	 0
_PumpModeMessage ENDP
_TEXT	ENDS
END
