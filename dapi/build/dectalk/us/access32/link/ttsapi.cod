	TITLE	D:\work\Product\dapi\src\api\ttsapi.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_gszA32Id
PUBLIC	_hMapObject
PUBLIC	_gnInstanceCounter
PUBLIC	_tl_gnInstanceCounter
PUBLIC	_gpufdic_index
PUBLIC	_gpufdic_data
PUBLIC	_gufdic_entries
PUBLIC	_gufdic_bytes
PUBLIC	_gufdicMapObject
PUBLIC	_gufdicFileHandle
PUBLIC	_gufdicMapStartAddr
PUBLIC	_gpufordic_index
PUBLIC	_gpufordic_data
PUBLIC	_gufordic_entries
PUBLIC	_gufordic_bytes
PUBLIC	_gufordicMapObject
PUBLIC	_gufordicFileHandle
PUBLIC	_gufordicMapStartAddr
PUBLIC	_szLicenseKey
_BSS	SEGMENT
_gszA32Id DB	0100H DUP (?)
_guiLoadedLicenseShare DD 01H DUP (?)
_lpvMemLicense DD 01H DUP (?)
_hMapObject DD	01H DUP (?)
_gnInstanceCounter DD 01H DUP (?)
_tl_gnInstanceCounter DB 0cH DUP (?)
_gpufdic_index DD 01H DUP (?)
_gpufdic_data DD 01H DUP (?)
_gufdic_entries DD 01H DUP (?)
_gufdic_bytes DD 01H DUP (?)
_gufdicMapObject DD 01H DUP (?)
_gufdicFileHandle DD 01H DUP (?)
_gufdicMapStartAddr DD 01H DUP (?)
_gpufordic_index DD 01H DUP (?)
_gpufordic_data DD 01H DUP (?)
_gufordic_entries DD 01H DUP (?)
_gufordic_bytes DD 01H DUP (?)
_gufordicMapObject DD 01H DUP (?)
_gufordicFileHandle DD 01H DUP (?)
_gufordicMapStartAddr DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_LanguageParamsArray:QWORD
_szLicenseKey DB 'Software\GW Micro, Inc.\DECtalk-OEM\4.62', 00H
	ORG $+3
_?wExponentLut@?1??LinearToMuLaw@@9@9 DW 00H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
_ptab	DB	065H
	DB	03H
	DB	061H
	DB	06H
	DB	069H
	DB	01H
	DB	045H
	DB	04H
	DB	041H
	DB	07H
	DB	049H
	DB	02H
	DB	04fH
	DB	0cH
	DB	06fH
	DB	0bH
	DB	075H
	DB	0eH
	DB	05eH
	DB	09H
	DB	057H
	DB	08H
	DB	059H
	DB	010H
	DB	052H
	DB	0fH
	DB	063H
	DB	0aH
	DB	040H
	DB	05H
	DB	055H
	DB	0dH
	DB	07cH
	DB	012H
	DB	078H
	DB	011H
	DB	070H
	DB	02dH
	DB	074H
	DB	02fH
	DB	06bH
	DB	031H
	DB	066H
	DB	025H
	DB	054H
	DB	027H
	DB	073H
	DB	029H
	DB	053H
	DB	02bH
	DB	043H
	DB	036H
	DB	077H
	DB	018H
	DB	079H
	DB	019H
	DB	068H
	DB	01cH
	DB	06cH
	DB	01bH
	DB	04cH
	DB	022H
	DB	04eH
	DB	024H
	DB	062H
	DB	02eH
	DB	064H
	DB	030H
	DB	067H
	DB	032H
	DB	076H
	DB	026H
	DB	044H
	DB	028H
	DB	07aH
	DB	02aH
	DB	05aH
	DB	02cH
	DB	04aH
	DB	037H
	DB	06dH
	DB	01fH
	DB	06eH
	DB	020H
	DB	047H
	DB	021H
	DB	072H
	DB	01aH
	DB	071H
	DB	035H
	DB	051H
	DB	034H
	DB	026H
	DB	033H
	DB	046H
	DB	038H
	DB	042H
	DB	013H
	DB	04bH
	DB	014H
	DB	050H
	DB	015H
	DB	04dH
	DB	016H
	DB	06aH
	DB	017H
	DB	02cH
	DB	073H
	DB	020H
	DB	06fH
	DB	09H
	DB	06fH
	DB	027H
	DB	067H
	DB	060H
	DB	066H
	DB	022H
	DB	068H
	DB	023H
	DB	06eH
	DB	028H
	DB	070H
	DB	029H
	DB	071H
	DB	02aH
	DB	06dH
	DB	07eH
	DB	064H
	DB	02dH
	DB	06cH
_DATA	ENDS
PUBLIC	_all_digits
_TEXT	SEGMENT
_input$ = 8
_all_digits PROC NEAR

; 689  : 	while (*input)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _input$[esp-4]
  00004	8a 01		 mov	 al, BYTE PTR [ecx]
  00006	84 c0		 test	 al, al
  00008	74 10		 je	 SHORT $L72765
$L72764:

; 690  : 	{
; 691  : 		if (*input<'0' || *input >'9')

  0000a	3c 30		 cmp	 al, 48			; 00000030H
  0000c	7c 12		 jl	 SHORT $L74625
  0000e	3c 39		 cmp	 al, 57			; 00000039H
  00010	7f 0e		 jg	 SHORT $L74625
  00012	8a 41 01	 mov	 al, BYTE PTR [ecx+1]

; 693  : 		input++;

  00015	41		 inc	 ecx
  00016	84 c0		 test	 al, al
  00018	75 f0		 jne	 SHORT $L72764
$L72765:

; 694  : 	}
; 695  : 	return(1);

  0001a	b8 01 00 00 00	 mov	 eax, 1

; 696  : }

  0001f	c3		 ret	 0
$L74625:

; 692  : 			return(0);

  00020	33 c0		 xor	 eax, eax

; 696  : }

  00022	c3		 ret	 0
_all_digits ENDP
_TEXT	ENDS
PUBLIC	_LibMain@12
_TEXT	SEGMENT
_LibMain@12 PROC NEAR

; 755  : 	switch(ul_reason_being_called)
; 756  : 	{
; 757  : 	/*
; 758  : 	* DLL is attaching to a process.It could be
; 759  : 	* while process getting loaded (The process 
; 760  : 	* might have used load-time dynamic linking i.e
; 761  : 	* built using dectalk.lib import library)
; 762  : 	* OR   
; 763  : 	* Process made a call to LoadLibrary(dectalk.dll)
; 764  : 		*/
; 765  : 	case DLL_PROCESS_ATTACH :
; 766  : 		//#ifdef LICENSES
; 767  : 		//              if (!AddLicenseRef())
; 768  : 		//                      return FALSE; // no licenses.
; 769  : 		//#endif
; 770  : 		break;
; 771  : 	case DLL_THREAD_ATTACH:
; 772  : 		break;
; 773  : 	case DLL_THREAD_DETACH:
; 774  : 		break;
; 775  : 	case DLL_PROCESS_DETACH :
; 776  : 		//#ifdef LICENSES
; 777  : 		//              ReleaseLicenseRef();
; 778  : 		//#endif
; 779  : 		break;
; 780  : 	}
; 781  : 	
; 782  : 	return(TRUE);

  00030	b8 01 00 00 00	 mov	 eax, 1

; 783  : 	//  return( 1 );
; 784  : 	//  UNREFERENCED_PARAMETER( hInst );
; 785  : 	//  UNREFERENCED_PARAMETER( ul_reason_being_called );
; 786  : 	//  UNREFERENCED_PARAMETER( lpReserved );
; 787  : }

  00035	c2 0c 00	 ret	 12			; 0000000cH
_LibMain@12 ENDP
_TEXT	ENDS
PUBLIC	_AddLicenseRef
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	_decryptString:NEAR
EXTRN	__imp__CreateFileMappingA@24:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	__imp__fclose:NEAR
EXTRN	__imp__fflush:NEAR
EXTRN	__imp__fopen:NEAR
EXTRN	__imp__fprintf:NEAR
EXTRN	__imp__MapViewOfFile@20:NEAR
EXTRN	__imp__UnmapViewOfFile@4:NEAR
EXTRN	__imp___strdate:NEAR
EXTRN	__imp___strtime:NEAR
_BSS	SEGMENT
$SG72835 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+2
$SG72812 DB	'a+', 00H
	ORG $+1
$SG72813 DB	'\dtlic.log', 00H
	ORG $+1
$SG72817 DB	'%s %s : Text-to-speech license information invalid!', 0aH
	DB	00H
	ORG $+3
$SG72822 DB	'a32DECtalkDllFileMap', 00H
	ORG $+3
$SG72849 DB	'a+', 00H
	ORG $+1
$SG72850 DB	'\dtlic.log', 00H
	ORG $+1
$SG72854 DB	'%s %s : Insufficient Text-to-Speech Run-time Licenses.', 0aH
	DB	00H
_DATA	ENDS
_TEXT	SEGMENT
_dwMAXRunTimeLicenses$ = -644
_szDateBuf$72815 = -576
_szTimeBuf$72816 = -640
_szEncryptedString$72834 = -512
_szDateBuf$72852 = -640
_szTimeBuf$72853 = -576
_AddLicenseRef PROC NEAR

; 874  : {

  00040	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H
  00046	53		 push	 ebx

; 875  : 	BOOL fInit,fIgnore;
; 876  : 	DWORD dwMAXRunTimeLicenses ;
; 877  : 	DWORD dwLicenseCount;
; 878  : 	
; 879  : #ifdef UNDER_CE
; 880  : 	HANDLE hFile;
; 881  : 	char temp[256];
; 882  : 	DWORD dwRw;
; 883  : 
; 884  : 	DeleteFile(_T("\\dtlic.log"));	// Delete file if it exist
; 885  : #else
; 886  : 	FILE *outfile;
; 887  : #endif
; 888  : 	
; 889  : 	if(dwMAXRunTimeLicenses == LICENSE_KEY_ERROR)

  00047	8b 5c 24 04	 mov	 ebx, DWORD PTR _dwMAXRunTimeLicenses$[esp+648]
  0004b	83 fb ff	 cmp	 ebx, -1
  0004e	56		 push	 esi
  0004f	75 61		 jne	 SHORT $L72810

; 890  : 	{
; 891  : #ifndef UNDER_CE
; 892  : #ifdef DEBUG // removed message box from release code BATS#741
; 893  : 		MessageBox(NULL,"Text-to-speech license information invalid!",
; 894  : 			"LicenseKey",MB_ICONSTOP|MB_OK);
; 895  : #endif	/* DEBUG */
; 896  : 
; 897  : 		{
; 898  : 			FILE *outfile;
; 899  : 			outfile=fopen("\\dtlic.log","a+");

  00051	68 00 00 00 00	 push	 OFFSET FLAT:$SG72812
  00056	68 00 00 00 00	 push	 OFFSET FLAT:$SG72813
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00061	8b f0		 mov	 esi, eax
  00063	83 c4 08	 add	 esp, 8

; 900  : 			if (outfile)

  00066	85 f6		 test	 esi, esi
  00068	74 3d		 je	 SHORT $L72851

; 901  : 			{
; 902  : 				char szDateBuf[64];
; 903  : 				char szTimeBuf[64];
; 904  : 			   // log the pertinent info
; 905  : 			   _strdate(szDateBuf);

  0006a	8d 44 24 4c	 lea	 eax, DWORD PTR _szDateBuf$72815[esp+652]
  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdate

; 906  : 			   _strtime(szTimeBuf);

  00075	8d 4c 24 10	 lea	 ecx, DWORD PTR _szTimeBuf$72816[esp+656]
  00079	51		 push	 ecx
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strtime

; 907  : 			   fprintf(outfile,"%s %s : Text-to-speech license information invalid!\n",
; 908  : 				   szDateBuf, szTimeBuf);

  00080	8d 54 24 14	 lea	 edx, DWORD PTR _szTimeBuf$72816[esp+660]
  00084	8d 44 24 54	 lea	 eax, DWORD PTR _szDateBuf$72815[esp+660]
  00088	52		 push	 edx
  00089	50		 push	 eax
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:$SG72817
$L74629:
  0008f	56		 push	 esi
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf

; 909  : 			   fflush(outfile);

  00096	56		 push	 esi
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush

; 910  : 			   fclose(outfile);

  0009d	56		 push	 esi
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000a4	83 c4 20	 add	 esp, 32			; 00000020H
$L72851:
  000a7	5e		 pop	 esi

; 911  : 			}
; 912  : 		}
; 913  : 
; 914  : #else
; 915  : #ifdef DEBUG // removed message box from release code BATS#790
; 916  : 
; 917  : 		MessageBox(NULL,_T("Text-to-speech license information invalid!"),
; 918  : 			_T("LicenseKey"),MB_ICONSTOP|MB_OK);
; 919  : #endif	/* DEBUG */
; 920  : #endif	/* UNDER_CE */
; 921  : 
; 922  : 		return FALSE;  // Don't load DLL

  000a8	33 c0		 xor	 eax, eax
  000aa	5b		 pop	 ebx

; 1080 : 	}
; 1081 : 	
; 1082 : }

  000ab	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  000b1	c3		 ret	 0
$L72810:

; 923  : 	}
; 924  : 	/* Create a named file mapping object */ 
; 925  : 	// 0 means Unlimited Licenses :Just return from DllEntry function.
; 926  : 	if(!dwMAXRunTimeLicenses)     

  000b2	85 db		 test	 ebx, ebx

; 927  : 		return TRUE;

  000b4	0f 84 b5 01 00
	00		 je	 $L72844

; 928  : 	
; 929  : 	if (!guiLoadedLicenseShare)			 /* tek 08Jan97 BATS 205*/

  000ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _guiLoadedLicenseShare
  000bf	85 c0		 test	 eax, eax
  000c1	0f 85 13 01 00
	00		 jne	 $L72819

; 930  : 	{
; 931  : 		hMapObject = CreateFileMapping( 
; 932  : 			(HANDLE) 0xFFFFFFFF, /* use paging file    */ 
; 933  : 			NULL,                /* no security attr.  */ 
; 934  : 			PAGE_READWRITE,      /* read/write access  */ 
; 935  : 			0,                   /* size: high 32-bits */ 
; 936  : 			SHMEMSIZE,           /* size: low 32-bits  */
; 937  : #ifndef ACI_LICENSE	//tek 01may97
; 938  : #ifdef WILLOWPOND
; 939  : 			"wpDECtalkDllLicensememfilemap");    /* name of map object */
; 940  : #else // not aci, not willowpond
; 941  : #ifdef ACCESS32 // tek 15sep97
; 942  : 		"a32DECtalkDllFileMap");                        /* name of map object */

  000c7	68 00 00 00 00	 push	 OFFSET FLAT:$SG72822
  000cc	6a 0a		 push	 10			; 0000000aH
  000ce	6a 00		 push	 0
  000d0	6a 04		 push	 4
  000d2	6a 00		 push	 0
  000d4	6a ff		 push	 -1
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingA@24

; 943  : #else // not aci, not willowpond, not access32
; 944  : #ifdef UNDER_CE
; 945  : 		TEXT("DECtalkDllLicensememfilemap"));    /* name of map object */
; 946  : #else
; 947  : 		"DECtalkDllLicensememfilemap");    /* name of map object */
; 948  : #endif	/* UNDER_CE */
; 949  : #endif	/* ACCESS32 */
; 950  : #endif	/* WILLOWPOND */
; 951  : #else
; 952  : 		"AciSpeechLicenseMemFileMap");	/* name of map object */
; 953  : #endif	/* ACI_LICENSE */
; 954  : 		
; 955  : 		if (hMapObject == NULL) 

  000dc	85 c0		 test	 eax, eax
  000de	a3 00 00 00 00	 mov	 DWORD PTR _hMapObject, eax
  000e3	75 09		 jne	 SHORT $L72824
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1080 : 	}
; 1081 : 	
; 1082 : }

  000e7	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  000ed	c3		 ret	 0
$L72824:

; 956  : 			return FALSE; 
; 957  : 		
; 958  : 		/* The first process to attach initializes memory. */ 
; 959  : 		
; 960  : 		fInit = (GetLastError() != ERROR_ALREADY_EXISTS); 

  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000f4	33 c9		 xor	 ecx, ecx
  000f6	3d b7 00 00 00	 cmp	 eax, 183		; 000000b7H
  000fb	0f 95 c1	 setne	 cl
  000fe	8b c1		 mov	 eax, ecx

; 961  : #ifdef ACCESS32 //tek 15sep97 SMIT licensing
; 962  : 		// ACCESS32 requires the SMITxx code to do the init..
; 963  : 		if (fInit)      // false if the section already exists

  00100	85 c0		 test	 eax, eax
  00102	74 18		 je	 SHORT $L72825

; 964  : 		{
; 965  : 			// get rid of the handle
; 966  : 			CloseHandle(hMapObject);

  00104	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hMapObject
  0010a	52		 push	 edx
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00111	5e		 pop	 esi

; 967  : 			// return a license failure.
; 968  : 			return FALSE;

  00112	33 c0		 xor	 eax, eax
  00114	5b		 pop	 ebx

; 1080 : 	}
; 1081 : 	
; 1082 : }

  00115	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  0011b	c3		 ret	 0
$L72825:

; 969  : 		} // if (fInit)
; 970  : #endif /* ACCESS32 */
; 971  : 		/* Get a pointer to the file-mapped shared memory. */
; 972  : 		
; 973  : 		lpvMemLicense = MapViewOfFile( 
; 974  : 			hMapObject,     /* object to map view of    */ 
; 975  : 			FILE_MAP_WRITE, /* read/write access        */ 
; 976  : 			0,              /* high offset:   map from  */ 
; 977  : 			0,              /* low offset:    beginning */ 
; 978  : 			0);             /* default: map entire file */ 

  0011c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	6a 02		 push	 2
  00129	50		 push	 eax
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20
  00130	8b d0		 mov	 edx, eax

; 979  : 		if (lpvMemLicense == NULL) 

  00132	85 d2		 test	 edx, edx
  00134	89 15 00 00 00
	00		 mov	 DWORD PTR _lpvMemLicense, edx
  0013a	75 09		 jne	 SHORT $L72828
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx

; 1080 : 	}
; 1081 : 	
; 1082 : }

  0013e	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  00144	c3		 ret	 0
$L72828:

; 980  : 			return FALSE; 
; 981  : 		
; 982  : 		/* Initialize memory if this is the first process. */ 
; 983  : 		if (fInit)
; 984  : 		{
; 985  : 			//memset(lpvMemLicense, '\0', SHMEMSIZE);
; 986  : 			*(PDWORD)lpvMemLicense = (DWORD)0;
; 987  : 			// To set the Number of Licenses
; 988  : 			
; 989  : 		}
; 990  : #ifdef ACCESS32 //tek 15sep97 SMIT licensing
; 991  :         else
; 992  :         {
; 993  : 			char *szMemLicense=NULL;
; 994  : 			char szEncryptedString[512]="";

  00145	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR $SG72835
  0014b	57		 push	 edi
  0014c	88 8c 24 90 00
	00 00		 mov	 BYTE PTR _szEncryptedString$72834[esp+656], cl
  00153	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00158	33 c0		 xor	 eax, eax
  0015a	8d bc 24 91 00
	00 00		 lea	 edi, DWORD PTR _szEncryptedString$72834[esp+657]
  00161	f3 ab		 rep stosd
  00163	66 ab		 stosw
  00165	aa		 stosb

; 995  : 			UINT uiResult=0;
; 996  : 			// we have to check that the memory area is valid..
; 997  : 			szMemLicense = (char *)(lpvMemLicense);
; 998  : 			strcpy(szEncryptedString,&szMemLicense[4]);     // this is [4], because the

  00166	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00169	83 c9 ff	 or	 ecx, -1
  0016c	33 c0		 xor	 eax, eax
  0016e	8d 94 24 90 00
	00 00		 lea	 edx, DWORD PTR _szEncryptedString$72834[esp+656]
  00175	f2 ae		 repne scasb
  00177	f7 d1		 not	 ecx
  00179	2b f9		 sub	 edi, ecx

; 999  : 			// first DWORD is the license
; 1000 : 			// count.
; 1001 : 			// decrypt it..
; 1002 : 			uiResult = decryptString(szEncryptedString,
; 1003 : 				DEFAULT_ACCESS32_KEY,
; 1004 : 				gszA32Id);

  0017b	68 00 00 00 00	 push	 OFFSET FLAT:_gszA32Id
  00180	8b c1		 mov	 eax, ecx
  00182	8b f7		 mov	 esi, edi
  00184	8b fa		 mov	 edi, edx
  00186	68 6f 2b 00 00	 push	 11119			; 00002b6fH
  0018b	c1 e9 02	 shr	 ecx, 2
  0018e	f3 a5		 rep movsd
  00190	8b c8		 mov	 ecx, eax
  00192	83 e1 03	 and	 ecx, 3
  00195	f3 a4		 rep movsb
  00197	8d 8c 24 98 00
	00 00		 lea	 ecx, DWORD PTR _szEncryptedString$72834[esp+664]
  0019e	51		 push	 ecx
  0019f	e8 00 00 00 00	 call	 _decryptString
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1005 : 			
; 1006 : 			if (!uiResult)

  001a7	85 c0		 test	 eax, eax
  001a9	5f		 pop	 edi
  001aa	75 24		 jne	 SHORT $L72838

; 1007 : 			{
; 1008 : 				// unmap the section
; 1009 : 				UnmapViewOfFile(lpvMemLicense);

  001ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpvMemLicense
  001b2	52		 push	 edx
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 1010 : 				// get rid of the handle
; 1011 : 				CloseHandle(hMapObject);

  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  001be	50		 push	 eax
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  001c5	5e		 pop	 esi

; 1012 : 				// return a license failure.
; 1013 : 				return FALSE;

  001c6	33 c0		 xor	 eax, eax
  001c8	5b		 pop	 ebx

; 1080 : 	}
; 1081 : 	
; 1082 : }

  001c9	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  001cf	c3		 ret	 0
$L72838:

; 1014 : 			}
; 1015 :         }
; 1016 : 		
; 1017 : #endif	/* ACCESS32 */
; 1018 : 		
; 1019 : 		guiLoadedLicenseShare = TRUE;

  001d0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 1
$L72819:

; 1020 : 	}
; 1021 : 	/* tek 08jan97, BATS 205 */
; 1022 : 	/* make sure we have the section.. */
; 1023 : 	if (lpvMemLicense == NULL) 

  001da	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  001df	85 c0		 test	 eax, eax
  001e1	75 09		 jne	 SHORT $L72840
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx

; 1080 : 	}
; 1081 : 	
; 1082 : }

  001e5	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  001eb	c3		 ret	 0
$L72840:

; 1024 : 		return FALSE; 
; 1025 : 	
; 1026 : 	// Increment Run-time License Counter.(i.e How many Processes are using DECtalk.dll)
; 1027 : 	(*(PDWORD)lpvMemLicense)++;

  001ec	8b 30		 mov	 esi, DWORD PTR [eax]
  001ee	46		 inc	 esi
  001ef	89 30		 mov	 DWORD PTR [eax], esi

; 1028 : 	dwLicenseCount =  (*(PDWORD)lpvMemLicense);
; 1029 : 	
; 1030 : 	if(*(PDWORD)lpvMemLicense > dwMAXRunTimeLicenses)

  001f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpvMemLicense
  001f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f9	3b c3		 cmp	 eax, ebx
  001fb	76 72		 jbe	 SHORT $L72844

; 1031 : 	{
; 1032 : 		// Decrement Run-time License Counter.(i.e How many Processes are using DECtalk.dll)
; 1033 : 		(*(PDWORD)lpvMemLicense)--;

  001fd	48		 dec	 eax
  001fe	89 01		 mov	 DWORD PTR [ecx], eax

; 1034 : 		/* tek 08jan97 BATS 205 */
; 1035 : 		/* only unmap the section if the count is zero - which */
; 1036 : 		/* should never happen, I think.. */
; 1037 : 		if (*(PDWORD)lpvMemLicense == 0)

  00200	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  00205	83 38 00	 cmp	 DWORD PTR [eax], 0
  00208	75 1e		 jne	 SHORT $L72847

; 1038 : 		{
; 1039 : 			/* Unmap shared memory from the process's address space. */ 
; 1040 : 			fIgnore = UnmapViewOfFile(lpvMemLicense); 

  0020a	50		 push	 eax
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 1041 : 			/* Close the process's handle to the file-mapping object. */ 
; 1042 : 			fIgnore = CloseHandle(hMapObject); 

  00211	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hMapObject
  00217	51		 push	 ecx
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 1043 : 			guiLoadedLicenseShare = FALSE;

  0021e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 0
$L72847:

; 1044 : 		}
; 1045 : 		
; 1046 : #ifndef UNDER_CE
; 1047 : #ifdef DEBUG // removed message box from release code BATS#741
; 1048 : #if defined(UNDER_CE) && !defined(CUP28PROJECT)
; 1049 : 		MessageBox(NULL, _T("Insufficient Text-to-Speech Run-time Licenses."),_T("Licenses"),MB_ICONSTOP|MB_OK);
; 1050 : #else
; 1051 : 		 MessageBox(NULL,"Insufficient Text-to-Speech Run-time Licenses.","Licenses",MB_ICONSTOP|MB_OK);
; 1052 : #endif
; 1053 : #endif	/* DEBUG */
; 1054 :  		{
; 1055 : 			FILE *outfile;
; 1056 : 			outfile=fopen("\\dtlic.log","a+");

  00228	68 00 00 00 00	 push	 OFFSET FLAT:$SG72849
  0022d	68 00 00 00 00	 push	 OFFSET FLAT:$SG72850
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00238	8b f0		 mov	 esi, eax
  0023a	83 c4 08	 add	 esp, 8

; 1057 : 			if (outfile)

  0023d	85 f6		 test	 esi, esi
  0023f	0f 84 62 fe ff
	ff		 je	 $L72851

; 1058 : 			{
; 1059 : 				char szDateBuf[64];
; 1060 : 				char szTimeBuf[64];
; 1061 : 			   // log the pertinent info
; 1062 : 			   _strdate(szDateBuf);

  00245	8d 54 24 0c	 lea	 edx, DWORD PTR _szDateBuf$72852[esp+652]
  00249	52		 push	 edx
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdate

; 1063 : 			   _strtime(szTimeBuf);

  00250	8d 44 24 50	 lea	 eax, DWORD PTR _szTimeBuf$72853[esp+656]
  00254	50		 push	 eax
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strtime

; 1064 : 			   fprintf(outfile,"%s %s : Insufficient Text-to-Speech Run-time Licenses.\n",
; 1065 : 				   szDateBuf, szTimeBuf);

  0025b	8d 4c 24 54	 lea	 ecx, DWORD PTR _szTimeBuf$72853[esp+660]
  0025f	8d 54 24 14	 lea	 edx, DWORD PTR _szDateBuf$72852[esp+660]
  00263	51		 push	 ecx
  00264	52		 push	 edx
  00265	68 00 00 00 00	 push	 OFFSET FLAT:$SG72854

; 1066 : 			   fflush(outfile);
; 1067 : 			   fclose(outfile);
; 1068 : 			}
; 1069 : 		}
; 1070 : 
; 1071 : #else
; 1072 : 		MessageBox(NULL,_T("Insufficient Text-to-Speech Run-time Licenses."),_T("Licenses"),MB_ICONSTOP|MB_OK);
; 1073 : #endif	/* UNDER_CE */
; 1074 : 		
; 1075 : 		return FALSE; //Don't load DLL

  0026a	e9 20 fe ff ff	 jmp	 $L74629
$L72844:
  0026f	5e		 pop	 esi

; 1076 : 	}
; 1077 : 	else
; 1078 : 	{
; 1079 : 		return TRUE;

  00270	b8 01 00 00 00	 mov	 eax, 1
  00275	5b		 pop	 ebx

; 1080 : 	}
; 1081 : 	
; 1082 : }

  00276	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  0027c	c3		 ret	 0
_AddLicenseRef ENDP
_TEXT	ENDS
PUBLIC	_ReleaseLicenseRef
_TEXT	SEGMENT
_ReleaseLicenseRef PROC NEAR

; 1091 : 
; 1092 : #ifndef LICENSES
; 1093 : 	return;
; 1094 : #else
; 1095 : 	BOOL    fIgnore;
; 1096 : 	DWORD dwMAXRunTimeLicenses ;
; 1097 : 	dwMAXRunTimeLicenses = GetFromSomeWhere();

  00280	e8 00 00 00 00	 call	 _GetFromSomeWhere

; 1098 : 	if(dwMAXRunTimeLicenses == LICENSE_KEY_ERROR)

  00285	83 f8 ff	 cmp	 eax, -1
  00288	74 35		 je	 SHORT $L72864

; 1099 : 		return;
; 1100 : 	if(!dwMAXRunTimeLicenses)  //MVP: For '0'licenses return.   

  0028a	85 c0		 test	 eax, eax
  0028c	74 31		 je	 SHORT $L72864

; 1101 : 		return;
; 1102 : 	// Decrement Run-time license counter.
; 1103 : 	(*(PDWORD)lpvMemLicense)--;

  0028e	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  00293	8b 10		 mov	 edx, DWORD PTR [eax]
  00295	4a		 dec	 edx
  00296	89 10		 mov	 DWORD PTR [eax], edx

; 1104 : 	if (*(PDWORD)lpvMemLicense == 0)  /* tek 08jan96 BATS 205 */

  00298	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  0029d	83 38 00	 cmp	 DWORD PTR [eax], 0
  002a0	75 1d		 jne	 SHORT $L72864

; 1105 : 	{
; 1106 : 		/* Unmap shared memory from the process's address space. */ 
; 1107 : 		fIgnore = UnmapViewOfFile(lpvMemLicense); 

  002a2	50		 push	 eax
  002a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 1108 : 		/* Close the process's handle to the file-mapping object. */ 
; 1109 : 		fIgnore = CloseHandle(hMapObject); 

  002a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  002ae	50		 push	 eax
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 1110 : 		guiLoadedLicenseShare = FALSE;

  002b5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 0
$L72864:

; 1111 : 	}
; 1112 : #endif /* LICENSES */
; 1113 : }

  002bf	c3		 ret	 0
_ReleaseLicenseRef ENDP
_GetFromSomeWhere PROC NEAR

; 797  : #ifdef ACCESS32 // tek 15sep97 SMIT licensing
; 798  : #define ACCESS32_LICENSE_COUNT (4)
; 799  : 	return ACCESS32_LICENSE_COUNT;

  002c0	b8 04 00 00 00	 mov	 eax, 4

; 800  : #else //ACCESS32
; 801  : 	HKEY hKeyLicense = NULL;
; 802  : 	// tek 01may97 key now comes from coop.h
; 803  : 	CHAR szLicensesEncrypted[MAX_STR];
; 804  : 
; 805  : #ifdef UNDER_CE //mfg 09jan99 Windows CE support
; 806  : 	TCHAR wszLicensesEncrypted[MAX_STR/2];
; 807  : #endif	/*UNDER_CE */
; 808  : 
; 809  : 	char szLicenses[64];
; 810  : 	DWORD dwType,cbData;
; 811  : 	
; 812  : 	if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
; 813  : 		szLicenseKey,
; 814  : 		0,
; 815  : 		KEY_QUERY_VALUE,
; 816  : 		&hKeyLicense ) != ERROR_SUCCESS )
; 817  : 	{
; 818  : 		return LICENSE_KEY_ERROR;
; 819  : 	}
; 820  : 	else
; 821  : 	{
; 822  : 		cbData = MAX_STR;
; 823  : 		if ( RegQueryValueEx( hKeyLicense,
; 824  : #ifndef UNDER_CE //mfg 09jan99 Windows CE support
; 825  : 			"Licenses",
; 826  : #else
; 827  : 			TEXT("Licenses"),
; 828  : #endif	/* UNDER_CE */
; 829  : 
; 830  : 			NULL,
; 831  : 			&dwType,
; 832  : 
; 833  : #ifndef UNDER_CE //mfg 09jan99 Windows CE support
; 834  : 			(LPBYTE)szLicensesEncrypted,
; 835  : #else
; 836  : 			(LPBYTE)wszLicensesEncrypted,
; 837  : #endif	/* UNDER_CE */
; 838  : 
; 839  : 			&cbData ) != ERROR_SUCCESS )
; 840  : 		{
; 841  : 			return LICENSE_KEY_ERROR;
; 842  : 		}       
; 843  : 
; 844  : #ifdef UNDER_CE	//mfg 09jan99 Windows CE support
; 845  : WideStringtoAsciiString(szLicensesEncrypted, wszLicensesEncrypted, MAX_STR);
; 846  : #endif	/* UNDER_CE */
; 847  : 
; 848  : 		RegCloseKey( hKeyLicense );
; 849  : 	}
; 850  : 	
; 851  : 	if (decryptString((const unsigned char *)szLicensesEncrypted,LICENSE_KEY,(unsigned char *)szLicenses))
; 852  : 	{
; 853  : 		if (all_digits(szLicenses)==0)
; 854  : 		{	
; 855  : 			return(LICENSE_KEY_ERROR);
; 856  : 		}
; 857  : 		return(atol(szLicenses));
; 858  : 	}
; 859  : 	return(LICENSE_KEY_ERROR);
; 860  : #endif /* ACCESS32 */
; 861  : }

  002c5	c3		 ret	 0
_GetFromSomeWhere ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechStartupEx
PUBLIC	_TextToSpeechStartupExFonix
_TEXT	SEGMENT
_pphTTS$ = 8
_uiDeviceNumber$ = 12
_dwDeviceOptions$ = 16
_DtCallbackRoutine$ = 20
_dwTTSInstanceParameter$ = 24
_TextToSpeechStartupEx PROC NEAR

; 1595 : 
; 1596 : 
; 1597 : return TextToSpeechStartupExFonix( pphTTS,
; 1598 : 							   uiDeviceNumber,
; 1599 : 							   dwDeviceOptions,
; 1600 : 							   DtCallbackRoutine,
; 1601 : 							   dwTTSInstanceParameter,
; 1602 : 							   NULL);

  002d0	8b 44 24 14	 mov	 eax, DWORD PTR _dwTTSInstanceParameter$[esp-4]
  002d4	8b 4c 24 10	 mov	 ecx, DWORD PTR _DtCallbackRoutine$[esp-4]
  002d8	8b 54 24 0c	 mov	 edx, DWORD PTR _dwDeviceOptions$[esp-4]
  002dc	6a 00		 push	 0
  002de	50		 push	 eax
  002df	8b 44 24 10	 mov	 eax, DWORD PTR _uiDeviceNumber$[esp+4]
  002e3	51		 push	 ecx
  002e4	8b 4c 24 10	 mov	 ecx, DWORD PTR _pphTTS$[esp+8]
  002e8	52		 push	 edx
  002e9	50		 push	 eax
  002ea	51		 push	 ecx
  002eb	e8 00 00 00 00	 call	 _TextToSpeechStartupExFonix
  002f0	83 c4 18	 add	 esp, 24			; 00000018H

; 1603 : }

  002f3	c3		 ret	 0
_TextToSpeechStartupEx ENDP
_TEXT	ENDS
PUBLIC	_PlayAudioCallbackRoutine
PUBLIC	__real@8@4008fa00000000000000
PUBLIC	_TextToSpeechReset
EXTRN	__imp__calloc:NEAR
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__InitializeCriticalSection@4:NEAR
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	__imp__RegisterWindowMessageA@4:NEAR
EXTRN	_create_pipe:NEAR
EXTRN	_PA_CreatePlayHandle:NEAR
EXTRN	_PA_GetFormat:NEAR
EXTRN	__fltused:NEAR
EXTRN	_OP_SetThreadPriority:NEAR
EXTRN	_OP_CreateMutex:NEAR
EXTRN	_cmd_main@4:NEAR
EXTRN	_lts_main@4:NEAR
EXTRN	_ph_main@4:NEAR
EXTRN	_vtm_main@4:NEAR
EXTRN	_sync_main@4:NEAR
_DATA	SEGMENT
$SG73025 DB	'DECtalkErrorMessage', 00H
$SG73027 DB	'DECtalkIndexMessage', 00H
$SG73029 DB	'DECtalkBookmarkMessage', 00H
	ORG $+1
$SG73031 DB	'DECtalkWordposMessage', 00H
	ORG $+2
$SG73033 DB	'DECtalkStartMessage', 00H
$SG73035 DB	'DECtalkStopMessage', 00H
	ORG $+1
$SG73037 DB	'DECtalkVisualMessage', 00H
	ORG $+3
$SG73039 DB	'DECtalkBufferMessage', 00H
_DATA	ENDS
;	COMDAT __real@8@4008fa00000000000000
; File D:\work\Product\dapi\src\api\ttsapi.c
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_pphTTS$ = 8
_uiDeviceNumber$ = 12
_dwDeviceOptions$ = 16
_DtCallbackRoutine$ = 20
_dwTTSInstanceParameter$ = 24
_dictionary_file_name$ = 28
_pPlayAudio$ = -12
_cmd_pipe$ = 20
_lts_pipe$ = -8
_vtm_pipe$ = 28
_sync_pipe$ = 24
_pKsd_t$ = -8
_TextToSpeechStartupExFonix PROC NEAR

; 1698 : {

  00300	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00303	53		 push	 ebx
  00304	55		 push	 ebp
  00305	56		 push	 esi
  00306	57		 push	 edi

; 1699 : 	MMRESULT mmStatus;
; 1700 : 	UINT i;
; 1701 : #if defined __osf__ || defined __linux__
; 1702 : 	int  productIndex; /* Index into product license list */
; 1703 : #endif	/* defined __osf__ || defined __linux__ */
; 1704 : 	
; 1705 : #if defined OLEDECTALK || defined SAPI5DECTALK
; 1706 : 	LPAUDIO_HANDLE_T pPlayAudio;
; 1707 : #else
; 1708 : 	HPLAY_AUDIO_T pPlayAudio;         //New audio Integration
; 1709 : #endif	/* defined OLEDECTALK || defined SAPI5DECTALK */
; 1710 : 	
; 1711 : #ifndef SAPI5DECTALK
; 1712 : 	LPWAVEFORMATEX pWaveFormat;	// 01aug97 bats423: now used for both SAPI and DAPI
; 1713 : #endif	/* SAPI5DECTALK */
; 1714 : 
; 1715 : 	LPTTS_HANDLE_T phTTS;
; 1716 : 	int nReturnCode;           /*MVP : a variable to hold the return value of this API*/
; 1717 : 	
; 1718 : 	P_PIPE cmd_pipe = NULL_PIPE;
; 1719 : 	P_PIPE lts_pipe = NULL_PIPE;
; 1720 : 	P_PIPE ph_pipe  = NULL_PIPE;
; 1721 : 	P_PIPE vtm_pipe = NULL_PIPE;
; 1722 : 	P_PIPE sync_pipe = NULL_PIPE;
; 1723 : 
; 1724 : #ifdef NEW_TRANSPORT
; 1725 : 	P_PIPE new_lts_pipe = NULL_PIPE;
; 1726 : #endif	/* NEW_TRANSPORT */
; 1727 : 
; 1728 : 	/* Define a variable for kernel_share_data to allocate after dynamically :MVP
; 1729 : 	*/
; 1730 : 	PKSD_T pKsd_t = NULL;
; 1731 : 	
; 1732 : #ifdef LICENSES
; 1733 : #if defined WIN32 || defined __linux__
; 1734 : #define MAX_INSTANCES_EXCEEDED  (MMSYSERR_ALLOCATED) // tek 29jul96
; 1735 : 	if (!AddLicenseRef())

  00307	e8 00 00 00 00	 call	 _AddLicenseRef
  0030c	85 c0		 test	 eax, eax
  0030e	75 0d		 jne	 SHORT $L72916
  00310	5f		 pop	 edi
  00311	5e		 pop	 esi
  00312	5d		 pop	 ebp

; 1736 : 	{
; 1737 : 		return MAX_INSTANCES_EXCEEDED;

  00313	b8 04 00 00 00	 mov	 eax, 4
  00318	5b		 pop	 ebx

; 3099 : }

  00319	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031c	c3		 ret	 0
$L72916:

; 1738 : 	}
; 1739 : #else
; 1740 : 	/* Check for a valid license */
; 1741 : 	mmStatus = CheckLicenses();
; 1742 : 	if (mmStatus)
; 1743 : 	{
; 1744 : 		if (mmStatus == LIC_NO_MORE_UNITS)
; 1745 : 			return (MMSYSERR_ALLOCATED);
; 1746 : 		else
; 1747 : 			if (mmStatus == LIC_NO_PAK)
; 1748 : 				return (MMSYSERR_NOTENABLED);
; 1749 : 			else
; 1750 : 				return (MMSYSERR_ERROR);
; 1751 : 	}
; 1752 : #endif /* defined WIN32 || defined __linux__ */
; 1753 : #endif /* LICENSES */
; 1754 : 	
; 1755 : 	/********************************************************************/
; 1756 : 	/*  Set default parameters.                                         */
; 1757 : 	/********************************************************************/
; 1758 : 	
; 1759 : 	/* 
; 1760 : 	* Allocate kernel_share_data structure to make unique for each instance MVP
; 1761 : 	*/
; 1762 : 	if((pKsd_t = (PKSD_T) calloc(1,sizeof(KSD_T))) == NULL)

  0031d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__calloc
  00323	68 58 06 00 00	 push	 1624			; 00000658H
  00328	6a 01		 push	 1
  0032a	ff d7		 call	 edi
  0032c	8b f0		 mov	 esi, eax
  0032e	33 db		 xor	 ebx, ebx
  00330	83 c4 08	 add	 esp, 8
  00333	3b f3		 cmp	 esi, ebx
  00335	89 74 24 14	 mov	 DWORD PTR _pKsd_t$[esp+28], esi

; 1763 : 	{
; 1764 : #if defined WIN32 || defined __linux__
; 1765 : #ifdef LICENSES
; 1766 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1767 : #endif /* LICENSES */
; 1768 : 		return( MMSYSERR_NOMEM );

  00339	0f 84 d1 04 00
	00		 je	 $L74642

; 1769 : #endif /* defined WIN32 || defined __linux__ */
; 1770 : 	}
; 1771 : 	
; 1772 : 	/* GL 09/25/1997 initialize the dictionary entry */
; 1773 : 	for (i=0; i < MAX_languages; ++i)

  0033f	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  00342	b9 07 00 00 00	 mov	 ecx, 7
$L72921:

; 1774 : 	{
; 1775 : 		pKsd_t->adic_index[i] = 0;

  00347	89 58 70	 mov	 DWORD PTR [eax+112], ebx

; 1776 : 		pKsd_t->udic_index[i] = 0;

  0034a	89 18		 mov	 DWORD PTR [eax], ebx

; 1777 : 		pKsd_t->fdic_index[i] = 0;

  0034c	89 58 90	 mov	 DWORD PTR [eax-112], ebx

; 1778 : 		pKsd_t->adic_data[i] = 0;

  0034f	89 98 8c 00 00
	00		 mov	 DWORD PTR [eax+140], ebx

; 1779 : 		pKsd_t->udic_data[i] = 0;

  00355	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 1780 : 		pKsd_t->fdic_data[i] = 0;

  00358	89 58 ac	 mov	 DWORD PTR [eax-84], ebx

; 1781 : 		pKsd_t->adic_bytes[i] = 0;

  0035b	89 98 c4 00 00
	00		 mov	 DWORD PTR [eax+196], ebx

; 1782 : 		pKsd_t->udic_bytes[i] = 0;

  00361	89 58 54	 mov	 DWORD PTR [eax+84], ebx

; 1783 : 		pKsd_t->fdic_bytes[i] = 0;

  00364	89 58 e4	 mov	 DWORD PTR [eax-28], ebx

; 1784 : 		pKsd_t->adic_entries[i] = 0;

  00367	89 98 a8 00 00
	00		 mov	 DWORD PTR [eax+168], ebx

; 1785 : 		pKsd_t->udic_entries[i] = 0;

  0036d	89 58 38	 mov	 DWORD PTR [eax+56], ebx

; 1786 : 		pKsd_t->fdic_entries[i] = 0;

  00370	89 58 c8	 mov	 DWORD PTR [eax-56], ebx
  00373	83 c0 04	 add	 eax, 4
  00376	49		 dec	 ecx
  00377	75 ce		 jne	 SHORT $L72921

; 1787 : 	}
; 1788 : 	
; 1789 : 	pKsd_t->cmd_flush = FALSE;
; 1790 : 	pKsd_t->spc_flush = FALSE;
; 1791 : 	pKsd_t->halting = FALSE;
; 1792 : 	pKsd_t->logflag  = 0;
; 1793 : 	/* GL 11/15/1996 set defaulted Spanish to Latin */
; 1794 : #ifdef SPANISH_LA
; 1795 : 	pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
; 1796 : #else
; 1797 : 	pKsd_t->modeflag = MODE_CITATION;
; 1798 : #endif /* SPANISH_LA */
; 1799 : 	pKsd_t->sayflag = SAY_CLAUSE;
; 1800 : 	pKsd_t->pronflag = 0;
; 1801 : 	pKsd_t->wbreak = FALSE;
; 1802 : 	pKsd_t->text_flush = FALSE;
; 1803 : 	pKsd_t->async_change = FALSE;
; 1804 : 	pKsd_t->SamplePeriod = 9.07029478458E-5 ;  /* Initialize sample period */
; 1805 : 	pKsd_t->spc_pkt_save = NULL_SPC_PACKET;
; 1806 : 	pKsd_t->loaded_languages = NULL;           //MVP:05/10/96 Fixed an exception(When DECtalk runs on a machine without audio card)
; 1807 : 	pKsd_t->volume=100; //set volume to 100;

  00379	b8 64 00 00 00	 mov	 eax, 100		; 00000064H

; 1808 : 	pKsd_t->vol_att=100; //set volume to 100;
; 1809 : 	/********************************************************************/
; 1810 : 	/*  Create the TTS handle.                                          */
; 1811 : 	/********************************************************************/
; 1812 : 	
; 1813 : 	phTTS = (LPTTS_HANDLE_T )calloc(1,sizeof(TTS_HANDLE_T));

  0037e	68 f0 02 00 00	 push	 752			; 000002f0H
  00383	c7 86 f8 03 00
	00 07 f0 51 c7	 mov	 DWORD PTR [esi+1016], -950931449 ; c751f007H
  0038d	6a 01		 push	 1
  0038f	89 9e 2c 03 00
	00		 mov	 DWORD PTR [esi+812], ebx
  00395	89 9e 64 03 00
	00		 mov	 DWORD PTR [esi+868], ebx
  0039b	89 9e 34 03 00
	00		 mov	 DWORD PTR [esi+820], ebx
  003a1	89 9e c4 03 00
	00		 mov	 DWORD PTR [esi+964], ebx
  003a7	c7 86 c0 03 00
	00 00 01 00 00	 mov	 DWORD PTR [esi+960], 256 ; 00000100H
  003b1	89 9e c8 03 00
	00		 mov	 DWORD PTR [esi+968], ebx
  003b7	89 9e cc 03 00
	00		 mov	 DWORD PTR [esi+972], ebx
  003bd	89 9e d4 03 00
	00		 mov	 DWORD PTR [esi+980], ebx
  003c3	89 9e 30 03 00
	00		 mov	 DWORD PTR [esi+816], ebx
  003c9	89 9e 00 04 00
	00		 mov	 DWORD PTR [esi+1024], ebx
  003cf	c7 86 fc 03 00
	00 f8 c6 17 3f	 mov	 DWORD PTR [esi+1020], 1058522872 ; 3f17c6f8H
  003d9	89 9e 3c 03 00
	00		 mov	 DWORD PTR [esi+828], ebx
  003df	89 9e 1c 06 00
	00		 mov	 DWORD PTR [esi+1564], ebx
  003e5	89 86 dc 03 00
	00		 mov	 DWORD PTR [esi+988], eax
  003eb	89 86 e0 03 00
	00		 mov	 DWORD PTR [esi+992], eax
  003f1	ff d7		 call	 edi
  003f3	8b e8		 mov	 ebp, eax
  003f5	83 c4 08	 add	 esp, 8

; 1814 : 	
; 1815 : 	if ( phTTS == NULL )

  003f8	3b eb		 cmp	 ebp, ebx
  003fa	75 1c		 jne	 SHORT $L72929

; 1816 : 	{
; 1817 : #if defined WIN32 || defined __linux__
; 1818 : #ifdef LICENSES
; 1819 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  003fc	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 1820 : #endif /* LICENSES */
; 1821 : #endif /* defined WIN32 || defined __linux__ */
; 1822 : 		free(pKsd_t);			// tek 23sep96 plug memory leak

  00401	56		 push	 esi
  00402	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00408	83 c4 04	 add	 esp, 4

; 2720 : #endif	/* LICENSES */
; 2721 : #endif	/* defined WIN32 || defined __linux__ */
; 2722 : 
; 2723 : 			return( MMSYSERR_NOMEM );

  0040b	b8 07 00 00 00	 mov	 eax, 7
  00410	5f		 pop	 edi
  00411	5e		 pop	 esi
  00412	5d		 pop	 ebp
  00413	5b		 pop	 ebx

; 3099 : }

  00414	83 c4 0c	 add	 esp, 12			; 0000000cH
  00417	c3		 ret	 0
$L72929:

; 1823 : 		pKsd_t = NULL;
; 1824 : 		return( MMSYSERR_NOMEM );
; 1825 : 	}
; 1826 : 	// tek 20aug98 fill in the back pointer in kernel_share
; 1827 : 	pKsd_t->phTTS = phTTS;
; 1828 : 	
; 1829 : 	phTTS->dwDeviceOptions = dwDeviceOptions;
; 1830 : 	if (dictionary_file_name==NULL)

  00418	8b 7c 24 34	 mov	 edi, DWORD PTR _dictionary_file_name$[esp+24]
  0041c	8b 54 24 28	 mov	 edx, DWORD PTR _dwDeviceOptions$[esp+24]
  00420	89 ae 50 06 00
	00		 mov	 DWORD PTR [esi+1616], ebp
  00426	3b fb		 cmp	 edi, ebx
  00428	89 55 78	 mov	 DWORD PTR [ebp+120], edx
  0042b	75 08		 jne	 SHORT $L72932

; 1831 : 	{
; 1832 : 		phTTS->dictionary_file_name[0]='\0';

  0042d	88 9d fc 00 00
	00		 mov	 BYTE PTR [ebp+252], bl

; 1833 : 	}
; 1834 : 	else

  00433	eb 2d		 jmp	 SHORT $L72933
$L72932:

; 1835 : 	{
; 1836 : #ifdef UNDER_CE
; 1837 : 		wcscpy(phTTS->dictionary_file_name, dictionary_file_name);
; 1838 : #else
; 1839 : 		strcpy(phTTS->dictionary_file_name,dictionary_file_name);

  00435	83 c9 ff	 or	 ecx, -1
  00438	33 c0		 xor	 eax, eax
  0043a	f2 ae		 repne scasb
  0043c	f7 d1		 not	 ecx
  0043e	8d b5 fc 00 00
	00		 lea	 esi, DWORD PTR [ebp+252]
  00444	2b f9		 sub	 edi, ecx
  00446	8b c1		 mov	 eax, ecx
  00448	89 74 24 34	 mov	 DWORD PTR 28+[esp+24], esi
  0044c	8b f7		 mov	 esi, edi
  0044e	8b 7c 24 34	 mov	 edi, DWORD PTR 28+[esp+24]
  00452	c1 e9 02	 shr	 ecx, 2
  00455	f3 a5		 rep movsd
  00457	8b c8		 mov	 ecx, eax
  00459	83 e1 03	 and	 ecx, 3
  0045c	f3 a4		 rep movsb
  0045e	8b 74 24 14	 mov	 esi, DWORD PTR _pKsd_t$[esp+28]
$L72933:

; 1840 : #endif
; 1841 : 	}
; 1842 : 
; 1843 : #ifdef WIN32
; 1844 : 	// tek 13nov97 bats whatever: fix use of instance parameter as window
; 1845 : 	if (dwDeviceOptions&TTSSTARTUP_USING_DEFAULT_CALLBACK)

  00462	8b 44 24 30	 mov	 eax, DWORD PTR _dwTTSInstanceParameter$[esp+24]
  00466	81 e2 00 00 00
	08		 and	 edx, 134217728		; 08000000H
  0046c	f7 da		 neg	 edx
  0046e	1b d2		 sbb	 edx, edx

; 1846 : 	{
; 1847 : #endif	/* WIN32 */
; 1848 : 		phTTS->hWnd = (HWND)dwTTSInstanceParameter;  //Backward compatibilty for TextToSpeechStartupEx
; 1849 : 
; 1850 : #ifdef WIN32
; 1851 : 	}
; 1852 : 	else
; 1853 : 	{
; 1854 : 		phTTS->hWnd = NULL; // the instance param is just that!
; 1855 : 	}
; 1856 : #endif	/* WIN32 */
; 1857 : 	
; 1858 : 	phTTS->uiCurrentMsgNumber = 1;

  00470	b9 01 00 00 00	 mov	 ecx, 1
  00475	23 d0		 and	 edx, eax

; 1859 : 	phTTS->uiLastTextMsgNumber = 0;
; 1860 : 	phTTS->uiFlushMsgNumber = 0;
; 1861 : 
; 1862 : #if defined __osf__ || defined __linux__ 
; 1863 : 	phTTS->uiLastQueuedTextMsgNumber = 0; // tek 01sep98
; 1864 : 	phTTS->uiTextThreadExit = FALSE;
; 1865 : 	phTTS->bInReset = FALSE;
; 1866 : 	phTTS->uiID_Error_Message = TTS_MSG_STATUS;
; 1867 : 	phTTS->uiID_Index_Message = TTS_MSG_INDEX_MARK;
; 1868 : 	phTTS->uiID_Buffer_Message = TTS_MSG_BUFFER;
; 1869 : 	phTTS->uiID_Visual_Message = 0xDEADC0DE;
; 1870 : 	//phTTS->uiID_Bookmark_Message = TTS_MSG_BOOKMARK;
; 1871 : 	//phTTS->uiID_Wordpos_Message = TTS_MSG_WORDPOS;
; 1872 : 	//phTTS->uiID_Start_Message = TTS_MSG_START;
; 1873 : 	//phTTS->uiID_Stop_Message = TTS_MSG_STOP;
; 1874 : 	//phTTS->uiID_Sentence_Message = TTS_MSG_SENTENCE;
; 1875 : 
; 1876 : 	phTTS->bInReset = FALSE;
; 1877 : #endif	/* defined __osf__ || defined __linux__  */
; 1878 : 
; 1879 : 	phTTS->dwQueuedSampleCount = 0;
; 1880 : 	phTTS->uiQueuedCharacterCount = 0;
; 1881 : 	phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 1882 : 	phTTS->bEnableErrorMessage = TRUE;
; 1883 : 	phTTS->bMemoryReset = FALSE;
; 1884 : 	phTTS->szPhonemeBuffer = NULL; // tek 19aug98 ConvertToPhonemes
; 1885 : 	phTTS->dwPhonemeCvtFlags = 0;	// 20aug98 ConvertToPhonemes
; 1886 : 	/* Initialize new element "pKernelShareData" for MI :MVP */
; 1887 : 	phTTS->pKernelShareData = pKsd_t;
; 1888 : 	/********************************************************************/
; 1889 : 	/*  Initialize all of the handle objects to NULL.                   */
; 1890 : 	/********************************************************************/
; 1891 : 	
; 1892 : 	phTTS->pAudioHandle = NULL;
; 1893 : 	phTTS->hSyncEvent = NULL;
; 1894 : 	phTTS->hNotEmptyingVtmPipeEvent = NULL;
; 1895 : 	phTTS->pcsLogFile = NULL;
; 1896 : 	phTTS->pcsQueuedCharacterCount = NULL;
; 1897 : 	phTTS->pcsFlushMsgNumber = NULL;
; 1898 : 	phTTS->pcsLastQueuedTextMsgNumber = NULL;
; 1899 : 	phTTS->pcsQueuedSampleCount = NULL;
; 1900 : 	phTTS->pcsMemoryBuffer = NULL;
; 1901 : 	phTTS->hTuneStopEvent=NULL;
; 1902 : 
; 1903 : #ifdef WIN32
; 1904 : 	phTTS->pcsBufferPipe = NULL;
; 1905 : #endif	/* WIN32 */
; 1906 : 
; 1907 : 	phTTS->hThread_TXT = NULL;
; 1908 : 	phTTS->hThread_CMD = NULL;
; 1909 : 	phTTS->hThread_LTS = NULL;
; 1910 : 	phTTS->hThread_PH = NULL;
; 1911 : 	phTTS->hThread_VTM = NULL;
; 1912 : 	phTTS->hThread_SYNC = NULL;	
; 1913 : 
; 1914 : #if defined __osf__ || defined __linux__
; 1915 : 	phTTS->hTextInQueueEvent = NULL;
; 1916 : 	phTTS->pcsTextMsgList = NULL;
; 1917 : 	phTTS->pcsBufferPipe = NULL;
; 1918 : #endif	/* defined __osf__ || defined __linux__ */
; 1919 : 
; 1920 : #ifdef NOWIN
; 1921 : 	phTTS->hTextInQueueEvent = NULL;
; 1922 : 	phTTS->pcsTextMsgList = NULL;
; 1923 : 	phTTS->uiLastQueuedTextMsgNumber = 0; // tek 01sep98
; 1924 : 	phTTS->uiTextThreadExit = FALSE;
; 1925 : #endif
; 1926 : 	/*************************************************************************/
; 1927 : 	/*  Initialize all of the Thread specific data structure pointers to NULL*/
; 1928 : 	/*  Murthy Parakala : for multiple instances                             */
; 1929 : 	/*************************************************************************/
; 1930 : 	phTTS->pCMDThreadData = NULL;            /*CMD Thread */
; 1931 : 	phTTS->pLTSThreadData = NULL;            /*LTS Thread */ 
; 1932 : 	phTTS->pVTMThreadData = NULL;            /*VTM Thread */
; 1933 : 	phTTS->pPHThreadData = NULL;             /*PH  Thread */
; 1934 : 	phTTS->hMallocSuccessEvent = NULL;   /* Event handle for successful memory allocations*/
; 1935 : 
; 1936 : #ifdef TYPING_MODE	//09jun97 tek
; 1937 : 	phTTS->wTypingFrameCount=0;
; 1938 : #endif /* TYPING_MODE */
; 1939 : 
; 1940 : 	/*********************************************************************/
; 1941 : 	/*  Initialize Instance specific CallbackFunction,Instance parameter */
; 1942 : 	/*  MVP : 05/08/96                                                   */
; 1943 : 	/*********************************************************************/
; 1944 : 	phTTS->DtCallbackRoutine = DtCallbackRoutine;
; 1945 : 	phTTS->dwTTSInstanceParameter = dwTTSInstanceParameter;
; 1946 : 
; 1947 : #ifdef WIN32
; 1948 : 	phTTS->hmxCallback = NULL;
; 1949 : #endif /* WIN32 */
; 1950 : 
; 1951 : #if defined __osf__ || defined __linux__
; 1952 : 	phTTS->pcsCallback = NULL;
; 1953 : #endif	/* defined __osf__ || defined __linux__ */
; 1954 : 
; 1955 : 	/********************************************************************/
; 1956 : 	/*  Create the queued sample count critical section.                */
; 1957 : 	/********************************************************************/
; 1958 : #ifdef WIN32
; 1959 : 	phTTS->pcsQueuedSampleCount =
; 1960 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  00477	6a 18		 push	 24			; 00000018H
  00479	89 55 00	 mov	 DWORD PTR [ebp], edx
  0047c	89 4d 44	 mov	 DWORD PTR [ebp+68], ecx
  0047f	89 5d 48	 mov	 DWORD PTR [ebp+72], ebx
  00482	89 5d 50	 mov	 DWORD PTR [ebp+80], ebx
  00485	89 9d 80 00 00
	00		 mov	 DWORD PTR [ebp+128], ebx
  0048b	89 5d 40	 mov	 DWORD PTR [ebp+64], ebx
  0048e	c7 85 88 00 00
	00 04 00 00 00	 mov	 DWORD PTR [ebp+136], 4
  00498	89 8d 8c 00 00
	00		 mov	 DWORD PTR [ebp+140], ecx
  0049e	8b 4c 24 30	 mov	 ecx, DWORD PTR _DtCallbackRoutine$[esp+28]
  004a2	89 9d 90 00 00
	00		 mov	 DWORD PTR [ebp+144], ebx
  004a8	89 9d e8 00 00
	00		 mov	 DWORD PTR [ebp+232], ebx
  004ae	89 9d f4 00 00
	00		 mov	 DWORD PTR [ebp+244], ebx
  004b4	89 75 08	 mov	 DWORD PTR [ebp+8], esi
  004b7	89 9d d8 00 00
	00		 mov	 DWORD PTR [ebp+216], ebx
  004bd	89 5d 38	 mov	 DWORD PTR [ebp+56], ebx
  004c0	89 5d 3c	 mov	 DWORD PTR [ebp+60], ebx
  004c3	89 9d c8 00 00
	00		 mov	 DWORD PTR [ebp+200], ebx
  004c9	89 9d c4 00 00
	00		 mov	 DWORD PTR [ebp+196], ebx
  004cf	89 9d c0 00 00
	00		 mov	 DWORD PTR [ebp+192], ebx
  004d5	89 9d bc 00 00
	00		 mov	 DWORD PTR [ebp+188], ebx
  004db	89 9d b8 00 00
	00		 mov	 DWORD PTR [ebp+184], ebx
  004e1	89 9d b4 00 00
	00		 mov	 DWORD PTR [ebp+180], ebx
  004e7	89 9d f8 00 00
	00		 mov	 DWORD PTR [ebp+248], ebx
  004ed	89 9d cc 00 00
	00		 mov	 DWORD PTR [ebp+204], ebx
  004f3	89 5d 20	 mov	 DWORD PTR [ebp+32], ebx
  004f6	89 5d 24	 mov	 DWORD PTR [ebp+36], ebx
  004f9	89 5d 28	 mov	 DWORD PTR [ebp+40], ebx
  004fc	89 5d 2c	 mov	 DWORD PTR [ebp+44], ebx
  004ff	89 5d 30	 mov	 DWORD PTR [ebp+48], ebx
  00502	89 5d 34	 mov	 DWORD PTR [ebp+52], ebx
  00505	89 5d 0c	 mov	 DWORD PTR [ebp+12], ebx
  00508	89 5d 10	 mov	 DWORD PTR [ebp+16], ebx
  0050b	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  0050e	89 5d 18	 mov	 DWORD PTR [ebp+24], ebx
  00511	89 5d 1c	 mov	 DWORD PTR [ebp+28], ebx
  00514	66 89 9d e0 00
	00 00		 mov	 WORD PTR [ebp+224], bx
  0051b	89 8d a8 00 00
	00		 mov	 DWORD PTR [ebp+168], ecx
  00521	89 85 ac 00 00
	00		 mov	 DWORD PTR [ebp+172], eax
  00527	89 9d b0 00 00
	00		 mov	 DWORD PTR [ebp+176], ebx
  0052d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00533	83 c4 04	 add	 esp, 4

; 1961 : #endif /* WIN32 */
; 1962 : 
; 1963 : #if defined __osf__ || defined __linux__
; 1964 : 	phTTS->pcsQueuedSampleCount = OP_CreateMutex();
; 1965 : #endif	/* defined __osf__ || defined __linux__ */
; 1966 : 
; 1967 : 	if ( phTTS->pcsQueuedSampleCount == NULL )

  00536	3b c3		 cmp	 eax, ebx
  00538	89 85 b8 00 00
	00		 mov	 DWORD PTR [ebp+184], eax

; 1968 : 	{
; 1969 : 		DeleteTextToSpeechObjects( phTTS );
; 1970 : 
; 1971 : #if defined WIN32 || defined __linux__
; 1972 : #ifdef LICENSES
; 1973 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1974 : #endif	/* LICENSES */
; 1975 : #endif	/* defined WIN32 || defined __linux__ */
; 1976 : 		return( MMSYSERR_NOMEM );

  0053e	0f 84 c3 02 00
	00		 je	 $L74640

; 1977 : 	}
; 1978 : 	
; 1979 : #ifdef WIN32
; 1980 : #ifdef DTALK50
; 1981 : 	phTTS->CPanelThread = CPInitAPI();
; 1982 : #endif	/* DTALK50 */
; 1983 : 	
; 1984 : 	InitializeCriticalSection( phTTS->pcsQueuedSampleCount );

  00544	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__InitializeCriticalSection@4
  0054a	50		 push	 eax
  0054b	ff d7		 call	 edi

; 1985 : #endif /* WIN32 */
; 1986 : 
; 1987 : 	/********************************************************************/
; 1988 : 	/*  Create the 'Buffer Pipe' mutex.                                 */
; 1989 : 	/********************************************************************/
; 1990 : 	
; 1991 : #ifdef WIN32
; 1992 : 	phTTS->pcsBufferPipe =
; 1993 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  0054d	6a 18		 push	 24			; 00000018H
  0054f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00555	83 c4 04	 add	 esp, 4

; 1994 : #endif	/* WIN32 */
; 1995 : 
; 1996 : #if defined __osf__ || defined __linux__
; 1997 : 	phTTS->pcsBufferPipe = OP_CreateMutex();
; 1998 : #endif	/* defined __osf__ || defined __linux__ */
; 1999 : 
; 2000 : 	if ( phTTS->pcsBufferPipe == NULL )

  00558	3b c3		 cmp	 eax, ebx
  0055a	89 85 cc 00 00
	00		 mov	 DWORD PTR [ebp+204], eax

; 2001 : 	{
; 2002 : 		DeleteTextToSpeechObjects( phTTS );
; 2003 : 
; 2004 : #if defined WIN32 || defined __linux__
; 2005 : #ifdef LICENSES
; 2006 : 		ReleaseLicenseRef();
; 2007 : #endif	/* LICENSES */
; 2008 : #endif	/* defined WIN32 || defined __linux__ */
; 2009 : 
; 2010 : 		return( MMSYSERR_NOMEM );

  00560	0f 84 a1 02 00
	00		 je	 $L74640

; 2011 : 	}
; 2012 : 
; 2013 : #ifdef WIN32
; 2014 : 	InitializeCriticalSection( phTTS->pcsBufferPipe );

  00566	50		 push	 eax
  00567	ff d7		 call	 edi

; 2015 : #endif /* WIN32 */
; 2016 : 	
; 2017 : 	/********************************************************************/
; 2018 : 	/*  Create the 'Text List' mutex.                                   */
; 2019 : 	/********************************************************************/
; 2020 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 2021 : 	
; 2022 : 	phTTS->pcsTextMsgList = OP_CreateMutex();
; 2023 : 	
; 2024 : 	if ( phTTS->pcsTextMsgList == NULL )
; 2025 : 	{
; 2026 : 		DeleteTextToSpeechObjects( phTTS );
; 2027 : 
; 2028 : #ifdef __linux__
; 2029 : #ifdef LICENSES
; 2030 : 		ReleaseLicenseRef();
; 2031 : #endif	/* LICENSES */
; 2032 : #endif	/*	__linux__ */
; 2033 : 
; 2034 : 		return( MMSYSERR_NOMEM );
; 2035 : 	}
; 2036 : #endif /* defined __osf__ || defined __linux__ */
; 2037 : 	
; 2038 : 	/********************************************************************/
; 2039 : 	/*  Create the last queued text message number critical section.    */
; 2040 : 	/********************************************************************/
; 2041 : #ifdef WIN32
; 2042 : 	phTTS->pcsLastQueuedTextMsgNumber =
; 2043 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  00569	6a 18		 push	 24			; 00000018H
  0056b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00571	83 c4 04	 add	 esp, 4

; 2044 : #endif	/* WIN32 */
; 2045 : 
; 2046 : #if defined __osf__ || defined __linux__
; 2047 : 	phTTS->pcsLastQueuedTextMsgNumber = OP_CreateMutex();
; 2048 : #endif /* defined __osf__ || defined __linux__ */
; 2049 : 	
; 2050 : 	if ( phTTS->pcsLastQueuedTextMsgNumber == NULL )

  00574	3b c3		 cmp	 eax, ebx
  00576	89 85 bc 00 00
	00		 mov	 DWORD PTR [ebp+188], eax

; 2051 : 	{
; 2052 : 		DeleteTextToSpeechObjects( phTTS );
; 2053 : 
; 2054 : #if defined WIN32 || defined __linux__
; 2055 : #ifdef LICENSES
; 2056 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2057 : #endif	/* LICENSES */
; 2058 : #endif /* defined WIN32 || defined __linux__ */
; 2059 : 		return( MMSYSERR_NOMEM );

  0057c	0f 84 85 02 00
	00		 je	 $L74640

; 2060 : 	}
; 2061 : 	
; 2062 : #ifdef WIN32
; 2063 : 	InitializeCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  00582	50		 push	 eax
  00583	ff d7		 call	 edi

; 2064 : #endif /* WIN32 */
; 2065 : 	
; 2066 : 	/********************************************************************/
; 2067 : 	/*  Create the flush message number critical section.               */
; 2068 : 	/********************************************************************/
; 2069 : 	
; 2070 : #ifdef WIN32
; 2071 : 	phTTS->pcsFlushMsgNumber =
; 2072 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  00585	6a 18		 push	 24			; 00000018H
  00587	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0058d	83 c4 04	 add	 esp, 4

; 2073 : #endif /* WIN32 */
; 2074 : 
; 2075 : #if defined __osf__ || defined __linux__
; 2076 : 	phTTS->pcsFlushMsgNumber = OP_CreateMutex();
; 2077 : #endif	/* defined __osf__ || defined __linux__ */
; 2078 : 	
; 2079 : 	
; 2080 : 	if ( phTTS->pcsFlushMsgNumber == NULL )

  00590	3b c3		 cmp	 eax, ebx
  00592	89 85 c0 00 00
	00		 mov	 DWORD PTR [ebp+192], eax

; 2081 : 	{
; 2082 : 		DeleteTextToSpeechObjects( phTTS );
; 2083 : 
; 2084 : #if defined WIN32 || defined __linux__
; 2085 : #ifdef LICENSES
; 2086 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2087 : #endif /* LICENSES */
; 2088 : #endif /* defined WIN32 || defined __linux__ */
; 2089 : 
; 2090 : 		return( MMSYSERR_NOMEM );

  00598	0f 84 69 02 00
	00		 je	 $L74640

; 2091 : 	}
; 2092 : 	
; 2093 : #ifdef WIN32
; 2094 : 	InitializeCriticalSection( phTTS->pcsFlushMsgNumber );

  0059e	50		 push	 eax
  0059f	ff d7		 call	 edi

; 2095 : #endif /* WIN32 */
; 2096 : 
; 2097 : 	/********************************************************************/
; 2098 : 	/*  Create the queued character count critical section.             */
; 2099 : 	/********************************************************************/
; 2100 : 	
; 2101 : #ifdef WIN32
; 2102 : 	phTTS->pcsQueuedCharacterCount =
; 2103 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  005a1	6a 18		 push	 24			; 00000018H
  005a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  005a9	83 c4 04	 add	 esp, 4

; 2104 : #endif /* WIN32 */
; 2105 : 
; 2106 : #if defined __osf__ || defined __linux__
; 2107 : 	phTTS->pcsQueuedCharacterCount = OP_CreateMutex();
; 2108 : #endif	/* defined __osf__ || defined __linux__ */
; 2109 : 
; 2110 : 	
; 2111 : 	if ( phTTS->pcsQueuedCharacterCount == NULL )

  005ac	3b c3		 cmp	 eax, ebx
  005ae	89 85 c4 00 00
	00		 mov	 DWORD PTR [ebp+196], eax

; 2112 : 	{
; 2113 : 		DeleteTextToSpeechObjects( phTTS );
; 2114 : 
; 2115 : #if defined WIN32 || defined __linux__
; 2116 : #ifdef LICENSES
; 2117 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2118 : #endif /* LICENSES */
; 2119 : #endif /* defined WIN32 || defined __linux__ */
; 2120 : 
; 2121 : 		return( MMSYSERR_NOMEM );

  005b4	0f 84 4d 02 00
	00		 je	 $L74640

; 2122 : 	}
; 2123 : 	
; 2124 : #ifdef WIN32
; 2125 : 	InitializeCriticalSection( phTTS->pcsQueuedCharacterCount );

  005ba	50		 push	 eax
  005bb	ff d7		 call	 edi

; 2126 : #endif /* WIN32 */
; 2127 : 	
; 2128 : //#ifdef WIN32 /* WIN32 (2) */
; 2129 : 	/* tek 6mar97 bats 278 */
; 2130 : 	/********************************************************************/
; 2131 : 	/*  Create the index list critical section.                         */
; 2132 : 	/********************************************************************/
; 2133 : 	
; 2134 : #ifdef WIN32 
; 2135 : 	pKsd_t->pcsSpcPktSave =
; 2136 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  005bd	6a 18		 push	 24			; 00000018H
  005bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  005c5	83 c4 04	 add	 esp, 4

; 2137 : #endif
; 2138 : #if defined __osf__ || defined __linux__
; 2139 : 	pKsd_t->pcsSpcPktSave=OP_CreateMutex();
; 2140 : #endif
; 2141 : 	
; 2142 : 	if ( pKsd_t->pcsSpcPktSave == NULL )

  005c8	3b c3		 cmp	 eax, ebx
  005ca	89 86 40 03 00
	00		 mov	 DWORD PTR [esi+832], eax
  005d0	75 1b		 jne	 SHORT $L72985

; 2143 : 	{
; 2144 : #if defined WIN32 || defined __linux__
; 2145 : #ifdef LICENSES
; 2146 : 		ReleaseLicenseRef(); // tek 23sep96

  005d2	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 2147 : #endif	/* LICENSES */
; 2148 : #endif
; 2149 : 
; 2150 : 		DeleteTextToSpeechObjects( phTTS );

  005d7	55		 push	 ebp
  005d8	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  005dd	83 c4 04	 add	 esp, 4

; 2720 : #endif	/* LICENSES */
; 2721 : #endif	/* defined WIN32 || defined __linux__ */
; 2722 : 
; 2723 : 			return( MMSYSERR_NOMEM );

  005e0	b8 07 00 00 00	 mov	 eax, 7
  005e5	5f		 pop	 edi
  005e6	5e		 pop	 esi
  005e7	5d		 pop	 ebp
  005e8	5b		 pop	 ebx

; 3099 : }

  005e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ec	c3		 ret	 0
$L72985:

; 2151 : 		return( MMSYSERR_NOMEM );
; 2152 : 	}
; 2153 : #ifdef WIN32
; 2154 : 	InitializeCriticalSection( pKsd_t->pcsSpcPktSave );

  005ed	50		 push	 eax
  005ee	ff d7		 call	 edi

; 2155 : #endif
; 2156 : 	
; 2157 : 	/* end 6mar97 bats 278 */
; 2158 : 	
; 2159 : 	/********************************************************************/
; 2160 : 	/*  Create the vtm pipe read critical section.                      */
; 2161 : 	/********************************************************************/
; 2162 : 	// tek 09jun97 needed to allow fast flushing of the  VTM
; 2163 : #ifdef WIN32
; 2164 : 	pKsd_t->pcsVtmPipeRead =
; 2165 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  005f0	6a 18		 push	 24			; 00000018H
  005f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  005f8	83 c4 04	 add	 esp, 4

; 2166 : #endif
; 2167 : #if defined __osf__ || defined __linux__
; 2168 : 	pKsd_t->pcsVtmPipeRead=OP_CreateMutex();
; 2169 : #endif
; 2170 : 	
; 2171 : 	if ( pKsd_t->pcsVtmPipeRead == NULL )

  005fb	3b c3		 cmp	 eax, ebx
  005fd	89 86 b4 02 00
	00		 mov	 DWORD PTR [esi+692], eax
  00603	75 1b		 jne	 SHORT $L72989

; 2172 : 	{
; 2173 : #if defined WIN32 || defined __linux__
; 2174 : #ifdef LICENSES
; 2175 : 		ReleaseLicenseRef(); // tek 23sep96

  00605	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 2176 : #endif	/* LICENSES */
; 2177 : #endif
; 2178 : 
; 2179 : 		DeleteTextToSpeechObjects( phTTS );

  0060a	55		 push	 ebp
  0060b	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  00610	83 c4 04	 add	 esp, 4

; 2720 : #endif	/* LICENSES */
; 2721 : #endif	/* defined WIN32 || defined __linux__ */
; 2722 : 
; 2723 : 			return( MMSYSERR_NOMEM );

  00613	b8 07 00 00 00	 mov	 eax, 7
  00618	5f		 pop	 edi
  00619	5e		 pop	 esi
  0061a	5d		 pop	 ebp
  0061b	5b		 pop	 ebx

; 3099 : }

  0061c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0061f	c3		 ret	 0
$L72989:

; 2180 : 		return( MMSYSERR_NOMEM );
; 2181 : 	}
; 2182 : #ifdef WIN32
; 2183 : 	InitializeCriticalSection( pKsd_t->pcsVtmPipeRead );

  00620	50		 push	 eax
  00621	ff d7		 call	 edi

; 2184 : #endif
; 2185 : //#endif /* WIN32 (2) */
; 2186 : 	
; 2187 : 	/********************************************************************/
; 2188 : 	/*  Create the log file critical section.                           */
; 2189 : 	/********************************************************************/
; 2190 : #ifdef WIN32
; 2191 : 	phTTS->pcsLogFile =
; 2192 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  00623	6a 18		 push	 24			; 00000018H
  00625	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0062b	83 c4 04	 add	 esp, 4

; 2193 : #endif /* WIN32 */
; 2194 : 
; 2195 : #if defined __osf__ || defined __linux__
; 2196 : 	phTTS->pcsLogFile = OP_CreateMutex();
; 2197 : #endif /* defined __osf__ || defined __linux__ */
; 2198 : 	
; 2199 : 	if ( phTTS->pcsLogFile == NULL )

  0062e	3b c3		 cmp	 eax, ebx
  00630	89 85 c8 00 00
	00		 mov	 DWORD PTR [ebp+200], eax

; 2200 : 	{
; 2201 : 		DeleteTextToSpeechObjects( phTTS );
; 2202 : 
; 2203 : #if defined WIN32 || defined __linux__
; 2204 : #ifdef LICENSES
; 2205 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2206 : #endif	/* LICENSES */
; 2207 : #endif	/* defined WIN32 || defined __linux__ */
; 2208 : 
; 2209 : 		return( MMSYSERR_NOMEM );

  00636	0f 84 cb 01 00
	00		 je	 $L74640

; 2210 : 	}
; 2211 : 	
; 2212 : #ifdef WIN32
; 2213 : 	InitializeCriticalSection( phTTS->pcsLogFile );

  0063c	50		 push	 eax
  0063d	ff d7		 call	 edi

; 2214 : #endif	/* WIN32 */
; 2215 : 
; 2216 : 	/********************************************************************/
; 2217 : 	/*  Create a "Sync" event. The initial state is not signaled.       */
; 2218 : 	/********************************************************************/
; 2219 : 
; 2220 : 	phTTS->hSyncEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

  0063f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateEventA@16
  00645	53		 push	 ebx
  00646	53		 push	 ebx
  00647	6a 01		 push	 1
  00649	53		 push	 ebx
  0064a	ff d7		 call	 edi

; 2221 : 	
; 2222 : 	if ( phTTS->hSyncEvent == NULL )

  0064c	3b c3		 cmp	 eax, ebx
  0064e	89 45 38	 mov	 DWORD PTR [ebp+56], eax

; 2223 : 	{
; 2224 : 		DeleteTextToSpeechObjects( phTTS );
; 2225 : 
; 2226 : #if defined WIN32 || defined __linux__
; 2227 : #ifdef LICENSES
; 2228 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2229 : #endif	/* LICENSES */
; 2230 : #endif	/* defined WIN32 || defined __linux__ */
; 2231 : 
; 2232 : 		return( MMSYSERR_NOMEM );

  00651	0f 84 b0 01 00
	00		 je	 $L74640

; 2233 : 	}
; 2234 : 	
; 2235 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 2236 : 	
; 2237 : 	/********************************************************************/
; 2238 : 	/*  Create a "Text in Queue" event. The initial state is not signaled.*/
; 2239 : 	/********************************************************************/
; 2240 : 	
; 2241 : 	phTTS->hTextInQueueEvent = OP_CreateEvent( TRUE, FALSE );
; 2242 : 	
; 2243 : 	if ( phTTS->hTextInQueueEvent == NULL )
; 2244 : 	{
; 2245 : 		DeleteTextToSpeechObjects( phTTS );
; 2246 : 		return( MMSYSERR_NOMEM );
; 2247 : 	}
; 2248 : #endif /* defined __osf__ || defined __linux__ */
; 2249 : 	
; 2250 : 	/********************************************************************/
; 2251 : 	/*  Create a "Not Emptying Vtm Pipe" event. The initial state is    */
; 2252 : 	/*  signaled.                                                       */
; 2253 : 	/********************************************************************/
; 2254 : 	
; 2255 : 	phTTS->hNotEmptyingVtmPipeEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

  00657	53		 push	 ebx
  00658	6a 01		 push	 1
  0065a	6a 01		 push	 1
  0065c	53		 push	 ebx
  0065d	ff d7		 call	 edi

; 2256 : 
; 2257 : 	if ( phTTS->hNotEmptyingVtmPipeEvent == NULL )

  0065f	3b c3		 cmp	 eax, ebx
  00661	89 45 3c	 mov	 DWORD PTR [ebp+60], eax

; 2258 : 	{
; 2259 : 		DeleteTextToSpeechObjects( phTTS );
; 2260 : 
; 2261 : #if defined WIN32 || defined __linux__
; 2262 : #ifdef LICENSES
; 2263 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2264 : #endif	/* LICENSES */
; 2265 : #endif	/* defined WIN32 || defined __linux__ */
; 2266 : 
; 2267 : 		return( MMSYSERR_NOMEM );

  00664	0f 84 9d 01 00
	00		 je	 $L74640

; 2268 : 	}
; 2269 : 	
; 2270 : 	/*******************************************************************/
; 2271 : 	/*  Create the TTS callback mutex.                                 */
; 2272 : 	/*******************************************************************/
; 2273 : 	
; 2274 : 	if ( DtCallbackRoutine != NULL )

  0066a	39 5c 24 2c	 cmp	 DWORD PTR _DtCallbackRoutine$[esp+24], ebx
  0066e	74 13		 je	 SHORT $L73005

; 2275 : 	{
; 2276 : #ifdef WIN32
; 2277 : 		phTTS->hmxCallback = OP_CreateMutex();

  00670	e8 00 00 00 00	 call	 _OP_CreateMutex

; 2278 : 		if ( phTTS->hmxCallback == NULL )

  00675	3b c3		 cmp	 eax, ebx
  00677	89 85 b0 00 00
	00		 mov	 DWORD PTR [ebp+176], eax

; 2279 : #endif	/* WIN32 */
; 2280 : 
; 2281 : #if defined __osf__ || defined __linux__
; 2282 : 			phTTS->pcsCallback = OP_CreateMutex();
; 2283 : 		if ( phTTS->pcsCallback == NULL )
; 2284 : #endif	/* defined __osf__ || defined __linux__ */
; 2285 : 
; 2286 : 		{
; 2287 : 			DeleteTextToSpeechObjects( phTTS );
; 2288 : 
; 2289 : #if defined WIN32 || defined __linux__
; 2290 : #ifdef LICENSES
; 2291 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2292 : #endif	/* LICENSES */
; 2293 : #endif	/* defined WIN32 || defined __linux__ */
; 2294 : 
; 2295 : 			return MMSYSERR_NOMEM;

  0067d	0f 84 84 01 00
	00		 je	 $L74640
$L73005:

; 2296 : 		}
; 2297 : 	}
; 2298 : 	
; 2299 : 	/********************************************************************************/
; 2300 : 	/*  MVP :Create a "Successful Memory Allocation " event.                        */
; 2301 : 	/*  The event configuration is non-inheritable,AUTO RESET,not signaled, Unnamed */
; 2302 : 	/********************************************************************************/
; 2303 : 
; 2304 : 	phTTS->hMallocSuccessEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  00683	53		 push	 ebx
  00684	53		 push	 ebx
  00685	53		 push	 ebx
  00686	53		 push	 ebx
  00687	ff d7		 call	 edi

; 2305 : 	
; 2306 : 	if ( phTTS->hMallocSuccessEvent == NULL )

  00689	3b c3		 cmp	 eax, ebx
  0068b	89 45 1c	 mov	 DWORD PTR [ebp+28], eax

; 2307 : 	{
; 2308 : 		DeleteTextToSpeechObjects( phTTS );
; 2309 : 
; 2310 : #if defined WIN32 || defined __linux__
; 2311 : #ifdef LICENSES
; 2312 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2313 : #endif	/* LICENSES */
; 2314 : #endif	/* defined WIN32 || defined __linux__ */
; 2315 : 
; 2316 : 		return( MMSYSERR_NOMEM );

  0068e	0f 84 73 01 00
	00		 je	 $L74640

; 2317 : 	}
; 2318 : 	
; 2319 : 	/********************************************************************/
; 2320 : 	/*  Initialize the inter-thread communication pipes.                */
; 2321 : 	/********************************************************************/
; 2322 : 	
; 2323 : 	cmd_pipe = create_pipe( BYTE_PIPE, CMD_PIPE_LENGTH );

  00694	6a 40		 push	 64			; 00000040H
  00696	53		 push	 ebx
  00697	e8 00 00 00 00	 call	 _create_pipe
  0069c	83 c4 08	 add	 esp, 8

; 2324 : 	
; 2325 : 	if ( cmd_pipe == NULL )

  0069f	3b c3		 cmp	 eax, ebx
  006a1	89 44 24 2c	 mov	 DWORD PTR _cmd_pipe$[esp+24], eax

; 2326 : 	{
; 2327 : 		DeleteTextToSpeechObjects( phTTS );
; 2328 : 
; 2329 : #if defined WIN32 || defined __linux__
; 2330 : #ifdef LICENSES
; 2331 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2332 : #endif	/* LICENSES */
; 2333 : #endif	/* defined WIN32 || defined __linux__ */
; 2334 : 
; 2335 : 		return( MMSYSERR_NOMEM );

  006a5	0f 84 5c 01 00
	00		 je	 $L74640

; 2336 : 	}
; 2337 : 	
; 2338 : 	lts_pipe = create_pipe( WORD_PIPE, LTS_PIPE_LENGTH );

  006ab	68 80 00 00 00	 push	 128			; 00000080H
  006b0	6a 01		 push	 1
  006b2	e8 00 00 00 00	 call	 _create_pipe
  006b7	83 c4 08	 add	 esp, 8

; 2339 : 	
; 2340 : 	if ( lts_pipe == NULL )

  006ba	3b c3		 cmp	 eax, ebx
  006bc	89 44 24 14	 mov	 DWORD PTR _lts_pipe$[esp+28], eax

; 2341 : 	{
; 2342 : 		DeleteTextToSpeechObjects( phTTS );
; 2343 : 
; 2344 : #if defined WIN32 || defined __linux__
; 2345 : #ifdef LICENSES
; 2346 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2347 : #endif	/* LICENSES */
; 2348 : #endif	/* defined WIN32 || defined __linux__ */
; 2349 : 
; 2350 : 		return( MMSYSERR_NOMEM );

  006c0	0f 84 41 01 00
	00		 je	 $L74640

; 2351 : 	}
; 2352 : 	
; 2353 : #ifdef NEW_TRANSPORT
; 2354 : 	new_lts_pipe = create_pipe( DWORD_PIPE, LTS_PIPE_LENGTH );
; 2355 : 	
; 2356 : 	if ( new_lts_pipe == NULL )
; 2357 : 	{
; 2358 : 		DeleteTextToSpeechObjects( phTTS );
; 2359 : 
; 2360 : #if defined WIN32 || defined __linux__
; 2361 : #ifdef LICENSES
; 2362 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2363 : #endif	/* LICENSES */
; 2364 : #endif	/* defined WIN32 || defined __linux__ */
; 2365 : 
; 2366 : 		return( MMSYSERR_NOMEM );
; 2367 : 	}
; 2368 : #endif	/* NEW_TRANSPORT */
; 2369 : 
; 2370 : 
; 2371 : 	ph_pipe = create_pipe( WORD_PIPE, PH_PIPE_LENGTH );

  006c6	68 00 01 00 00	 push	 256			; 00000100H
  006cb	6a 01		 push	 1
  006cd	e8 00 00 00 00	 call	 _create_pipe
  006d2	8b f8		 mov	 edi, eax
  006d4	83 c4 08	 add	 esp, 8

; 2372 : 	
; 2373 : 	if ( ph_pipe == NULL )

  006d7	3b fb		 cmp	 edi, ebx

; 2374 : 	{
; 2375 : 		DeleteTextToSpeechObjects( phTTS );
; 2376 : 
; 2377 : #if defined WIN32 || defined __linux__
; 2378 : #ifdef LICENSES
; 2379 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2380 : #endif	/* LICENSES */
; 2381 : #endif	/* defined WIN32 || defined __linux__ */
; 2382 : 
; 2383 : 		return( MMSYSERR_NOMEM );

  006d9	0f 84 28 01 00
	00		 je	 $L74640

; 2384 : 	}
; 2385 : 	
; 2386 : 	vtm_pipe = create_pipe( WORD_PIPE, VTM_PIPE_LENGTH );

  006df	68 00 40 00 00	 push	 16384			; 00004000H
  006e4	6a 01		 push	 1
  006e6	e8 00 00 00 00	 call	 _create_pipe
  006eb	83 c4 08	 add	 esp, 8

; 2387 : 	
; 2388 : 	if ( vtm_pipe == NULL )

  006ee	3b c3		 cmp	 eax, ebx
  006f0	89 44 24 34	 mov	 DWORD PTR _vtm_pipe$[esp+24], eax

; 2389 : 	{
; 2390 : 		DeleteTextToSpeechObjects( phTTS );
; 2391 : 
; 2392 : #if defined WIN32 || defined __linux__
; 2393 : #ifdef LICENSES
; 2394 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2395 : #endif	/* LICENSES */
; 2396 : #endif	/* defined WIN32 || defined __linux__ */
; 2397 : 
; 2398 : 		return( MMSYSERR_NOMEM );

  006f4	0f 84 0d 01 00
	00		 je	 $L74640

; 2399 : 	}
; 2400 : 	
; 2401 : 	sync_pipe = create_pipe( DWORD_PIPE, SYNC_PIPE_LENGTH );

  006fa	68 00 08 00 00	 push	 2048			; 00000800H
  006ff	6a 02		 push	 2
  00701	e8 00 00 00 00	 call	 _create_pipe
  00706	83 c4 08	 add	 esp, 8

; 2402 : 	
; 2403 : 	if ( sync_pipe == NULL )

  00709	3b c3		 cmp	 eax, ebx
  0070b	89 44 24 30	 mov	 DWORD PTR _sync_pipe$[esp+24], eax

; 2404 : 	{
; 2405 : 		DeleteTextToSpeechObjects( phTTS );
; 2406 : 
; 2407 : #if defined WIN32 || defined __linux__
; 2408 : #ifdef LICENSES
; 2409 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2410 : #endif	/* LICENSES */
; 2411 : #endif	/* defined WIN32 || defined __linux__ */
; 2412 : 
; 2413 : 		return( MMSYSERR_NOMEM );

  0070f	0f 84 f2 00 00
	00		 je	 $L74640

; 2414 : 	}
; 2415 : 	
; 2416 : 	/********************************************************************/
; 2417 : 	/*  Set default pipe parameters.                                    */
; 2418 : 	/********************************************************************/
; 2419 : 	/* Comment out the below line for MI : MVP */
; 2420 : 	/*
; 2421 : 	kernel_share = &kernel_data;
; 2422 : 	*/
; 2423 : 	
; 2424 : 	for ( i = 0; i < MAX_languages; i++ )

  00715	8d 96 f4 02 00
	00		 lea	 edx, DWORD PTR [esi+756]
  0071b	b8 07 00 00 00	 mov	 eax, 7
  00720	8b ca		 mov	 ecx, edx
$L73020:

; 2425 : 	{
; 2426 : 		pKsd_t->lang_lts[i] = NULL_PIPE;

  00722	89 59 e4	 mov	 DWORD PTR [ecx-28], ebx

; 2427 : 		pKsd_t->lang_ph[i]  = NULL_PIPE;

  00725	89 19		 mov	 DWORD PTR [ecx], ebx

; 2428 : 		pKsd_t->lang_ready[i] = 0;

  00727	89 59 c8	 mov	 DWORD PTR [ecx-56], ebx
  0072a	83 c1 04	 add	 ecx, 4
  0072d	48		 dec	 eax
  0072e	75 f2		 jne	 SHORT $L73020

; 2429 : 	}
; 2430 : 	
; 2431 : 	/* GL 04/21/1997 add code to support the local language pipe */
; 2432 : 	pKsd_t->lang_lts[0] = lts_pipe;
; 2433 : 	pKsd_t->lang_ph[0] = ph_pipe;
; 2434 : 	
; 2435 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[0];
; 2436 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[0];
; 2437 : 	
; 2438 : 	pKsd_t->cmd_pipe = cmd_pipe;

  00730	8b 44 24 2c	 mov	 eax, DWORD PTR _cmd_pipe$[esp+24]

; 2439 : 	pKsd_t->vtm_pipe = vtm_pipe;

  00734	8b 4c 24 34	 mov	 ecx, DWORD PTR _vtm_pipe$[esp+24]
  00738	89 86 98 02 00
	00		 mov	 DWORD PTR [esi+664], eax

; 2440 : 	pKsd_t->sync_pipe = sync_pipe;

  0073e	8b 44 24 30	 mov	 eax, DWORD PTR _sync_pipe$[esp+24]
  00742	89 86 a0 02 00
	00		 mov	 DWORD PTR [esi+672], eax

; 2441 : 	
; 2442 : 	/*
; 2443 : 	GL 12/11/1996, set up the language flag pKsd_t->lang_curr
; 2444 : 	this flag will be used in CMD and phlog.c to pick up the language
; 2445 : 	depended code
; 2446 : 	*/
; 2447 : #ifdef ENGLISH_US
; 2448 : 	pKsd_t->lang_lts[LANG_english] = lts_pipe;

  00748	8b 44 24 14	 mov	 eax, DWORD PTR _lts_pipe$[esp+28]
  0074c	89 8e 9c 02 00
	00		 mov	 DWORD PTR [esi+668], ecx
  00752	89 86 d8 02 00
	00		 mov	 DWORD PTR [esi+728], eax

; 2449 : 	pKsd_t->lang_ph[LANG_english] = ph_pipe;
; 2450 : 	
; 2451 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_english];

  00758	89 86 90 02 00
	00		 mov	 DWORD PTR [esi+656], eax

; 2452 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_english];

  0075e	89 be 94 02 00
	00		 mov	 DWORD PTR [esi+660], edi

; 2453 : 	pKsd_t->lang_curr = LANG_english;

  00764	89 9e b8 02 00
	00		 mov	 DWORD PTR [esi+696], ebx

; 2454 : #endif	/* ENGLISH_US */
; 2455 : 
; 2456 : #ifdef ENGLISH_UK
; 2457 : 	pKsd_t->lang_lts[LANG_british] = lts_pipe;
; 2458 : 	pKsd_t->lang_ph[LANG_british] = ph_pipe;
; 2459 : 	
; 2460 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_british];
; 2461 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_british];
; 2462 : 	pKsd_t->lang_curr = LANG_british;
; 2463 : #endif	/* ENGLISH_UK */
; 2464 : 
; 2465 : #ifdef SPANISH_SP
; 2466 :   pKsd_t->lang_lts[LANG_spanish] = lts_pipe;
; 2467 :   pKsd_t->lang_ph[LANG_spanish] = ph_pipe;
; 2468 : 
; 2469 :   pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_spanish];
; 2470 :   pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_spanish];
; 2471 : 
; 2472 :   pKsd_t->lang_curr = LANG_spanish;
; 2473 : #endif	/* SPANISH_SP */
; 2474 : 
; 2475 : #ifdef SPANISH_LA
; 2476 :   pKsd_t->lang_lts[LANG_latin_american] = lts_pipe;
; 2477 :   pKsd_t->lang_ph[LANG_latin_american] = ph_pipe;
; 2478 : 
; 2479 :   pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_latin_american];
; 2480 :   pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_latin_american];
; 2481 : 
; 2482 :   pKsd_t->lang_curr = LANG_latin_american;
; 2483 : #endif	/* SPANISH_LA */
; 2484 : 
; 2485 : #ifdef GERMAN
; 2486 : 	pKsd_t->lang_lts[LANG_german] = lts_pipe;
; 2487 : 	pKsd_t->lang_ph[LANG_german] = ph_pipe;
; 2488 : 	
; 2489 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_german];
; 2490 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_german];
; 2491 : 	pKsd_t->lang_curr = LANG_german;
; 2492 : #endif	/* GERMAN */
; 2493 : 
; 2494 : #ifdef FRENCH
; 2495 : 	pKsd_t->lang_lts[LANG_french] = lts_pipe;
; 2496 : 	pKsd_t->lang_ph[LANG_french] = ph_pipe;
; 2497 : 	
; 2498 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_french];
; 2499 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_french];
; 2500 : 	pKsd_t->lang_curr = LANG_french;
; 2501 : #endif	/* FRENCH */
; 2502 : 
; 2503 : #ifdef NEW_TRANSPORT
; 2504 : 	pKsd_t->new_lts_pipe=new_lts_pipe;
; 2505 : #endif	/* NEW_TRANSPORT */
; 2506 : 
; 2507 : #ifdef CUP28PROJECT
; 2508 : 	phTTS->uiID_Error_Message = TTS_MSG_STATUS;
; 2509 : 	phTTS->uiID_Index_Message = TTS_MSG_INDEX_MARK;
; 2510 : 	phTTS->uiID_Buffer_Message = TTS_MSG_BUFFER;
; 2511 : 	phTTS->uiID_Visual_Message = TTS_MSG_VISUAL;
; 2512 : 	phTTS->uiID_Bookmark_Message = TTS_MSG_BOOKMARK;
; 2513 : 	phTTS->uiID_Wordpos_Message = TTS_MSG_WORDPOS;
; 2514 : 	phTTS->uiID_Start_Message = TTS_MSG_START;
; 2515 : 	phTTS->uiID_Stop_Message = TTS_MSG_STOP;
; 2516 : 	phTTS->uiID_Sentence_Message = TTS_MSG_SENTENCE;
; 2517 : #elif defined WIN32	/* WIN32 (3) */
; 2518 : 	/********************************************************************/
; 2519 : 	/*  Get the DECtalk error message.                                  */
; 2520 : 	/********************************************************************/
; 2521 : 	
; 2522 :   phTTS->uiID_Error_Message =
; 2523 : 
; 2524 : #if UNDER_CE //mfgce
; 2525 : 	  RegisterWindowMessage(TEXT("DECtalkErrorMessage"));
; 2526 : #else
; 2527 : 	  RegisterWindowMessage("DECtalkErrorMessage");

  0076a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegisterWindowMessageA@4
  00770	68 00 00 00 00	 push	 OFFSET FLAT:$SG73025
  00775	89 3a		 mov	 DWORD PTR [edx], edi
  00777	ff d6		 call	 esi

; 2528 : #endif	/* UNDER_CE */
; 2529 : 	
; 2530 : 	if ( phTTS->uiID_Error_Message == 0 )

  00779	3b c3		 cmp	 eax, ebx
  0077b	89 45 54	 mov	 DWORD PTR [ebp+84], eax

; 2531 : 	{
; 2532 : 		DeleteTextToSpeechObjects( phTTS );
; 2533 : 
; 2534 : #ifdef LICENSES
; 2535 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2536 : #endif	/* LICENSES */
; 2537 : 
; 2538 : 		return( MMSYSERR_NOMEM );

  0077e	0f 84 83 00 00
	00		 je	 $L74640

; 2539 : 	}
; 2540 : 	
; 2541 : 	/********************************************************************/
; 2542 : 	/*  Get the DECtalk index mark message.                             */
; 2543 : 	/********************************************************************/
; 2544 : 	
; 2545 :   phTTS->uiID_Index_Message =
; 2546 : 
; 2547 : #ifdef UNDER_CE
; 2548 : 	RegisterWindowMessage(TEXT("DECtalkIndexMessage"));
; 2549 : #else
; 2550 :     RegisterWindowMessage("DECtalkIndexMessage");

  00784	68 00 00 00 00	 push	 OFFSET FLAT:$SG73027
  00789	ff d6		 call	 esi

; 2551 : #endif	/* UNDER_CE */
; 2552 : 	
; 2553 : 	if ( phTTS->uiID_Index_Message == 0 )

  0078b	3b c3		 cmp	 eax, ebx
  0078d	89 45 58	 mov	 DWORD PTR [ebp+88], eax

; 2554 : 	{
; 2555 : 		DeleteTextToSpeechObjects( phTTS );
; 2556 : 
; 2557 : #ifdef LICENSES
; 2558 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2559 : #endif	/* LICENSES */
; 2560 : 
; 2561 : 		return( MMSYSERR_NOMEM );

  00790	74 75		 je	 SHORT $L74640

; 2562 : 	}
; 2563 : 	
; 2564 : 	// tek 01aug97 bats 404 register messages for 
; 2565 : 	// bookmark, wordpos, start, stop.
; 2566 : 	
; 2567 : phTTS->uiID_Bookmark_Message =
; 2568 : 
; 2569 : #if UNDER_CE //mfgce
; 2570 : 	RegisterWindowMessage(TEXT("DECtalkBookmarkMessage"));
; 2571 : #else
; 2572 :     RegisterWindowMessage("DECtalkBookmarkMessage");

  00792	68 00 00 00 00	 push	 OFFSET FLAT:$SG73029
  00797	ff d6		 call	 esi

; 2573 : #endif	/* UNDER_CE */
; 2574 : 	
; 2575 : 	if ( phTTS->uiID_Bookmark_Message == 0 )

  00799	3b c3		 cmp	 eax, ebx
  0079b	89 45 60	 mov	 DWORD PTR [ebp+96], eax

; 2576 : 	{
; 2577 : 		DeleteTextToSpeechObjects( phTTS );
; 2578 : 
; 2579 : #ifdef LICENSES
; 2580 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2581 : #endif /* LICENSES */
; 2582 : 
; 2583 : 		return( MMSYSERR_NOMEM );

  0079e	74 67		 je	 SHORT $L74640

; 2584 : 	}
; 2585 : 	
; 2586 : phTTS->uiID_Wordpos_Message =
; 2587 : #if UNDER_CE //mfgce
; 2588 : 	RegisterWindowMessage(TEXT("DECtalkWordposMessage"));
; 2589 : #else
; 2590 : 	RegisterWindowMessage("DECtalkWordposMessage");

  007a0	68 00 00 00 00	 push	 OFFSET FLAT:$SG73031
  007a5	ff d6		 call	 esi

; 2591 : #endif	/* UNDER_CE */
; 2592 : 	
; 2593 : 	if ( phTTS->uiID_Wordpos_Message == 0 )

  007a7	3b c3		 cmp	 eax, ebx
  007a9	89 45 64	 mov	 DWORD PTR [ebp+100], eax

; 2594 : 	{
; 2595 : 		DeleteTextToSpeechObjects( phTTS );
; 2596 : 
; 2597 : #ifdef LICENSES
; 2598 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2599 : #endif	/* LICENSES */
; 2600 : 
; 2601 : 		return( MMSYSERR_NOMEM );

  007ac	74 59		 je	 SHORT $L74640

; 2602 : 	}
; 2603 : 	
; 2604 : phTTS->uiID_Start_Message =
; 2605 : #if UNDER_CE //mfgce
; 2606 : 	RegisterWindowMessage(TEXT("DECtalkStartMessage"));
; 2607 : #else
; 2608 :     RegisterWindowMessage("DECtalkStartMessage");

  007ae	68 00 00 00 00	 push	 OFFSET FLAT:$SG73033
  007b3	ff d6		 call	 esi

; 2609 : #endif	/* UNDER_CE */
; 2610 : 	
; 2611 : 	if ( phTTS->uiID_Start_Message == 0 )

  007b5	3b c3		 cmp	 eax, ebx
  007b7	89 45 68	 mov	 DWORD PTR [ebp+104], eax

; 2612 : 	{
; 2613 : 		DeleteTextToSpeechObjects( phTTS );
; 2614 : 
; 2615 : #ifdef LICENSES
; 2616 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2617 : #endif	/* LICENSES */
; 2618 : 
; 2619 : 		return( MMSYSERR_NOMEM );

  007ba	74 4b		 je	 SHORT $L74640

; 2620 : 	}
; 2621 : 	
; 2622 : 	phTTS->uiID_Stop_Message =
; 2623 : #if UNDER_CE //mfgce
; 2624 : 	RegisterWindowMessage(TEXT("DECtalkStopMessage"));
; 2625 : #else
; 2626 : 	RegisterWindowMessage("DECtalkStopMessage");

  007bc	68 00 00 00 00	 push	 OFFSET FLAT:$SG73035
  007c1	ff d6		 call	 esi

; 2627 : #endif	/* UNDER_CE */
; 2628 : 	
; 2629 : 	if ( phTTS->uiID_Stop_Message == 0 )

  007c3	3b c3		 cmp	 eax, ebx
  007c5	89 45 6c	 mov	 DWORD PTR [ebp+108], eax

; 2630 : 	{
; 2631 : 		DeleteTextToSpeechObjects( phTTS );
; 2632 : 
; 2633 : #ifdef LICENSES
; 2634 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2635 : #endif	/* LICENSES */
; 2636 : 
; 2637 : 		return( MMSYSERR_NOMEM );

  007c8	74 3d		 je	 SHORT $L74640

; 2638 : 	}
; 2639 : 	
; 2640 : 	// tek 27aug97 
; 2641 :   phTTS->uiID_Visual_Message =
; 2642 : #if UNDER_CE //mfgce
; 2643 : 	RegisterWindowMessage(TEXT("DECtalkVisualMessage"));
; 2644 : #else
; 2645 : 	RegisterWindowMessage("DECtalkVisualMessage");

  007ca	68 00 00 00 00	 push	 OFFSET FLAT:$SG73037
  007cf	ff d6		 call	 esi

; 2646 : #endif	/* UNDER_CE */
; 2647 : 	
; 2648 : 	if ( phTTS->uiID_Visual_Message == 0 )

  007d1	3b c3		 cmp	 eax, ebx
  007d3	89 45 70	 mov	 DWORD PTR [ebp+112], eax

; 2649 : 	{
; 2650 : 		DeleteTextToSpeechObjects( phTTS );
; 2651 : #ifdef LICENSES
; 2652 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2653 : #endif	/* LICENSES */
; 2654 : 		return( MMSYSERR_NOMEM );

  007d6	74 2f		 je	 SHORT $L74640

; 2655 : 	}
; 2656 : 	
; 2657 : #ifdef SAPI5DECTALK
; 2658 : 	phTTS->uiID_Sentence_Message =
; 2659 : #if UNDER_CE //mfgce
; 2660 : 	RegisterWindowMessage(TEXT("DECtalkSentenceMessage"));
; 2661 : #else
; 2662 :     RegisterWindowMessage("DECtalkSentenceMessage");
; 2663 : #endif	/* UNDER_CE */
; 2664 : 	
; 2665 : 	if ( phTTS->uiID_Sentence_Message == 0 )
; 2666 : 	{
; 2667 : 		DeleteTextToSpeechObjects( phTTS );
; 2668 : #ifdef LICENSES
; 2669 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2670 : #endif	/* LICENSES */
; 2671 : 		return( MMSYSERR_NOMEM );
; 2672 : 	}
; 2673 : #endif	/* SAPI5DECTALK */
; 2674 : 	
; 2675 : 	
; 2676 : 	/********************************************************************/
; 2677 : 	/*  Get the DECtalk buffer message.                                 */
; 2678 : 	/********************************************************************/
; 2679 : 	
; 2680 :   phTTS->uiID_Buffer_Message =
; 2681 : #if UNDER_CE //mfgce
; 2682 : 	RegisterWindowMessage(TEXT("DECtalkBufferMessage"));
; 2683 : #else
; 2684 :     RegisterWindowMessage("DECtalkBufferMessage");

  007d8	68 00 00 00 00	 push	 OFFSET FLAT:$SG73039
  007dd	ff d6		 call	 esi

; 2685 : #endif	/* UNDER_CE */
; 2686 : 	
; 2687 : 	if ( phTTS->uiID_Buffer_Message == 0 )

  007df	3b c3		 cmp	 eax, ebx
  007e1	89 45 5c	 mov	 DWORD PTR [ebp+92], eax

; 2688 : 	{
; 2689 : 		DeleteTextToSpeechObjects( phTTS );
; 2690 : 
; 2691 : #ifdef LICENSES
; 2692 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2693 : #endif	/* LICENSES */
; 2694 : 
; 2695 : 		return( MMSYSERR_NOMEM );

  007e4	74 21		 je	 SHORT $L74640

; 2696 : 	}
; 2697 : 	
; 2698 : #endif /* WIN32 (3) */
; 2699 : 	
; 2700 : 	/********************************************************************/
; 2701 : 	/*  Initialize the audio driver.                                    */
; 2702 : 	/********************************************************************/
; 2703 : 	
; 2704 : #ifndef SAPI5DECTALK	/* SAPI5DECTALK (1) */
; 2705 : 	if (( dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  007e6	8b 7c 24 28	 mov	 edi, DWORD PTR _dwDeviceOptions$[esp+24]
  007ea	f7 c7 00 00 00
	80		 test	 edi, -2147483648	; 80000000H
  007f0	0f 85 d5 00 00
	00		 jne	 $L73041

; 2706 : 	{
; 2707 : 		/********************************************************************/
; 2708 : 		/*  Allocate memory for the local WAVEFORMATEX structure.           */
; 2709 : 		/********************************************************************/
; 2710 : 		// 01aug97 bats423: allocate this for both SAPI and DAPI
; 2711 : 		pWaveFormat = (LPWAVEFORMATEX)malloc(sizeof(WAVEFORMATEX));

  007f6	6a 12		 push	 18			; 00000012H
  007f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  007fe	8b f0		 mov	 esi, eax
  00800	83 c4 04	 add	 esp, 4

; 2712 : 		
; 2713 : 		if ( pWaveFormat == NULL )

  00803	3b f3		 cmp	 esi, ebx
  00805	75 1b		 jne	 SHORT $L73045
$L74640:

; 2714 : 		{
; 2715 : 			DeleteTextToSpeechObjects( phTTS );

  00807	55		 push	 ebp
  00808	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  0080d	83 c4 04	 add	 esp, 4
$L74642:

; 2716 : 
; 2717 : #if defined WIN32 || defined __linux__
; 2718 : #ifdef LICENSES
; 2719 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00810	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  00815	5f		 pop	 edi
  00816	5e		 pop	 esi
  00817	5d		 pop	 ebp

; 2720 : #endif	/* LICENSES */
; 2721 : #endif	/* defined WIN32 || defined __linux__ */
; 2722 : 
; 2723 : 			return( MMSYSERR_NOMEM );

  00818	b8 07 00 00 00	 mov	 eax, 7
  0081d	5b		 pop	 ebx

; 3099 : }

  0081e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00821	c3		 ret	 0
$L73045:

; 2724 : 		}
; 2725 : 		
; 2726 : #ifndef OLEDECTALK
; 2727 : 		/********************************************************************/
; 2728 : 		/*  Fill in all the required fields of the WAVEFORMATEX structure.  */
; 2729 : 		/********************************************************************/
; 2730 : 		
; 2731 : 		pWaveFormat->wFormatTag = WAVE_FORMAT_PCM;
; 2732 : 
; 2733 : #ifdef TUNE_8KHZ_VOICE
; 2734 : 		pWaveFormat->nSamplesPerSec = MULAW_SAMPLE_RATE;
; 2735 : #else
; 2736 : 		pWaveFormat->nSamplesPerSec = PC_SAMPLE_RATE;
; 2737 : #endif	/* TUNE_8KHZ_VOICE */
; 2738 : 
; 2739 : 		pWaveFormat->nChannels = 1;
; 2740 : 		pWaveFormat->wBitsPerSample = 16;
; 2741 : 		/********************************************************************/
; 2742 : 		/*  Open the audio device.                                          */
; 2743 : 		/********************************************************************/
; 2744 : 		
; 2745 : 		mmStatus = PA_CreatePlayHandle( &pPlayAudio,
; 2746 : 			uiDeviceNumber,
; 2747 : 			pWaveFormat,
; 2748 : 			dwDeviceOptions,
; 2749 : 			PlayAudioCallbackRoutine,
; 2750 : 			(ATYPE_T)phTTS);

  00822	8b 4c 24 24	 mov	 ecx, DWORD PTR _uiDeviceNumber$[esp+24]
  00826	55		 push	 ebp
  00827	68 00 00 00 00	 push	 OFFSET FLAT:_PlayAudioCallbackRoutine
  0082c	57		 push	 edi
  0082d	56		 push	 esi
  0082e	8d 54 24 20	 lea	 edx, DWORD PTR _pPlayAudio$[esp+44]
  00832	51		 push	 ecx
  00833	52		 push	 edx
  00834	66 c7 06 01 00	 mov	 WORD PTR [esi], 1
  00839	c7 46 04 11 2b
	00 00		 mov	 DWORD PTR [esi+4], 11025 ; 00002b11H
  00840	66 c7 46 02 01
	00		 mov	 WORD PTR [esi+2], 1
  00846	66 c7 46 0e 10
	00		 mov	 WORD PTR [esi+14], 16	; 00000010H
  0084c	e8 00 00 00 00	 call	 _PA_CreatePlayHandle
  00851	8b f8		 mov	 edi, eax
  00853	83 c4 18	 add	 esp, 24			; 00000018H

; 2751 : 		// bats423: free (pWaveFormat) done later
; 2752 : #else	/* OLEDECTALK */
; 2753 : 		/*******************************************************/
; 2754 : 		/* Initialize the DECtalk audio system for OLE-DECTALK */
; 2755 : 		/*******************************************************/
; 2756 : 			      mmStatus = InitializeDECtalkAudio((HWND)dwTTSInstanceParameter,&pPlayAudio);
; 2757 : #endif /* OLEDECTALK */
; 2758 : 		
; 2759 : 		if ( mmStatus )

  00856	3b fb		 cmp	 edi, ebx
  00858	74 2b		 je	 SHORT $L73049

; 2760 : 		{
; 2761 : 
; 2762 : #if defined WIN32 || defined __linux__
; 2763 : #ifdef LICENSES
; 2764 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0085a	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 2765 : #endif	/* LICENSES */
; 2766 : #endif	/* defined WIN32 || defined __linux__ */
; 2767 : 
; 2768 : 			free( pWaveFormat ); // bats423

  0085f	56		 push	 esi
  00860	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00866	83 c4 04	 add	 esp, 4

; 2769 : #ifdef API_DEBUG
; 2770 : 			OutputDebugString("ttsapi: error initializing audio\n");
; 2771 : #endif /* API_DEBUG */
; 2772 : 
; 2773 : 			if ( mmStatus == MMSYSERR_ERROR ) // tek 24sep96

  00869	83 ff 01	 cmp	 edi, 1
  0086c	75 0d		 jne	 SHORT $L73048
  0086e	5f		 pop	 edi
  0086f	5e		 pop	 esi
  00870	5d		 pop	 ebp

; 2774 : 			{
; 2775 : 				return( MMSYSERR_NODRIVER );

  00871	b8 06 00 00 00	 mov	 eax, 6
  00876	5b		 pop	 ebx

; 3099 : }

  00877	83 c4 0c	 add	 esp, 12			; 0000000cH
  0087a	c3		 ret	 0
$L73048:

; 2776 : 			}
; 2777 : 
; 2778 : #ifdef DONT_RETURN_BADFORMAT
; 2779 : 			else if (mmStatus == WAVERR_BADFORMAT)
; 2780 : 			{	// tek 24sep96 we'd really like to return BADFORMAT here
; 2781 : 				// but that will break existing users. Baggage..
; 2782 : 				return (MMSYSERR_NODRIVER);
; 2783 : 			} 
; 2784 : #endif	/* DONT_RETURN_BADFORMAT */
; 2785 : 			else
; 2786 : 				return( mmStatus );

  0087b	8b c7		 mov	 eax, edi
  0087d	5f		 pop	 edi
  0087e	5e		 pop	 esi
  0087f	5d		 pop	 ebp
  00880	5b		 pop	 ebx

; 3099 : }

  00881	83 c4 0c	 add	 esp, 12			; 0000000cH
  00884	c3		 ret	 0
$L73049:

; 2787 : 		}
; 2788 : 		
; 2789 : 		phTTS->pAudioHandle = pPlayAudio;

  00885	8b 44 24 10	 mov	 eax, DWORD PTR _pPlayAudio$[esp+28]

; 2790 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 2791 : 		// tek 01aug97 bats423 init some stuff for later use here..
; 2792 : 
; 2793 : #ifdef OLEDECTALK
; 2794 : 		phTTS->pAudioHandle->pcMode = NULL; // this gets filled in later.
; 2795 : #endif	/* OLEDECTALK */
; 2796 : 
; 2797 : 		// get the sample rate and stash it away.. 
; 2798 : 		PA_GetFormat(pPlayAudio,pWaveFormat);

  00889	56		 push	 esi
  0088a	89 85 d8 00 00
	00		 mov	 DWORD PTR [ebp+216], eax
  00890	89 9d 88 00 00
	00		 mov	 DWORD PTR [ebp+136], ebx
  00896	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+32]
  0089a	51		 push	 ecx
  0089b	e8 00 00 00 00	 call	 _PA_GetFormat

; 2799 : 		pPlayAudio->dMsecPerSample = 
; 2800 : 			(double)(1000)/(double)(pWaveFormat->nAvgBytesPerSec);

  008a0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  008a3	89 5c 24 20	 mov	 DWORD PTR -8+[esp+40], ebx
  008a7	89 54 24 1c	 mov	 DWORD PTR -8+[esp+36], edx
  008ab	8b 44 24 18	 mov	 eax, DWORD PTR _pPlayAudio$[esp+36]
  008af	df 6c 24 1c	 fild	 QWORD PTR -8+[esp+36]

; 2801 : 		free( pWaveFormat );

  008b3	56		 push	 esi
  008b4	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@8@4008fa00000000000000
  008ba	dd 98 b0 00 00
	00		 fstp	 QWORD PTR [eax+176]
  008c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  008c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2802 : 		
; 2803 : 	}
; 2804 : 	else // tek 01jul97/01aug97 bats 423

  008c9	eb 06		 jmp	 SHORT $L73052
$L73041:

; 2805 : 		//have to deal with the DO_NOT_USE_AUDIO_DEVICE
; 2806 : 		// case for DAPI..  (well, not really, but doing this here 
; 2807 : 		// reminds us that there IS another case..
; 2808 : 	{
; 2809 : 		phTTS->pAudioHandle = NULL;

  008cb	89 9d d8 00 00
	00		 mov	 DWORD PTR [ebp+216], ebx
$L73052:

; 2810 : 	}
; 2811 : 
; 2812 : #else /* SAPI5DECTALK (1) */
; 2813 : 
; 2814 : 	if (( dwDeviceOptions & USE_SAPI5_AUDIO_DEVICE ) != 0 )
; 2815 : 	{
; 2816 : 		mmStatus = InitializeDECtalkAudio((HWND)dwTTSInstanceParameter,&pPlayAudio);
; 2817 : 		if ( mmStatus )
; 2818 : 		{
; 2819 : 
; 2820 : #if defined WIN32 || defined __linux__
; 2821 : #ifdef LICENSES
; 2822 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2823 : #endif	/* LICENSES */
; 2824 : #endif	/* defined WIN32 || defined __linux__ */
; 2825 : 
; 2826 : 			DeleteTextToSpeechObjects( phTTS );
; 2827 : 
; 2828 : 			if ( mmStatus == MMSYSERR_ERROR ) // tek 24sep96
; 2829 : 			{
; 2830 : 				return( MMSYSERR_NODRIVER );
; 2831 : 			}
; 2832 : 			else
; 2833 : 			{
; 2834 : 				return( mmStatus );
; 2835 : 			}
; 2836 : 		}
; 2837 : 		phTTS->pAudioHandle = pPlayAudio;
; 2838 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 2839 : 		// tek 01aug97 bats423 init some stuff for later use here..
; 2840 : 		pPlayAudio->dMsecPerSample = 
; 2841 : 			(double)(1000)/(double)(22050);  // 11025 *2
; 2842 : 	}
; 2843 : 
; 2844 : 
; 2845 : #endif /* SAPI5DECTALK (1) */
; 2846 : 	
; 2847 : 	/********************************************************************/
; 2848 : 	/*  Start the Synchronization thread.                               */
; 2849 : 	/********************************************************************/
; 2850 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_SYNC),
; 2851 : 
; 2852 : #ifdef WIN32
; 2853 : 		FALSE,(start_address)sync_main))== MMSYSERR_NOMEM)

  008d1	68 00 00 00 00	 push	 OFFSET FLAT:_sync_main@4
  008d6	8d 45 34	 lea	 eax, DWORD PTR [ebp+52]
  008d9	53		 push	 ebx
  008da	50		 push	 eax
  008db	55		 push	 ebp
  008dc	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  008e1	83 c4 10	 add	 esp, 16			; 00000010H
  008e4	83 f8 07	 cmp	 eax, 7
  008e7	75 12		 jne	 SHORT $L73055

; 2854 : #endif	/* WIN32 */
; 2855 : 
; 2856 : #if defined __osf__ || defined __linux__
; 2857 : 		FALSE, sync_main))== MMSYSERR_NOMEM)
; 2858 : #endif
; 2859 : 	{
; 2860 : #if defined WIN32 || defined __linux__
; 2861 : #ifdef LICENSES
; 2862 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  008e9	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  008ee	5f		 pop	 edi
  008ef	5e		 pop	 esi
  008f0	5d		 pop	 ebp

; 2863 : #endif // LICENSES
; 2864 : #endif
; 2865 : 		return(MMSYSERR_NOMEM);

  008f1	b8 07 00 00 00	 mov	 eax, 7
  008f6	5b		 pop	 ebx

; 3099 : }

  008f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  008fa	c3		 ret	 0
$L73055:

; 2866 : 	}
; 2867 : 	
; 2868 : 	/********************************************************************/
; 2869 : 	/*  Start the Vocal Tract Model thread.                             */
; 2870 : 	/********************************************************************/
; 2871 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_VTM),
; 2872 : #ifdef WIN32
; 2873 : 		TRUE,(start_address)vtm_main))== MMSYSERR_NOMEM)

  008fb	68 00 00 00 00	 push	 OFFSET FLAT:_vtm_main@4
  00900	8d 7d 30	 lea	 edi, DWORD PTR [ebp+48]
  00903	6a 01		 push	 1
  00905	57		 push	 edi
  00906	55		 push	 ebp
  00907	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  0090c	83 c4 10	 add	 esp, 16			; 00000010H
  0090f	83 f8 07	 cmp	 eax, 7
  00912	75 12		 jne	 SHORT $L73057

; 2874 : #endif
; 2875 : #if defined __osf__ || defined __linux__
; 2876 : 		TRUE, vtm_main))== MMSYSERR_NOMEM)
; 2877 : #endif
; 2878 : 	{
; 2879 : #if defined WIN32 || defined __linux__
; 2880 : #ifdef LICENSES
; 2881 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00914	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  00919	5f		 pop	 edi
  0091a	5e		 pop	 esi
  0091b	5d		 pop	 ebp

; 2882 : #endif //LICENSES
; 2883 : #endif
; 2884 : 		return(MMSYSERR_NOMEM);

  0091c	b8 07 00 00 00	 mov	 eax, 7
  00921	5b		 pop	 ebx

; 3099 : }

  00922	83 c4 0c	 add	 esp, 12			; 0000000cH
  00925	c3		 ret	 0
$L73057:

; 2885 : 	}
; 2886 : 	
; 2887 : 	/********************************************************************/
; 2888 : 	/*  Start the Phonetic processing thread.                           */
; 2889 : 	/********************************************************************/
; 2890 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_PH),
; 2891 : #ifdef WIN32
; 2892 : 		TRUE, (start_address)ph_main))== MMSYSERR_NOMEM)

  00926	68 00 00 00 00	 push	 OFFSET FLAT:_ph_main@4
  0092b	8d 75 2c	 lea	 esi, DWORD PTR [ebp+44]
  0092e	6a 01		 push	 1
  00930	56		 push	 esi
  00931	55		 push	 ebp
  00932	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  00937	83 c4 10	 add	 esp, 16			; 00000010H
  0093a	83 f8 07	 cmp	 eax, 7
  0093d	75 12		 jne	 SHORT $L73059

; 2893 : #endif
; 2894 : #if defined __osf__ || defined __linux__
; 2895 : 		TRUE, ph_main))== MMSYSERR_NOMEM)
; 2896 : #endif
; 2897 : 	{
; 2898 : #if defined WIN32 || defined __linux__
; 2899 : #ifdef LICENSES
; 2900 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0093f	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  00944	5f		 pop	 edi
  00945	5e		 pop	 esi
  00946	5d		 pop	 ebp

; 2901 : #endif //LICENSES
; 2902 : #endif 
; 2903 : 		return(MMSYSERR_NOMEM);

  00947	b8 07 00 00 00	 mov	 eax, 7
  0094c	5b		 pop	 ebx

; 3099 : }

  0094d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00950	c3		 ret	 0
$L73059:

; 2904 : 	}
; 2905 : 	
; 2906 : #ifdef TYPING_MODE	 //09jun97 tek
; 2907 : 	// elevate the PH and VTM thread priority
; 2908 : 	if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)

  00951	39 9d 88 00 00
	00		 cmp	 DWORD PTR [ebp+136], ebx
  00957	75 17		 jne	 SHORT $L73060

; 2909 : 	{
; 2910 : 		// 19nov97 VTM adjusts the priority of both PH and VTM, so we
; 2911 : 		// set it high to start and then let it back down automagically
; 2912 : #ifndef UNDER_CE
; 2913 : 		OP_SetThreadPriority((phTTS->hThread_PH),OP_PRIORITY_HIGHEST);

  00959	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0095b	6a 02		 push	 2
  0095d	51		 push	 ecx
  0095e	e8 00 00 00 00	 call	 _OP_SetThreadPriority

; 2914 : 		OP_SetThreadPriority((phTTS->hThread_VTM),OP_PRIORITY_HIGHEST);

  00963	8b 17		 mov	 edx, DWORD PTR [edi]
  00965	6a 02		 push	 2
  00967	52		 push	 edx
  00968	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  0096d	83 c4 10	 add	 esp, 16			; 00000010H
$L73060:

; 2915 : #endif
; 2916 : 	}
; 2917 : #ifndef UNDER_CE
; 2918 : 	OP_SetThreadPriority((phTTS->hThread_SYNC),OP_PRIORITY_ABOVE_NORMAL);

  00970	8b 45 34	 mov	 eax, DWORD PTR [ebp+52]
  00973	6a 01		 push	 1
  00975	50		 push	 eax
  00976	e8 00 00 00 00	 call	 _OP_SetThreadPriority

; 2919 : #endif
; 2920 : #endif //TYPING_MODE
; 2921 : 	
; 2922 : 	/********************************************************************/
; 2923 : 	/*  Start the Letter To Sound thread.                               */
; 2924 : 	/********************************************************************/
; 2925 : 	nReturnCode = StartDecTalkSystemThread(phTTS, &(phTTS->hThread_LTS),
; 2926 : #ifdef WIN32
; 2927 : 		TRUE,(start_address)lts_main);

  0097b	68 00 00 00 00	 push	 OFFSET FLAT:_lts_main@4
  00980	8d 45 28	 lea	 eax, DWORD PTR [ebp+40]
  00983	6a 01		 push	 1
  00985	50		 push	 eax
  00986	55		 push	 ebp
  00987	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  0098c	8b f0		 mov	 esi, eax
  0098e	83 c4 18	 add	 esp, 24			; 00000018H

; 2928 : #endif
; 2929 : #if defined __osf__ || defined __linux__
; 2930 : 		TRUE, lts_main);			
; 2931 : #endif
; 2932 : 		if(nReturnCode == MMSYSERR_NOMEM ||
; 2933 : 			nReturnCode == MMSYSERR_INVALPARAM ||
; 2934 : 			nReturnCode == MMSYSERR_ERROR )

  00991	83 fe 07	 cmp	 esi, 7
  00994	74 73		 je	 SHORT $L73070
  00996	83 fe 0b	 cmp	 esi, 11			; 0000000bH
  00999	74 6e		 je	 SHORT $L73070
  0099b	83 fe 01	 cmp	 esi, 1
  0099e	74 69		 je	 SHORT $L73070

; 2942 : 		}
; 2943 : 		
; 2944 : 		/********************************************************************/
; 2945 : 		/*  Start the Command thread.                                       */
; 2946 : 		/********************************************************************/
; 2947 : 		if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_CMD),
; 2948 : #ifdef WIN32
; 2949 : 			TRUE,(start_address)cmd_main))== MMSYSERR_NOMEM)

  009a0	68 00 00 00 00	 push	 OFFSET FLAT:_cmd_main@4
  009a5	8d 45 24	 lea	 eax, DWORD PTR [ebp+36]
  009a8	6a 01		 push	 1
  009aa	50		 push	 eax
  009ab	55		 push	 ebp
  009ac	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  009b1	83 c4 10	 add	 esp, 16			; 00000010H
  009b4	83 f8 07	 cmp	 eax, 7
  009b7	75 12		 jne	 SHORT $L73065

; 2950 : #endif
; 2951 : #if defined __osf__ || defined __linux__
; 2952 : 			TRUE, cmd_main))== MMSYSERR_NOMEM)
; 2953 : #endif
; 2954 : 		{
; 2955 : #if defined WIN32 || defined __linux__
; 2956 : #ifdef LICENSES
; 2957 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  009b9	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  009be	5f		 pop	 edi
  009bf	5e		 pop	 esi
  009c0	5d		 pop	 ebp

; 2958 : #endif //LICENSES
; 2959 : #endif
; 2960 : 			return(MMSYSERR_NOMEM);

  009c1	b8 07 00 00 00	 mov	 eax, 7
  009c6	5b		 pop	 ebx

; 3099 : }

  009c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  009ca	c3		 ret	 0
$L73065:

; 2961 : 		}
; 2962 : 		
; 2963 : 		/********************************************************************/
; 2964 : 		/*  Start the Text Queueing thread.                                 */
; 2965 : 		/********************************************************************/
; 2966 : 		phTTS->hTextToSpeechWnd = (int)NULL;
; 2967 : 		
; 2968 : 		nReturnCode = StartDecTalkSystemThread(phTTS, &(phTTS->hThread_TXT),
; 2969 : #ifdef WIN32
; 2970 : 			TRUE,(start_address)TextToSpeechThreadMain);

  009cb	68 00 00 00 00	 push	 OFFSET FLAT:_TextToSpeechThreadMain@4
  009d0	8d 45 20	 lea	 eax, DWORD PTR [ebp+32]
  009d3	6a 01		 push	 1
  009d5	50		 push	 eax
  009d6	55		 push	 ebp
  009d7	89 5d 04	 mov	 DWORD PTR [ebp+4], ebx
  009da	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  009df	8b f0		 mov	 esi, eax
  009e1	83 c4 10	 add	 esp, 16			; 00000010H

; 2971 : #endif
; 2972 : #if defined __osf__ || defined __linux__
; 2973 : 		TRUE, TextToSpeechThreadMain);
; 2974 : #endif
; 2975 : 		if(nReturnCode == MMSYSERR_NOMEM ||
; 2976 : 			nReturnCode == MMSYSERR_ERROR)

  009e4	83 fe 07	 cmp	 esi, 7
  009e7	74 20		 je	 SHORT $L73070
  009e9	83 fe 01	 cmp	 esi, 1
  009ec	74 1b		 je	 SHORT $L73070

; 2977 : 		{
; 2978 : #if defined WIN32 || defined __linux__
; 2979 : #ifdef LICENSES
; 2980 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2981 : #endif //LICENSES
; 2982 : #endif
; 2983 : 			return(nReturnCode);
; 2984 : 		}
; 2985 : 		
; 2986 : #ifdef OLD
; 2987 : 		phTTS->hThread_TXT = CreateThread( NULL,
; 2988 : 			0,
; 2989 : 			(LPTHREAD_START_ROUTINE)TextToSpeechThreadMain,
; 2990 : 			(LPVOID)phTTS,
; 2991 : 			0,
; 2992 : 			&ID_Thread_TXT );
; 2993 : 		
; 2994 : 		/********************************************************************/
; 2995 : 		/*  Wait here until the LTS thread loads the dictionary.            */
; 2996 : 		/********************************************************************/
; 2997 : 		/* GL 11/05/1997  for BATS#510 */
; 2998 : 		for ( i = 0; pKsd_t->fdic_entries[pKsd_t->lang_curr] == 0; i++ )
; 2999 : 		{
; 3000 : 			Sleep( STARTUP_LOOP_WAIT_TIME );
; 3001 : 			if ( i > MAX_STARTUP_WAIT_COUNT )
; 3002 : 			{                                                            
; 3003 : 				DeleteTextToSpeechObjects( phTTS );
; 3004 : #if defined WIN32 || defined __linux__            
; 3005 : #ifdef LICENSES
; 3006 : 				ReleaseLicenseRef();	
; 3007 : /* tek 23sep96 give back the license unit */
; 3008 : #endif //LICENSES
; 3009 : #endif
; 3010 : 				return( MMSYSERR_ERROR );
; 3011 : 			}
; 3012 : 		}
; 3013 : 		
; 3014 : 		/********************************************************************/
; 3015 : 		/*  If the dictionary length was set to 0xFFFFFFFF then the         */
; 3016 : 		/*  dictionary file was not found. Return an error.                 */
; 3017 : 		/********************************************************************/
; 3018 : 		
; 3019 : 		/* GL 11/05/1997  for BATS#510 */
; 3020 : 		if ( pKsd_t->fdic_entries[pKsd_t->lang_curr] == 0xFFFFFFFF )
; 3021 : 		{
; 3022 : #if defined WIN32 || defined __linux__  
; 3023 : #ifdef LICENSES
; 3024 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 3025 : #endif //LICENSES
; 3026 : #endif
; 3027 : 			return( MMSYSERR_ERROR );
; 3028 : 		}
; 3029 : 		
; 3030 : 		/********************************************************************/
; 3031 : 		/*  Wait here until the Text-To-Speech main thread initializes the  */
; 3032 : 		/*  Text-To-Speech window handle.                                   */
; 3033 : /********************************************************************/
; 3034 : 
; 3035 : 		for ( i = 0; phTTS->hTextToSpeechWnd == NULL; i++ )
; 3036 : 		{
; 3037 : 			Sleep( STARTUP_LOOP_WAIT_TIME );
; 3038 : 			if ( i > MAX_STARTUP_WAIT_COUNT )
; 3039 : 			{
; 3040 : 				DeleteTextToSpeechObjects( phTTS );
; 3041 : #if defined WIN32 || defined __linux__ 
; 3042 : #ifdef LICENSES
; 3043 : 				ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 3044 : #endif //LICENSES
; 3045 : #endif
; 3046 : 				return( MMSYSERR_NOMEM );
; 3047 : 			}
; 3048 : 		}
; 3049 : 		
; 3050 : 		if ( phTTS->hThread_TXT == NULL )
; 3051 : 		{
; 3052 : 			DeleteTextToSpeechObjects( phTTS );
; 3053 : #if defined WIN32 || defined __linux__ 
; 3054 : #ifdef LICENSES
; 3055 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 3056 : #endif //LICENSES
; 3057 : #endif
; 3058 : 			return( MMSYSERR_NOMEM );
; 3059 : 		}
; 3060 : 		
; 3061 : #endif //OLD
; 3062 : 		
; 3063 : 		
; 3064 : 		/********************************************************************/
; 3065 : 		/*  MVP:06/19/96 Initialize the TextToSpeech handle the function        */
; 3066 : 		/*  returns through pphTTS argument.                                */
; 3067 : 		/********************************************************************/
; 3068 : 		
; 3069 : 		*pphTTS = phTTS;

  009ee	8b 4c 24 20	 mov	 ecx, DWORD PTR _pphTTS$[esp+24]

; 3070 : 		
; 3071 : 		/******************************************************************/
; 3072 : 		/*  Put the system into a known state.                            */
; 3073 : 		/******************************************************************/
; 3074 : 		
; 3075 : 		TextToSpeechReset( phTTS, TRUE );

  009f2	6a 01		 push	 1
  009f4	55		 push	 ebp
  009f5	89 29		 mov	 DWORD PTR [ecx], ebp
  009f7	e8 00 00 00 00	 call	 _TextToSpeechReset
  009fc	83 c4 08	 add	 esp, 8

; 3076 : 		
; 3077 : 		//MVP: Increment InstanceCounter on successful creation of a speech object.
; 3078 : 		//gnInstanceCounter++; // tek bats 668 12may98 this is done by the dic loader.
; 3079 : #if defined __osf__ || defined __linux__
; 3080 : 		gnInstanceCounter++;
; 3081 : #endif
; 3082 : 		
; 3083 : #ifdef DECTALKBETA430        //MVP:04/09/96 A message will be spoken for Beta releases.
; 3084 : #ifdef ENGLISH
; 3085 : 		TextToSpeechSpeak(phTTS, "DECtalk beta S D K version 4.4a is running. For evaluation only. ", TTS_FORCE);
; 3086 : #endif //ENGLISH
; 3087 : #ifdef SPANISH
; 3088 : 		TextToSpeechSpeak(phTTS, "DECtalk beta S d k versin 4.4a est corriendo. Para evaluacin solamente.", TTS_FORCE);
; 3089 : #endif //SPANISH
; 3090 : #ifdef GERMAN
; 3091 : 		TextToSpeechSpeak(phTTS, "Dies ist das DECtalk S D K, beta Version 4.4 A. Unlizensierte Testversion.", TTS_FORCE);
; 3092 : #endif //GERMAN
; 3093 : #ifdef FRENCH
; 3094 : 		TextToSpeechSpeak(phTTS, "DECtalk bta S D K version 4.4a fonctionne. Pour l'valuation seulement.", TTS_FORCE);
; 3095 : #endif //ENGLISH
; 3096 : #endif //DECTALKBETA430
; 3097 : 		
; 3098 : 		return( MMSYSERR_NOERROR );

  009ff	33 c0		 xor	 eax, eax
  00a01	5f		 pop	 edi
  00a02	5e		 pop	 esi
  00a03	5d		 pop	 ebp
  00a04	5b		 pop	 ebx

; 3099 : }

  00a05	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a08	c3		 ret	 0
$L73070:

; 2935 : 		{
; 2936 : #if defined WIN32 || defined __linux__
; 2937 : #ifdef LICENSES
; 2938 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00a09	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 2939 : #endif //LICENSES
; 2940 : #endif
; 2941 : 			return(nReturnCode);

  00a0e	8b c6		 mov	 eax, esi
  00a10	5f		 pop	 edi
  00a11	5e		 pop	 esi
  00a12	5d		 pop	 ebp
  00a13	5b		 pop	 ebx

; 3099 : }

  00a14	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a17	c3		 ret	 0
_TextToSpeechStartupExFonix ENDP
_TEXT	ENDS
PUBLIC	_DefaultTTSCallbackRoutine
PUBLIC	_TextToSpeechStartup
_TEXT	SEGMENT
_hWnd$ = 8
_pphTTS$ = 12
_uiDeviceNumber$ = 16
_dwDeviceOptions$ = 20
_TextToSpeechStartup PROC NEAR

; 3202 : 	// tek 13nov97 flag that we're using the default callback, so that
; 3203 : 	// we know that the instance param is actually hWnd..
; 3204 : 	return(TextToSpeechStartupEx(pphTTS,
; 3205 : 		uiDeviceNumber,
; 3206 : 		dwDeviceOptions|TTSSTARTUP_USING_DEFAULT_CALLBACK,
; 3207 : 		DefaultTTSCallbackRoutine,
; 3208 : 		(LONG)hWnd));

  00a20	8b 44 24 04	 mov	 eax, DWORD PTR _hWnd$[esp-4]
  00a24	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwDeviceOptions$[esp-4]
  00a28	8b 54 24 0c	 mov	 edx, DWORD PTR _uiDeviceNumber$[esp-4]
  00a2c	50		 push	 eax
  00a2d	8b 44 24 0c	 mov	 eax, DWORD PTR _pphTTS$[esp]
  00a31	81 c9 00 00 00
	08		 or	 ecx, 134217728		; 08000000H
  00a37	68 00 00 00 00	 push	 OFFSET FLAT:_DefaultTTSCallbackRoutine
  00a3c	51		 push	 ecx
  00a3d	52		 push	 edx
  00a3e	50		 push	 eax
  00a3f	e8 00 00 00 00	 call	 _TextToSpeechStartupEx
  00a44	83 c4 14	 add	 esp, 20			; 00000014H

; 3209 : 
; 3210 : /* GL 11/19/1998, the following codes never get used */
; 3211 : #if 0
; 3212 : 
; 3213 : 	/********************************************************************/
; 3214 : 	/*  Get the DECtalk error message.                                  */
; 3215 : 	/********************************************************************/
; 3216 : 	
; 3217 : 	phTTS->uiID_Error_Message =
; 3218 : 	  RegisterWindowMessage("DECtalkErrorMessage");
; 3219 : 	
; 3220 : 	if ( phTTS->uiID_Error_Message == 0 )
; 3221 : 	{
; 3222 : 	    DeleteTextToSpeechObjects( phTTS );
; 3223 : 	    return( MMSYSERR_NOMEM );
; 3224 : 	}
; 3225 : 	
; 3226 : 	/********************************************************************/
; 3227 : 	/*  Get the DECtalk index mark message.                             */
; 3228 : 	/********************************************************************/
; 3229 : 	
; 3230 : 	phTTS->uiID_Index_Message =
; 3231 : 	  RegisterWindowMessage("DECtalkIndexMessage");
; 3232 : 	
; 3233 : 	if ( phTTS->uiID_Index_Message == 0 )
; 3234 : 	{
; 3235 : 	    DeleteTextToSpeechObjects( phTTS );
; 3236 : 	    return( MMSYSERR_NOMEM );
; 3237 : 	}
; 3238 : 	
; 3239 : 	/********************************************************************/
; 3240 : 	/*  Get the DECtalk buffer message.                                 */
; 3241 : 	/********************************************************************/
; 3242 : 	
; 3243 : 	phTTS->uiID_Buffer_Message =
; 3244 : 	  RegisterWindowMessage("DECtalkBufferMessage");
; 3245 : 	
; 3246 : 	if ( phTTS->uiID_Buffer_Message == 0 )
; 3247 : 	{
; 3248 : 	    DeleteTextToSpeechObjects( phTTS );
; 3249 : 	    return( MMSYSERR_NOMEM );
; 3250 : 	}
; 3251 : #endif
; 3252 : 
; 3253 : }

  00a47	c3		 ret	 0
_TextToSpeechStartup ENDP
_TEXT	ENDS
EXTRN	__imp__PostMessageA@16:NEAR
_TEXT	SEGMENT
_lParam1$ = 8
_lParam2$ = 12
_dwInstanceParam$ = 16
_uiMsg$ = 20
_DefaultTTSCallbackRoutine PROC NEAR

; 3261 : #ifdef API_DEBUG
; 3262 : 	char szTemp[256]="";
; 3263 : 	ULONG ulStartTime,ulEndTime;
; 3264 : 	ulStartTime=timeGetTime();
; 3265 : 	sprintf(szTemp, "DTTSCallback(%ld) at %ld.\n", lParam1,ulStartTime);
; 3266 : 	OutputDebugString(szTemp);
; 3267 : #endif //API_DEBUG
; 3268 : 	
; 3269 : 	switch( lParam1 )
; 3270 : 	{

  00a50	8b 4c 24 04	 mov	 ecx, DWORD PTR _lParam1$[esp-4]
  00a54	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00a57	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00a5a	77 0f		 ja	 SHORT $L73094
  00a5c	33 d2		 xor	 edx, edx
  00a5e	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L74646[eax]
  00a64	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L74647[edx*4]
$L73094:

; 3271 : 	case TTS_AUDIO_PLAY_START:
; 3272 : 	case TTS_AUDIO_PLAY_STOP:
; 3273 : 	case ERROR_OPENING_WAVE_OUTPUT_DEVICE:
; 3274 : 	case ERROR_IN_AUDIO_WRITE:
; 3275 : 	case ERROR_GETTING_DEVICE_CAPABILITIES:
; 3276 : 		PostMessage((HWND)dwInstanceParam,uiMsg,lParam1,lParam2);
; 3277 : 		break;
; 3278 : 		
; 3279 : 	default:
; 3280 : 		// tek 19aug96 must this be a post?
; 3281 : 		PostMessage((HWND)dwInstanceParam,uiMsg,lParam1,lParam2);

  00a6b	8b 44 24 08	 mov	 eax, DWORD PTR _lParam2$[esp-4]
  00a6f	8b 54 24 0c	 mov	 edx, DWORD PTR _dwInstanceParam$[esp-4]
  00a73	50		 push	 eax
  00a74	51		 push	 ecx
  00a75	8b 4c 24 18	 mov	 ecx, DWORD PTR _uiMsg$[esp+4]
  00a79	51		 push	 ecx
  00a7a	52		 push	 edx
  00a7b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 3282 : 		break;
; 3283 : 	}
; 3284 : }

  00a81	c3		 ret	 0
  00a82	8b ff		 npad	 2
$L74647:
  00a84	00 00 00 00	 DD	 $L73094
  00a88	00 00 00 00	 DD	 $L73094
$L74646:
  00a8c	00		 DB	 0
  00a8d	00		 DB	 0
  00a8e	00		 DB	 0
  00a8f	01		 DB	 1
  00a90	01		 DB	 1
  00a91	01		 DB	 1
  00a92	01		 DB	 1
  00a93	01		 DB	 1
  00a94	01		 DB	 1
  00a95	01		 DB	 1
  00a96	01		 DB	 1
  00a97	00		 DB	 0
  00a98	00		 DB	 0
_DefaultTTSCallbackRoutine ENDP
_TEXT	ENDS
EXTRN	__imp__WaitForMultipleObjects@16:NEAR
EXTRN	__imp___beginthreadex:NEAR
EXTRN	__imp__GetExitCodeThread@8:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_ppDecTalkThread$ = 12
_bMalloc$ = 16
_ThreadFunction$ = 20
_IDThread$ = 20
_WaitObjArray$ = -8
_exit_code$ = 8
_StartDecTalkSystemThread PROC NEAR

; 3325 : 	UINT IDThread;
; 3326 : 	DWORD cNumObjects =2;
; 3327 : #if !defined __osf__ && !defined __linux__
; 3328 : 	HANDLE WaitObjArray[2];
; 3329 : 	ULONG exit_code ;
; 3330 : #endif
; 3331 : 	/*typedef int ( * _stdcall Stdstart_address ) (void *);*/
; 3332 : 	
; 3333 : #ifdef WIN32
; 3334 : 	*ppDecTalkThread = (HANDLE) _beginthreadex(NULL,
; 3335 : 								0,
; 3336 : 								ThreadFunction,             
; 3337 : 								(void *)phTTS,                                   
; 3338 : 								0,
; 3339 : 								&IDThread
; 3340 : 								);

  00aa0	8b 4c 24 10	 mov	 ecx, DWORD PTR _ThreadFunction$[esp-4]
  00aa4	83 ec 08	 sub	 esp, 8
  00aa7	8d 44 24 18	 lea	 eax, DWORD PTR _IDThread$[esp+4]
  00aab	56		 push	 esi
  00aac	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  00ab0	57		 push	 edi
  00ab1	50		 push	 eax
  00ab2	6a 00		 push	 0
  00ab4	56		 push	 esi
  00ab5	51		 push	 ecx
  00ab6	6a 00		 push	 0
  00ab8	6a 00		 push	 0
  00aba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthreadex
  00ac0	8b 7c 24 30	 mov	 edi, DWORD PTR _ppDecTalkThread$[esp+36]
  00ac4	83 c4 18	 add	 esp, 24			; 00000018H

; 3341 : #endif
; 3342 : #if defined __osf__ || defined __linux__
; 3343 : 	*ppDecTalkThread = OP_CreateThread(0,
; 3344 : 					   ThreadFunction,             
; 3345 : 					   (void *)phTTS);
; 3346 : #endif
; 3347 : 	
; 3348 : 	if ( *ppDecTalkThread == NULL )

  00ac7	85 c0		 test	 eax, eax
  00ac9	89 07		 mov	 DWORD PTR [edi], eax
  00acb	75 14		 jne	 SHORT $L73115

; 3349 : 	{
; 3350 : 		DeleteTextToSpeechObjects( phTTS );

  00acd	56		 push	 esi
  00ace	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  00ad3	83 c4 04	 add	 esp, 4

; 3351 : 		return( MMSYSERR_NOMEM );

  00ad6	b8 07 00 00 00	 mov	 eax, 7
  00adb	5f		 pop	 edi
  00adc	5e		 pop	 esi

; 3378 : #endif
; 3379 : #if defined __osf__ || defined __linux__
; 3380 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 3381 : 		DeleteTextToSpeechObjects( phTTS );
; 3382 : 	
; 3383 : 	return (phTTS->uiThreadError);
; 3384 : #endif
; 3385 : }

  00add	83 c4 08	 add	 esp, 8
  00ae0	c3		 ret	 0
$L73115:

; 3352 : 	}
; 3353 : 	
; 3354 : 	if(bMalloc == FALSE)          /* No dynamic memory allocations within thread main function */

  00ae1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _bMalloc$[esp+12]
  00ae5	85 c9		 test	 ecx, ecx
  00ae7	75 08		 jne	 SHORT $L73116
  00ae9	5f		 pop	 edi

; 3355 : 		return MMSYSERR_NOERROR;  /*No errors */

  00aea	33 c0		 xor	 eax, eax
  00aec	5e		 pop	 esi

; 3378 : #endif
; 3379 : #if defined __osf__ || defined __linux__
; 3380 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 3381 : 		DeleteTextToSpeechObjects( phTTS );
; 3382 : 	
; 3383 : 	return (phTTS->uiThreadError);
; 3384 : #endif
; 3385 : }

  00aed	83 c4 08	 add	 esp, 8
  00af0	c3		 ret	 0
$L73116:

; 3356 : #if !defined __osf__ && !defined __linux__
; 3357 : 	WaitObjArray[0] = *ppDecTalkThread;
; 3358 : 	WaitObjArray[1] = phTTS->hMallocSuccessEvent;

  00af1	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00af4	89 44 24 08	 mov	 DWORD PTR _WaitObjArray$[esp+16], eax

; 3359 : 	
; 3360 : 	WaitForMultipleObjects(cNumObjects,WaitObjArray,FALSE,INFINITE); 

  00af8	6a ff		 push	 -1
  00afa	8d 44 24 0c	 lea	 eax, DWORD PTR _WaitObjArray$[esp+20]
  00afe	6a 00		 push	 0
  00b00	50		 push	 eax
  00b01	6a 02		 push	 2
  00b03	89 54 24 1c	 mov	 DWORD PTR _WaitObjArray$[esp+36], edx
  00b07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForMultipleObjects@16

; 3361 : 	
; 3362 : 	GetExitCodeThread(*ppDecTalkThread,&exit_code);

  00b0d	8b 17		 mov	 edx, DWORD PTR [edi]
  00b0f	8d 4c 24 14	 lea	 ecx, DWORD PTR _exit_code$[esp+12]
  00b13	51		 push	 ecx
  00b14	52		 push	 edx
  00b15	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8

; 3363 : #endif /* __osf__ && __linux__ */
; 3364 : #if defined __osf__ || defined __linux__
; 3365 : 	OP_WaitForEvent( phTTS->hMallocSuccessEvent, OP_INFINITE );
; 3366 : #endif
; 3367 : 	
; 3368 : #if !defined __osf__ && !defined __linux__
; 3369 : 	if(exit_code == MMSYSERR_NOMEM ||
; 3370 : 		exit_code == MMSYSERR_INVALPARAM ||
; 3371 : 		exit_code == MMSYSERR_ERROR )

  00b1b	8b 44 24 14	 mov	 eax, DWORD PTR _exit_code$[esp+12]
  00b1f	83 f8 07	 cmp	 eax, 7
  00b22	74 12		 je	 SHORT $L73118
  00b24	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00b27	74 0d		 je	 SHORT $L73118
  00b29	83 f8 01	 cmp	 eax, 1
  00b2c	74 08		 je	 SHORT $L73118
  00b2e	5f		 pop	 edi

; 3375 : 	}
; 3376 : 	
; 3377 : 	return MMSYSERR_NOERROR;    /*No errors */

  00b2f	33 c0		 xor	 eax, eax
  00b31	5e		 pop	 esi

; 3378 : #endif
; 3379 : #if defined __osf__ || defined __linux__
; 3380 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 3381 : 		DeleteTextToSpeechObjects( phTTS );
; 3382 : 	
; 3383 : 	return (phTTS->uiThreadError);
; 3384 : #endif
; 3385 : }

  00b32	83 c4 08	 add	 esp, 8
  00b35	c3		 ret	 0
$L73118:

; 3372 : 	{
; 3373 : 		DeleteTextToSpeechObjects( phTTS );

  00b36	56		 push	 esi
  00b37	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects

; 3374 : 		return(exit_code);

  00b3c	8b 44 24 18	 mov	 eax, DWORD PTR _exit_code$[esp+16]
  00b40	83 c4 04	 add	 esp, 4
  00b43	5f		 pop	 edi
  00b44	5e		 pop	 esi

; 3378 : #endif
; 3379 : #if defined __osf__ || defined __linux__
; 3380 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 3381 : 		DeleteTextToSpeechObjects( phTTS );
; 3382 : 	
; 3383 : 	return (phTTS->uiThreadError);
; 3384 : #endif
; 3385 : }

  00b45	83 c4 08	 add	 esp, 8
  00b48	c3		 ret	 0
_StartDecTalkSystemThread ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechShutdown
PUBLIC	_TextToSpeechCloseInMemory
EXTRN	__imp__IsBadWritePtr@8:NEAR
EXTRN	_ThreadLock:NEAR
EXTRN	_ThreadUnlock:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechShutdown PROC NEAR

; 3418 : {

  00b50	56		 push	 esi

; 3419 : 	/********************************************************************/
; 3420 : 	/*  Return error if invalid handle.                                 */
; 3421 : 	/********************************************************************/
; 3422 : 	
; 3423 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  00b51	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00b55	6a 04		 push	 4
  00b57	56		 push	 esi
  00b58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  00b5e	85 c0		 test	 eax, eax
  00b60	74 07		 je	 SHORT $L73122

; 3424 : 		return( MMSYSERR_INVALHANDLE );

  00b62	b8 05 00 00 00	 mov	 eax, 5
  00b67	5e		 pop	 esi

; 3481 : }

  00b68	c3		 ret	 0
$L73122:

; 3425 : 	
; 3426 : 	/********************************************************************/
; 3427 : 	/*  If the last item in the TextToSpeechStartup() function was      */
; 3428 : 	/*  initialized then reset the the Text-To-Speech system.           */
; 3429 : 	/********************************************************************/
; 3430 : 	
; 3431 : 	/* The if statement is not reqd as phTTSglobal is going to be oboselete for MI :MVP */
; 3432 : 	/*if ( phTTSglobal != NULL )*/
; 3433 : 	if(phTTS != NULL)

  00b69	85 f6		 test	 esi, esi
  00b6b	74 0b		 je	 SHORT $L73124

; 3434 : 		TextToSpeechReset( phTTS, TRUE );

  00b6d	6a 01		 push	 1
  00b6f	56		 push	 esi
  00b70	e8 00 00 00 00	 call	 _TextToSpeechReset
  00b75	83 c4 08	 add	 esp, 8
$L73124:

; 3435 : 	
; 3436 : #ifdef DTALK50
; 3437 : 	CPUnitAPI(phTTS->CPanelThread);       // Remove the Control Panel - KSB
; 3438 : #endif //DTALK50
; 3439 : 	
; 3440 : 	/********************************************************************/
; 3441 : 	/*  Delete any objects created by the TextToSpeechInMemory().       */
; 3442 : 	/*  function.                                                       */
; 3443 : 	/********************************************************************/
; 3444 : 	
; 3445 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  00b78	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  00b7f	75 09		 jne	 SHORT $L73125

; 3446 : 		TextToSpeechCloseInMemory( phTTS );

  00b81	56		 push	 esi
  00b82	e8 00 00 00 00	 call	 _TextToSpeechCloseInMemory
  00b87	83 c4 04	 add	 esp, 4
$L73125:

; 3447 : 	
; 3448 : #ifdef SAPI5DECTALK
; 3449 : 	if (phTTS->dwOutputState == STATE_OUTPUT_SAPI5)
; 3450 : 		TextToSpeechCloseSapi5Output(phTTS);
; 3451 : #endif
; 3452 : 	
; 3453 : 	/********************************************************************/
; 3454 : 	/*  Delete all objects created in the TextToSpeechStartup()         */
; 3455 : 	/*  function.                                                       */
; 3456 : 	/********************************************************************/
; 3457 : 	// tek bats668 12may98 this must be decremented here to make sure 
; 3458 : 	// the dictionary gets unloaded.
; 3459 : 	// tek 27may98 bats 689:
; 3460 : 	// we need to lock around this to make sure we don't end up with a 
; 3461 : 	// startup and a shutdown colliding
; 3462 : #ifdef WIN32
; 3463 : 	ThreadLock(&tl_gnInstanceCounter,5); // tek 27may98 bats 689

  00b8a	6a 05		 push	 5
  00b8c	68 00 00 00 00	 push	 OFFSET FLAT:_tl_gnInstanceCounter
  00b91	e8 00 00 00 00	 call	 _ThreadLock

; 3464 : #endif
; 3465 : 	gnInstanceCounter--;     /* MVP: Decrement the instance counter */

  00b96	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gnInstanceCounter

; 3466 : 	
; 3467 : 	DeleteTextToSpeechObjects( phTTS );

  00b9c	56		 push	 esi
  00b9d	49		 dec	 ecx
  00b9e	89 0d 00 00 00
	00		 mov	 DWORD PTR _gnInstanceCounter, ecx
  00ba4	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects

; 3468 : 	
; 3469 : #ifdef WIN32
; 3470 : 	ThreadUnlock(&tl_gnInstanceCounter); // tek 27may98 bats 689

  00ba9	68 00 00 00 00	 push	 OFFSET FLAT:_tl_gnInstanceCounter
  00bae	e8 00 00 00 00	 call	 _ThreadUnlock
  00bb3	83 c4 10	 add	 esp, 16			; 00000010H

; 3471 : #endif
; 3472 : 	
; 3473 : 	// release the license count..
; 3474 : #if defined WIN32 || defined __linux__
; 3475 : #ifdef LICENSES
; 3476 : 	ReleaseLicenseRef();

  00bb6	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 3477 : #endif //LICENSES
; 3478 : #endif
; 3479 : 	
; 3480 : 	return( MMSYSERR_NOERROR );

  00bbb	33 c0		 xor	 eax, eax
  00bbd	5e		 pop	 esi

; 3481 : }

  00bbe	c3		 ret	 0
_TextToSpeechShutdown ENDP
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:NEAR
EXTRN	__imp__SetEvent@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	_write_pipe:NEAR
EXTRN	_exit_pipe:NEAR
EXTRN	_destroy_pipe:NEAR
EXTRN	__imp__SendMessageA@16:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	_PA_DestroyPlayHandle:NEAR
EXTRN	__imp__UnregisterClassA@8:NEAR
EXTRN	_OP_DestroyMutex:NEAR
EXTRN	_FreePHInstanceData:NEAR
EXTRN	_unload_dictionary:NEAR
EXTRN	_FreeCMDThreadMemory:NEAR
_DATA	SEGMENT
	ORG $+3
$SG73163 DB	'TextToSpeechWndClass', 00H
	ORG $+3
$SG73164 DB	'%s_%08X', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pCmd_t$ = -272
_dwDump$ = -268
_wDump$ = -280
_cDump$ = -284
_wndclass$ = -256
_DeleteTextToSpeechObjects PROC NEAR

; 3512 : {

  00bc0	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00bc6	53		 push	 ebx
  00bc7	55		 push	 ebp
  00bc8	56		 push	 esi
  00bc9	57		 push	 edi

; 3513 : 	/* Added the following 2 varaibles for MI :MVP */
; 3514 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00bca	8b bc 24 30 01
	00 00		 mov	 edi, DWORD PTR _phTTS$[esp+296]

; 3515 : 	PVOID pCmd_t = phTTS->pCMDThreadData;
; 3516 : 	DWORD dwDump[3] = { 0x0b, 0x0b, 0x0b };  /*MVP not a static variable,is a const*/
; 3517 : 	WORD wDump[3] = { 0x0b, 0x0b, 0x0b };    /*MVP not a static variable,is a const*/
; 3518 : 	char cDump[3] = { 0x0b, 0x0b, 0x0b };    /*MVP not a static variable,is a const*/
; 3519 : #ifdef WIN32
; 3520 : 	HINSTANCE hInstance;	// 06may97 BATS320   
; 3521 : #ifndef	UNDER_CE 
; 3522 : 	char wndclass[255];	// Window Class (KSB Aug-13-97)
; 3523 : #else
; 3524 : 	static TCHAR wndclass[255];
; 3525 : #endif
; 3526 : #endif
; 3527 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 3528 : 	THREAD_STATUS_T ThreadStatus;
; 3529 : #endif
; 3530 : 	
; 3531 : 	/********************************************************************/
; 3532 : 	/*  Terminate all threads.                                          */
; 3533 : 	/********************************************************************/
; 3534 : 	
; 3535 : 	if ( pKsd_t->sync_pipe != NULL )

  00bd1	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__CloseHandle@4
  00bd7	33 db		 xor	 ebx, ebx
  00bd9	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00bdc	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00bdf	89 44 24 1c	 mov	 DWORD PTR _pCmd_t$[esp+300], eax
  00be3	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00be8	89 44 24 20	 mov	 DWORD PTR _dwDump$[esp+300], eax
  00bec	89 44 24 24	 mov	 DWORD PTR _dwDump$[esp+304], eax
  00bf0	89 44 24 28	 mov	 DWORD PTR _dwDump$[esp+308], eax
  00bf4	66 89 44 24 14	 mov	 WORD PTR _wDump$[esp+300], ax
  00bf9	66 89 44 24 16	 mov	 WORD PTR _wDump$[esp+302], ax
  00bfe	66 89 44 24 18	 mov	 WORD PTR _wDump$[esp+304], ax
  00c03	88 44 24 10	 mov	 BYTE PTR _cDump$[esp+300], al
  00c07	88 44 24 11	 mov	 BYTE PTR _cDump$[esp+301], al
  00c0b	88 44 24 12	 mov	 BYTE PTR _cDump$[esp+302], al
  00c0f	8b 86 a0 02 00
	00		 mov	 eax, DWORD PTR [esi+672]
  00c15	3b c3		 cmp	 eax, ebx
  00c17	0f 84 7f 01 00
	00		 je	 $L73153

; 3536 : 	{
; 3537 : 		/******************************************************************/
; 3538 : 		/*  Shut down the SYNC thread.                                    */
; 3539 : 		/******************************************************************/
; 3540 : 		
; 3541 : 		if ( phTTS->hThread_SYNC != NULL )

  00c1d	39 5f 34	 cmp	 DWORD PTR [edi+52], ebx
  00c20	74 31		 je	 SHORT $L73139

; 3542 : 		{
; 3543 : 												exit_pipe( pKsd_t->sync_pipe );

  00c22	50		 push	 eax
  00c23	e8 00 00 00 00	 call	 _exit_pipe

; 3544 : 												write_pipe( pKsd_t->sync_pipe, dwDump, 3 );

  00c28	8b 96 a0 02 00
	00		 mov	 edx, DWORD PTR [esi+672]
  00c2e	8d 4c 24 24	 lea	 ecx, DWORD PTR _dwDump$[esp+304]
  00c32	6a 03		 push	 3
  00c34	51		 push	 ecx
  00c35	52		 push	 edx
  00c36	e8 00 00 00 00	 call	 _write_pipe

; 3545 : #ifdef WIN32
; 3546 : 												WaitForSingleObject( phTTS->hThread_SYNC,
; 3547 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00c3b	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  00c3e	83 c4 10	 add	 esp, 16			; 00000010H
  00c41	68 e8 03 00 00	 push	 1000			; 000003e8H
  00c46	50		 push	 eax
  00c47	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3548 : 												
; 3549 : 												CloseHandle( phTTS->hThread_SYNC );

  00c4d	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00c50	51		 push	 ecx
  00c51	ff d5		 call	 ebp
$L73139:

; 3550 : #endif
; 3551 : #if defined __osf__ || defined __linux__
; 3552 : 												OP_WaitForThreadTermination( phTTS->hThread_SYNC,
; 3553 : 													&ThreadStatus,
; 3554 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3555 : #endif
; 3556 : 		}
; 3557 : 		
; 3558 : 		/******************************************************************/
; 3559 : 		/*  Shut down the VTM thread.                                     */
; 3560 : 		/******************************************************************/
; 3561 : 		
; 3562 : 		if ( phTTS->hThread_VTM != NULL )

  00c53	39 5f 30	 cmp	 DWORD PTR [edi+48], ebx
  00c56	74 4b		 je	 SHORT $L73141

; 3563 : 		{
; 3564 : 												exit_pipe( pKsd_t->vtm_pipe );

  00c58	8b 96 9c 02 00
	00		 mov	 edx, DWORD PTR [esi+668]
  00c5e	52		 push	 edx
  00c5f	e8 00 00 00 00	 call	 _exit_pipe

; 3565 : 												write_pipe( pKsd_t->vtm_pipe, wDump, 3 );

  00c64	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  00c6a	8d 44 24 18	 lea	 eax, DWORD PTR _wDump$[esp+304]
  00c6e	6a 03		 push	 3
  00c70	50		 push	 eax
  00c71	51		 push	 ecx
  00c72	e8 00 00 00 00	 call	 _write_pipe

; 3566 : 												
; 3567 : 												/*MVP Free the allocated memory in LTS thread activity */
; 3568 : 												if(phTTS->pVTMThreadData)

  00c77	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00c7a	83 c4 10	 add	 esp, 16			; 00000010H
  00c7d	3b c3		 cmp	 eax, ebx
  00c7f	74 0d		 je	 SHORT $L73142

; 3569 : 												{
; 3570 : 													free(phTTS->pVTMThreadData);

  00c81	50		 push	 eax
  00c82	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00c88	83 c4 04	 add	 esp, 4

; 3571 : 													phTTS->pVTMThreadData = NULL;

  00c8b	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
$L73142:

; 3572 : 												}
; 3573 : 												
; 3574 : #ifdef WIN32
; 3575 : 												WaitForSingleObject( phTTS->hThread_VTM,
; 3576 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00c8e	8b 57 30	 mov	 edx, DWORD PTR [edi+48]
  00c91	68 e8 03 00 00	 push	 1000			; 000003e8H
  00c96	52		 push	 edx
  00c97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3577 : 												
; 3578 : 												CloseHandle( phTTS->hThread_VTM );

  00c9d	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00ca0	50		 push	 eax
  00ca1	ff d5		 call	 ebp
$L73141:

; 3579 : #endif
; 3580 : #if defined __osf__ || defined __linux__
; 3581 : 												OP_WaitForThreadTermination( phTTS->hThread_VTM,
; 3582 : 													&ThreadStatus,
; 3583 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3584 : #endif
; 3585 : 												
; 3586 : 		}
; 3587 : 		
; 3588 : 		/******************************************************************/
; 3589 : 		/*  Shut down the PH thread.                                      */
; 3590 : 		/******************************************************************/
; 3591 : 		
; 3592 : 		if ( phTTS->hThread_PH != NULL )

  00ca3	39 5f 2c	 cmp	 DWORD PTR [edi+44], ebx
  00ca6	74 4a		 je	 SHORT $L73145

; 3593 : 		{
; 3594 : 												exit_pipe( pKsd_t->ph_pipe );

  00ca8	8b 8e 94 02 00
	00		 mov	 ecx, DWORD PTR [esi+660]
  00cae	51		 push	 ecx
  00caf	e8 00 00 00 00	 call	 _exit_pipe

; 3595 : 												write_pipe( pKsd_t->ph_pipe, wDump, 3 );

  00cb4	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  00cba	8d 54 24 18	 lea	 edx, DWORD PTR _wDump$[esp+304]
  00cbe	6a 03		 push	 3
  00cc0	52		 push	 edx
  00cc1	50		 push	 eax
  00cc2	e8 00 00 00 00	 call	 _write_pipe

; 3596 : 												/*MVP Free the allocated memory in PH thread activity */
; 3597 : 												if(phTTS->pPHThreadData)

  00cc7	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00cca	83 c4 10	 add	 esp, 16			; 00000010H
  00ccd	3b c3		 cmp	 eax, ebx
  00ccf	74 09		 je	 SHORT $L73146

; 3598 : 													FreePHInstanceData(phTTS->pPHThreadData); /* 04aug96 */

  00cd1	50		 push	 eax
  00cd2	e8 00 00 00 00	 call	 _FreePHInstanceData
  00cd7	83 c4 04	 add	 esp, 4
$L73146:

; 3599 : 												phTTS->pPHThreadData = NULL;
; 3600 : 												
; 3601 : #ifdef WIN32
; 3602 : 												WaitForSingleObject( phTTS->hThread_PH,
; 3603 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00cda	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00cdd	68 e8 03 00 00	 push	 1000			; 000003e8H
  00ce2	51		 push	 ecx
  00ce3	89 5f 18	 mov	 DWORD PTR [edi+24], ebx
  00ce6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3604 : 												
; 3605 : 												CloseHandle( phTTS->hThread_PH );

  00cec	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00cef	52		 push	 edx
  00cf0	ff d5		 call	 ebp
$L73145:

; 3606 : #endif
; 3607 : #if defined __osf__ || defined __linux__
; 3608 : 												OP_WaitForThreadTermination( phTTS->hThread_PH,
; 3609 : 													&ThreadStatus,
; 3610 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3611 : #endif
; 3612 : 		}
; 3613 : 		
; 3614 : 		/******************************************************************/
; 3615 : 		/*  Shut down the LTS thread.                                     */
; 3616 : 		/******************************************************************/
; 3617 : 		
; 3618 : 		if ( phTTS->hThread_LTS != NULL )

  00cf2	39 5f 28	 cmp	 DWORD PTR [edi+40], ebx
  00cf5	74 4b		 je	 SHORT $L73149

; 3619 : 		{
; 3620 : 												exit_pipe( pKsd_t->lts_pipe );

  00cf7	8b 86 90 02 00
	00		 mov	 eax, DWORD PTR [esi+656]
  00cfd	50		 push	 eax
  00cfe	e8 00 00 00 00	 call	 _exit_pipe

; 3621 : 												write_pipe( pKsd_t->lts_pipe, wDump, 3 );

  00d03	8b 96 90 02 00
	00		 mov	 edx, DWORD PTR [esi+656]
  00d09	8d 4c 24 18	 lea	 ecx, DWORD PTR _wDump$[esp+304]
  00d0d	6a 03		 push	 3
  00d0f	51		 push	 ecx
  00d10	52		 push	 edx
  00d11	e8 00 00 00 00	 call	 _write_pipe

; 3622 : 												/*MVP Free the allocated memory in LTS thread activity */
; 3623 : 												if(phTTS->pLTSThreadData)

  00d16	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00d19	83 c4 10	 add	 esp, 16			; 00000010H
  00d1c	3b c3		 cmp	 eax, ebx
  00d1e	74 0a		 je	 SHORT $L73150

; 3624 : 													free(phTTS->pLTSThreadData);

  00d20	50		 push	 eax
  00d21	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00d27	83 c4 04	 add	 esp, 4
$L73150:

; 3625 : 												phTTS->pLTSThreadData = NULL;
; 3626 : #ifdef WIN32
; 3627 : 												WaitForSingleObject( phTTS->hThread_LTS,
; 3628 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00d2a	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00d2d	68 e8 03 00 00	 push	 1000			; 000003e8H
  00d32	50		 push	 eax
  00d33	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  00d36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3629 : 												
; 3630 : 												CloseHandle( phTTS->hThread_LTS );

  00d3c	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00d3f	51		 push	 ecx
  00d40	ff d5		 call	 ebp
$L73149:

; 3631 : #endif
; 3632 : #if defined __osf__ || defined __linux__
; 3633 : 												OP_WaitForThreadTermination( phTTS->hThread_LTS,
; 3634 : 													&ThreadStatus,
; 3635 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3636 : #endif
; 3637 : 		}
; 3638 : 
; 3639 : 		
; 3640 : 		/******************************************************************/
; 3641 : 		/*  Shut down the CMD thread.                                     */
; 3642 : 		/******************************************************************/
; 3643 : 		
; 3644 : 		if ( phTTS->hThread_CMD != NULL )

  00d42	39 5f 24	 cmp	 DWORD PTR [edi+36], ebx
  00d45	74 55		 je	 SHORT $L73153

; 3645 : 		{
; 3646 : 												exit_pipe( pKsd_t->cmd_pipe );

  00d47	8b 96 98 02 00
	00		 mov	 edx, DWORD PTR [esi+664]
  00d4d	52		 push	 edx
  00d4e	e8 00 00 00 00	 call	 _exit_pipe

; 3647 : 												write_pipe( pKsd_t->cmd_pipe, cDump, 3 );

  00d53	8b 8e 98 02 00
	00		 mov	 ecx, DWORD PTR [esi+664]
  00d59	8d 44 24 14	 lea	 eax, DWORD PTR _cDump$[esp+304]
  00d5d	6a 03		 push	 3
  00d5f	50		 push	 eax
  00d60	51		 push	 ecx
  00d61	e8 00 00 00 00	 call	 _write_pipe

; 3648 : 												/*MVP Free the allocated memory in CMD thread activity */
; 3649 : 												if(pCmd_t)

  00d66	8b 44 24 2c	 mov	 eax, DWORD PTR _pCmd_t$[esp+316]
  00d6a	83 c4 10	 add	 esp, 16			; 00000010H
  00d6d	3b c3		 cmp	 eax, ebx
  00d6f	74 09		 je	 SHORT $L73154

; 3650 : 													FreeCMDThreadMemory(pCmd_t);

  00d71	50		 push	 eax
  00d72	e8 00 00 00 00	 call	 _FreeCMDThreadMemory
  00d77	83 c4 04	 add	 esp, 4
$L73154:

; 3651 : 												phTTS->pCMDThreadData = pCmd_t = NULL;
; 3652 : 												
; 3653 : #ifdef WIN32
; 3654 : 												SetEvent( phTTS->hSyncEvent );

  00d7a	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  00d7d	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  00d80	52		 push	 edx
  00d81	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 3655 : 												
; 3656 : 												WaitForSingleObject( phTTS->hThread_CMD,
; 3657 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00d87	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00d8a	68 e8 03 00 00	 push	 1000			; 000003e8H
  00d8f	50		 push	 eax
  00d90	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3658 : 												
; 3659 : 												CloseHandle( phTTS->hThread_CMD );

  00d96	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00d99	51		 push	 ecx
  00d9a	ff d5		 call	 ebp
$L73153:

; 3660 : #endif
; 3661 : #if defined __osf__ || defined __linux__
; 3662 : 												OP_SetEvent( phTTS->hSyncEvent );
; 3663 : 												
; 3664 : 												OP_WaitForThreadTermination( phTTS->hThread_CMD,
; 3665 : 													&ThreadStatus,
; 3666 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 3667 : #endif
; 3668 : 		}
; 3669 :   }
; 3670 :   
; 3671 :   /********************************************************************/
; 3672 :   /*  Shutdown the Audio thread                                       */
; 3673 :   /********************************************************************/
; 3674 : #ifdef SAPI5DECTALK
; 3675 :   if ( phTTS->pAudioHandle != NULL )
; 3676 : 	  DestroyAudioObjects( phTTS->pAudioHandle );
; 3677 : 	phTTS->pAudioHandle = NULL ;
; 3678 : #endif
; 3679 :   
; 3680 :   if ( phTTS->pAudioHandle != NULL )

  00d9c	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  00da2	3b c3		 cmp	 eax, ebx
  00da4	74 09		 je	 SHORT $L73157

; 3681 : 	  PA_DestroyPlayHandle( phTTS->pAudioHandle );

  00da6	50		 push	 eax
  00da7	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00dac	83 c4 04	 add	 esp, 4
$L73157:

; 3682 :   
; 3683 :   /********************************************************************/
; 3684 :   /*  Terminate the Text-To-Speech thread.                            */
; 3685 :   /********************************************************************/
; 3686 :   
; 3687 :   // 06may97 tek BATS320
; 3688 :   // get the instance so that we can unregister the class
; 3689 :   // after the window is destroyed
; 3690 :   // tek 13nov97 we have no idea whether hWnd is valid, so use NULL.
; 3691 :   //hInstance = (HINSTANCE)GetWindowLong( phTTS->hWnd,
; 3692 :   //					GWL_HINSTANCE );
; 3693 : #ifdef WIN32
; 3694 :   hInstance = NULL;
; 3695 : #endif
; 3696 :   
; 3697 :   if ( phTTS->hThread_TXT != NULL )

  00daf	39 5f 20	 cmp	 DWORD PTR [edi+32], ebx
  00db2	74 4b		 je	 SHORT $L73160

; 3698 :   {
; 3699 : #if !defined __osf__ && !defined __linux__ && !defined VXWORKS && !defined _SPARC_SOLARIS_ && !defined NOWIN
; 3700 : 	  MMRESULT mmStatus=0;
; 3701 : 	  SendMessage( phTTS->hTextToSpeechWnd,
; 3702 : 		  ID_TTS_Destroy,
; 3703 : 		  0L,
; 3704 : 		  0L );

  00db4	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00db7	53		 push	 ebx
  00db8	53		 push	 ebx
  00db9	68 01 04 00 00	 push	 1025			; 00000401H
  00dbe	52		 push	 edx
  00dbf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 3705 : 	  
; 3706 : 	  WaitForSingleObject( phTTS->hThread_TXT,
; 3707 : 		  TIMEOUT_INTERVAL_IN_MSEC );

  00dc5	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00dc8	68 e8 03 00 00	 push	 1000			; 000003e8H
  00dcd	50		 push	 eax
  00dce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 3708 : 	  
; 3709 : 	  CloseHandle( phTTS->hThread_TXT );

  00dd4	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00dd7	51		 push	 ecx
  00dd8	ff d5		 call	 ebp

; 3710 : #ifndef UNDER_CE
; 3711 : 	  sprintf(wndclass,"%s_%08X",TEXTTOSPEECHWNDCLASS,(unsigned long int) phTTS);

  00dda	57		 push	 edi
  00ddb	68 00 00 00 00	 push	 OFFSET FLAT:$SG73163
  00de0	8d 54 24 34	 lea	 edx, DWORD PTR _wndclass$[esp+308]
  00de4	68 00 00 00 00	 push	 OFFSET FLAT:$SG73164
  00de9	52		 push	 edx
  00dea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00df0	83 c4 10	 add	 esp, 16			; 00000010H

; 3712 : #endif
; 3713 : 	  mmStatus = UnregisterClass(wndclass,hInstance);

  00df3	8d 44 24 2c	 lea	 eax, DWORD PTR _wndclass$[esp+300]
  00df7	53		 push	 ebx
  00df8	50		 push	 eax
  00df9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
$L73160:

; 3714 : #endif
; 3715 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 3716 : 	  phTTS->uiTextThreadExit = TRUE;
; 3717 : 	  OP_SetEvent(phTTS->hTextInQueueEvent);
; 3718 : 	  OP_WaitForThreadTermination(phTTS->hThread_TXT, 
; 3719 : 		  &ThreadStatus, 
; 3720 : 		  OP_INFINITE);
; 3721 : 	  phTTS->hThread_TXT = NULL;
; 3722 : #endif	
; 3723 :   }
; 3724 :   
; 3725 :   /********************************************************************/
; 3726 :   /*  Free the handle to the "Not Emptying Vtm Pipe" event.           */
; 3727 :   /********************************************************************/
; 3728 :   
; 3729 :   if ( phTTS->hNotEmptyingVtmPipeEvent != NULL )

  00dff	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00e02	3b c3		 cmp	 eax, ebx
  00e04	74 03		 je	 SHORT $L73166

; 3730 :   {
; 3731 : #ifdef WIN32
; 3732 : 	  CloseHandle( phTTS->hNotEmptyingVtmPipeEvent );

  00e06	50		 push	 eax
  00e07	ff d5		 call	 ebp
$L73166:

; 3733 : #endif
; 3734 : #if defined __osf__ || defined __linux__
; 3735 : 	  OP_DestroyEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 3736 : #endif
; 3737 :   }
; 3738 :   
; 3739 :   /********************************************************************/
; 3740 :   /*  Free the handle to the "Sync" event.                            */
; 3741 :   /********************************************************************/
; 3742 :   
; 3743 :   if ( phTTS->hSyncEvent != NULL )

  00e09	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00e0c	3b c3		 cmp	 eax, ebx
  00e0e	74 03		 je	 SHORT $L73168

; 3744 :   {
; 3745 : #ifdef WIN32
; 3746 : 	  CloseHandle( phTTS->hSyncEvent );

  00e10	50		 push	 eax
  00e11	ff d5		 call	 ebp
$L73168:

; 3747 : #endif
; 3748 : #if defined __osf__ || defined __linux__
; 3749 : 	  OP_DestroyEvent( phTTS->hSyncEvent );
; 3750 : #endif
; 3751 :   }
; 3752 :   
; 3753 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 3754 :   
; 3755 :   /********************************************************************/
; 3756 :   /*  Free the handle to the "TextInQueue" event.                     */
; 3757 :   /********************************************************************/
; 3758 :   
; 3759 :   if ( phTTS->hTextInQueueEvent != NULL )
; 3760 :   {
; 3761 : 	  OP_DestroyEvent( phTTS->hTextInQueueEvent );
; 3762 : 	  phTTS->hTextInQueueEvent = NULL;
; 3763 :   }
; 3764 : #endif
; 3765 :   
; 3766 :   /********************************************************************/
; 3767 :   /*  Free the handle to the "Successful Memory alloacation" event.   */
; 3768 :   /********************************************************************/
; 3769 :   
; 3770 :   if (phTTS->hMallocSuccessEvent != NULL)

  00e13	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00e16	3b c3		 cmp	 eax, ebx
  00e18	74 06		 je	 SHORT $L73170

; 3771 :   {
; 3772 : #ifdef WIN32
; 3773 : 	  CloseHandle(phTTS->hMallocSuccessEvent);

  00e1a	50		 push	 eax
  00e1b	ff d5		 call	 ebp

; 3774 : #endif
; 3775 : #if defined __osf__ || defined __linux__
; 3776 : 	  OP_DestroyEvent(phTTS->hMallocSuccessEvent);
; 3777 : #endif
; 3778 : 	  phTTS->hMallocSuccessEvent = NULL;

  00e1d	89 5f 1c	 mov	 DWORD PTR [edi+28], ebx
$L73170:

; 3779 : 	  
; 3780 :   }
; 3781 :   
; 3782 :   /********************************************************************/
; 3783 :   /*  Free the handle to the "TTS Callback Mutex .                    */
; 3784 :   /********************************************************************/
; 3785 :   
; 3786 : #ifdef WIN32
; 3787 :   if (phTTS->hmxCallback != NULL)

  00e20	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  00e26	3b c3		 cmp	 eax, ebx
  00e28	74 0f		 je	 SHORT $L73173

; 3788 :   {
; 3789 : 	  OP_DestroyMutex(phTTS->hmxCallback);    // tek 03aug96

  00e2a	50		 push	 eax
  00e2b	e8 00 00 00 00	 call	 _OP_DestroyMutex
  00e30	83 c4 04	 add	 esp, 4

; 3790 : 	  phTTS->hmxCallback = NULL;

  00e33	89 9f b0 00 00
	00		 mov	 DWORD PTR [edi+176], ebx
$L73173:

; 3791 :   }
; 3792 : #endif
; 3793 : #if defined __osf__ || defined __linux__
; 3794 :   if (phTTS->pcsCallback != NULL)
; 3795 :   {
; 3796 : 	  OP_DestroyMutex(phTTS->pcsCallback);
; 3797 : 	  phTTS->pcsCallback = NULL;
; 3798 :   }
; 3799 : #endif
; 3800 :   
; 3801 :   /********************************************************************/
; 3802 :   /*  Delete the log file critical section.                           */
; 3803 :   /********************************************************************/
; 3804 :   
; 3805 :   if ( phTTS->pcsLogFile != NULL )

  00e39	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  00e3f	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__DeleteCriticalSection@4
  00e45	3b c3		 cmp	 eax, ebx
  00e47	74 13		 je	 SHORT $L73176

; 3806 :   {
; 3807 : #ifdef WIN32
; 3808 : 	  DeleteCriticalSection( phTTS->pcsLogFile );

  00e49	50		 push	 eax
  00e4a	ff d5		 call	 ebp

; 3809 : 	  
; 3810 : 	  free( phTTS->pcsLogFile );

  00e4c	8b 8f c8 00 00
	00		 mov	 ecx, DWORD PTR [edi+200]
  00e52	51		 push	 ecx
  00e53	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00e59	83 c4 04	 add	 esp, 4
$L73176:

; 3811 : #endif
; 3812 : #if defined __osf__ || defined __linux__
; 3813 : 	  OP_DestroyMutex( phTTS->pcsLogFile );
; 3814 : #endif 
; 3815 : 	  
; 3816 :   }
; 3817 :   
; 3818 :   /********************************************************************/
; 3819 :   /*  Delete the queued character count critical section.             */
; 3820 :   /********************************************************************/
; 3821 :   
; 3822 :   if ( phTTS->pcsQueuedCharacterCount != NULL )

  00e5c	8b 87 c4 00 00
	00		 mov	 eax, DWORD PTR [edi+196]
  00e62	3b c3		 cmp	 eax, ebx
  00e64	74 13		 je	 SHORT $L73178

; 3823 :   {
; 3824 : #ifdef WIN32
; 3825 : 	  DeleteCriticalSection( phTTS->pcsQueuedCharacterCount );

  00e66	50		 push	 eax
  00e67	ff d5		 call	 ebp

; 3826 : 	  
; 3827 : 	  free( phTTS->pcsQueuedCharacterCount );

  00e69	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  00e6f	52		 push	 edx
  00e70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00e76	83 c4 04	 add	 esp, 4
$L73178:

; 3828 : #endif
; 3829 : #if defined __osf__ || defined __linux__
; 3830 : 	  OP_DestroyMutex( phTTS->pcsQueuedCharacterCount );
; 3831 : #endif
; 3832 :   }
; 3833 :   
; 3834 : //#ifdef WIN32
; 3835 :   /* tek 6mar97 bats 278 */
; 3836 :   /********************************************************************/
; 3837 :   /*  Delete the index queue critical section.                        */
; 3838 :   /********************************************************************/
; 3839 :   
; 3840 :   if ( pKsd_t->pcsSpcPktSave != NULL )

  00e79	8b 86 40 03 00
	00		 mov	 eax, DWORD PTR [esi+832]
  00e7f	3b c3		 cmp	 eax, ebx
  00e81	74 19		 je	 SHORT $L73180

; 3841 :   {
; 3842 : #ifdef WIN32
; 3843 : 	  DeleteCriticalSection( pKsd_t->pcsSpcPktSave );

  00e83	50		 push	 eax
  00e84	ff d5		 call	 ebp

; 3844 : 	  
; 3845 : 	  free( pKsd_t->pcsSpcPktSave );

  00e86	8b 86 40 03 00
	00		 mov	 eax, DWORD PTR [esi+832]
  00e8c	50		 push	 eax
  00e8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00e93	83 c4 04	 add	 esp, 4

; 3846 : #endif
; 3847 : #if defined __osf__ || defined __linux__
; 3848 : 	  OP_DestroyMutex(pKsd_t->pcsSpcPktSave);
; 3849 : #endif
; 3850 : 	  pKsd_t->pcsSpcPktSave = NULL;

  00e96	89 9e 40 03 00
	00		 mov	 DWORD PTR [esi+832], ebx
$L73180:

; 3851 :   }
; 3852 : //#endif
; 3853 :   
; 3854 :   
; 3855 :   /********************************************************************/
; 3856 :   /*  Delete the flush message number critical section.               */
; 3857 :   /********************************************************************/
; 3858 :   
; 3859 :   if ( phTTS->pcsFlushMsgNumber != NULL )

  00e9c	8b 87 c0 00 00
	00		 mov	 eax, DWORD PTR [edi+192]
  00ea2	3b c3		 cmp	 eax, ebx
  00ea4	74 13		 je	 SHORT $L73183

; 3860 :   {
; 3861 : #ifdef WIN32
; 3862 : 	  DeleteCriticalSection( phTTS->pcsFlushMsgNumber );

  00ea6	50		 push	 eax
  00ea7	ff d5		 call	 ebp

; 3863 : 	  
; 3864 : 	  free( phTTS->pcsFlushMsgNumber );

  00ea9	8b 8f c0 00 00
	00		 mov	 ecx, DWORD PTR [edi+192]
  00eaf	51		 push	 ecx
  00eb0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00eb6	83 c4 04	 add	 esp, 4
$L73183:

; 3865 : #endif
; 3866 : #if defined __osf__ || defined __linux__
; 3867 : 	  OP_DestroyMutex( phTTS->pcsFlushMsgNumber );
; 3868 : #endif
; 3869 :   }
; 3870 :   
; 3871 :   
; 3872 :   /********************************************************************/
; 3873 :   /*  Delete the Buffer Pipe mutex.                                   */
; 3874 :   /********************************************************************/
; 3875 :   
; 3876 :   if ( phTTS->pcsBufferPipe != NULL )

  00eb9	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00ebf	3b c3		 cmp	 eax, ebx
  00ec1	74 13		 je	 SHORT $L73185

; 3877 :   {
; 3878 : #ifdef WIN32
; 3879 : 	  DeleteCriticalSection( phTTS->pcsBufferPipe );

  00ec3	50		 push	 eax
  00ec4	ff d5		 call	 ebp

; 3880 : 	  
; 3881 : 	  free( phTTS->pcsBufferPipe );

  00ec6	8b 97 cc 00 00
	00		 mov	 edx, DWORD PTR [edi+204]
  00ecc	52		 push	 edx
  00ecd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00ed3	83 c4 04	 add	 esp, 4
$L73185:

; 3882 : #endif
; 3883 : #if defined __osf__ || defined __linux__
; 3884 : 	  OP_DestroyMutex( phTTS->pcsBufferPipe );
; 3885 : #endif
; 3886 :   }
; 3887 :   
; 3888 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 3889 :   /********************************************************************/
; 3890 :   /*  Delete the Text Msg mutex.                                      */
; 3891 :   /********************************************************************/
; 3892 :   
; 3893 :   if ( phTTS->pcsTextMsgList != NULL )
; 3894 :   {
; 3895 : 	  OP_DestroyMutex( phTTS->pcsTextMsgList );
; 3896 :   }
; 3897 : #endif
; 3898 :   
; 3899 :   /********************************************************************/
; 3900 :   /*  Delete the last queued text message number critical section.    */
; 3901 :   /********************************************************************/
; 3902 :   
; 3903 :   if ( phTTS->pcsLastQueuedTextMsgNumber != NULL )

  00ed6	8b 87 bc 00 00
	00		 mov	 eax, DWORD PTR [edi+188]
  00edc	3b c3		 cmp	 eax, ebx
  00ede	74 13		 je	 SHORT $L73187

; 3904 :   {
; 3905 : #ifdef WIN32
; 3906 : 	  DeleteCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  00ee0	50		 push	 eax
  00ee1	ff d5		 call	 ebp

; 3907 : 	  
; 3908 : 	  free( phTTS->pcsLastQueuedTextMsgNumber );

  00ee3	8b 87 bc 00 00
	00		 mov	 eax, DWORD PTR [edi+188]
  00ee9	50		 push	 eax
  00eea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00ef0	83 c4 04	 add	 esp, 4
$L73187:

; 3909 : #endif
; 3910 : #if defined __osf__ || defined __linux__
; 3911 : 	  OP_DestroyMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3912 : #endif
; 3913 :   }
; 3914 :   
; 3915 :   /********************************************************************/
; 3916 :   /*  Delete the queued sample count critical section.                */
; 3917 :   /********************************************************************/
; 3918 :   
; 3919 :   if ( phTTS->pcsQueuedSampleCount != NULL )

  00ef3	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [edi+184]
  00ef9	3b c3		 cmp	 eax, ebx
  00efb	74 13		 je	 SHORT $L73189

; 3920 :   {
; 3921 : #ifdef WIN32
; 3922 : 	  DeleteCriticalSection( phTTS->pcsQueuedSampleCount );

  00efd	50		 push	 eax
  00efe	ff d5		 call	 ebp

; 3923 : 	  
; 3924 : 	  free( phTTS->pcsQueuedSampleCount );

  00f00	8b 8f b8 00 00
	00		 mov	 ecx, DWORD PTR [edi+184]
  00f06	51		 push	 ecx
  00f07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00f0d	83 c4 04	 add	 esp, 4
$L73189:

; 3925 : #endif
; 3926 : #if defined __osf__ || defined __linux__
; 3927 : 	  OP_DestroyMutex( phTTS->pcsQueuedSampleCount );
; 3928 : #endif
; 3929 :   }
; 3930 :   
; 3931 :   // tek 24oct97 bats 497 delete and deallocate this critical section object
; 3932 :   if ( pKsd_t->pcsVtmPipeRead != NULL )

  00f10	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  00f16	3b c3		 cmp	 eax, ebx
  00f18	74 1d		 je	 SHORT $L74653

; 3933 :   {
; 3934 : #ifdef WIN32
; 3935 : 	  DeleteCriticalSection( pKsd_t->pcsVtmPipeRead );

  00f1a	50		 push	 eax
  00f1b	ff d5		 call	 ebp

; 3936 : 	  
; 3937 : 	  free( pKsd_t->pcsVtmPipeRead );

  00f1d	8b 96 b4 02 00
	00		 mov	 edx, DWORD PTR [esi+692]
  00f23	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__free
  00f29	52		 push	 edx
  00f2a	ff d5		 call	 ebp
  00f2c	83 c4 04	 add	 esp, 4

; 3938 : #endif
; 3939 : #if defined __osf__ || defined __linux__
; 3940 : 	  OP_DestroyMutex( pKsd_t->pcsVtmPipeRead );
; 3941 : #endif
; 3942 : 	  pKsd_t->pcsVtmPipeRead = NULL;

  00f2f	89 9e b4 02 00
	00		 mov	 DWORD PTR [esi+692], ebx
  00f35	eb 06		 jmp	 SHORT $L73191
$L74653:
  00f37	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__free
$L73191:

; 3943 :   }
; 3944 :   // tek 24oct97 end of bats 497
; 3945 :   
; 3946 :   /********************************************************************/
; 3947 :   /*  Free the dictionary memory.                                     */
; 3948 :   /********************************************************************/
; 3949 :   /*MVP : Unload dictionary when no other instance of DECtalk speech  */
; 3950 :   /*      object is running                                           */
; 3951 :   
; 3952 :   if(!gnInstanceCounter)        

  00f3d	39 1d 00 00 00
	00		 cmp	 DWORD PTR _gnInstanceCounter, ebx
  00f43	0f 85 ea 00 00
	00		 jne	 $L73207

; 3953 :   {
; 3954 : 	  /* GL 11/05/1997  for BATS#510 */
; 3955 : 	  if ( pKsd_t->fdic_entries[pKsd_t->lang_curr] != 0 )

  00f49	8b 86 b8 02 00
	00		 mov	 eax, DWORD PTR [esi+696]
  00f4f	8b 54 86 38	 mov	 edx, DWORD PTR [esi+eax*4+56]
  00f53	8d 4c 86 38	 lea	 ecx, DWORD PTR [esi+eax*4+56]
  00f57	3b d3		 cmp	 edx, ebx
  00f59	74 5b		 je	 SHORT $L73194

; 3956 : 	  {
; 3957 : 		  unload_dictionary((void **)&(pKsd_t->fdic_index[pKsd_t->lang_curr]),
; 3958 : 			  (void **)&pKsd_t->fdic_data[pKsd_t->lang_curr],
; 3959 : 			  (unsigned int *)&(pKsd_t->fdic_entries[pKsd_t->lang_curr]),
; 3960 : 			  (unsigned int *)&(pKsd_t->fdic_bytes[pKsd_t->lang_curr])
; 3961 : 			  ,(LPVOID*)&(pKsd_t->fdicMapStartAddr[pKsd_t->lang_curr]),
; 3962 : 			  (HANDLE*)&(pKsd_t->fdicMapObject[pKsd_t->lang_curr]),
; 3963 : 			  (HANDLE*)&(pKsd_t->fdicFileHandle[pKsd_t->lang_curr]),		  
; 3964 : 		      MEMMAP_ON 
; 3965 : 			  );

  00f5b	8d 94 86 dc 01
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+476]
  00f62	6a 01		 push	 1
  00f64	52		 push	 edx
  00f65	8d 94 86 c0 01
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+448]
  00f6c	52		 push	 edx
  00f6d	8d 94 86 f8 01
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+504]
  00f74	52		 push	 edx
  00f75	8d 54 86 54	 lea	 edx, DWORD PTR [esi+eax*4+84]
  00f79	52		 push	 edx
  00f7a	51		 push	 ecx
  00f7b	8d 4c 86 1c	 lea	 ecx, DWORD PTR [esi+eax*4+28]
  00f7f	8d 14 86	 lea	 edx, DWORD PTR [esi+eax*4]
  00f82	51		 push	 ecx
  00f83	52		 push	 edx
  00f84	e8 00 00 00 00	 call	 _unload_dictionary
  00f89	83 c4 20	 add	 esp, 32			; 00000020H

; 3966 : 
; 3967 : 
; 3968 : 
; 3969 : 		  gpufdic_index = NULL;

  00f8c	89 1d 00 00 00
	00		 mov	 DWORD PTR _gpufdic_index, ebx

; 3970 : 		  gpufdic_data = NULL;

  00f92	89 1d 00 00 00
	00		 mov	 DWORD PTR _gpufdic_data, ebx

; 3971 : 		  gufdic_entries = 0;

  00f98	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufdic_entries, ebx

; 3972 : 		  gufdic_bytes = 0;

  00f9e	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufdic_bytes, ebx

; 3973 : 		  gufdicMapObject=NULL;

  00fa4	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufdicMapObject, ebx

; 3974 : 		  gufdicFileHandle=NULL;

  00faa	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufdicFileHandle, ebx

; 3975 : 		  gufdicMapStartAddr=NULL;

  00fb0	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufdicMapStartAddr, ebx
$L73194:

; 3976 : 
; 3977 : 	  }
; 3978 : 	  if ( pKsd_t->foreigndic_entries[pKsd_t->lang_curr] != 0 )

  00fb6	8b 86 b8 02 00
	00		 mov	 eax, DWORD PTR [esi+696]
  00fbc	8b 94 86 88 01
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+392]
  00fc3	8d 8c 86 88 01
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+392]
  00fca	3b d3		 cmp	 edx, ebx
  00fcc	74 65		 je	 SHORT $L73207

; 3979 : 	  {
; 3980 : 		  unload_dictionary((void **)&(pKsd_t->foreigndic_index[pKsd_t->lang_curr]),
; 3981 : 			  (void **)&pKsd_t->foreigndic_data[pKsd_t->lang_curr],
; 3982 : 			  (unsigned int *)&(pKsd_t->foreigndic_entries[pKsd_t->lang_curr]),
; 3983 : 			  (unsigned int *)&(pKsd_t->foreigndic_bytes[pKsd_t->lang_curr])
; 3984 : 			  ,(LPVOID*)&(pKsd_t->foreigndicMapStartAddr[pKsd_t->lang_curr]),
; 3985 : 			  (HANDLE*)&(pKsd_t->foreigndicMapObject[pKsd_t->lang_curr]),
; 3986 : 			  (HANDLE*)&(pKsd_t->foreigndicFileHandle[pKsd_t->lang_curr]),		  
; 3987 : 		      MEMMAP_ON 
; 3988 : 			  );

  00fce	8d 94 86 30 02
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+560]
  00fd5	6a 01		 push	 1
  00fd7	52		 push	 edx
  00fd8	8d 94 86 14 02
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+532]
  00fdf	52		 push	 edx
  00fe0	8d 94 86 4c 02
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+588]
  00fe7	52		 push	 edx
  00fe8	8d 94 86 a4 01
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+420]
  00fef	52		 push	 edx
  00ff0	51		 push	 ecx
  00ff1	8d 8c 86 6c 01
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+364]
  00ff8	8d 94 86 50 01
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+336]
  00fff	51		 push	 ecx
  01000	52		 push	 edx
  01001	e8 00 00 00 00	 call	 _unload_dictionary
  01006	83 c4 20	 add	 esp, 32			; 00000020H

; 3989 : 
; 3990 : 
; 3991 : 
; 3992 : 		  gpufordic_index = NULL;

  01009	89 1d 00 00 00
	00		 mov	 DWORD PTR _gpufordic_index, ebx

; 3993 : 		  gpufordic_data = NULL;

  0100f	89 1d 00 00 00
	00		 mov	 DWORD PTR _gpufordic_data, ebx

; 3994 : 		  gufordic_entries = 0;

  01015	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufordic_entries, ebx

; 3995 : 		  gufordic_bytes = 0;

  0101b	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufordic_bytes, ebx

; 3996 : 		  gufordicMapObject=NULL;

  01021	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufordicMapObject, ebx

; 3997 : 		  gufordicFileHandle=NULL;

  01027	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufordicFileHandle, ebx

; 3998 : 		  gufordicMapStartAddr=NULL;

  0102d	89 1d 00 00 00
	00		 mov	 DWORD PTR _gufordicMapStartAddr, ebx
$L73207:

; 3999 : 
; 4000 : 	  }
; 4001 :   }
; 4002 :   
; 4003 :   /********************************************************************/
; 4004 :   /*  Free the user dictionary memory.                                */
; 4005 :   /********************************************************************/
; 4006 :   
; 4007 :   /* GL 11/05/1997  for BATS#510 */
; 4008 :   if ( pKsd_t->udic_entries[pKsd_t->lang_curr] != 0 )

  01033	8b 86 b8 02 00
	00		 mov	 eax, DWORD PTR [esi+696]
  01039	8b 94 86 a8 00
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+168]
  01040	8d 8c 86 a8 00
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+168]
  01047	3b d3		 cmp	 edx, ebx
  01049	74 37		 je	 SHORT $L73220

; 4009 :   {
; 4010 : 	  unload_dictionary((void **)&pKsd_t->udic_index[pKsd_t->lang_curr],
; 4011 : 		  (void **)&pKsd_t->udic_data[pKsd_t->lang_curr],
; 4012 : 		  (unsigned int *)&pKsd_t->udic_entries[pKsd_t->lang_curr],
; 4013 : 		  (unsigned int *)&pKsd_t->udic_bytes[pKsd_t->lang_curr]
; 4014 : 		  ,(LPVOID*)&(pKsd_t->fdicMapStartAddr[pKsd_t->lang_curr]),		  
; 4015 : 			(HANDLE*)&(pKsd_t->fdicMapObject[pKsd_t->lang_curr]),
; 4016 : 		    (HANDLE*)&(pKsd_t->fdicFileHandle[pKsd_t->lang_curr]),		  
; 4017 : 		  MEMMAP_OFF 
; 4018 : 		  );

  0104b	8d 94 86 dc 01
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+476]
  01052	53		 push	 ebx
  01053	52		 push	 edx
  01054	8d 94 86 c0 01
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+448]
  0105b	52		 push	 edx
  0105c	8d 94 86 f8 01
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+504]
  01063	52		 push	 edx
  01064	8d 94 86 c4 00
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+196]
  0106b	52		 push	 edx
  0106c	51		 push	 ecx
  0106d	8d 8c 86 8c 00
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+140]
  01074	8d 54 86 70	 lea	 edx, DWORD PTR [esi+eax*4+112]
  01078	51		 push	 ecx
  01079	52		 push	 edx
  0107a	e8 00 00 00 00	 call	 _unload_dictionary
  0107f	83 c4 20	 add	 esp, 32			; 00000020H
$L73220:

; 4019 : 
; 4020 :   }
; 4021 :   
; 4022 :   /********************************************************************/
; 4023 :   /*  Destroy all the pipes.                                          */
; 4024 :   /********************************************************************/
; 4025 :   /* tek 30aug96 be kind; NULL the pointers when done.. */
; 4026 :   if ( pKsd_t->sync_pipe != NULL )

  01082	8b 86 a0 02 00
	00		 mov	 eax, DWORD PTR [esi+672]
  01088	3b c3		 cmp	 eax, ebx
  0108a	74 0f		 je	 SHORT $L73229

; 4027 :   {
; 4028 : 	  destroy_pipe( pKsd_t->sync_pipe );

  0108c	50		 push	 eax
  0108d	e8 00 00 00 00	 call	 _destroy_pipe
  01092	83 c4 04	 add	 esp, 4

; 4029 : 	  pKsd_t->sync_pipe = NULL;

  01095	89 9e a0 02 00
	00		 mov	 DWORD PTR [esi+672], ebx
$L73229:

; 4030 :   }
; 4031 :   
; 4032 :   if ( pKsd_t->vtm_pipe != NULL )

  0109b	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  010a1	3b c3		 cmp	 eax, ebx
  010a3	74 0f		 je	 SHORT $L73232

; 4033 :   {
; 4034 : 	  destroy_pipe( pKsd_t->vtm_pipe );

  010a5	50		 push	 eax
  010a6	e8 00 00 00 00	 call	 _destroy_pipe
  010ab	83 c4 04	 add	 esp, 4

; 4035 : 	  pKsd_t->vtm_pipe = NULL;

  010ae	89 9e 9c 02 00
	00		 mov	 DWORD PTR [esi+668], ebx
$L73232:

; 4036 :   }
; 4037 :   
; 4038 :   if ( pKsd_t->ph_pipe != NULL )

  010b4	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  010ba	3b c3		 cmp	 eax, ebx
  010bc	74 0f		 je	 SHORT $L73235

; 4039 :   {
; 4040 : 	  destroy_pipe( pKsd_t->ph_pipe );

  010be	50		 push	 eax
  010bf	e8 00 00 00 00	 call	 _destroy_pipe
  010c4	83 c4 04	 add	 esp, 4

; 4041 : 	  pKsd_t->ph_pipe = NULL;

  010c7	89 9e 94 02 00
	00		 mov	 DWORD PTR [esi+660], ebx
$L73235:

; 4042 :   }
; 4043 :   
; 4044 :   if ( pKsd_t->lts_pipe != NULL )

  010cd	8b 86 90 02 00
	00		 mov	 eax, DWORD PTR [esi+656]
  010d3	3b c3		 cmp	 eax, ebx
  010d5	74 0f		 je	 SHORT $L73238

; 4045 :   {
; 4046 : 	  destroy_pipe( pKsd_t->lts_pipe );

  010d7	50		 push	 eax
  010d8	e8 00 00 00 00	 call	 _destroy_pipe
  010dd	83 c4 04	 add	 esp, 4

; 4047 : 	  pKsd_t->lts_pipe = NULL;

  010e0	89 9e 90 02 00
	00		 mov	 DWORD PTR [esi+656], ebx
$L73238:

; 4048 :   }
; 4049 :   
; 4050 :   if ( pKsd_t->cmd_pipe != NULL )

  010e6	8b 86 98 02 00
	00		 mov	 eax, DWORD PTR [esi+664]
  010ec	3b c3		 cmp	 eax, ebx
  010ee	74 0f		 je	 SHORT $L73241

; 4051 :   {
; 4052 : 	  destroy_pipe( pKsd_t->cmd_pipe );

  010f0	50		 push	 eax
  010f1	e8 00 00 00 00	 call	 _destroy_pipe
  010f6	83 c4 04	 add	 esp, 4

; 4053 : 	  pKsd_t->cmd_pipe = NULL;

  010f9	89 9e 98 02 00
	00		 mov	 DWORD PTR [esi+664], ebx
$L73241:

; 4054 :   }
; 4055 :   
; 4056 :   /********************************************************************/
; 4057 :   /* Free the "loaded_languages" element of Kernel_share_data structure*/
; 4058 :   /* This element have been allocated in Kernel sub-system in usa_init*/
; 4059 :   /* function. MVP MI                                                 */
; 4060 :   /********************************************************************/
; 4061 :   if(pKsd_t->loaded_languages != NULL)  

  010ff	8b 86 1c 06 00
	00		 mov	 eax, DWORD PTR [esi+1564]
  01105	3b c3		 cmp	 eax, ebx
  01107	74 0c		 je	 SHORT $L73244

; 4062 :   {
; 4063 : 	  free(pKsd_t->loaded_languages);

  01109	50		 push	 eax
  0110a	ff d5		 call	 ebp
  0110c	83 c4 04	 add	 esp, 4

; 4064 : 	  pKsd_t->loaded_languages = NULL;

  0110f	89 9e 1c 06 00
	00		 mov	 DWORD PTR [esi+1564], ebx
$L73244:

; 4065 :   }
; 4066 :   
; 4067 :   /********************************************************************/
; 4068 :   /* Free the kernel_share_data element in TTS structure for MI :MVP  */
; 4069 :   /********************************************************************/
; 4070 :   if(phTTS->pKernelShareData != NULL)

  01115	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  01118	3b c3		 cmp	 eax, ebx
  0111a	74 09		 je	 SHORT $L73247

; 4071 :   {
; 4072 : 	  free(phTTS->pKernelShareData);

  0111c	50		 push	 eax
  0111d	ff d5		 call	 ebp
  0111f	83 c4 04	 add	 esp, 4

; 4073 : 	  phTTS->pKernelShareData = NULL;

  01122	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
$L73247:

; 4074 :   }
; 4075 :   
; 4076 :   /********************************************************************/
; 4077 :   /*  Free the TTS handle structure.                                  */
; 4078 :   /********************************************************************/
; 4079 :   
; 4080 :   free( phTTS );

  01125	57		 push	 edi
  01126	ff d5		 call	 ebp
  01128	83 c4 04	 add	 esp, 4
  0112b	5f		 pop	 edi
  0112c	5e		 pop	 esi
  0112d	5d		 pop	 ebp
  0112e	5b		 pop	 ebx

; 4081 :   phTTS=NULL;
; 4082 :   
; 4083 :   return;
; 4084 : }

  0112f	81 c4 1c 01 00
	00		 add	 esp, 284		; 0000011cH
  01135	c3		 ret	 0
_DeleteTextToSpeechObjects ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSpeakEx
PUBLIC	_TextToSpeechSpeak
_TEXT	SEGMENT
_phTTS$ = 8
_pszTextString$ = 12
_dwFlags$ = 16
_TextToSpeechSpeak PROC NEAR

; 4147 : {

  01140	56		 push	 esi

; 4148 : 
; 4149 : #ifdef UNDER_CE	//01jan99 mfg convert unicode string to char string for Windows CE
; 4150 : char string[16384];
; 4151 : 
; 4152 : WideStringtoAsciiString(string, pszTextString, 16384);
; 4153 : #endif
; 4154 : 
; 4155 : 	/********************************************************************/
; 4156 : 	/*  Return error if invalid handle.                                 */
; 4157 : 	/********************************************************************/
; 4158 : #ifdef WIN32
; 4159 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01141	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01145	6a 04		 push	 4
  01147	56		 push	 esi
  01148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0114e	85 c0		 test	 eax, eax
  01150	74 07		 je	 SHORT $L73257

; 4160 : 		return( MMSYSERR_INVALHANDLE );

  01152	b8 05 00 00 00	 mov	 eax, 5
  01157	5e		 pop	 esi

; 4176 : 		// will break existing apps.. sigh..
; 4177 : 	}
; 4178 : #endif
; 4179 : #if defined __osf__ || defined __linux__
; 4180 : 	if ( phTTS==NULL)
; 4181 : 		return( MMSYSERR_INVALHANDLE );
; 4182 : 	
; 4183 : 	if (!phTTS->bInReset)
; 4184 : 	{
; 4185 : 		return (TextToSpeechSpeakEx( phTTS,
; 4186 : 				pszTextString,
; 4187 : 				dwFlags,
; 4188 : 				TRUE));
; 4189 : 	}
; 4190 : 	else
; 4191 : 	{
; 4192 : 		return (MMSYSERR_NOERROR); // _HANDLEBUSY would be better, but
; 4193 : 		// will break existing apps.. sigh..
; 4194 : 	}
; 4195 : #endif
; 4196 : #if 0 // not used anymore
; 4197 : 	char proc_name[]="TextToSpeechSpeak";
; 4198 : 	int uiTextLength = 0;
; 4199 : 	unsigned char * pText;
; 4200 : 	LPTEXT_MSG_T pTextMsg;
; 4201 : 	LPTEXT_MSG_T pNextTextMsg;
; 4202 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 4203 : 	const char cForce2 = (char)(SYNC);
; 4204 : 	
; 4205 : #ifdef TTSDBG
; 4206 : 	printf("%s\n",proc_name);
; 4207 : #endif
; 4208 : 	
; 4209 : 	/********************************************************************/
; 4210 : 	/*  Return error if NULL handle.                                    */
; 4211 : 	/********************************************************************/
; 4212 : 	if (phTTS == NULL)
; 4213 : 		return( MMSYSERR_INVALHANDLE );
; 4214 : 	
; 4215 : 	/********************************************************************/
; 4216 : 	/*  Allocate the memory locked Text Message structure.              */
; 4217 : 	/********************************************************************/
; 4218 : 	
; 4219 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 4220 : 	
; 4221 : 	if ( pTextMsg == NULL )
; 4222 : 		return( MMSYSERR_NOMEM );
; 4223 : 	
; 4224 : 	pTextMsg->pLink = NULL;
; 4225 : 	
; 4226 : 	/********************************************************************/
; 4227 : 	/*  Adjust string length for force character.                       */
; 4228 : 	/********************************************************************/
; 4229 : 
; 4230 : 	// MGS fixed getting NULL strings as input
; 4231 : 	if (pszTextString==NULL)
; 4232 : 	{
; 4233 : 		uiTextLength=0;
; 4234 : 	}
; 4235 : 	else
; 4236 : 	{
; 4237 : 		uiTextLength = strlen(pszTextString);
; 4238 : 	}
; 4239 : 
; 4240 : 	if( dwFlags & TTS_FORCE )
; 4241 : 	{
; 4242 : 		uiTextLength++;
; 4243 : 	}
; 4244 : 	
; 4245 : 	/********************************************************************/
; 4246 : 	/*  If the text length is zero then exit with success.              */
; 4247 : 	/********************************************************************/
; 4248 : 	
; 4249 : 	if ( uiTextLength == 0 )
; 4250 : 	{
; 4251 : 		free( pTextMsg );
; 4252 : 		return MMSYSERR_NOERROR;
; 4253 : 	}
; 4254 : 	
; 4255 : 	/********************************************************************/
; 4256 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 4257 : 	/*  location in case the force character is appended to the text    */
; 4258 : 	/*  string.                                                         */
; 4259 : 	/********************************************************************/
; 4260 : 	
; 4261 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 4262 : 	
; 4263 : 	if ( pText == NULL )
; 4264 : 	{ 
; 4265 : 		free( pTextMsg );
; 4266 : 		return( MMSYSERR_NOMEM );
; 4267 : 	} 
; 4268 : 	
; 4269 : 	/********************************************************************/
; 4270 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 4271 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 4272 : 	/*  should not be used after the call to the function.              */
; 4273 : 	/********************************************************************/
; 4274 : 	
; 4275 : 	strcpy( pText, pszTextString );
; 4276 : 	
; 4277 : 	/********************************************************************/
; 4278 : 	/*  Conditionally append the force character to the text.           */
; 4279 : 	/********************************************************************/
; 4280 : 	
; 4281 : 	if( dwFlags & TTS_FORCE )
; 4282 : 	{
; 4283 : 		pText[uiTextLength-1] = cForce;
; 4284 : 	}
; 4285 : 	
; 4286 : 	pTextMsg->pText = pText;
; 4287 : 	pTextMsg->uiLength = uiTextLength;
; 4288 : 	
; 4289 :     // tek 01sep98
; 4290 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 4291 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 4292 : 	phTTS->uiCurrentMsgNumber++;
; 4293 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 4294 : 	
; 4295 : 	/********************************************************************/
; 4296 : 	/*  Increment the queued character count.                           */
; 4297 : 	/********************************************************************/
; 4298 : 	
; 4299 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 4300 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 4301 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 4302 : 	
; 4303 : 	/*
; 4304 : 	* keep track of what we've queued so that we can 
; 4305 : 	* sync correctly
; 4306 : 	* (tek 11aug98)
; 4307 : 	*/
; 4308 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 4309 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 4310 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 4311 : 
; 4312 : 	/********************************************************************/
; 4313 : 	/*  Add the text message to the text-message linked list.           */
; 4314 : 	/********************************************************************/
; 4315 : 	
; 4316 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 4317 : 	
; 4318 : 	/********************************************************************/
; 4319 : 	/*  Put the Text Message at the end of the linked list.             */
; 4320 : 	/********************************************************************/
; 4321 : 	
; 4322 : 	if ( phTTS->pTextMsgList == NULL )
; 4323 : 	{
; 4324 : 		phTTS->pTextMsgList = pTextMsg;
; 4325 : 	}
; 4326 : 	else
; 4327 : 	{
; 4328 : 		pNextTextMsg = phTTS->pTextMsgList;
; 4329 : 		
; 4330 : 		while ( pNextTextMsg->pLink != NULL )
; 4331 : 		{
; 4332 : 			pNextTextMsg = pNextTextMsg->pLink;
; 4333 : 		}
; 4334 : 		
; 4335 : 		pNextTextMsg->pLink = pTextMsg;
; 4336 : 	}
; 4337 : 	
; 4338 : 	/********************************************************************/
; 4339 : 	/*  Set the Text In Queue event.                                    */
; 4340 : 	/********************************************************************/
; 4341 : 	
; 4342 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 4343 : 	
; 4344 : 	/********************************************************************/
; 4345 : 	/*  Unlock the text-message linked list.                            */
; 4346 : 	/********************************************************************/
; 4347 : 	
; 4348 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 4349 : 	
; 4350 : 	return( MMSYSERR_NOERROR );
; 4351 : #endif
; 4352 : 	
; 4353 : }

  01158	c3		 ret	 0
$L73257:

; 4161 : 	
; 4162 : 	if (!phTTS->bInReset)

  01159	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  0115f	85 c0		 test	 eax, eax
  01161	75 17		 jne	 SHORT $L73258

; 4163 : 	{
; 4164 : 		return (TextToSpeechSpeakEx( phTTS,
; 4165 : #ifdef UNDER_CE
; 4166 : 				string,
; 4167 : #else
; 4168 : 				pszTextString,
; 4169 : #endif
; 4170 : 				dwFlags,
; 4171 : 				TRUE));

  01163	8b 44 24 10	 mov	 eax, DWORD PTR _dwFlags$[esp]
  01167	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pszTextString$[esp]
  0116b	6a 01		 push	 1
  0116d	50		 push	 eax
  0116e	51		 push	 ecx
  0116f	56		 push	 esi
  01170	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx
  01175	83 c4 10	 add	 esp, 16			; 00000010H
  01178	5e		 pop	 esi

; 4176 : 		// will break existing apps.. sigh..
; 4177 : 	}
; 4178 : #endif
; 4179 : #if defined __osf__ || defined __linux__
; 4180 : 	if ( phTTS==NULL)
; 4181 : 		return( MMSYSERR_INVALHANDLE );
; 4182 : 	
; 4183 : 	if (!phTTS->bInReset)
; 4184 : 	{
; 4185 : 		return (TextToSpeechSpeakEx( phTTS,
; 4186 : 				pszTextString,
; 4187 : 				dwFlags,
; 4188 : 				TRUE));
; 4189 : 	}
; 4190 : 	else
; 4191 : 	{
; 4192 : 		return (MMSYSERR_NOERROR); // _HANDLEBUSY would be better, but
; 4193 : 		// will break existing apps.. sigh..
; 4194 : 	}
; 4195 : #endif
; 4196 : #if 0 // not used anymore
; 4197 : 	char proc_name[]="TextToSpeechSpeak";
; 4198 : 	int uiTextLength = 0;
; 4199 : 	unsigned char * pText;
; 4200 : 	LPTEXT_MSG_T pTextMsg;
; 4201 : 	LPTEXT_MSG_T pNextTextMsg;
; 4202 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 4203 : 	const char cForce2 = (char)(SYNC);
; 4204 : 	
; 4205 : #ifdef TTSDBG
; 4206 : 	printf("%s\n",proc_name);
; 4207 : #endif
; 4208 : 	
; 4209 : 	/********************************************************************/
; 4210 : 	/*  Return error if NULL handle.                                    */
; 4211 : 	/********************************************************************/
; 4212 : 	if (phTTS == NULL)
; 4213 : 		return( MMSYSERR_INVALHANDLE );
; 4214 : 	
; 4215 : 	/********************************************************************/
; 4216 : 	/*  Allocate the memory locked Text Message structure.              */
; 4217 : 	/********************************************************************/
; 4218 : 	
; 4219 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 4220 : 	
; 4221 : 	if ( pTextMsg == NULL )
; 4222 : 		return( MMSYSERR_NOMEM );
; 4223 : 	
; 4224 : 	pTextMsg->pLink = NULL;
; 4225 : 	
; 4226 : 	/********************************************************************/
; 4227 : 	/*  Adjust string length for force character.                       */
; 4228 : 	/********************************************************************/
; 4229 : 
; 4230 : 	// MGS fixed getting NULL strings as input
; 4231 : 	if (pszTextString==NULL)
; 4232 : 	{
; 4233 : 		uiTextLength=0;
; 4234 : 	}
; 4235 : 	else
; 4236 : 	{
; 4237 : 		uiTextLength = strlen(pszTextString);
; 4238 : 	}
; 4239 : 
; 4240 : 	if( dwFlags & TTS_FORCE )
; 4241 : 	{
; 4242 : 		uiTextLength++;
; 4243 : 	}
; 4244 : 	
; 4245 : 	/********************************************************************/
; 4246 : 	/*  If the text length is zero then exit with success.              */
; 4247 : 	/********************************************************************/
; 4248 : 	
; 4249 : 	if ( uiTextLength == 0 )
; 4250 : 	{
; 4251 : 		free( pTextMsg );
; 4252 : 		return MMSYSERR_NOERROR;
; 4253 : 	}
; 4254 : 	
; 4255 : 	/********************************************************************/
; 4256 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 4257 : 	/*  location in case the force character is appended to the text    */
; 4258 : 	/*  string.                                                         */
; 4259 : 	/********************************************************************/
; 4260 : 	
; 4261 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 4262 : 	
; 4263 : 	if ( pText == NULL )
; 4264 : 	{ 
; 4265 : 		free( pTextMsg );
; 4266 : 		return( MMSYSERR_NOMEM );
; 4267 : 	} 
; 4268 : 	
; 4269 : 	/********************************************************************/
; 4270 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 4271 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 4272 : 	/*  should not be used after the call to the function.              */
; 4273 : 	/********************************************************************/
; 4274 : 	
; 4275 : 	strcpy( pText, pszTextString );
; 4276 : 	
; 4277 : 	/********************************************************************/
; 4278 : 	/*  Conditionally append the force character to the text.           */
; 4279 : 	/********************************************************************/
; 4280 : 	
; 4281 : 	if( dwFlags & TTS_FORCE )
; 4282 : 	{
; 4283 : 		pText[uiTextLength-1] = cForce;
; 4284 : 	}
; 4285 : 	
; 4286 : 	pTextMsg->pText = pText;
; 4287 : 	pTextMsg->uiLength = uiTextLength;
; 4288 : 	
; 4289 :     // tek 01sep98
; 4290 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 4291 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 4292 : 	phTTS->uiCurrentMsgNumber++;
; 4293 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 4294 : 	
; 4295 : 	/********************************************************************/
; 4296 : 	/*  Increment the queued character count.                           */
; 4297 : 	/********************************************************************/
; 4298 : 	
; 4299 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 4300 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 4301 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 4302 : 	
; 4303 : 	/*
; 4304 : 	* keep track of what we've queued so that we can 
; 4305 : 	* sync correctly
; 4306 : 	* (tek 11aug98)
; 4307 : 	*/
; 4308 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 4309 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 4310 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 4311 : 
; 4312 : 	/********************************************************************/
; 4313 : 	/*  Add the text message to the text-message linked list.           */
; 4314 : 	/********************************************************************/
; 4315 : 	
; 4316 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 4317 : 	
; 4318 : 	/********************************************************************/
; 4319 : 	/*  Put the Text Message at the end of the linked list.             */
; 4320 : 	/********************************************************************/
; 4321 : 	
; 4322 : 	if ( phTTS->pTextMsgList == NULL )
; 4323 : 	{
; 4324 : 		phTTS->pTextMsgList = pTextMsg;
; 4325 : 	}
; 4326 : 	else
; 4327 : 	{
; 4328 : 		pNextTextMsg = phTTS->pTextMsgList;
; 4329 : 		
; 4330 : 		while ( pNextTextMsg->pLink != NULL )
; 4331 : 		{
; 4332 : 			pNextTextMsg = pNextTextMsg->pLink;
; 4333 : 		}
; 4334 : 		
; 4335 : 		pNextTextMsg->pLink = pTextMsg;
; 4336 : 	}
; 4337 : 	
; 4338 : 	/********************************************************************/
; 4339 : 	/*  Set the Text In Queue event.                                    */
; 4340 : 	/********************************************************************/
; 4341 : 	
; 4342 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 4343 : 	
; 4344 : 	/********************************************************************/
; 4345 : 	/*  Unlock the text-message linked list.                            */
; 4346 : 	/********************************************************************/
; 4347 : 	
; 4348 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 4349 : 	
; 4350 : 	return( MMSYSERR_NOERROR );
; 4351 : #endif
; 4352 : 	
; 4353 : }

  01179	c3		 ret	 0
$L73258:

; 4172 : 	}
; 4173 : 	else
; 4174 : 	{
; 4175 : 		return (MMSYSERR_NOERROR); // _HANDLEBUSY would be better, but

  0117a	33 c0		 xor	 eax, eax
  0117c	5e		 pop	 esi

; 4176 : 		// will break existing apps.. sigh..
; 4177 : 	}
; 4178 : #endif
; 4179 : #if defined __osf__ || defined __linux__
; 4180 : 	if ( phTTS==NULL)
; 4181 : 		return( MMSYSERR_INVALHANDLE );
; 4182 : 	
; 4183 : 	if (!phTTS->bInReset)
; 4184 : 	{
; 4185 : 		return (TextToSpeechSpeakEx( phTTS,
; 4186 : 				pszTextString,
; 4187 : 				dwFlags,
; 4188 : 				TRUE));
; 4189 : 	}
; 4190 : 	else
; 4191 : 	{
; 4192 : 		return (MMSYSERR_NOERROR); // _HANDLEBUSY would be better, but
; 4193 : 		// will break existing apps.. sigh..
; 4194 : 	}
; 4195 : #endif
; 4196 : #if 0 // not used anymore
; 4197 : 	char proc_name[]="TextToSpeechSpeak";
; 4198 : 	int uiTextLength = 0;
; 4199 : 	unsigned char * pText;
; 4200 : 	LPTEXT_MSG_T pTextMsg;
; 4201 : 	LPTEXT_MSG_T pNextTextMsg;
; 4202 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 4203 : 	const char cForce2 = (char)(SYNC);
; 4204 : 	
; 4205 : #ifdef TTSDBG
; 4206 : 	printf("%s\n",proc_name);
; 4207 : #endif
; 4208 : 	
; 4209 : 	/********************************************************************/
; 4210 : 	/*  Return error if NULL handle.                                    */
; 4211 : 	/********************************************************************/
; 4212 : 	if (phTTS == NULL)
; 4213 : 		return( MMSYSERR_INVALHANDLE );
; 4214 : 	
; 4215 : 	/********************************************************************/
; 4216 : 	/*  Allocate the memory locked Text Message structure.              */
; 4217 : 	/********************************************************************/
; 4218 : 	
; 4219 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 4220 : 	
; 4221 : 	if ( pTextMsg == NULL )
; 4222 : 		return( MMSYSERR_NOMEM );
; 4223 : 	
; 4224 : 	pTextMsg->pLink = NULL;
; 4225 : 	
; 4226 : 	/********************************************************************/
; 4227 : 	/*  Adjust string length for force character.                       */
; 4228 : 	/********************************************************************/
; 4229 : 
; 4230 : 	// MGS fixed getting NULL strings as input
; 4231 : 	if (pszTextString==NULL)
; 4232 : 	{
; 4233 : 		uiTextLength=0;
; 4234 : 	}
; 4235 : 	else
; 4236 : 	{
; 4237 : 		uiTextLength = strlen(pszTextString);
; 4238 : 	}
; 4239 : 
; 4240 : 	if( dwFlags & TTS_FORCE )
; 4241 : 	{
; 4242 : 		uiTextLength++;
; 4243 : 	}
; 4244 : 	
; 4245 : 	/********************************************************************/
; 4246 : 	/*  If the text length is zero then exit with success.              */
; 4247 : 	/********************************************************************/
; 4248 : 	
; 4249 : 	if ( uiTextLength == 0 )
; 4250 : 	{
; 4251 : 		free( pTextMsg );
; 4252 : 		return MMSYSERR_NOERROR;
; 4253 : 	}
; 4254 : 	
; 4255 : 	/********************************************************************/
; 4256 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 4257 : 	/*  location in case the force character is appended to the text    */
; 4258 : 	/*  string.                                                         */
; 4259 : 	/********************************************************************/
; 4260 : 	
; 4261 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 4262 : 	
; 4263 : 	if ( pText == NULL )
; 4264 : 	{ 
; 4265 : 		free( pTextMsg );
; 4266 : 		return( MMSYSERR_NOMEM );
; 4267 : 	} 
; 4268 : 	
; 4269 : 	/********************************************************************/
; 4270 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 4271 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 4272 : 	/*  should not be used after the call to the function.              */
; 4273 : 	/********************************************************************/
; 4274 : 	
; 4275 : 	strcpy( pText, pszTextString );
; 4276 : 	
; 4277 : 	/********************************************************************/
; 4278 : 	/*  Conditionally append the force character to the text.           */
; 4279 : 	/********************************************************************/
; 4280 : 	
; 4281 : 	if( dwFlags & TTS_FORCE )
; 4282 : 	{
; 4283 : 		pText[uiTextLength-1] = cForce;
; 4284 : 	}
; 4285 : 	
; 4286 : 	pTextMsg->pText = pText;
; 4287 : 	pTextMsg->uiLength = uiTextLength;
; 4288 : 	
; 4289 :     // tek 01sep98
; 4290 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 4291 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 4292 : 	phTTS->uiCurrentMsgNumber++;
; 4293 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 4294 : 	
; 4295 : 	/********************************************************************/
; 4296 : 	/*  Increment the queued character count.                           */
; 4297 : 	/********************************************************************/
; 4298 : 	
; 4299 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 4300 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 4301 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 4302 : 	
; 4303 : 	/*
; 4304 : 	* keep track of what we've queued so that we can 
; 4305 : 	* sync correctly
; 4306 : 	* (tek 11aug98)
; 4307 : 	*/
; 4308 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 4309 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 4310 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 4311 : 
; 4312 : 	/********************************************************************/
; 4313 : 	/*  Add the text message to the text-message linked list.           */
; 4314 : 	/********************************************************************/
; 4315 : 	
; 4316 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 4317 : 	
; 4318 : 	/********************************************************************/
; 4319 : 	/*  Put the Text Message at the end of the linked list.             */
; 4320 : 	/********************************************************************/
; 4321 : 	
; 4322 : 	if ( phTTS->pTextMsgList == NULL )
; 4323 : 	{
; 4324 : 		phTTS->pTextMsgList = pTextMsg;
; 4325 : 	}
; 4326 : 	else
; 4327 : 	{
; 4328 : 		pNextTextMsg = phTTS->pTextMsgList;
; 4329 : 		
; 4330 : 		while ( pNextTextMsg->pLink != NULL )
; 4331 : 		{
; 4332 : 			pNextTextMsg = pNextTextMsg->pLink;
; 4333 : 		}
; 4334 : 		
; 4335 : 		pNextTextMsg->pLink = pTextMsg;
; 4336 : 	}
; 4337 : 	
; 4338 : 	/********************************************************************/
; 4339 : 	/*  Set the Text In Queue event.                                    */
; 4340 : 	/********************************************************************/
; 4341 : 	
; 4342 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 4343 : 	
; 4344 : 	/********************************************************************/
; 4345 : 	/*  Unlock the text-message linked list.                            */
; 4346 : 	/********************************************************************/
; 4347 : 	
; 4348 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 4349 : 	
; 4350 : 	return( MMSYSERR_NOERROR );
; 4351 : #endif
; 4352 : 	
; 4353 : }

  0117d	c3		 ret	 0
_TextToSpeechSpeak ENDP
_TEXT	ENDS
EXTRN	_OP_LockMutex:NEAR
EXTRN	_OP_UnlockMutex:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pszTextString$ = 12
_dwFlags$ = 16
_bIsUser$ = 20
_TextToSpeechSpeakEx PROC NEAR

; 4360 : {

  01180	53		 push	 ebx
  01181	55		 push	 ebp
  01182	56		 push	 esi

; 4361 : 	UINT i;
; 4362 : 	UINT uiLength;
; 4363 : 	unsigned char * pTextBuffer;
; 4364 : 	TEXT_MSG_T * pTextMsg;
; 4365 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 4366 : 	LPTEXT_MSG_T pNextTextMsg;
; 4367 : #endif
; 4368 : 	const char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 4369 : 	const char cForce2 = (char)(SYNC);
; 4370 : 	
; 4371 : 	
; 4372 : 	
; 4373 : 	
; 4374 : 	/********************************************************************/
; 4375 : 	/*  Return error if invalid handle.                                 */
; 4376 : 	/********************************************************************/
; 4377 : #ifdef WIN32
; 4378 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01183	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  01187	57		 push	 edi
  01188	6a 04		 push	 4
  0118a	56		 push	 esi
  0118b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01191	85 c0		 test	 eax, eax
  01193	74 0a		 je	 SHORT $L73277
  01195	5f		 pop	 edi
  01196	5e		 pop	 esi
  01197	5d		 pop	 ebp

; 4379 : 		return( MMSYSERR_INVALHANDLE );

  01198	b8 05 00 00 00	 mov	 eax, 5
  0119d	5b		 pop	 ebx

; 4595 : }

  0119e	c3		 ret	 0
$L73277:

; 4380 : #endif
; 4381 : #if defined __osf__ || defined __linux__
; 4382 : 	if (phTTS == NULL)
; 4383 : 		return( MMSYSERR_INVALHANDLE );
; 4384 : #endif
; 4385 : 	// if this is the null state, and it is a user call, don't accept the text (for now)...
; 4386 : 	if (phTTS->dwOutputState == STATE_OUTPUT_NULL && bIsUser)

  0119f	83 be 88 00 00
	00 04		 cmp	 DWORD PTR [esi+136], 4
  011a6	75 12		 jne	 SHORT $L73278
  011a8	8b 44 24 20	 mov	 eax, DWORD PTR _bIsUser$[esp+12]
  011ac	85 c0		 test	 eax, eax
  011ae	74 0a		 je	 SHORT $L73278
  011b0	5f		 pop	 edi
  011b1	5e		 pop	 esi
  011b2	5d		 pop	 ebp

; 4387 : 		return(MMSYSERR_ERROR);

  011b3	b8 01 00 00 00	 mov	 eax, 1
  011b8	5b		 pop	 ebx

; 4595 : }

  011b9	c3		 ret	 0
$L73278:

; 4388 : 
; 4389 : 	
; 4390 : #ifdef TYPING_MODE
; 4391 : 	// tek 06nov97 (during BATS508)
; 4392 : 	// we have to clear out the typing mode flag here, because if
; 4393 : 	// we don't we can end up with a message queued but still do
; 4394 : 	// a typing-mode fast reset (which will leave this sneak
; 4395 : 	// message inside the synthesizer)
; 4396 : 	phTTS->bInTypingMode = FALSE;
; 4397 : #endif TYPING_MODE
; 4398 : 	
; 4399 : 	/********************************************************************/
; 4400 : 	/*  Allocate the Text Message structure.                            */
; 4401 : 	/********************************************************************/
; 4402 : 	
; 4403 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));

  011ba	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__malloc
  011c0	6a 0c		 push	 12			; 0000000cH
  011c2	c7 86 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+220], 0
  011cc	ff d3		 call	 ebx
  011ce	8b e8		 mov	 ebp, eax
  011d0	83 c4 04	 add	 esp, 4

; 4404 : 	
; 4405 : 	if ( pTextMsg == NULL )

  011d3	85 ed		 test	 ebp, ebp
  011d5	75 0a		 jne	 SHORT $L73282
  011d7	5f		 pop	 edi
  011d8	5e		 pop	 esi
  011d9	5d		 pop	 ebp

; 4406 : 		return( MMSYSERR_NOMEM );

  011da	b8 07 00 00 00	 mov	 eax, 7
  011df	5b		 pop	 ebx

; 4595 : }

  011e0	c3		 ret	 0
$L73282:

; 4407 : 	
; 4408 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 4409 : 	pTextMsg->pLink = NULL;
; 4410 : #endif
; 4411 : 	
; 4412 : 	/********************************************************************/
; 4413 : 	/*  Get the character string length.                                */
; 4414 : 	/********************************************************************/
; 4415 : 	// MGS fixed getting NULL strings as input
; 4416 : 	if (pszTextString==NULL)

  011e1	8b 7c 24 18	 mov	 edi, DWORD PTR _pszTextString$[esp+12]
  011e5	85 ff		 test	 edi, edi
  011e7	74 0c		 je	 SHORT $L73285
$L73284:

; 4417 : 	{
; 4418 : 		uiLength=0;
; 4419 : 	}
; 4420 : 	else
; 4421 : 	{
; 4422 : 		uiLength = strlen(pszTextString);

  011e9	83 c9 ff	 or	 ecx, -1
  011ec	33 c0		 xor	 eax, eax
  011ee	f2 ae		 repne scasb
  011f0	f7 d1		 not	 ecx
  011f2	49		 dec	 ecx
  011f3	8b f9		 mov	 edi, ecx
$L73285:

; 4423 : 	}
; 4424 : 	
; 4425 : 	/********************************************************************/
; 4426 : 	/*  Allocate the pipe text buffer. Allocate 1 extra location in     */
; 4427 : 	/*  case the force character is appended to the text string.        */
; 4428 : 	/* now allocate 2 extra for the two forcing chars.. tex 16aug96     */
; 4429 : 	/********************************************************************/
; 4430 : 	
; 4431 : 	pTextBuffer = (unsigned char *)malloc(( uiLength + 2 ) * sizeof(char));

  011f5	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  011f8	50		 push	 eax
  011f9	ff d3		 call	 ebx
  011fb	8b d8		 mov	 ebx, eax
  011fd	83 c4 04	 add	 esp, 4

; 4432 : 	
; 4433 : 	if ( pTextBuffer == NULL )

  01200	85 db		 test	 ebx, ebx
  01202	75 14		 jne	 SHORT $L73289

; 4434 : 	{
; 4435 : 		free( pTextMsg );

  01204	55		 push	 ebp
  01205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0120b	83 c4 04	 add	 esp, 4

; 4436 : 		return( MMSYSERR_NOMEM );

  0120e	b8 07 00 00 00	 mov	 eax, 7
  01213	5f		 pop	 edi
  01214	5e		 pop	 esi
  01215	5d		 pop	 ebp
  01216	5b		 pop	 ebx

; 4595 : }

  01217	c3		 ret	 0
$L73289:

; 4437 : 	}
; 4438 : 	
; 4439 : 	/********************************************************************/
; 4440 : 	/*  The memory pointed to by pTextMsg and pTextBuffer is            */
; 4441 : 	/*  deallocated in the Text To Speech thread window procedure and   */
; 4442 : 	/*  should not be used after the call to the SendMessage()          */
; 4443 : 	/*  function.                                                       */
; 4444 : 	/********************************************************************/
; 4445 : 	
; 4446 : 	for ( i = 0; i < uiLength; i++ )

  01218	85 ff		 test	 edi, edi
  0121a	76 1d		 jbe	 SHORT $L73292
  0121c	8b 4c 24 18	 mov	 ecx, DWORD PTR _pszTextString$[esp+12]
  01220	8b c3		 mov	 eax, ebx
  01222	2b cb		 sub	 ecx, ebx
  01224	89 7c 24 18	 mov	 DWORD PTR 12+[esp+12], edi
$L73290:

; 4447 : 		pTextBuffer[i] = pszTextString[i];

  01228	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0122b	88 10		 mov	 BYTE PTR [eax], dl
  0122d	8b 54 24 18	 mov	 edx, DWORD PTR 12+[esp+12]
  01231	40		 inc	 eax
  01232	4a		 dec	 edx
  01233	89 54 24 18	 mov	 DWORD PTR 12+[esp+12], edx
  01237	75 ef		 jne	 SHORT $L73290
$L73292:

; 4448 : 	
; 4449 : 	/********************************************************************/
; 4450 : 	/*  Conditionally append the force character to the text.           */
; 4451 : 	/********************************************************************/
; 4452 : 	
; 4453 : 	if ( dwFlags & TTS_FORCE )

  01239	f6 44 24 1c 01	 test	 BYTE PTR _dwFlags$[esp+12], 1
  0123e	74 0a		 je	 SHORT $L73293

; 4454 : 	{
; 4455 : 		pTextBuffer[uiLength] = cForce;

  01240	c6 04 3b 0b	 mov	 BYTE PTR [ebx+edi], 11	; 0000000bH

; 4456 : 		uiLength++;

  01244	47		 inc	 edi

; 4457 : 		pTextBuffer[uiLength] = cForce2;

  01245	c6 04 3b 0a	 mov	 BYTE PTR [ebx+edi], 10	; 0000000aH

; 4458 : 		uiLength++;

  01249	47		 inc	 edi
$L73293:

; 4459 : 	}
; 4460 : 	// tek 05nov97 bats472 we have to do all message numbering and 
; 4461 : 	// queueing under a critical section, so that we are absolutely
; 4462 : 	// sure that the numbers will be monotonically increasing; if 
; 4463 : 	// they aren't. WaitForTextQueueingToComplete will end up 
; 4464 : 	// waiting forever.
; 4465 : 
; 4466 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );

  0124a	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  01250	50		 push	 eax
  01251	e8 00 00 00 00	 call	 _OP_LockMutex

; 4467 : 
; 4468 : 	/********************************************************************/
; 4469 : 	/*  Set up the Text Message structure.                              */
; 4470 : 	/*  The message number is used in the Text-To-Speech thread to      */
; 4471 : 	/*  to throw away window messages which are received after          */
; 4472 : 	/*  TextToSpeechReset() is called.                                  */
; 4473 : 	/********************************************************************/
; 4474 : 	
; 4475 : 	pTextMsg->pText = pTextBuffer;

  01256	89 5d 08	 mov	 DWORD PTR [ebp+8], ebx

; 4476 : 	pTextMsg->uiLength = uiLength;

  01259	89 7d 04	 mov	 DWORD PTR [ebp+4], edi

; 4477 : 	
; 4478 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );

  0125c	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  01262	51		 push	 ecx
  01263	e8 00 00 00 00	 call	 _OP_LockMutex

; 4479 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;

  01268	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  0126b	89 55 00	 mov	 DWORD PTR [ebp], edx

; 4480 : 	phTTS->uiCurrentMsgNumber++;

  0126e	8b 56 44	 mov	 edx, DWORD PTR [esi+68]

; 4481 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );

  01271	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  01277	42		 inc	 edx
  01278	50		 push	 eax
  01279	89 56 44	 mov	 DWORD PTR [esi+68], edx
  0127c	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4482 : 
; 4483 : 	// tek 16jun97 bats 385 moves the store/increment inside the CS
; 4484 : 	
; 4485 : 	/********************************************************************/
; 4486 : 	/*  Save this message number in the Text-To-Speech handle for       */
; 4487 : 	/*  the TextToSpeechSync() function.                                */
; 4488 : 	/********************************************************************/
; 4489 : 
; 4490 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );

  01281	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  01287	51		 push	 ecx
  01288	e8 00 00 00 00	 call	 _OP_LockMutex

; 4491 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 4492 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );

  0128d	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  01293	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  01296	50		 push	 eax
  01297	89 56 48	 mov	 DWORD PTR [esi+72], edx
  0129a	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4493 : 
; 4494 : 	/********************************************************************/
; 4495 : 	/*  Accumulate the queued character count.                          */
; 4496 : 	/********************************************************************/
; 4497 : #if defined WIN32 && !defined NOWIN
; 4498 : 	//tek bats472: move this up to before the point where we 
; 4499 : 	// take a number
; 4500 : 	//EnterCriticalSection( phTTS->pcsQueuedCharacterCount );
; 4501 : 	phTTS->uiQueuedCharacterCount += uiLength;

  0129f	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  012a2	83 c4 14	 add	 esp, 20			; 00000014H
  012a5	03 cf		 add	 ecx, edi
  012a7	89 4e 40	 mov	 DWORD PTR [esi+64], ecx

; 4502 : 	// tek bats472: move this to after the PostMessage.
; 4503 : 	//LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );
; 4504 : #ifdef API_DEBUG
; 4505 : 	{
; 4506 : 		char szTemp[256]="";
; 4507 : 		char szTemp2[128]="";
; 4508 : 		int	i=0;
; 4509 : 		for (i=0;i<127 && i<pTextMsg->uiLength ;i++)
; 4510 : 		{
; 4511 : 			if (!isprint(pTextBuffer[i]))
; 4512 : 			{
; 4513 : 				szTemp2[i]='.';
; 4514 : 			}
; 4515 : 			else
; 4516 : 			{
; 4517 : 				szTemp2[i]=pTextBuffer[i];
; 4518 : 			}
; 4519 : 		}
; 4520 : 		szTemp2[i]='\0';
; 4521 : 		sprintf(szTemp,"  .. TTSMessage %u posting. [%s]\n",
; 4522 : 			pTextMsg->uiMsgNumber,
; 4523 : 			szTemp2);
; 4524 : 		OutputDebugString(szTemp);
; 4525 : 	}
; 4526 : #endif //API_DEBUG
; 4527 : 	/********************************************************************/
; 4528 : 	/*  Send the structure pointed to by pTextMsg to the text thread.   */
; 4529 : 	/********************************************************************/
; 4530 : 	
; 4531 : 	PostMessage( phTTS->hTextToSpeechWnd,
; 4532 : 		ID_TTS_Queue_Text,
; 4533 : 		0L,
; 4534 : 		(LPARAM)pTextMsg );

  012aa	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  012ad	55		 push	 ebp
  012ae	6a 00		 push	 0
  012b0	68 00 04 00 00	 push	 1024			; 00000400H
  012b5	51		 push	 ecx
  012b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 4535 : 	// tek bats472: OK to do this now.
; 4536 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );

  012bc	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  012c2	52		 push	 edx
  012c3	e8 00 00 00 00	 call	 _OP_UnlockMutex
  012c8	83 c4 04	 add	 esp, 4

; 4537 : 	/********************************************************************/
; 4538 : 	/*  Re-enable error messages in the audio thread. The audio thread  */
; 4539 : 	/*  disables the audio error handler after sending a message. This  */
; 4540 : 	/*  is done to ensure that the application only receives at most    */
; 4541 : 	/*  only one error message per call to the TextToSpeechSpeak()      */
; 4542 : 	/*  function. Otherwise a message would be sent each time the audio */
; 4543 : 	/*  thread was unable to open the audio device.                     */
; 4544 : 	/********************************************************************/
; 4545 : 	
; 4546 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
; 4547 : 	{
; 4548 : #ifndef OLEDECTALK
; 4549 : 		//  EnableAudioErrorMessage( phTTS->pAudioHandle );
; 4550 : #endif //OLEDECTALK
; 4551 : 	}
; 4552 : #endif // WIN32
; 4553 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 4554 : 	/********************************************************************/
; 4555 : 	/*  Add the text message to the text-message linked list.           */
; 4556 : 	/********************************************************************/
; 4557 : 	
; 4558 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 4559 : 	
; 4560 : 	/********************************************************************/
; 4561 : 	/*  Put the Text Message at the end of the linked list.             */
; 4562 : 	/********************************************************************/
; 4563 : 	
; 4564 : 	if ( phTTS->pTextMsgList == NULL )
; 4565 : 	{
; 4566 : 		phTTS->pTextMsgList = pTextMsg;
; 4567 : 	}
; 4568 : 	else
; 4569 : 	{
; 4570 : 		pNextTextMsg = phTTS->pTextMsgList;
; 4571 : 		while ( pNextTextMsg->pLink != NULL )
; 4572 : 		{
; 4573 : 			pNextTextMsg = pNextTextMsg->pLink;
; 4574 : 		}
; 4575 : 		pNextTextMsg->pLink = pTextMsg;
; 4576 : 	}
; 4577 : 	phTTS->uiQueuedCharacterCount += uiLength;
; 4578 : 	
; 4579 : 	/********************************************************************/
; 4580 : 	/*  Set the Text In Queue event.                                    */
; 4581 : 	/********************************************************************/
; 4582 : 	
; 4583 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 4584 : 	
; 4585 : 	/********************************************************************/
; 4586 : 	/*  Unlock the text-message linked list.                            */
; 4587 : 	/********************************************************************/
; 4588 : 	
; 4589 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 4590 : 
; 4591 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 4592 : 
; 4593 : #endif
; 4594 : 	return( MMSYSERR_NOERROR );

  012cb	33 c0		 xor	 eax, eax
  012cd	5f		 pop	 edi
  012ce	5e		 pop	 esi
  012cf	5d		 pop	 ebp
  012d0	5b		 pop	 ebx

; 4595 : }

  012d1	c3		 ret	 0
_TextToSpeechSpeakEx ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechPause
EXTRN	_PA_Pause:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechPause PROC NEAR

; 4630 : {

  012e0	56		 push	 esi

; 4631 : 	MMRESULT mmStatus;
; 4632 : 	
; 4633 : 	/********************************************************************/
; 4634 : 	/*  Return error if invalid handle.                                 */
; 4635 : 	/********************************************************************/
; 4636 : 	
; 4637 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  012e1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  012e5	6a 04		 push	 4
  012e7	56		 push	 esi
  012e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  012ee	85 c0		 test	 eax, eax
  012f0	74 07		 je	 SHORT $L73300

; 4638 : 	{
; 4639 : 		mmStatus = MMSYSERR_INVALHANDLE;

  012f2	b8 05 00 00 00	 mov	 eax, 5
  012f7	5e		 pop	 esi

; 4645 : #endif //OLEDECTALK
; 4646 : 	}
; 4647 : 	return( mmStatus );
; 4648 : }

  012f8	c3		 ret	 0
$L73300:

; 4640 : 	}
; 4641 : 	else
; 4642 : 	{
; 4643 : #ifndef OLEDECTALK
; 4644 : 		mmStatus = PA_Pause( phTTS->pAudioHandle );

  012f9	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  012ff	50		 push	 eax
  01300	e8 00 00 00 00	 call	 _PA_Pause
  01305	83 c4 04	 add	 esp, 4
  01308	5e		 pop	 esi

; 4645 : #endif //OLEDECTALK
; 4646 : 	}
; 4647 : 	return( mmStatus );
; 4648 : }

  01309	c3		 ret	 0
_TextToSpeechPause ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechResume
EXTRN	_PA_Resume:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechResume PROC NEAR

; 4682 : {

  01310	56		 push	 esi

; 4683 : 	MMRESULT mmStatus;
; 4684 : 	
; 4685 : 	/********************************************************************/
; 4686 : 	/*  Return error if invalid handle.                                 */
; 4687 : 	/********************************************************************/
; 4688 : 	
; 4689 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01311	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01315	6a 04		 push	 4
  01317	56		 push	 esi
  01318	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0131e	85 c0		 test	 eax, eax
  01320	74 07		 je	 SHORT $L73306

; 4690 : 	{
; 4691 : 		mmStatus = MMSYSERR_INVALHANDLE;

  01322	b8 05 00 00 00	 mov	 eax, 5
  01327	5e		 pop	 esi

; 4697 : #endif //OLEDECTALK
; 4698 : 	}
; 4699 : 	return( mmStatus );
; 4700 : }

  01328	c3		 ret	 0
$L73306:

; 4692 : 	}
; 4693 : 	else
; 4694 : 	{
; 4695 : #ifndef OLEDECTALK
; 4696 : 		mmStatus = PA_Resume( phTTS->pAudioHandle );

  01329	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  0132f	50		 push	 eax
  01330	e8 00 00 00 00	 call	 _PA_Resume
  01335	83 c4 04	 add	 esp, 4
  01338	5e		 pop	 esi

; 4697 : #endif //OLEDECTALK
; 4698 : 	}
; 4699 : 	return( mmStatus );
; 4700 : }

  01339	c3		 ret	 0
_TextToSpeechResume ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenWaveOutFile
PUBLIC	_TextToSpeechSync
EXTRN	__imp__fwrite:NEAR
EXTRN	_SetSampleRate:NEAR
_DATA	SEGMENT
$SG73334 DB	'wb', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pszFileName$ = 12
_dwFormat$ = 16
_TextToSpeechOpenWaveOutFile PROC NEAR

; 4760 : {

  01340	53		 push	 ebx
  01341	55		 push	 ebp
  01342	56		 push	 esi
  01343	57		 push	 edi

; 4761 :   MMRESULT mmStatus;
; 4762 :   WAVE_FILE_HDR_T * pWaveFileHdr;
; 4763 : #ifdef UNDER_CE
; 4764 :   DWORD dwRW;
; 4765 : #endif
; 4766 : 
; 4767 : 	/********************************************************************/
; 4768 : 	/*  Return error if invalid handle.                                 */
; 4769 : 	/********************************************************************/
; 4770 : 	
; 4771 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01344	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  01348	6a 04		 push	 4
  0134a	57		 push	 edi
  0134b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01351	85 c0		 test	 eax, eax
  01353	74 0a		 je	 SHORT $L73317
  01355	5f		 pop	 edi
  01356	5e		 pop	 esi
  01357	5d		 pop	 ebp

; 4772 : 		return( MMSYSERR_INVALHANDLE );

  01358	b8 05 00 00 00	 mov	 eax, 5
  0135d	5b		 pop	 ebx

; 4913 : }

  0135e	c3		 ret	 0
$L73317:

; 4773 : 	
; 4774 : 	/********************************************************************/
; 4775 : 	/*  If a file is already open, then don't try to open another one.  */
; 4776 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 4777 : 	/*  an error.                                                       */
; 4778 : 	/********************************************************************/
; 4779 : 	
; 4780 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 4781 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  0135f	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  01365	33 ed		 xor	 ebp, ebp
  01367	3b c5		 cmp	 eax, ebp
  01369	74 0f		 je	 SHORT $L73318
  0136b	83 f8 04	 cmp	 eax, 4
  0136e	74 0a		 je	 SHORT $L73318
  01370	5f		 pop	 edi
  01371	5e		 pop	 esi
  01372	5d		 pop	 ebp

; 4782 : 		return( MMSYSERR_ALLOCATED );

  01373	b8 04 00 00 00	 mov	 eax, 4
  01378	5b		 pop	 ebx

; 4913 : }

  01379	c3		 ret	 0
$L73318:

; 4783 : 	
; 4784 : 	/********************************************************************/
; 4785 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 4786 : 	/*  function have completed.                                        */
; 4787 : 	/********************************************************************/
; 4788 : 	
; 4789 : 	mmStatus = TextToSpeechSync( phTTS );

  0137a	57		 push	 edi
  0137b	e8 00 00 00 00	 call	 _TextToSpeechSync
  01380	83 c4 04	 add	 esp, 4

; 4790 : 	
; 4791 : 	if ( mmStatus )

  01383	3b c5		 cmp	 eax, ebp

; 4792 : 		return( mmStatus );

  01385	0f 85 57 01 00
	00		 jne	 $L73314

; 4793 : 	
; 4794 : 	/********************************************************************/
; 4795 : 	/*  Create the header for the output file                           */
; 4796 : 	/********************************************************************/
; 4797 : 	
; 4798 : 	pWaveFileHdr = (WAVE_FILE_HDR_T *) malloc( sizeof(WAVE_FILE_HDR_T));

  0138b	6a 2c		 push	 44			; 0000002cH
  0138d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  01393	8b f0		 mov	 esi, eax
  01395	83 c4 04	 add	 esp, 4

; 4799 : 	
; 4800 : 	if ( pWaveFileHdr == NULL )

  01398	3b f5		 cmp	 esi, ebp
  0139a	75 0a		 jne	 SHORT $L73323
  0139c	5f		 pop	 edi
  0139d	5e		 pop	 esi
  0139e	5d		 pop	 ebp

; 4801 : 		return( MMSYSERR_NOMEM );

  0139f	b8 07 00 00 00	 mov	 eax, 7
  013a4	5b		 pop	 ebx

; 4913 : }

  013a5	c3		 ret	 0
$L73323:

; 4802 : 	
; 4803 : 	/* MVP: Initialize the Wave_File_header's common elements for all waveformats.*/
; 4804 : 	/*{ "RIFF", 0, "WAVEfmt ", 16, 1, 1, 11025, 11025, 1, 8, "data", 0 };*/
; 4805 : 	pWaveFileHdr->psRiff[0] = 'R';
; 4806 : 	pWaveFileHdr->psRiff[1] = 'I';
; 4807 : 	pWaveFileHdr->psRiff[2] = 'F';

  013a6	b0 46		 mov	 al, 70			; 00000046H

; 4808 : 	pWaveFileHdr->psRiff[3] = 'F';
; 4809 : 	pWaveFileHdr->dwRiffChunkSize = 0;

  013a8	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  013ab	88 46 02	 mov	 BYTE PTR [esi+2], al
  013ae	88 46 03	 mov	 BYTE PTR [esi+3], al

; 4810 : 	pWaveFileHdr->psWaveFmt[0] = 'W';
; 4811 : 	pWaveFileHdr->psWaveFmt[1] = 'A';
; 4812 : 	pWaveFileHdr->psWaveFmt[2] = 'V';
; 4813 : 	pWaveFileHdr->psWaveFmt[3] = 'E';
; 4814 : 	pWaveFileHdr->psWaveFmt[4] = 'f';
; 4815 : 	pWaveFileHdr->psWaveFmt[5] = 'm';
; 4816 : 	pWaveFileHdr->psWaveFmt[6] = 't';
; 4817 : 	pWaveFileHdr->psWaveFmt[7] = ' ';
; 4818 : 	pWaveFileHdr->dwWaveChunkSize = 16;
; 4819 : 	pWaveFileHdr->wNumberOfChannels = 1;
; 4820 : 	pWaveFileHdr->psData[0] = 'd';
; 4821 : 	pWaveFileHdr->psData[1] = 'a';

  013b1	b0 61		 mov	 al, 97			; 00000061H

; 4822 : 	pWaveFileHdr->psData[2] = 't';
; 4823 : 	pWaveFileHdr->psData[3] = 'a';
; 4824 : 	pWaveFileHdr->dwDataChunkSize = 0;

  013b3	89 6e 28	 mov	 DWORD PTR [esi+40], ebp

; 4825 : 	
; 4826 : 	/********************************************************************/
; 4827 : 	/*  If the dwFormat value is invalid then return an error.          */
; 4828 : 	/********************************************************************/
; 4829 : 	
; 4830 : 	switch( dwFormat )
; 4831 : 	{

  013b6	8b 6c 24 1c	 mov	 ebp, DWORD PTR _dwFormat$[esp+12]
  013ba	88 46 25	 mov	 BYTE PTR [esi+37], al
  013bd	88 46 27	 mov	 BYTE PTR [esi+39], al
  013c0	8b c5		 mov	 eax, ebp
  013c2	b1 74		 mov	 cl, 116			; 00000074H
  013c4	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  013c9	bb 01 00 00 00	 mov	 ebx, 1
  013ce	48		 dec	 eax
  013cf	c6 06 52	 mov	 BYTE PTR [esi], 82	; 00000052H
  013d2	c6 46 01 49	 mov	 BYTE PTR [esi+1], 73	; 00000049H
  013d6	c6 46 08 57	 mov	 BYTE PTR [esi+8], 87	; 00000057H
  013da	c6 46 09 41	 mov	 BYTE PTR [esi+9], 65	; 00000041H
  013de	c6 46 0a 56	 mov	 BYTE PTR [esi+10], 86	; 00000056H
  013e2	c6 46 0b 45	 mov	 BYTE PTR [esi+11], 69	; 00000045H
  013e6	c6 46 0c 66	 mov	 BYTE PTR [esi+12], 102	; 00000066H
  013ea	c6 46 0d 6d	 mov	 BYTE PTR [esi+13], 109	; 0000006dH
  013ee	88 4e 0e	 mov	 BYTE PTR [esi+14], cl
  013f1	c6 46 0f 20	 mov	 BYTE PTR [esi+15], 32	; 00000020H
  013f5	89 56 10	 mov	 DWORD PTR [esi+16], edx
  013f8	66 89 5e 16	 mov	 WORD PTR [esi+22], bx
  013fc	c6 46 24 64	 mov	 BYTE PTR [esi+36], 100	; 00000064H
  01400	88 4e 26	 mov	 BYTE PTR [esi+38], cl
  01403	74 4a		 je	 SHORT $L73329
  01405	83 e8 03	 sub	 eax, 3
  01408	74 26		 je	 SHORT $L73328
  0140a	83 e8 03	 sub	 eax, 3
  0140d	74 14		 je	 SHORT $L73330

; 4867 : 		
; 4868 : 	default:
; 4869 : 		
; 4870 : 		free( pWaveFileHdr );

  0140f	56		 push	 esi
  01410	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  01416	83 c4 04	 add	 esp, 4

; 4871 : 		return( MMSYSERR_INVALPARAM );

  01419	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0141e	5f		 pop	 edi
  0141f	5e		 pop	 esi
  01420	5d		 pop	 ebp
  01421	5b		 pop	 ebx

; 4913 : }

  01422	c3		 ret	 0
$L73330:

; 4853 : 		
; 4854 : 		break;
; 4855 : 		
; 4856 : 	case WAVE_FORMAT_08M08:
; 4857 : 		
; 4858 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_MULAW;

  01423	66 c7 46 14 07
	00		 mov	 WORD PTR [esi+20], 7

; 4859 : 		pWaveFileHdr->dwSamplesPerSecond = MULAW_SAMPLE_RATE;

  01429	b8 40 1f 00 00	 mov	 eax, 8000		; 00001f40H

; 4860 : 		pWaveFileHdr->dwAvgBytesPerSecond = MULAW_SAMPLE_RATE;
; 4861 : 		pWaveFileHdr->wNumberBlockAlign = 1;
; 4862 : 		pWaveFileHdr->wBitsPerSample = 8;
; 4863 : 		
; 4864 : 		SetSampleRate( phTTS, MULAW_SAMPLE_RATE );
; 4865 : 		
; 4866 : 		break;

  0142e	eb 28		 jmp	 SHORT $L74662
$L73328:

; 4832 : 	case WAVE_FORMAT_1M16:
; 4833 : 		
; 4834 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_PCM;
; 4835 : 		pWaveFileHdr->dwSamplesPerSecond = PC_SAMPLE_RATE;

  01430	b8 11 2b 00 00	 mov	 eax, 11025		; 00002b11H
  01435	66 89 5e 14	 mov	 WORD PTR [esi+20], bx
  01439	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 4836 : 		pWaveFileHdr->dwAvgBytesPerSecond = PC_SAMPLE_RATE + PC_SAMPLE_RATE;

  0143c	c7 46 1c 22 56
	00 00		 mov	 DWORD PTR [esi+28], 22050 ; 00005622H

; 4837 : 		pWaveFileHdr->wNumberBlockAlign = 2;

  01443	66 c7 46 20 02
	00		 mov	 WORD PTR [esi+32], 2

; 4838 : 		pWaveFileHdr->wBitsPerSample = 16;

  01449	66 89 56 22	 mov	 WORD PTR [esi+34], dx

; 4839 : 		
; 4840 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 4841 : 		
; 4842 : 		break;

  0144d	eb 19		 jmp	 SHORT $L74663
$L73329:

; 4843 : 		
; 4844 : 	case WAVE_FORMAT_1M08:
; 4845 : 		
; 4846 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_PCM;

  0144f	66 89 5e 14	 mov	 WORD PTR [esi+20], bx

; 4847 : 		pWaveFileHdr->dwSamplesPerSecond = PC_SAMPLE_RATE;

  01453	b8 11 2b 00 00	 mov	 eax, 11025		; 00002b11H
$L74662:
  01458	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 4848 : 		pWaveFileHdr->dwAvgBytesPerSecond = PC_SAMPLE_RATE;

  0145b	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 4849 : 		pWaveFileHdr->wNumberBlockAlign = 1;

  0145e	66 89 5e 20	 mov	 WORD PTR [esi+32], bx

; 4850 : 		pWaveFileHdr->wBitsPerSample = 8;

  01462	66 c7 46 22 08
	00		 mov	 WORD PTR [esi+34], 8
$L74663:

; 4851 : 		
; 4852 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );

  01468	50		 push	 eax
  01469	57		 push	 edi
  0146a	e8 00 00 00 00	 call	 _SetSampleRate

; 4872 : 	}
; 4873 : 	
; 4874 : 	phTTS->dwFormat = dwFormat;
; 4875 : 	
; 4876 : 	/********************************************************************/
; 4877 : 	/*  Open the wave output file.                                      */
; 4878 : 	/********************************************************************/
; 4879 : 	
; 4880 : #ifdef UNDER_CE //mfgce
; 4881 :   if((phTTS->pWaveFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL))==NULL)
; 4882 : #else
; 4883 :   if (( phTTS->pWaveFile = fopen(pszFileName, "wb" )) == NULL )

  0146f	8b 44 24 20	 mov	 eax, DWORD PTR _pszFileName$[esp+20]
  01473	83 c4 08	 add	 esp, 8
  01476	89 af 84 00 00
	00		 mov	 DWORD PTR [edi+132], ebp
  0147c	68 00 00 00 00	 push	 OFFSET FLAT:$SG73334
  01481	50		 push	 eax
  01482	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  01488	83 c4 08	 add	 esp, 8
  0148b	89 87 98 00 00
	00		 mov	 DWORD PTR [edi+152], eax
  01491	85 c0		 test	 eax, eax
  01493	75 11		 jne	 SHORT $L73333

; 4884 : #endif
; 4885 : 	{
; 4886 : 		free( pWaveFileHdr );

  01495	56		 push	 esi
  01496	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0149c	83 c4 04	 add	 esp, 4

; 4887 : 		return( MMSYSERR_ERROR );

  0149f	8b c3		 mov	 eax, ebx
  014a1	5f		 pop	 edi
  014a2	5e		 pop	 esi
  014a3	5d		 pop	 ebp
  014a4	5b		 pop	 ebx

; 4913 : }

  014a5	c3		 ret	 0
$L73333:

; 4888 : 	}
; 4889 : 	
; 4890 : 	/********************************************************************/
; 4891 : 	/*  Write the header to the output file.                            */
; 4892 : 	/********************************************************************/
; 4893 : 	
; 4894 : #ifdef UNDER_CE
; 4895 :   if(WriteFile( phTTS->pWaveFile,pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ), &dwRW, NULL)==0)
; 4896 : #else
; 4897 :   if( 1 != fwrite( (char *)pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ),1,phTTS->pWaveFile ))

  014a6	50		 push	 eax
  014a7	53		 push	 ebx
  014a8	6a 2c		 push	 44			; 0000002cH
  014aa	56		 push	 esi
  014ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  014b1	83 c4 10	 add	 esp, 16			; 00000010H
  014b4	3b c3		 cmp	 eax, ebx
  014b6	74 11		 je	 SHORT $L73337

; 4898 : #endif
; 4899 : 	{
; 4900 : 		free( pWaveFileHdr );

  014b8	56		 push	 esi
  014b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  014bf	83 c4 04	 add	 esp, 4

; 4901 : 		return( MMSYSERR_ERROR );

  014c2	8b c3		 mov	 eax, ebx
  014c4	5f		 pop	 edi
  014c5	5e		 pop	 esi
  014c6	5d		 pop	 ebp
  014c7	5b		 pop	 ebx

; 4913 : }

  014c8	c3		 ret	 0
$L73337:

; 4902 : 	}
; 4903 : 	
; 4904 : 	/********************************************************************/
; 4905 : 	/*  Initialize the file sample count.                               */
; 4906 : 	/********************************************************************/
; 4907 : 	
; 4908 : 	phTTS->dwFileSampleCount = 0;

  014c9	c7 47 7c 00 00
	00 00		 mov	 DWORD PTR [edi+124], 0

; 4909 : 	phTTS->pWaveFileHdr = pWaveFileHdr;

  014d0	89 b7 a0 00 00
	00		 mov	 DWORD PTR [edi+160], esi

; 4910 : 	phTTS->dwOutputState = STATE_OUTPUT_WAVE_FILE;

  014d6	c7 87 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+136], 2

; 4911 : 	
; 4912 : 	return( MMSYSERR_NOERROR );

  014e0	33 c0		 xor	 eax, eax
$L73314:
  014e2	5f		 pop	 edi
  014e3	5e		 pop	 esi
  014e4	5d		 pop	 ebp
  014e5	5b		 pop	 ebx

; 4913 : }

  014e6	c3		 ret	 0
_TextToSpeechOpenWaveOutFile ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechCloseWaveOutFile
EXTRN	__imp__fseek:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechCloseWaveOutFile PROC NEAR

; 4953 : {

  014f0	53		 push	 ebx
  014f1	55		 push	 ebp
  014f2	56		 push	 esi

; 4954 : 	DWORD dwLengthInBytes;
; 4955 : #ifdef UNDER_CE
; 4956 : 	HANDLE * pWaveFile;
; 4957 : 	DWORD dwRW;
; 4958 : #else
; 4959 : 	FILE * pWaveFile;
; 4960 : #endif
; 4961 : 	WAVE_FILE_HDR_T * pWaveFileHdr;
; 4962 : 	MMRESULT mmStatus;
; 4963 : 	
; 4964 : 	/********************************************************************/
; 4965 : 	/*  Return error if invalid handle.                                 */
; 4966 : 	/********************************************************************/
; 4967 : 	
; 4968 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  014f3	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  014f7	57		 push	 edi
  014f8	6a 04		 push	 4
  014fa	56		 push	 esi
  014fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01501	85 c0		 test	 eax, eax
  01503	74 0a		 je	 SHORT $L73345
  01505	5f		 pop	 edi
  01506	5e		 pop	 esi
  01507	5d		 pop	 ebp

; 4969 : 		return( MMSYSERR_INVALHANDLE );

  01508	b8 05 00 00 00	 mov	 eax, 5
  0150d	5b		 pop	 ebx

; 5095 : }

  0150e	c3		 ret	 0
$L73345:

; 4970 : 	
; 4971 : 	/********************************************************************/
; 4972 : 	/*  If a file is not open, then exit.                               */
; 4973 : 	/********************************************************************/
; 4974 : 	
; 4975 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_WAVE_FILE )

  0150f	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  01516	74 0a		 je	 SHORT $L73346
  01518	5f		 pop	 edi
  01519	5e		 pop	 esi
  0151a	5d		 pop	 ebp

; 4976 : 		return( MMSYSERR_ERROR );

  0151b	b8 01 00 00 00	 mov	 eax, 1
  01520	5b		 pop	 ebx

; 5095 : }

  01521	c3		 ret	 0
$L73346:

; 4977 : 	
; 4978 : 	/********************************************************************/
; 4979 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 4980 : 	/*  function have completed.                                        */
; 4981 : 	/********************************************************************/
; 4982 : 	
; 4983 : 	mmStatus = TextToSpeechSync( phTTS );

  01522	56		 push	 esi
  01523	e8 00 00 00 00	 call	 _TextToSpeechSync
  01528	8b d8		 mov	 ebx, eax

; 4984 : 	
; 4985 : 	if ( mmStatus )
; 4986 : 		mmStatus = MMSYSERR_ERROR;
; 4987 : 	else
; 4988 : 		mmStatus = MMSYSERR_NOERROR;
; 4989 : 	
; 4990 : 	/********************************************************************/
; 4991 : 	/*  Set the sample rate to the default value in case the sample     */
; 4992 : 	/*  was changed.                                                    */
; 4993 : 	/********************************************************************/
; 4994 : 	
; 4995 : 	SetSampleRate( phTTS, PC_SAMPLE_RATE );

  0152a	68 11 2b 00 00	 push	 11025			; 00002b11H
  0152f	f7 db		 neg	 ebx
  01531	1b db		 sbb	 ebx, ebx
  01533	56		 push	 esi
  01534	f7 db		 neg	 ebx
  01536	e8 00 00 00 00	 call	 _SetSampleRate

; 4996 : 	
; 4997 : 	/********************************************************************/
; 4998 : 	/*  Update the wave header riff chunk and data chunk lengths.       */
; 4999 : 	/********************************************************************/
; 5000 : 	
; 5001 : 	switch( phTTS->dwFormat )
; 5002 : 	{

  0153b	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01541	83 c4 0c	 add	 esp, 12			; 0000000cH
  01544	48		 dec	 eax
  01545	74 1b		 je	 SHORT $L73355
  01547	83 e8 03	 sub	 eax, 3
  0154a	74 0f		 je	 SHORT $L73353
  0154c	83 e8 03	 sub	 eax, 3
  0154f	74 11		 je	 SHORT $L73355
  01551	5f		 pop	 edi
  01552	5e		 pop	 esi
  01553	5d		 pop	 ebp

; 5012 : 		break;
; 5013 : 		
; 5014 : 	default:
; 5015 : 		
; 5016 : 		/******************************************************************/
; 5017 : 		/*  It should be impossible to get here so this error message is  */
; 5018 : 		/*  not documented.                                               */
; 5019 : 		/******************************************************************/
; 5020 : 		
; 5021 : 		return( MMSYSERR_INVALPARAM );

  01554	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01559	5b		 pop	 ebx

; 5095 : }

  0155a	c3		 ret	 0
$L73353:

; 5003 : 	case WAVE_FORMAT_1M16:
; 5004 : 		
; 5005 : 		dwLengthInBytes = (DWORD)phTTS->dwFileSampleCount << 1;

  0155b	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  0155e	d1 e0		 shl	 eax, 1

; 5006 : 		break;

  01560	eb 03		 jmp	 SHORT $L73350
$L73355:

; 5007 : 		
; 5008 : 	case WAVE_FORMAT_1M08:
; 5009 : 	case WAVE_FORMAT_08M08:
; 5010 : 		
; 5011 : 		dwLengthInBytes = (DWORD)phTTS->dwFileSampleCount;

  01562	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
$L73350:

; 5022 : 	}
; 5023 : 	
; 5024 : 	pWaveFileHdr = (WAVE_FILE_HDR_T *)phTTS->pWaveFileHdr;

  01565	8b be a0 00 00
	00		 mov	 edi, DWORD PTR [esi+160]

; 5025 : 	
; 5026 : 	pWaveFileHdr->dwDataChunkSize = dwLengthInBytes;
; 5027 : 	
; 5028 : 	pWaveFileHdr->dwRiffChunkSize =
; 5029 : 		pWaveFileHdr->dwDataChunkSize + RIFF_HEADER_OFFSET;
; 5030 : 	
; 5031 : 	/********************************************************************/
; 5032 : 	/*  Seek to the top of the file to write the updated wave header.   */
; 5033 : 	/********************************************************************/
; 5034 : 	
; 5035 : #ifdef UNDER_CE
; 5036 :    pWaveFile = (HANDLE *)phTTS->pWaveFile;
; 5037 : #else
; 5038 :    pWaveFile = (FILE *)phTTS->pWaveFile;
; 5039 : #endif
; 5040 : 
; 5041 : #ifdef UNDER_CE //mfgce fix return value
; 5042 :   SetFilePointer(pWaveFile ,0L ,NULL ,FILE_BEGIN);
; 5043 : #else
; 5044 :   if ( fseek( pWaveFile, 0L, SEEK_SET ))

  0156b	6a 00		 push	 0
  0156d	6a 00		 push	 0
  0156f	89 47 28	 mov	 DWORD PTR [edi+40], eax
  01572	83 c0 24	 add	 eax, 36			; 00000024H
  01575	89 47 04	 mov	 DWORD PTR [edi+4], eax
  01578	8b ae 98 00 00
	00		 mov	 ebp, DWORD PTR [esi+152]
  0157e	55		 push	 ebp
  0157f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  01585	83 c4 0c	 add	 esp, 12			; 0000000cH
  01588	85 c0		 test	 eax, eax
  0158a	74 14		 je	 SHORT $L73360

; 5045 :   {
; 5046 : 	free( pWaveFileHdr );

  0158c	57		 push	 edi
  0158d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  01593	83 c4 04	 add	 esp, 4

; 5047 : 	return( MMSYSERR_ERROR );

  01596	b8 01 00 00 00	 mov	 eax, 1
  0159b	5f		 pop	 edi
  0159c	5e		 pop	 esi
  0159d	5d		 pop	 ebp
  0159e	5b		 pop	 ebx

; 5095 : }

  0159f	c3		 ret	 0
$L73360:

; 5048 :   }
; 5049 : #endif
; 5050 : 	
; 5051 : 	/********************************************************************/
; 5052 : 	/*  Write the header to the output file.                            */
; 5053 : 	/********************************************************************/
; 5054 : 	
; 5055 : #ifdef UNDER_CE
; 5056 :   if(WriteFile( phTTS->pWaveFile,pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ), &dwRW, NULL)==0)
; 5057 : #else
; 5058 :   if ( 1 != fwrite( (char *)pWaveFileHdr,sizeof(WAVE_FILE_HDR_T ),1,phTTS->pWaveFile ))

  015a0	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  015a6	50		 push	 eax
  015a7	6a 01		 push	 1
  015a9	6a 2c		 push	 44			; 0000002cH
  015ab	57		 push	 edi
  015ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  015b2	83 c4 10	 add	 esp, 16			; 00000010H
  015b5	83 f8 01	 cmp	 eax, 1

; 5059 : #endif
; 5060 : 	{
; 5061 : 		free( pWaveFileHdr );

  015b8	57		 push	 edi
  015b9	74 13		 je	 SHORT $L73363
  015bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  015c1	83 c4 04	 add	 esp, 4

; 5062 : 		return( MMSYSERR_ERROR );

  015c4	b8 01 00 00 00	 mov	 eax, 1
  015c9	5f		 pop	 edi
  015ca	5e		 pop	 esi
  015cb	5d		 pop	 ebp
  015cc	5b		 pop	 ebx

; 5095 : }

  015cd	c3		 ret	 0
$L73363:

; 5063 : 	}
; 5064 : 	
; 5065 : 	/********************************************************************/
; 5066 : 	/*  Free the wave file header.                                      */
; 5067 : 	/********************************************************************/
; 5068 : 	
; 5069 : 	free( pWaveFileHdr );

  015ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 5070 : 	
; 5071 : 	/********************************************************************/
; 5072 : 	/*  Set the system output state to audio if it is enabled.          */
; 5073 : 	/********************************************************************/
; 5074 : 	
; 5075 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  015d4	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  015d7	83 c4 04	 add	 esp, 4
  015da	a9 00 00 00 80	 test	 eax, -2147483648	; 80000000H
  015df	75 17		 jne	 SHORT $L73364

; 5076 : 	{
; 5077 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 5078 : 		TextToSpeechReset(phTTS,FALSE); // tek 29jan99 bats 849: this resets the counters..

  015e1	6a 00		 push	 0
  015e3	56		 push	 esi
  015e4	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0
  015ee	e8 00 00 00 00	 call	 _TextToSpeechReset
  015f3	83 c4 08	 add	 esp, 8

; 5079 : 	}
; 5080 : 	else

  015f6	eb 0a		 jmp	 SHORT $L73365
$L73364:

; 5081 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;

  015f8	c7 86 88 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+136], 4
$L73365:

; 5082 : 	
; 5083 : 	/********************************************************************/
; 5084 : 	/*  Close the wave file.                                            */
; 5085 : 	/********************************************************************/
; 5086 : 	
; 5087 : #if UNDER_CE
; 5088 : 	if ( CloseHandle( pWaveFile ) == 0)
; 5089 : #else
; 5090 : 	if ( fclose( pWaveFile ))

  01602	55		 push	 ebp
  01603	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  01609	83 c4 04	 add	 esp, 4
  0160c	85 c0		 test	 eax, eax

; 5091 : #endif
; 5092 : 		return( MMSYSERR_ERROR );

  0160e	b8 01 00 00 00	 mov	 eax, 1
  01613	75 02		 jne	 SHORT $L73340

; 5093 : 	
; 5094 : 	return( mmStatus );

  01615	8b c3		 mov	 eax, ebx
$L73340:
  01617	5f		 pop	 edi
  01618	5e		 pop	 esi
  01619	5d		 pop	 ebp
  0161a	5b		 pop	 ebx

; 5095 : }

  0161b	c3		 ret	 0
_TextToSpeechCloseWaveOutFile ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetStatus
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
EXTRN	_PA_Status:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_dwIdentifierArray$ = 12
_dwStatusArray$ = 16
_dwNumberOfStatusValues$ = 20
_dwIdentifier$ = 8
_dwAudioStatus$ = -4
_TextToSpeechGetStatus PROC NEAR

; 5171 : {

  01620	51		 push	 ecx
  01621	53		 push	 ebx

; 5172 : 	UINT i;
; 5173 : #ifndef OLEDECTALK
; 5174 : 	DWORD dwIdentifier[1];
; 5175 : #endif //OLEDECTALK
; 5176 : 	DWORD dwAudioStatus[1];
; 5177 : 	MMRESULT mmStatus =0;
; 5178 : 	MMRESULT mmStatusReturn;
; 5179 : 	
; 5180 : 	/********************************************************************/
; 5181 : 	/*  Return error if invalid handle.                                 */
; 5182 : 	/********************************************************************/
; 5183 : 	
; 5184 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01622	8b 5c 24 0c	 mov	 ebx, DWORD PTR _phTTS$[esp+4]
  01626	6a 04		 push	 4
  01628	53		 push	 ebx
  01629	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0162f	85 c0		 test	 eax, eax
  01631	74 08		 je	 SHORT $L73381

; 5185 : 		return( MMSYSERR_INVALHANDLE );

  01633	b8 05 00 00 00	 mov	 eax, 5
  01638	5b		 pop	 ebx

; 5278 : }

  01639	59		 pop	 ecx
  0163a	c3		 ret	 0
$L73381:

; 5186 : 	
; 5187 : 	/********************************************************************/
; 5188 : 	/*  Range test the number of status values requested.               */
; 5189 : 	/********************************************************************/
; 5190 : 	
; 5191 : 	if (( dwNumberOfStatusValues == 0 )
; 5192 : 		|| ( dwNumberOfStatusValues > MAXIMUM_STATUS_VALUES ))

  0163b	8b 44 24 18	 mov	 eax, DWORD PTR _dwNumberOfStatusValues$[esp+4]
  0163f	85 c0		 test	 eax, eax
  01641	0f 84 26 01 00
	00		 je	 $L73383
  01647	83 f8 03	 cmp	 eax, 3
  0164a	0f 87 1d 01 00
	00		 ja	 $L73383
  01650	57		 push	 edi

; 5194 : 	
; 5195 : 	mmStatusReturn = MMSYSERR_NOERROR;

  01651	33 ff		 xor	 edi, edi

; 5196 : 	
; 5197 : 	/********************************************************************/
; 5198 : 	/*  Loop and fill in array dwStatusArray[].                             */
; 5199 : 	/********************************************************************/
; 5200 : 	
; 5201 : 	for ( i = 0; i < dwNumberOfStatusValues; i++ )

  01653	85 c0		 test	 eax, eax
  01655	0f 86 0c 01 00
	00		 jbe	 $L73386
  0165b	55		 push	 ebp

; 5269 : 			
; 5270 : 		default:
; 5271 : 			
; 5272 : 			dwStatusArray[i] = 0xFFFFFFFF;

  0165c	8b 6c 24 18	 mov	 ebp, DWORD PTR _dwIdentifierArray$[esp+12]
  01660	56		 push	 esi
  01661	8b 74 24 20	 mov	 esi, DWORD PTR _dwStatusArray$[esp+16]
  01665	2b ee		 sub	 ebp, esi
  01667	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
$L73384:
  0166b	8b 04 2e	 mov	 eax, DWORD PTR [esi+ebp]
  0166e	83 e8 00	 sub	 eax, 0
  01671	0f 84 bd 00 00
	00		 je	 $L73391

; 5202 : 	{
; 5203 : 		switch( dwIdentifierArray[i] )
; 5204 : 		{

  01677	48		 dec	 eax
  01678	74 68		 je	 SHORT $L73392
  0167a	48		 dec	 eax
  0167b	74 10		 je	 SHORT $L73397

; 5269 : 			
; 5270 : 		default:
; 5271 : 			
; 5272 : 			dwStatusArray[i] = 0xFFFFFFFF;

  0167d	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 5273 : 			mmStatusReturn = MMSYSERR_INVALPARAM;

  01683	bf 0b 00 00 00	 mov	 edi, 11			; 0000000bH

; 5274 : 			break;

  01688	e9 c6 00 00 00	 jmp	 $L73385
$L73397:

; 5240 : 			
; 5241 : 		case WAVE_OUT_DEVICE_ID:
; 5242 : 			
; 5243 : 			if ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE )

  0168d	f7 43 78 00 00
	00 80		 test	 DWORD PTR [ebx+120], -2147483648 ; 80000000H
  01694	74 10		 je	 SHORT $L73398

; 5244 : 			{
; 5245 : 				dwStatusArray[i] = 0xFFFFFFFF;

  01696	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 5246 : 				mmStatusReturn = MMSYSERR_ERROR;

  0169c	bf 01 00 00 00	 mov	 edi, 1

; 5247 : 			}
; 5248 : 			else

  016a1	e9 ad 00 00 00	 jmp	 $L73385
$L73398:

; 5249 : 			{
; 5250 : #ifndef OLEDECTALK
; 5251 : 				dwIdentifier[0] = PA_DEVICE_ID;
; 5252 : 				
; 5253 : 				mmStatus = PA_Status( phTTS->pAudioHandle,
; 5254 : 					dwIdentifier,
; 5255 : 					dwAudioStatus,
; 5256 : 					1 );

  016a6	8b 93 d8 00 00
	00		 mov	 edx, DWORD PTR [ebx+216]
  016ac	8d 44 24 10	 lea	 eax, DWORD PTR _dwAudioStatus$[esp+20]
  016b0	6a 01		 push	 1
  016b2	8d 4c 24 1c	 lea	 ecx, DWORD PTR _dwIdentifier$[esp+20]
  016b6	50		 push	 eax
  016b7	51		 push	 ecx
  016b8	52		 push	 edx
  016b9	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR _dwIdentifier$[esp+32], 3
  016c1	e8 00 00 00 00	 call	 _PA_Status
  016c6	83 c4 10	 add	 esp, 16			; 00000010H

; 5257 : #endif //OLEDECTALK
; 5258 : 				if ( mmStatus )

  016c9	85 c0		 test	 eax, eax
  016cb	74 0d		 je	 SHORT $L73400

; 5259 : 				{
; 5260 : 					dwStatusArray[i] = 0xFFFFFFFF;

  016cd	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 5261 : 					mmStatusReturn = MMSYSERR_ERROR;

  016d3	bf 01 00 00 00	 mov	 edi, 1

; 5262 : 				}
; 5263 : 				else

  016d8	eb 79		 jmp	 SHORT $L73385
$L73400:

; 5264 : 				{
; 5265 : 					dwStatusArray[i] = dwAudioStatus[0];

  016da	8b 44 24 10	 mov	 eax, DWORD PTR _dwAudioStatus$[esp+20]
  016de	89 06		 mov	 DWORD PTR [esi], eax

; 5266 : 				}
; 5267 : 			}
; 5268 : 			break;

  016e0	eb 71		 jmp	 SHORT $L73385
$L73392:

; 5210 : 			break;
; 5211 : 			
; 5212 : 		case STATUS_SPEAKING:
; 5213 : 			
; 5214 : 			if ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE )

  016e2	f7 43 78 00 00
	00 80		 test	 DWORD PTR [ebx+120], -2147483648 ; 80000000H
  016e9	74 0d		 je	 SHORT $L73393

; 5215 : 			{
; 5216 : 				dwStatusArray[i] = 0xFFFFFFFF;

  016eb	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 5217 : 				mmStatusReturn = MMSYSERR_ERROR;

  016f1	bf 01 00 00 00	 mov	 edi, 1

; 5218 : 			}
; 5219 : 			else

  016f6	eb 5b		 jmp	 SHORT $L73385
$L73393:

; 5220 : 			{
; 5221 : #ifndef OLEDECTALK
; 5222 : 				dwIdentifier[0] = PA_DEVICE_PLAYING;
; 5223 : 				
; 5224 : 				mmStatus = PA_Status( phTTS->pAudioHandle,
; 5225 : 					dwIdentifier,
; 5226 : 					dwAudioStatus,
; 5227 : 					1 );

  016f8	8b 83 d8 00 00
	00		 mov	 eax, DWORD PTR [ebx+216]
  016fe	8d 4c 24 10	 lea	 ecx, DWORD PTR _dwAudioStatus$[esp+20]
  01702	6a 01		 push	 1
  01704	8d 54 24 1c	 lea	 edx, DWORD PTR _dwIdentifier$[esp+20]
  01708	51		 push	 ecx
  01709	52		 push	 edx
  0170a	50		 push	 eax
  0170b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _dwIdentifier$[esp+32], 0
  01713	e8 00 00 00 00	 call	 _PA_Status
  01718	83 c4 10	 add	 esp, 16			; 00000010H

; 5228 : #endif //OLEDECTALK
; 5229 : 				if ( mmStatus )

  0171b	85 c0		 test	 eax, eax
  0171d	74 0d		 je	 SHORT $L73395

; 5230 : 				{
; 5231 : 					dwStatusArray[i] = 0xFFFFFFFF;

  0171f	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 5232 : 					mmStatusReturn = MMSYSERR_ERROR;

  01725	bf 01 00 00 00	 mov	 edi, 1

; 5233 : 				}
; 5234 : 				else

  0172a	eb 27		 jmp	 SHORT $L73385
$L73395:

; 5235 : 				{
; 5236 : 					dwStatusArray[i] = dwAudioStatus[0];

  0172c	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwAudioStatus$[esp+20]
  01730	89 0e		 mov	 DWORD PTR [esi], ecx

; 5237 : 				}
; 5238 : 			}
; 5239 : 			break;

  01732	eb 1f		 jmp	 SHORT $L73385
$L73391:

; 5205 : 		case INPUT_CHARACTER_COUNT:
; 5206 : 			
; 5207 : 			EnterCriticalSection( phTTS->pcsQueuedCharacterCount );

  01734	8b 93 c4 00 00
	00		 mov	 edx, DWORD PTR [ebx+196]
  0173a	52		 push	 edx
  0173b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 5208 : 			dwStatusArray[i] = phTTS->uiQueuedCharacterCount;

  01741	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  01744	89 06		 mov	 DWORD PTR [esi], eax

; 5209 : 			LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );

  01746	8b 8b c4 00 00
	00		 mov	 ecx, DWORD PTR [ebx+196]
  0174c	51		 push	 ecx
  0174d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L73385:
  01753	8b 44 24 24	 mov	 eax, DWORD PTR 20+[esp+16]
  01757	83 c6 04	 add	 esi, 4
  0175a	48		 dec	 eax
  0175b	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
  0175f	0f 85 06 ff ff
	ff		 jne	 $L73384
  01765	5e		 pop	 esi
  01766	5d		 pop	 ebp
$L73386:

; 5275 : 		}
; 5276 : 	}
; 5277 : 	return( mmStatusReturn );

  01767	8b c7		 mov	 eax, edi
  01769	5f		 pop	 edi
  0176a	5b		 pop	 ebx

; 5278 : }

  0176b	59		 pop	 ecx
  0176c	c3		 ret	 0
$L73383:

; 5193 : 		return( MMSYSERR_INVALPARAM );

  0176d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01772	5b		 pop	 ebx

; 5278 : }

  01773	59		 pop	 ecx
  01774	c3		 ret	 0
_TextToSpeechGetStatus ENDP
_TEXT	ENDS
PUBLIC	_SendBuffer
PUBLIC	_ReturnRemainingBuffers
PUBLIC	_DrainPipes
PUBLIC	_TextToSpeechAddBuffer
PUBLIC	_TextToSpeechCloseLogFile
PUBLIC	_TextToSpeechCloseSapi5Output
EXTRN	__imp__ResetEvent@4:NEAR
EXTRN	_EmptyVtmPipe:NEAR
EXTRN	_pipe_count:NEAR
EXTRN	_PA_Reset:NEAR
EXTRN	_ls_util_lts_init:NEAR
EXTRN	_OP_GetThreadPriority:NEAR
EXTRN	__imp__GetCurrentThread@0:NEAR
EXTRN	_cmd_init:NEAR
EXTRN	_phinit:NEAR
EXTRN	_InitializeVTM:NEAR
EXTRN	_free_index:NEAR
_BSS	SEGMENT
	ALIGN	4

$SG73436 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_bReset$ = 12
_mmStatus$ = 8
_bWasTyping$ = 8
_szCforce3$ = -12
_tptPriority$ = -8
_dtpSync$73424 = -4
_LastVoice$73456 = 12
_TextToSpeechReset PROC NEAR

; 5330 : {

  01780	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01783	53		 push	 ebx
  01784	55		 push	 ebp
  01785	56		 push	 esi

; 5331 :   MMRESULT mmStatus;
; 5332 :   /* Added a varaible to get handle of instance specific Kernel_share_data for MI:MVP */
; 5333 :   PKSD_T pKsd_t;
; 5334 :   LPTTS_BUFFER_T pTTS_Buffer;
; 5335 :   
; 5336 : #ifdef API_DEBUG
; 5337 :   char szTemp[256]="";
; 5338 : #endif //API_DEBUG
; 5339 :   
; 5340 : #ifdef WIN32	
; 5341 : #ifdef TYPING_MODE	// 09jun97 tek
; 5342 :   BOOL	bWasTyping=FALSE;
; 5343 :   
; 5344 :   char szCforce3[] = {  
; 5345 :     (char)((PFASCII<<PSFONT)+0xb),

  01786	b0 0b		 mov	 al, 11			; 0000000bH

; 5346 :     /*	(char)(SYNC),					
; 5347 : 	(char)((PFASCII<<PSFONT)+0xb),
; 5348 : 	(char)(SYNC),					
; 5349 :     */
; 5350 :     (char)((PFASCII<<PSFONT)+0xb),
; 5351 :     (char)(SYNC),
; 5352 :     '\0'
; 5353 :   };

  01788	33 db		 xor	 ebx, ebx
  0178a	57		 push	 edi
  0178b	88 44 24 10	 mov	 BYTE PTR _szCforce3$[esp+28], al
  0178f	88 44 24 11	 mov	 BYTE PTR _szCforce3$[esp+29], al
  01793	c6 44 24 12 0a	 mov	 BYTE PTR _szCforce3$[esp+30], 10 ; 0000000aH
  01798	88 5c 24 13	 mov	 BYTE PTR _szCforce3$[esp+31], bl

; 5354 : #endif //TYPING_MODE
; 5355 :   HANDLE hThisThread=NULL;
; 5356 :   THREAD_PRIORITY_T tptPriority=0;

  0179c	89 5c 24 14	 mov	 DWORD PTR _tptPriority$[esp+28], ebx

; 5357 :   hThisThread = GetCurrentThread();

  017a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  017a6	8b e8		 mov	 ebp, eax

; 5358 :   if (hThisThread)

  017a8	3b eb		 cmp	 ebp, ebx
  017aa	74 15		 je	 SHORT $L73419

; 5359 :     {
; 5360 : #ifndef UNDER_CE
; 5361 :       tptPriority = OP_GetThreadPriority(hThisThread);

  017ac	55		 push	 ebp
  017ad	e8 00 00 00 00	 call	 _OP_GetThreadPriority

; 5362 :       OP_SetThreadPriority(hThisThread,OP_PRIORITY_HIGHEST);

  017b2	6a 02		 push	 2
  017b4	55		 push	 ebp
  017b5	89 44 24 20	 mov	 DWORD PTR _tptPriority$[esp+40], eax
  017b9	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  017be	83 c4 0c	 add	 esp, 12			; 0000000cH
$L73419:

; 5363 : #endif
; 5364 :     }
; 5365 :   
; 5366 :   
; 5367 : #ifdef API_DEBUG
; 5368 :   // tek 10aug97 (during bats423)
; 5369 :        // fix this for typing/nontyping
; 5370 : #ifdef TYPING_MODE  // tek 10aug97 (during bats423)
; 5371 : 			       // fix this for typing/nontyping
; 5372 : #ifndef UNDER_CE
; 5373 : 	sprintf(szTemp,"TTSreset() at %ld (%d). \n",timeGetTime(),phTTS->bInTypingMode);
; 5374 : #endif
; 5375 : 
; 5376 : 
; 5377 : #else //TYPING_MODE
; 5378 :   sprintf(szTemp,"TTSreset() at %ld. \n",timeGetTime());
; 5379 : #endif //TYPING_MODE
; 5380 :   OutputDebugString(szTemp);
; 5381 : #endif //API_DEBUG
; 5382 :   
; 5383 :   /********************************************************************/
; 5384 :   /*  Return error if invalid handle.                                 */
; 5385 :   /********************************************************************/
; 5386 :   
; 5387 :   if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  017c1	8b 74 24 20	 mov	 esi, DWORD PTR _phTTS$[esp+24]
  017c5	6a 04		 push	 4
  017c7	56		 push	 esi
  017c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  017ce	85 c0		 test	 eax, eax
  017d0	74 1f		 je	 SHORT $L73420

; 5388 :     {
; 5389 : #ifndef UNDER_CE
; 5390 :       if ( hThisThread)	 // tek 09jun97

  017d2	3b eb		 cmp	 ebp, ebx
  017d4	74 0e		 je	 SHORT $L73421

; 5391 : 	  {
; 5392 : 	OP_SetThreadPriority(hThisThread,tptPriority);

  017d6	8b 44 24 14	 mov	 eax, DWORD PTR _tptPriority$[esp+28]
  017da	50		 push	 eax
  017db	55		 push	 ebp
  017dc	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  017e1	83 c4 08	 add	 esp, 8
$L73421:
  017e4	5f		 pop	 edi
  017e5	5e		 pop	 esi
  017e6	5d		 pop	 ebp

; 5393 :       }
; 5394 : #endif
; 5395 :       return( MMSYSERR_INVALHANDLE );

  017e7	b8 05 00 00 00	 mov	 eax, 5
  017ec	5b		 pop	 ebx

; 6056 : 	  return( MMSYSERR_ERROR );
; 6057 :   
; 6058 :   return( MMSYSERR_NOERROR );
; 6059 : }

  017ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  017f0	c3		 ret	 0
$L73420:

; 5396 :     }
; 5397 : 
; 5398 :   /* 16jun97 tek bats385
; 5399 :      merged 28jul97 tek
; 5400 :      lock up the synthesizer against new speech.. 
; 5401 :   */
; 5402 : #endif /* WIN32 */
; 5403 :   
; 5404 :   /********************************************************************/
; 5405 :   /*   Set the InReset flag                                           */
; 5406 :   /********************************************************************/
; 5407 :   
; 5408 : #if defined __osf__ || defined __linux__
; 5409 :   /********************************************************************/
; 5410 :   /*  Return error if invalid handle.                                 */
; 5411 :   /********************************************************************/
; 5412 :   
; 5413 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 5414 :   	{ 
; 5415 : 		// phTTS->bInReset = FALSE; // this line of code is guaranted to blow up..... MGS
; 5416 :     	return( MMSYSERR_INVALHANDLE );
; 5417 :   	}
; 5418 : #endif /* osf */
; 5419 :   
; 5420 : 	phTTS->bInReset = TRUE;
; 5421 :   	/********************************************************************/
; 5422 :   	/*  Set the halting flag. This will cause the CMD, LTS, PH, VTM,    */
; 5423 :   	/*  and SYNC threads to all discard input data and flush the pipes. */
; 5424 :   	/********************************************************************/
; 5425 :   	/* Get the current instance kernel_share_data : MVP */
; 5426 :   pKsd_t = phTTS->pKernelShareData;

  017f1	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  017f4	b8 01 00 00 00	 mov	 eax, 1
  017f9	89 86 e4 00 00
	00		 mov	 DWORD PTR [esi+228], eax

; 5427 :   
; 5428 :   pKsd_t->halting = TRUE;

  017ff	89 87 34 03 00
	00		 mov	 DWORD PTR [edi+820], eax

; 5429 :   
; 5430 :   /* ETT fixme?: why is this only win32? */
; 5431 : //#ifdef WIN32 // now it is for all MGS 02/15/2001
; 5432 : #ifdef API_DEBUG
; 5433 :   OutputDebugString("TTSreset: ->halting is set. \n");
; 5434 : #endif //API_DEBUG
; 5435 :   /********************************************************************/
; 5436 :   /*  Stop the Text To Speech thread if it is queueing text.          */
; 5437 :   /*  The Text-To-Speech thread will queue no text if the message     */
; 5438 :   /*  number is less than phTTS->uiFlushMsgNumber.                    */
; 5439 :   /* this needs to happen before we do too much.. tek 17jun97		  */
; 5440 :   /********************************************************************/
; 5441 :   EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  01805	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  0180b	51		 push	 ecx
  0180c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 5442 :   phTTS->uiFlushMsgNumber = phTTS->uiCurrentMsgNumber;

  01812	8b 46 44	 mov	 eax, DWORD PTR [esi+68]

; 5443 :   phTTS->uiCurrentMsgNumber++;
; 5444 :   LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  01815	8b 96 c0 00 00
	00		 mov	 edx, DWORD PTR [esi+192]
  0181b	89 46 50	 mov	 DWORD PTR [esi+80], eax
  0181e	40		 inc	 eax
  0181f	52		 push	 edx
  01820	89 46 44	 mov	 DWORD PTR [esi+68], eax
  01823	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 5445 :   
; 5446 :   
; 5447 : #ifdef TYPING_MODE
; 5448 :   bWasTyping = phTTS->bInTypingMode;

  01829	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  0182f	89 44 24 20	 mov	 DWORD PTR _bWasTyping$[esp+24], eax

; 5449 :   /* tek 15may97
; 5450 :      we set the PH thread's prority up here so that the first burst of
; 5451 :      sound that we need to get out in typing mode is quickly available; 
; 5452 :      after the VTM has processes two speech frames, vtmiont will drop the 
; 5453 :      PH thread back to normal priority so that any user processes can 
; 5454 :      continue running.
; 5455 :      if you change this, make sure the code in vtmiont still makes sense.
; 5456 :      */	
; 5457 :   if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)

  01833	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01839	3b c3		 cmp	 eax, ebx
  0183b	75 19		 jne	 SHORT $L73422

; 5458 :     {
; 5459 :       /* tek 19nov97 this needs to be "highest" rather than "above normal";
; 5460 : 	 also, we need to do this for both VTM and PH, and VTM will 
; 5461 : 	 readjust it later for us. (this is all to deal with responsiveness
; 5462 : 	 in the presence of greedy tasks..)
; 5463 : 	 */
; 5464 : #ifndef UNDER_CE
; 5465 :       OP_SetThreadPriority((phTTS->hThread_VTM),OP_PRIORITY_HIGHEST);

  0183d	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  01840	6a 02		 push	 2
  01842	51		 push	 ecx
  01843	e8 00 00 00 00	 call	 _OP_SetThreadPriority

; 5466 :       OP_SetThreadPriority((phTTS->hThread_PH),OP_PRIORITY_HIGHEST);

  01848	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0184b	6a 02		 push	 2
  0184d	52		 push	 edx
  0184e	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  01853	83 c4 10	 add	 esp, 16			; 00000010H
$L73422:

; 5467 : #endif
; 5468 :     }
; 5469 :   
; 5470 : #endif //TYPING_MODE
; 5471 : //#endif /* WIN32 */ // MGS not it is for all 02/15/2001
; 5472 :   
; 5473 :   pKsd_t->cmd_flush=CMD_flush_toss;
; 5474 :   
; 5475 :   /* tek 04sep96   drain the lts and ph pipes, just like on the 
; 5476 :      hardware platforms..
; 5477 :      */  
; 5478 :   DrainPipes(phTTS);

  01856	56		 push	 esi
  01857	c7 87 2c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+812], 1
  01861	e8 00 00 00 00	 call	 _DrainPipes

; 5479 :   
; 5480 : //#ifdef WIN32
; 5481 : /* MGS This should be for all platforms, but vtmio.c and vtmiont.c have
; 5482 :    to be merged first */
; 5483 :   EmptyVtmPipe(pKsd_t); /* tek 15may  */

  01866	57		 push	 edi
  01867	e8 00 00 00 00	 call	 _EmptyVtmPipe

; 5484 :   
; 5485 : #ifdef TYPING_MODE /*09jun97 tek */
; 5486 :   if (bWasTyping)

  0186c	8b 44 24 28	 mov	 eax, DWORD PTR _bWasTyping$[esp+32]
  01870	83 c4 08	 add	 esp, 8
  01873	3b c3		 cmp	 eax, ebx
  01875	74 2b		 je	 SHORT $L73423

; 5487 :     {
; 5488 :       /* start the pipes clearing out */
; 5489 :       DT_PIPE_T dtpSync = SYNC;
; 5490 :       write_pipe(pKsd_t->ph_pipe,&dtpSync,1);

  01877	8b 8f 94 02 00
	00		 mov	 ecx, DWORD PTR [edi+660]
  0187d	8d 44 24 18	 lea	 eax, DWORD PTR _dtpSync$73424[esp+28]
  01881	6a 01		 push	 1
  01883	50		 push	 eax
  01884	51		 push	 ecx
  01885	c7 44 24 24 0a
	1f 00 00	 mov	 DWORD PTR _dtpSync$73424[esp+40], 7946 ; 00001f0aH
  0188d	e8 00 00 00 00	 call	 _write_pipe

; 5491 :       /* this WFEP is important for the case where the VTM still has
; 5492 : 	 work to do from above; we need to make sure that the VTM
; 5493 : 	 IO routines get to empty before we clear the halting flag.
; 5494 : 	 */	 
; 5495 :       mmStatus = WaitForEmptyPipes( phTTS,
; 5496 : 				    MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 5497 : 				    TRUE );

  01892	6a 01		 push	 1
  01894	68 10 27 00 00	 push	 10000			; 00002710H
  01899	56		 push	 esi
  0189a	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  0189f	83 c4 18	 add	 esp, 24			; 00000018H
$L73423:

; 5498 :     }
; 5499 : #endif /* TYPING_MODE */
; 5500 : //#endif /* WIN32 */
; 5501 :   
; 5502 :   /********************************************************************/
; 5503 :   /*  Perform an audio reset to immediately stop audio from playing   */
; 5504 :   /*  and to make sure the VTM thread is not blocked.                 */
; 5505 :   /********************************************************************/
; 5506 :   
; 5507 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  018a2	39 9e 88 00 00
	00		 cmp	 DWORD PTR [esi+136], ebx
  018a8	75 0f		 jne	 SHORT $L73425

; 5508 :     {
; 5509 :       PA_Reset( phTTS->pAudioHandle );

  018aa	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  018b0	52		 push	 edx
  018b1	e8 00 00 00 00	 call	 _PA_Reset
  018b6	83 c4 04	 add	 esp, 4
$L73425:

; 5510 :     }
; 5511 :   
; 5512 :   // 09jun97tek 
; 5513 :        // at this point, we should be able to drop back to our old priority
; 5514 :        
; 5515 : #ifdef WIN32
; 5516 : #ifndef UNDER_CE
; 5517 : 	if (hThisThread)

  018b9	3b eb		 cmp	 ebp, ebx
  018bb	74 0e		 je	 SHORT $L73426

; 5518 : 		OP_SetThreadPriority(hThisThread,tptPriority);

  018bd	8b 44 24 14	 mov	 eax, DWORD PTR _tptPriority$[esp+28]
  018c1	50		 push	 eax
  018c2	55		 push	 ebp
  018c3	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  018c8	83 c4 08	 add	 esp, 8
$L73426:

; 5519 : #endif
; 5520 : #endif
; 5521 : 	
; 5522 : 	// tek 19aug96 the same anti-block issue for the memory case..
; 5523 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  018cb	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  018d2	75 5c		 jne	 SHORT $L74671

; 5524 : 	{     
; 5525 : 		// tek 29aug96 always send back the user's buffers.Do it
; 5526 : 		// now and git them out of the way.
; 5527 : 		ReturnRemainingBuffers(phTTS);

  018d4	56		 push	 esi
  018d5	e8 00 00 00 00	 call	 _ReturnRemainingBuffers

; 5528 : 		// we could have gotten stuck behind a buffer dump that happened
; 5529 : 		// "just after" the message to the calling loop that got us here;
; 5530 : 		// so, we have to queue up a dummy buffer to make sure we 
; 5531 : 		// survive the get_pipe call..
; 5532 : 		if((pKsd_t->buffer_pipe != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 1) )

  018da	8b 87 a4 02 00
	00		 mov	 eax, DWORD PTR [edi+676]
  018e0	83 c4 04	 add	 esp, 4
  018e3	3b c3		 cmp	 eax, ebx
  018e5	74 18		 je	 SHORT $L73429
  018e7	50		 push	 eax
  018e8	e8 00 00 00 00	 call	 _pipe_count
  018ed	83 c4 04	 add	 esp, 4
  018f0	83 f8 01	 cmp	 eax, 1
  018f3	73 0a		 jae	 SHORT $L73429

; 5533 : 			TextToSpeechAddBuffer(phTTS, NULL); //GetBuffer knows how to handle nulls

  018f5	53		 push	 ebx
  018f6	56		 push	 esi
  018f7	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  018fc	83 c4 08	 add	 esp, 8
$L73429:

; 5534 : 
; 5535 : 		EnterCriticalSection(phTTS->pcsMemoryBuffer);

  018ff	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  01905	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__EnterCriticalSection@4
  0190b	51		 push	 ecx
  0190c	ff d5		 call	 ebp

; 5536 : 
; 5537 : 		// if we have an active output buffer, clear it.
; 5538 : 		if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  0190e	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  01914	3b c3		 cmp	 eax, ebx
  01916	74 09		 je	 SHORT $L73433

; 5539 : 		{
; 5540 : 			
; 5541 : 			pTTS_Buffer->dwBufferLength = 0;

  01918	89 58 18	 mov	 DWORD PTR [eax+24], ebx

; 5542 : 			pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  0191b	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 5543 : 			pTTS_Buffer->dwNumberOfIndexMarks = 0;

  0191e	89 58 20	 mov	 DWORD PTR [eax+32], ebx
$L73433:

; 5544 : 			
; 5545 : 			
; 5546 : 		} // was not a null buffer
; 5547 : 
; 5548 : 		LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  01921	8b 96 b4 00 00
	00		 mov	 edx, DWORD PTR [esi+180]
  01927	52		 push	 edx
  01928	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0192e	eb 06		 jmp	 SHORT $L73427
$L74671:
  01930	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__EnterCriticalSection@4
$L73427:

; 5549 : 		
; 5550 : 	}
; 5551 : 	
; 5552 : #ifdef TYPING_MODE // tek 09jun97
; 5553 : 	if (bWasTyping)

  01936	39 5c 24 20	 cmp	 DWORD PTR _bWasTyping$[esp+24], ebx
  0193a	75 3f		 jne	 SHORT $L73435

; 5554 : 	{
; 5555 : 		
; 5556 : 	}
; 5557 : 	else
; 5558 : 	{
; 5559 : #endif //TYPING_MODE
; 5560 : 		/********************************************************************/
; 5561 : 		/*  Stop the Text To Speech thread if it is queueing text.          */
; 5562 : 		/*  The Text-To-Speech thread will queue no text if the message     */
; 5563 : 		/*  number is less than phTTS->uiFlushMsgNumber.                    */
; 5564 : 		/********************************************************************/
; 5565 : 
; 5566 : 		EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  0193c	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  01942	50		 push	 eax
  01943	ff d5		 call	 ebp

; 5567 : 		phTTS->uiFlushMsgNumber = phTTS->uiCurrentMsgNumber;

  01945	8b 46 44	 mov	 eax, DWORD PTR [esi+68]

; 5568 : 		phTTS->uiCurrentMsgNumber++;
; 5569 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  01948	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  0194e	89 46 50	 mov	 DWORD PTR [esi+80], eax
  01951	40		 inc	 eax
  01952	51		 push	 ecx
  01953	89 46 44	 mov	 DWORD PTR [esi+68], eax
  01956	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 5570 : 
; 5571 : 		// merged 28jul97 tek
; 5572 : 		// tek 16jun97 bats 385 moves the increment inside the CS
; 5573 : 		
; 5574 : 		// tek 19aug96 we now need to force speech, so that everybody
; 5575 : 		// along the way gets cleared out. We do it here, so that the
; 5576 : 		// above setting of FlushMsgNumber will allow this force to
; 5577 : 		// go through.
; 5578 : //#ifdef WIN32
; 5579 : 		TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  0195c	53		 push	 ebx
  0195d	6a 01		 push	 1
  0195f	68 00 00 00 00	 push	 OFFSET FLAT:$SG73436
  01964	56		 push	 esi
  01965	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5580 : //#endif
; 5581 : //#if defined __osf__ || defined __linux__
; 5582 : //		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5583 : //#endif
; 5584 : 		/********************************************************************/
; 5585 : 		/*  Wait for the Text thread to complete all text queueing.         */
; 5586 : 		/********************************************************************/
; 5587 : 		WaitForTextQueuingToComplete( phTTS, TRUE );

  0196a	6a 01		 push	 1
  0196c	56		 push	 esi
  0196d	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete
  01972	83 c4 18	 add	 esp, 24			; 00000018H

; 5588 : 		
; 5589 : 		
; 5590 : 		/********************************************************************/
; 5591 : 		/*  Clear the halting flag.                                         */
; 5592 : 		/********************************************************************/
; 5593 : 		
; 5594 : 		pKsd_t->halting = FALSE;

  01975	89 9f 34 03 00
	00		 mov	 DWORD PTR [edi+820], ebx
$L73435:

; 5595 : #ifdef TYPING_MODE
; 5596 : 	}
; 5597 : #endif //TYPING_MODE
; 5598 : 	
; 5599 : 	/********************************************************************/
; 5600 : 	/*  If the output state is memory then return all buffers to the    */
; 5601 : 	/*  application.  WIH 3/28/95 Changed order for proper reset.       */
; 5602 : 	/********************************************************************/
; 5603 : 	
; 5604 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  0197b	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  01982	0f 85 f4 00 00
	00		 jne	 $L73437

; 5605 : 	{
; 5606 : 		/******************************************************************/
; 5607 : 		/*  If there is nothing to reset then return.                     */
; 5608 : 		/******************************************************************/
; 5609 : 		
; 5610 : 		if (( pipe_count( pKsd_t->cmd_pipe ) == 0 )
; 5611 : 			&& ( pipe_count( pKsd_t->lts_pipe ) == 0 )
; 5612 : 			&& ( pipe_count( pKsd_t->ph_pipe ) == 0 )
; 5613 : 			&& ( pipe_count( pKsd_t->vtm_pipe ) == 0 )
; 5614 : 			&& ( pipe_count( pKsd_t->buffer_pipe) == 0))

  01988	8b 97 98 02 00
	00		 mov	 edx, DWORD PTR [edi+664]
  0198e	52		 push	 edx
  0198f	e8 00 00 00 00	 call	 _pipe_count
  01994	83 c4 04	 add	 esp, 4
  01997	85 c0		 test	 eax, eax
  01999	75 74		 jne	 SHORT $L73440
  0199b	8b 87 90 02 00
	00		 mov	 eax, DWORD PTR [edi+656]
  019a1	50		 push	 eax
  019a2	e8 00 00 00 00	 call	 _pipe_count
  019a7	83 c4 04	 add	 esp, 4
  019aa	85 c0		 test	 eax, eax
  019ac	75 61		 jne	 SHORT $L73440
  019ae	8b 8f 94 02 00
	00		 mov	 ecx, DWORD PTR [edi+660]
  019b4	51		 push	 ecx
  019b5	e8 00 00 00 00	 call	 _pipe_count
  019ba	83 c4 04	 add	 esp, 4
  019bd	85 c0		 test	 eax, eax
  019bf	75 4e		 jne	 SHORT $L73440
  019c1	8b 97 9c 02 00
	00		 mov	 edx, DWORD PTR [edi+668]
  019c7	52		 push	 edx
  019c8	e8 00 00 00 00	 call	 _pipe_count
  019cd	83 c4 04	 add	 esp, 4
  019d0	85 c0		 test	 eax, eax
  019d2	75 3b		 jne	 SHORT $L73440
  019d4	8b 87 a4 02 00
	00		 mov	 eax, DWORD PTR [edi+676]
  019da	50		 push	 eax
  019db	e8 00 00 00 00	 call	 _pipe_count
  019e0	83 c4 04	 add	 esp, 4
  019e3	85 c0		 test	 eax, eax
  019e5	75 28		 jne	 SHORT $L73440

; 5615 : 		{
; 5616 : 			// tek 22aug96 by now, the cmd parser should be well oiled. Let it go*/
; 5617 : 			pKsd_t->cmd_flush = FALSE;

  019e7	89 9f 2c 03 00
	00		 mov	 DWORD PTR [edi+812], ebx

; 5618 : #ifdef API_DEBUG
; 5619 : 			OutputDebugString("TTSReset() exiting1.\n");
; 5620 : #endif //API_DEBUG
; 5621 : 			
; 5622 : 			// 16jun97 tek bats385
; 5623 : 			// merged 28jul97 tek
; 5624 : 			phTTS->bInReset = FALSE;
; 5625 : 			
; 5626 : 			if (pipe_count( phTTS->pKernelShareData->buffer_pipe ))

  019ed	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  019f0	89 9e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ebx
  019f6	8b 91 a4 02 00
	00		 mov	 edx, DWORD PTR [ecx+676]
  019fc	52		 push	 edx
  019fd	e8 00 00 00 00	 call	 _pipe_count
  01a02	83 c4 04	 add	 esp, 4
  01a05	33 c0		 xor	 eax, eax
  01a07	5f		 pop	 edi
  01a08	5e		 pop	 esi
  01a09	5d		 pop	 ebp
  01a0a	5b		 pop	 ebx

; 6056 : 	  return( MMSYSERR_ERROR );
; 6057 :   
; 6058 :   return( MMSYSERR_NOERROR );
; 6059 : }

  01a0b	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a0e	c3		 ret	 0
$L73440:

; 5627 : 			{
; 5628 : #ifdef API_DEBUG
; 5629 : 				OutputDebugString("Reset return: still have buffers.\n");
; 5630 : #endif //API_DEBUG
; 5631 : 				return(MMSYSERR_NOERROR);
; 5632 : 			}
; 5633 : 			else
; 5634 : 				return( MMSYSERR_NOERROR );
; 5635 : 		}
; 5636 : 		
; 5637 : 		/******************************************************************/
; 5638 : 		/*  If the previous reset has not completed then just flush the   */
; 5639 : 		/*  pipes and exit.                                               */
; 5640 : 		/******************************************************************/
; 5641 : 		if ( phTTS->bMemoryReset )

  01a0f	39 9e 90 00 00
	00		 cmp	 DWORD PTR [esi+144], ebx
  01a15	74 5b		 je	 SHORT $L73443

; 5642 : 		{
; 5643 : 			// reset the sync event so that we can use it to see when 
; 5644 : 			// this stuff gets through
; 5645 : #ifdef WIN32
; 5646 : 			ResetEvent(phTTS->hSyncEvent);

  01a17	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  01a1a	50		 push	 eax
  01a1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 5647 : #endif
; 5648 : #if defined __osf__ || defined __linux__
; 5649 : 			OP_ResetEvent(phTTS->hSyncEvent);
; 5650 : #endif
; 5651 : #ifdef	TYPING_MODE // tek 17jun97
; 5652 : 			TextToSpeechSpeakEx( phTTS, szCforce3,TTS_FORCE,FALSE);

  01a21	53		 push	 ebx
  01a22	8d 4c 24 14	 lea	 ecx, DWORD PTR _szCforce3$[esp+32]
  01a26	6a 01		 push	 1
  01a28	51		 push	 ecx
  01a29	56		 push	 esi
  01a2a	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5653 : #else
; 5654 : 			
; 5655 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 5656 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 5657 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 5658 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 5659 : 			
; 5660 : #endif //TYPING_MODE
; 5661 : //#if deIfined __osf__ || defined __linux__
; 5662 : 			//OP_ResetEvent(phTTS->hSyncEvent);
; 5663 : 			//
; 5664 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5665 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5666 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5667 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5668 : //#endif
; 5669 : /****************************************************************/
; 5670 : /*  Wait until the VTM thread is about to send a buffer.        */
; 5671 : /****************************************************************/
; 5672 : /* tek 19aug96 this is probably a bad way to do it; it is 
; 5673 : better to wait for the sync even that we get from those
; 5674 : forces going through..
; 5675 : */
; 5676 : #ifdef API_DEBUG
; 5677 : sprintf(szTemp,"TTSReset wait for sync at %ld \n",timeGetTime());
; 5678 : OutputDebugString(szTemp);
; 5679 : #endif //API_DEBUG
; 5680 : #ifdef WIN32
; 5681 : 			WaitForSingleObject(phTTS->hSyncEvent,INFINITE);

  01a2f	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  01a32	83 c4 10	 add	 esp, 16			; 00000010H
  01a35	6a ff		 push	 -1
  01a37	52		 push	 edx
  01a38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 5682 : #endif
; 5683 : #if defined __osf__ || defined __linux__
; 5684 : 			OP_WaitForEvent(phTTS->hSyncEvent, OP_INFINITE);
; 5685 : #endif
; 5686 : 			//                while ( ! phTTS->bSendingBuffer )
; 5687 : 			//        {
; 5688 : 			//      Sleep( SEND_BUFFER_WAIT_TIME );
; 5689 : 			//        }
; 5690 : #ifdef API_DEBUG
; 5691 : 			sprintf(szTemp,"TTSReset sync'd at %ld\n",timeGetTime());
; 5692 : 			OutputDebugString(szTemp);
; 5693 : #endif //API_DEBUG
; 5694 : 			/****************************************************************/
; 5695 : 			/*  Empty all of the Text-To-Speech pipes.                      */
; 5696 : 			/****************************************************************/
; 5697 : 			
; 5698 : 			pKsd_t->halting = TRUE;
; 5699 : 			mmStatus = WaitForEmptyPipes( phTTS,
; 5700 : 				MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 5701 : 				TRUE );

  01a3e	6a 01		 push	 1
  01a40	68 10 27 00 00	 push	 10000			; 00002710H
  01a45	56		 push	 esi
  01a46	c7 87 34 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+820], 1
  01a50	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  01a55	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5702 : 			pKsd_t->halting = FALSE;

  01a58	89 9f 34 03 00
	00		 mov	 DWORD PTR [edi+820], ebx

; 5703 : 			// tek 29aug96 I'm not clear about the state of cmd_flush
; 5704 : 			// at this point. I don't know if I can clear it, because
; 5705 : 			// I *think* we're nested. But, I'll do it anyway.
; 5706 : 			pKsd_t->cmd_flush = FALSE;

  01a5e	89 9f 2c 03 00
	00		 mov	 DWORD PTR [edi+812], ebx

; 5707 : #ifdef API_DEBUG
; 5708 : 			if (pipe_count( pKsd_t->buffer_pipe ))
; 5709 : 			{
; 5710 : 				OutputDebugString("Reset return: still have buffers. \n");
; 5711 : 			}
; 5712 : 			OutputDebugString("TTSReset() exiting 2.\n");
; 5713 : #endif //API_DEBUG
; 5714 : 			
; 5715 : 			// 16jun97 tek bats385
; 5716 : 			// merged 28jul97 tek
; 5717 : 			phTTS->bInReset = FALSE;

  01a64	89 9e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ebx
  01a6a	5f		 pop	 edi
  01a6b	5e		 pop	 esi
  01a6c	5d		 pop	 ebp
  01a6d	5b		 pop	 ebx

; 6056 : 	  return( MMSYSERR_ERROR );
; 6057 :   
; 6058 :   return( MMSYSERR_NOERROR );
; 6059 : }

  01a6e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a71	c3		 ret	 0
$L73443:

; 5718 : 			
; 5719 : #ifdef WIN32
; 5720 : 			if (mmStatus)
; 5721 : 				return( mmStatus );
; 5722 : 			else
; 5723 : #endif
; 5724 : 				return(mmStatus);
; 5725 : 		}
; 5726 : 		
; 5727 : 		phTTS->bMemoryReset = TRUE;

  01a72	c7 86 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+144], 1
$L73437:

; 5728 :   }
; 5729 :   
; 5730 :   /********************************************************************/
; 5731 :   /*  At this point there may still be a clause stuck in ph. Force    */
; 5732 :   /*  the clause out.                                                 */
; 5733 :   /********************************************************************/
; 5734 :   
; 5735 :   /********************************************************************/
; 5736 :   /*  Set the halting flag. This will cause the CMD, LTS, PH, VTM,    */
; 5737 :   /*  and SYNC threads to all discard input data and flush the pipes. */
; 5738 :   /********************************************************************/
; 5739 : #ifdef TYPING_MODE
; 5740 :   if (!bWasTyping)

  01a7c	39 5c 24 20	 cmp	 DWORD PTR _bWasTyping$[esp+24], ebx
  01a80	75 23		 jne	 SHORT $L73444

; 5741 :   {
; 5742 : #endif //TYPING_MODE
; 5743 : 	  //tek 22aug96
; 5744 : 	  pKsd_t->halting = TRUE;
; 5745 : 	  
; 5746 : 	  
; 5747 : 
; 5748 : #ifdef	TYPING_MODE // tek 17jun97
; 5749 : 	  TextToSpeechSpeakEx( phTTS, szCforce3,TTS_FORCE,FALSE); // bats 385

  01a82	53		 push	 ebx
  01a83	8d 44 24 14	 lea	 eax, DWORD PTR _szCforce3$[esp+32]
  01a87	6a 01		 push	 1
  01a89	50		 push	 eax
  01a8a	56		 push	 esi
  01a8b	c7 87 34 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+820], 1
  01a95	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 5750 : #else
; 5751 : //#ifdef WIN32
; 5752 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 5753 : 	  /* MGS made change for SAPI so it wouldn't crash when exiting */
; 5754 : #if ! defined  OLEDECTALK && !defined SAPI5DECTALK
; 5755 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 5756 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 5757 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 5758 : #endif
; 5759 : //#endif
; 5760 : //#if defined __osf__ || defined __linux__
; 5761 : 	  //TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5762 : 	  //TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5763 : 	  //TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5764 : 	  //TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5765 : //#endif
; 5766 : #endif //TYPING_MODE
; 5767 : 	  
; 5768 : 	  /********************************************************************/
; 5769 : 	  /*  Wait for the Text thread to complete all text queueing.         */
; 5770 : 	  /********************************************************************/
; 5771 : 	  // tek 22aug96
; 5772 : 	  WaitForTextQueuingToComplete( phTTS, TRUE );

  01a9a	6a 01		 push	 1
  01a9c	56		 push	 esi
  01a9d	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete
  01aa2	83 c4 18	 add	 esp, 24			; 00000018H
$L73444:

; 5773 : #ifdef TYPING_MODE
; 5774 :   }
; 5775 : #endif //TYPING_MODE
; 5776 :   // tek 22aug96 by now, the cmd parser should be well oiled. Let it go*/
; 5777 :   pKsd_t->cmd_flush = FALSE;

  01aa5	89 9f 2c 03 00
	00		 mov	 DWORD PTR [edi+812], ebx

; 5778 :   
; 5779 :   /********************************************************************/
; 5780 :   /*  Perform an second audio reset to immediately stop audio from    */
; 5781 :   /*  playing and to make sure the VTM thread is not blocked.         */
; 5782 :   /********************************************************************/
; 5783 :   
; 5784 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01aab	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01ab1	3b c3		 cmp	 eax, ebx
  01ab3	75 0f		 jne	 SHORT $L73445

; 5785 :   {
; 5786 : 	  PA_Reset( phTTS->pAudioHandle );

  01ab5	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]
  01abb	51		 push	 ecx
  01abc	e8 00 00 00 00	 call	 _PA_Reset
  01ac1	83 c4 04	 add	 esp, 4
$L73445:

; 5787 :   }
; 5788 :   
; 5789 :   // tek 19aug96 anti-block for the memory case.. 
; 5790 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  01ac4	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  01acb	75 4a		 jne	 SHORT $L73446

; 5791 :   {
; 5792 : 	  if (pipe_count( phTTS->pKernelShareData->buffer_pipe ) < 1)

  01acd	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01ad0	8b 82 a4 02 00
	00		 mov	 eax, DWORD PTR [edx+676]
  01ad6	50		 push	 eax
  01ad7	e8 00 00 00 00	 call	 _pipe_count
  01adc	83 c4 04	 add	 esp, 4
  01adf	83 f8 01	 cmp	 eax, 1
  01ae2	73 0a		 jae	 SHORT $L73447

; 5793 : 		  TextToSpeechAddBuffer(phTTS, NULL); //deadlock avoidance

  01ae4	53		 push	 ebx
  01ae5	56		 push	 esi
  01ae6	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  01aeb	83 c4 08	 add	 esp, 8
$L73447:

; 5794 : 
; 5795 : 	  EnterCriticalSection(phTTS->pcsMemoryBuffer);

  01aee	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  01af4	51		 push	 ecx
  01af5	ff d5		 call	 ebp

; 5796 : 
; 5797 : 	  // if we have an active output buffer, clear it.
; 5798 : 	  if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  01af7	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  01afd	3b c3		 cmp	 eax, ebx
  01aff	74 09		 je	 SHORT $L73451

; 5799 : 	  {
; 5800 : 		  
; 5801 : 		  pTTS_Buffer->dwBufferLength = 0;

  01b01	89 58 18	 mov	 DWORD PTR [eax+24], ebx

; 5802 : 		  pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  01b04	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 5803 : 		  pTTS_Buffer->dwNumberOfIndexMarks = 0;

  01b07	89 58 20	 mov	 DWORD PTR [eax+32], ebx
$L73451:

; 5804 : 		  
; 5805 : 		  
; 5806 : 	  } // was not a null buffer
; 5807 : 
; 5808 : 	  LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  01b0a	8b 96 b4 00 00
	00		 mov	 edx, DWORD PTR [esi+180]
  01b10	52		 push	 edx
  01b11	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L73446:

; 5809 :   }
; 5810 :   
; 5811 :   /********************************************************************/
; 5812 :   /*  Maximize the queued sample count to release the                 */
; 5813 :   /*  WaitForAudioSampleToPlay() function (in file sync.c).           */
; 5814 :   /********************************************************************/
; 5815 : #ifdef TYPING_MODE
; 5816 :   if (!bWasTyping)

  01b17	39 5c 24 20	 cmp	 DWORD PTR _bWasTyping$[esp+24], ebx
  01b1b	75 30		 jne	 SHORT $L73453

; 5817 :   {
; 5818 : #endif //TYPING_MODE
; 5819 : 
; 5820 : 	  EnterCriticalSection( phTTS->pcsQueuedSampleCount );

  01b1d	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  01b23	50		 push	 eax
  01b24	ff d5		 call	 ebp

; 5821 : 	  phTTS->dwQueuedSampleCount = 4294967295;
; 5822 : 	  LeaveCriticalSection( phTTS->pcsQueuedSampleCount );

  01b26	8b 8e b8 00 00
	00		 mov	 ecx, DWORD PTR [esi+184]
  01b2c	c7 86 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+128], -1
  01b36	51		 push	 ecx
  01b37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 5823 : 	  
; 5824 : #ifdef TYPING_MODE
; 5825 :   }
; 5826 : #endif //TYPING_MODE
; 5827 :   /********************************************************************/
; 5828 :   /*  Empty all of the Text-To-Speech pipes.                          */
; 5829 :   /********************************************************************/
; 5830 : #ifdef TYPING_MODE
; 5831 :   if (!bWasTyping)
; 5832 : #endif //TYPING_MODE
; 5833 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 5834 : 	  MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 5835 : 	  TRUE );

  01b3d	6a 01		 push	 1
  01b3f	68 10 27 00 00	 push	 10000			; 00002710H
  01b44	56		 push	 esi
  01b45	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  01b4a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L73453:

; 5836 :   
; 5837 :   /********************************************************************/
; 5838 :   /*  Initialize the VTM, PH, LTS, and CMD threads.                   */
; 5839 :   /********************************************************************/
; 5840 : #ifdef API_DEBUG
; 5841 : sprintf(szTemp,"TTSReset init threads at %ld\n",timeGetTime());
; 5842 :   OutputDebugString(szTemp);  
; 5843 : #endif //API_DEBUG
; 5844 :   if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  01b4d	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  01b54	74 09		 je	 SHORT $L73454

; 5845 :   {
; 5846 : 	  InitializeVTM(phTTS);

  01b56	56		 push	 esi
  01b57	e8 00 00 00 00	 call	 _InitializeVTM
  01b5c	83 c4 04	 add	 esp, 4
$L73454:

; 5847 :   };
; 5848 :   
; 5849 :   
; 5850 :   phinit( phTTS, bReset );

  01b5f	8b 6c 24 24	 mov	 ebp, DWORD PTR _bReset$[esp+24]
  01b63	55		 push	 ebp
  01b64	56		 push	 esi
  01b65	e8 00 00 00 00	 call	 _phinit

; 5851 : #ifdef TYPING_MODE
; 5852 :   if (!bWasTyping)

  01b6a	8b 44 24 28	 mov	 eax, DWORD PTR _bWasTyping$[esp+32]
  01b6e	83 c4 08	 add	 esp, 8
  01b71	3b c3		 cmp	 eax, ebx
  01b73	75 17		 jne	 SHORT $L73455

; 5853 :   {
; 5854 : #endif //TYPING_MODE
; 5855 : 	  
; 5856 : 	  ls_util_lts_init(phTTS->pLTSThreadData,phTTS->pKernelShareData);

  01b75	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01b78	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01b7b	52		 push	 edx
  01b7c	50		 push	 eax
  01b7d	e8 00 00 00 00	 call	 _ls_util_lts_init

; 5857 : 	  
; 5858 : 	  
; 5859 : 	  cmd_init( phTTS,bReset );

  01b82	55		 push	 ebp
  01b83	56		 push	 esi
  01b84	e8 00 00 00 00	 call	 _cmd_init
  01b89	83 c4 10	 add	 esp, 16			; 00000010H
$L73455:

; 5860 : 	  
; 5861 : #ifdef TYPING_MODE
; 5862 :   }
; 5863 : #endif //TYPING_MODE
; 5864 :   
; 5865 :   pKsd_t->halting = FALSE;
; 5866 :   // tek 22aug96 we still need to do a LAST_VOICE to make sure the VTM */
; 5867 :   // is in a nice state..
; 5868 :   {
; 5869 :     //#if defined __osf__ || defined __linux__
; 5870 :     //	  unsigned short LastVoice=LAST_VOICE;
; 5871 :     //	  write_pipe( pKsd_t->lts_pipe, &LastVoice, 1 );
; 5872 :     //#endif
; 5873 : 
; 5874 :     //#ifdef WIN32
; 5875 : 	  unsigned short LastVoice[2];
; 5876 : #ifndef TYPING_MODE
; 5877 : 		unsigned short phone;
; 5878 : #endif
; 5879 : 	  LastVoice[0]=LAST_VOICE;
; 5880 : 	  LastVoice[1]=SYNC;
; 5881 : #ifdef TYPING_MODE
; 5882 : 	  //	if (bWasTyping)
; 5883 : 	  //	{
; 5884 : 	  write_pipe( pKsd_t->ph_pipe, &LastVoice, 2 );

  01b8c	8b 97 94 02 00
	00		 mov	 edx, DWORD PTR [edi+660]
  01b92	8d 4c 24 24	 lea	 ecx, DWORD PTR _LastVoice$73456[esp+24]
  01b96	6a 02		 push	 2
  01b98	51		 push	 ecx
  01b99	52		 push	 edx
  01b9a	89 9f 34 03 00
	00		 mov	 DWORD PTR [edi+820], ebx
  01ba0	66 c7 44 24 30
	03 1f		 mov	 WORD PTR _LastVoice$73456[esp+36], 7939 ; 00001f03H
  01ba7	66 c7 44 24 32
	0a 1f		 mov	 WORD PTR _LastVoice$73456[esp+38], 7946 ; 00001f0aH
  01bae	e8 00 00 00 00	 call	 _write_pipe

; 5885 : 	  //	}
; 5886 : 	  //	else
; 5887 : #else //TYPING_MODE
; 5888 : 	  write_pipe( pKsd_t->lts_pipe, &LastVoice, 2 );
; 5889 : 	  /* GL 01/08/98  BATS#547  force a extra space after SYNC, VT/HT to fix the
; 5890 : 	  dropping punctuation problem. */
; 5891 : 	  phone = (PFASCII<<PSFONT) + ' ';
; 5892 : 	  write_pipe( pKsd_t->lts_pipe, &phone, 1 );
; 5893 : #endif //TYPING_MODE
; 5894 : 	  //#endif
; 5895 :   }
; 5896 :   
; 5897 :   /********************************************************************/
; 5898 :   /*  Perform a third audio reset to make sure the audio queue is     */
; 5899 :   /*  empty after the pipes were emptied.                             */
; 5900 :   /********************************************************************/
; 5901 :   
; 5902 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01bb3	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01bb9	83 c4 0c	 add	 esp, 12			; 0000000cH
  01bbc	3b c3		 cmp	 eax, ebx
  01bbe	75 0f		 jne	 SHORT $L73457

; 5903 :   {
; 5904 : 	  PA_Reset( phTTS->pAudioHandle );

  01bc0	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  01bc6	50		 push	 eax
  01bc7	e8 00 00 00 00	 call	 _PA_Reset
  01bcc	83 c4 04	 add	 esp, 4
$L73457:

; 5905 :   }
; 5906 :   // tek 19aug96 anti-block for the memory case.. 
; 5907 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  01bcf	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  01bd6	75 4e		 jne	 SHORT $L73458

; 5908 :   {     
; 5909 : 	  if (pipe_count( phTTS->pKernelShareData->buffer_pipe ) < 2)

  01bd8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01bdb	8b 91 a4 02 00
	00		 mov	 edx, DWORD PTR [ecx+676]
  01be1	52		 push	 edx
  01be2	e8 00 00 00 00	 call	 _pipe_count
  01be7	83 c4 04	 add	 esp, 4
  01bea	83 f8 02	 cmp	 eax, 2
  01bed	73 0a		 jae	 SHORT $L73459

; 5910 : 		  TextToSpeechAddBuffer(phTTS, NULL); // deadlock avoidance

  01bef	53		 push	 ebx
  01bf0	56		 push	 esi
  01bf1	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  01bf6	83 c4 08	 add	 esp, 8
$L73459:

; 5911 : 
; 5912 : 	  EnterCriticalSection(phTTS->pcsMemoryBuffer);

  01bf9	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  01bff	50		 push	 eax
  01c00	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 5913 : 
; 5914 : 	  // if we have an active output buffer, clear it.
; 5915 : 	  if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  01c06	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  01c0c	3b c3		 cmp	 eax, ebx
  01c0e	74 09		 je	 SHORT $L73463

; 5916 : 	  {
; 5917 : 		  
; 5918 : 		  pTTS_Buffer->dwBufferLength = 0;

  01c10	89 58 18	 mov	 DWORD PTR [eax+24], ebx

; 5919 : 		  pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  01c13	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 5920 : 		  pTTS_Buffer->dwNumberOfIndexMarks = 0;

  01c16	89 58 20	 mov	 DWORD PTR [eax+32], ebx
$L73463:

; 5921 : 		  
; 5922 : 		  
; 5923 : 	  } // was not a null buffer
; 5924 : 
; 5925 : 	  LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  01c19	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  01c1f	51		 push	 ecx
  01c20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L73458:

; 5926 : 
; 5927 :   }
; 5928 : #ifdef TYPING_MODE
; 5929 :   if (bWasTyping)

  01c26	8b 44 24 20	 mov	 eax, DWORD PTR _bWasTyping$[esp+24]

; 5930 :   {
; 5931 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 5932 : 		  15,
; 5933 : 		  TRUE );

  01c2a	6a 01		 push	 1
  01c2c	3b c3		 cmp	 eax, ebx
  01c2e	74 04		 je	 SHORT $L73464
  01c30	6a 0f		 push	 15			; 0000000fH

; 5934 :   }
; 5935 :   else

  01c32	eb 05		 jmp	 SHORT $L74673
$L73464:

; 5936 : #endif //TYPING_MODE
; 5937 : 	  /********************************************************************/
; 5938 : 	  /*  Empty all of the Text-To-Speech pipes.                          */
; 5939 : 	  /********************************************************************/
; 5940 : 	  //tek 22aug96
; 5941 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 5942 : 	  MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 5943 : 	  TRUE );

  01c34	68 10 27 00 00	 push	 10000			; 00002710H
$L74673:
  01c39	56		 push	 esi
  01c3a	e8 00 00 00 00	 call	 _WaitForEmptyPipes

; 5944 :   
; 5945 :   
; 5946 :   /********************************************************************/
; 5947 :   /*  Zero the queued sample count (used for index marks and sync).   */
; 5948 :   /********************************************************************/
; 5949 :   
; 5950 :   EnterCriticalSection( phTTS->pcsQueuedSampleCount );

  01c3f	8b 96 b8 00 00
	00		 mov	 edx, DWORD PTR [esi+184]
  01c45	83 c4 0c	 add	 esp, 12			; 0000000cH
  01c48	89 44 24 20	 mov	 DWORD PTR _mmStatus$[esp+24], eax
  01c4c	52		 push	 edx
  01c4d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 5951 :   phTTS->dwQueuedSampleCount = 0;
; 5952 :   LeaveCriticalSection( phTTS->pcsQueuedSampleCount );

  01c53	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  01c59	89 9e 80 00 00
	00		 mov	 DWORD PTR [esi+128], ebx
  01c5f	50		 push	 eax
  01c60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 5953 :   
; 5954 :   /********************************************************************/
; 5955 :   /*  Conditionally reset the state of the Text-To-Speech system.     */
; 5956 :   /********************************************************************/
; 5957 :   
; 5958 :   
; 5959 :   if ( bReset )

  01c66	3b eb		 cmp	 ebp, ebx
  01c68	74 6e		 je	 SHORT $L73466

; 5960 :   {
; 5961 : 	  switch( phTTS->dwOutputState )
; 5962 : 	  {

  01c6a	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01c70	48		 dec	 eax
  01c71	83 f8 04	 cmp	 eax, 4
  01c74	77 28		 ja	 SHORT $L73475
  01c76	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L74675[eax*4]
$L73471:

; 5963 : 	  case STATE_OUTPUT_MEMORY:
; 5964 : 		  
; 5965 : 		  TextToSpeechCloseInMemory( phTTS );

  01c7d	56		 push	 esi
  01c7e	e8 00 00 00 00	 call	 _TextToSpeechCloseInMemory

; 5966 : 		  break;

  01c83	eb 16		 jmp	 SHORT $L74674
$L73472:

; 5967 : 		  
; 5968 : 	  case STATE_OUTPUT_WAVE_FILE:
; 5969 : 		  
; 5970 : 		  TextToSpeechCloseWaveOutFile( phTTS );

  01c85	56		 push	 esi
  01c86	e8 00 00 00 00	 call	 _TextToSpeechCloseWaveOutFile

; 5971 : 		  break;

  01c8b	eb 0e		 jmp	 SHORT $L74674
$L73473:

; 5972 : 		  
; 5973 : 	  case STATE_OUTPUT_LOG_FILE:
; 5974 : 		  
; 5975 : 		  TextToSpeechCloseLogFile( phTTS );

  01c8d	56		 push	 esi
  01c8e	e8 00 00 00 00	 call	 _TextToSpeechCloseLogFile

; 5976 : 		  break;

  01c93	eb 06		 jmp	 SHORT $L74674
$L73474:

; 5977 : 		  
; 5978 : 	  case STATE_OUTPUT_SAPI5:
; 5979 : 		  TextToSpeechCloseSapi5Output(phTTS);

  01c95	56		 push	 esi
  01c96	e8 00 00 00 00	 call	 _TextToSpeechCloseSapi5Output
$L74674:
  01c9b	83 c4 04	 add	 esp, 4
$L73475:

; 5980 : 		  break;
; 5981 : 
; 5982 : 	  default:
; 5983 : 		  break;
; 5984 : 	  }
; 5985 : 	  
; 5986 : 	  /******************************************************************/
; 5987 : 	  /*  Initialize the Text-To-Speech system state variables.         */
; 5988 : 	  /******************************************************************/
; 5989 : 	  
; 5990 : 	  pKsd_t->cmd_flush = FALSE;

  01c9e	89 9f 2c 03 00
	00		 mov	 DWORD PTR [edi+812], ebx

; 5991 : 	  pKsd_t->spc_flush = FALSE;

  01ca4	89 9f 64 03 00
	00		 mov	 DWORD PTR [edi+868], ebx

; 5992 : 	  pKsd_t->logflag  = 0;

  01caa	89 9f c4 03 00
	00		 mov	 DWORD PTR [edi+964], ebx

; 5993 : 	  /* GL 11/15/1996 set defaulted Spanish to Latin */
; 5994 : #ifdef SPANISH_LA
; 5995 : 	  pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
; 5996 : #else
; 5997 : 	  pKsd_t->modeflag = MODE_CITATION;

  01cb0	c7 87 c0 03 00
	00 00 01 00 00	 mov	 DWORD PTR [edi+960], 256 ; 00000100H

; 5998 : #endif //SPANISH_LA
; 5999 : 	  pKsd_t->sayflag = SAY_CLAUSE;

  01cba	89 9f c8 03 00
	00		 mov	 DWORD PTR [edi+968], ebx

; 6000 : 	  pKsd_t->pronflag = 0;

  01cc0	89 9f cc 03 00
	00		 mov	 DWORD PTR [edi+972], ebx

; 6001 : 	  pKsd_t->wbreak = FALSE;

  01cc6	89 9f d4 03 00
	00		 mov	 DWORD PTR [edi+980], ebx

; 6002 : 	  pKsd_t->text_flush = FALSE;

  01ccc	89 9f 30 03 00
	00		 mov	 DWORD PTR [edi+816], ebx

; 6003 : 	  pKsd_t->async_change = FALSE;

  01cd2	89 9f 00 04 00
	00		 mov	 DWORD PTR [edi+1024], ebx
$L73466:

; 6004 :   }
; 6005 :   
; 6006 :   /********************************************************************/
; 6007 :   /*  Free all allocated index mark memory.                           */
; 6008 :   /********************************************************************/
; 6009 :   
; 6010 :   
; 6011 :   free_index(pKsd_t);

  01cd8	57		 push	 edi
  01cd9	e8 00 00 00 00	 call	 _free_index

; 6012 :   
; 6013 :   /********************************************************************/
; 6014 :   /*  Enable error messages.                                          */
; 6015 :   /********************************************************************/
; 6016 :   
; 6017 :   phTTS->bEnableErrorMessage = TRUE;
; 6018 :   
; 6019 :   
; 6020 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  01cde	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01ce4	bd 01 00 00 00	 mov	 ebp, 1
  01ce9	83 c4 04	 add	 esp, 4
  01cec	3b c5		 cmp	 eax, ebp
  01cee	89 ae 8c 00 00
	00		 mov	 DWORD PTR [esi+140], ebp
  01cf4	75 09		 jne	 SHORT $L73476

; 6021 :   {
; 6022 : 	  ReturnRemainingBuffers(phTTS);   //tek 03sep96 make sure..

  01cf6	56		 push	 esi
  01cf7	e8 00 00 00 00	 call	 _ReturnRemainingBuffers
  01cfc	83 c4 04	 add	 esp, 4
$L73476:

; 6023 : 	  // tek somehow in here, Q2Mem could have snagged a buffer and
; 6024 : 	  // if so, we have to get rid of it..
; 6025 :   }
; 6026 :   
; 6027 :   if ((pKsd_t->buffer_pipe != NULL) && pipe_count(pKsd_t->buffer_pipe ) )

  01cff	8b bf a4 02 00
	00		 mov	 edi, DWORD PTR [edi+676]
  01d05	3b fb		 cmp	 edi, ebx
  01d07	74 16		 je	 SHORT $L73478
  01d09	57		 push	 edi
  01d0a	e8 00 00 00 00	 call	 _pipe_count
  01d0f	83 c4 04	 add	 esp, 4
  01d12	85 c0		 test	 eax, eax
  01d14	74 09		 je	 SHORT $L73478

; 6028 :   {
; 6029 : #ifdef API_DEBUG
; 6030 : 	  OutputDebugString("Reset return: still have buffers. \n");
; 6031 : #endif //API_DEBUG
; 6032 : 	  ReturnRemainingBuffers(phTTS);

  01d16	56		 push	 esi
  01d17	e8 00 00 00 00	 call	 _ReturnRemainingBuffers
  01d1c	83 c4 04	 add	 esp, 4
$L73478:

; 6033 :   }
; 6034 :   
; 6035 :   if (phTTS->pTTS_Buffer != NULL)

  01d1f	39 9e a4 00 00
	00		 cmp	 DWORD PTR [esi+164], ebx
  01d25	74 09		 je	 SHORT $L73480

; 6036 : 	  SendBuffer(phTTS); // tek 04sep96 get rid of current

  01d27	56		 push	 esi
  01d28	e8 00 00 00 00	 call	 _SendBuffer
  01d2d	83 c4 04	 add	 esp, 4
$L73480:

; 6037 :   // tek 29aug96 if we got this far, we know that we
; 6038 :   // can clear out MemoryReset.. normally SendBuf() would, 
; 6039 :   // but we've moved teh one that actually returns the buffers 
; 6040 :   // back in time.. 
; 6041 :   // tek 03sep96 now SendBuffer doesn't ever clear MemoryReset..
; 6042 :   phTTS->bMemoryReset = FALSE;
; 6043 :   // 16jun97 tek bats385
; 6044 :   // merged 28jul97 tek
; 6045 :   phTTS->bInReset = FALSE;
; 6046 :   
; 6047 : #ifdef API_DEBUG
; 6048 :   sprintf(szTemp,"TTSReset() exiting 3 at %ld\n",timeGetTime());
; 6049 :   OutputDebugString(szTemp);
; 6050 : #endif //API_DEBUG
; 6051 : #ifdef TYPING_MODE
; 6052 :   if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)

  01d30	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01d36	89 9e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ebx
  01d3c	3b c3		 cmp	 eax, ebx
  01d3e	89 9e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ebx
  01d44	75 06		 jne	 SHORT $L73481

; 6053 : 	  phTTS->bInTypingMode = TRUE;

  01d46	89 ae dc 00 00
	00		 mov	 DWORD PTR [esi+220], ebp
$L73481:

; 6054 : #endif //TYPING_MODE
; 6055 :   if  ( mmStatus )

  01d4c	8b 4c 24 20	 mov	 ecx, DWORD PTR _mmStatus$[esp+24]
  01d50	33 c0		 xor	 eax, eax
  01d52	5f		 pop	 edi
  01d53	3b cb		 cmp	 ecx, ebx
  01d55	5e		 pop	 esi
  01d56	5d		 pop	 ebp
  01d57	0f 95 c0	 setne	 al
  01d5a	5b		 pop	 ebx

; 6056 : 	  return( MMSYSERR_ERROR );
; 6057 :   
; 6058 :   return( MMSYSERR_NOERROR );
; 6059 : }

  01d5b	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d5e	c3		 ret	 0
  01d5f	90		 npad	 1
$L74675:
  01d60	00 00 00 00	 DD	 $L73471
  01d64	00 00 00 00	 DD	 $L73472
  01d68	00 00 00 00	 DD	 $L73473
  01d6c	00 00 00 00	 DD	 $L73475
  01d70	00 00 00 00	 DD	 $L73474
_TextToSpeechReset ENDP
_TEXT	ENDS
PUBLIC	_PumpModeMessage
EXTRN	__imp__Sleep@4:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_bReset$ = 12
_WaitForTextQueuingToComplete PROC NEAR

; 6097 : {

  01d80	53		 push	 ebx

; 6098 : 	int iLockupCount=0;
; 6099 : #ifdef API_DEBUG
; 6100 : 	char szTemp[256]="";
; 6101 : 	ULONG ulStartTime, ulEndTime;
; 6102 : 	ulStartTime=timeGetTime();
; 6103 : 	sprintf(szTemp, "WFTQTC() at %ld.\n", ulStartTime);
; 6104 : 	OutputDebugString(szTemp);
; 6105 : #endif //API_DEBUG
; 6106 : 	
; 6107 : 	/********************************************************************/
; 6108 : 	/*  Wait for the Text-To-Speech thread to complete text queueing.   */
; 6109 : 	/*  up to all messages numbered uiLastTextMessageNumber.            */
; 6110 : 	/********************************************************************/
; 6111 : 	
; 6112 : 	while ( TRUE )
; 6113 : 	{
; 6114 : 
; 6115 : 		EnterCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );
; 6116 : 
; 6117 : 		if ( phTTS->uiLastQueuedTextMsgNumber < phTTS->uiLastTextMsgNumber )

  01d81	8b 5c 24 0c	 mov	 ebx, DWORD PTR _bReset$[esp]
  01d85	55		 push	 ebp
  01d86	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__LeaveCriticalSection@4
  01d8c	56		 push	 esi
  01d8d	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  01d91	57		 push	 edi
  01d92	33 ff		 xor	 edi, edi
$L73490:
  01d94	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  01d9a	50		 push	 eax
  01d9b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  01da1	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  01da4	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  01da7	3b c8		 cmp	 ecx, eax
  01da9	73 69		 jae	 SHORT $L73492

; 6118 : 		{
; 6119 : 
; 6120 : 			LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  01dab	8b 96 bc 00 00
	00		 mov	 edx, DWORD PTR [esi+188]
  01db1	52		 push	 edx
  01db2	ff d5		 call	 ebp

; 6121 : 
; 6122 : 			/****************************************************************/
; 6123 : 			/*  Set the sync event in case the cmd thread is blocked in the */
; 6124 : 			/*  cmd_sync() function.                                        */
; 6125 : 			/****************************************************************/
; 6126 : 			
; 6127 : 			if ( bReset )

  01db4	85 db		 test	 ebx, ebx
  01db6	74 23		 je	 SHORT $L73494

; 6128 : 			{
; 6129 : #ifdef WIN32
; 6130 : 				SetEvent( phTTS->hSyncEvent );

  01db8	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  01dbb	50		 push	 eax
  01dbc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 6131 : #endif
; 6132 : #if defined __osf__ || defined __linux__
; 6133 : 				OP_SetEvent( phTTS->hSyncEvent );
; 6134 : #endif
; 6135 : 				
; 6136 : 				
; 6137 : 				/**************************************************************/
; 6138 : 				/*  Perform an audio reset to immediately stop audio from     */
; 6139 : 				/*  playing and to make sure the VTM thread is not blocked.   */
; 6140 : 				/**************************************************************/
; 6141 : 				
; 6142 : 				if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01dc2	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01dc8	85 c0		 test	 eax, eax
  01dca	75 0f		 jne	 SHORT $L73494

; 6143 : 				{
; 6144 : 					PA_Reset( phTTS->pAudioHandle );

  01dcc	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]
  01dd2	51		 push	 ecx
  01dd3	e8 00 00 00 00	 call	 _PA_Reset
  01dd8	83 c4 04	 add	 esp, 4
$L73494:

; 6145 : 				}
; 6146 : 			}
; 6147 : 			
; 6148 : 			/****************************************************************/
; 6149 : 			/*  Go to sleep while the text queue empties.                   */
; 6150 : 			/****************************************************************/
; 6151 : 			Sleep( TEXT_QUEUE_WAIT_TIME );

  01ddb	6a 05		 push	 5
  01ddd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 6152 : 			PumpModeMessage(phTTS->pAudioHandle);

  01de3	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  01de9	52		 push	 edx
  01dea	e8 00 00 00 00	 call	 _PumpModeMessage

; 6153 : 			if (( phTTS->dwOutputState == STATE_OUTPUT_MEMORY ) && ( bReset ))

  01def	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01df5	83 c4 04	 add	 esp, 4
  01df8	83 f8 01	 cmp	 eax, 1
  01dfb	75 97		 jne	 SHORT $L73490
  01dfd	85 db		 test	 ebx, ebx
  01dff	74 93		 je	 SHORT $L73490

; 6154 : 			{
; 6155 : 				iLockupCount++;

  01e01	47		 inc	 edi

; 6156 : 				
; 6157 : 				if ( iLockupCount > TEXT_LOCKUP_COUNT )

  01e02	83 ff 02	 cmp	 edi, 2
  01e05	7e 8d		 jle	 SHORT $L73490

; 6158 : 				{
; 6159 : 					FixMemoryLockup( phTTS );

  01e07	56		 push	 esi
  01e08	e8 00 00 00 00	 call	 _FixMemoryLockup
  01e0d	83 c4 04	 add	 esp, 4

; 6160 : 					
; 6161 : 					iLockupCount = 0;

  01e10	33 ff		 xor	 edi, edi
  01e12	eb 80		 jmp	 SHORT $L73490
$L73492:

; 6162 : 				}
; 6163 : 			}
; 6164 : 			
; 6165 : 		}
; 6166 : 		else
; 6167 : 		{
; 6168 : 
; 6169 : 			LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  01e14	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  01e1a	50		 push	 eax
  01e1b	ff d5		 call	 ebp
  01e1d	5f		 pop	 edi
  01e1e	5e		 pop	 esi
  01e1f	5d		 pop	 ebp
  01e20	5b		 pop	 ebx

; 6170 : 
; 6171 : 			break;
; 6172 : 		}
; 6173 : 	}
; 6174 : #ifdef API_DEBUG
; 6175 : 	ulEndTime=timeGetTime();
; 6176 : 	sprintf(szTemp, "WFTQTC() exit %ld ms.\n", ulEndTime-ulStartTime);
; 6177 : 	OutputDebugString(szTemp);
; 6178 : #endif //API_DEBUG
; 6179 : 	
; 6180 : 	return;
; 6181 : }

  01e21	c3		 ret	 0
_WaitForTextQueuingToComplete ENDP
_TEXT	ENDS
EXTRN	_PA_WaitForPlayToComplete:NEAR
EXTRN	_OP_Sleep:NEAR
_BSS	SEGMENT
	ALIGN	4

$SG73506 DB	01H DUP (?)
	ALIGN	4

$SG73507 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechSync PROC NEAR

; 6222 : {

  01e30	56		 push	 esi

; 6223 : 	MMRESULT mmStatus = MMSYSERR_NOERROR;
; 6224 : 	
; 6225 : 	/********************************************************************/
; 6226 : 	/*  Return error if invalid handle.                                 */
; 6227 : 	/********************************************************************/
; 6228 : 	
; 6229 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01e31	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01e35	6a 04		 push	 4
  01e37	56		 push	 esi
  01e38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01e3e	85 c0		 test	 eax, eax
  01e40	74 07		 je	 SHORT $L73502

; 6230 : 		return( MMSYSERR_INVALHANDLE );

  01e42	b8 05 00 00 00	 mov	 eax, 5
  01e47	5e		 pop	 esi

; 6337 : }

  01e48	c3		 ret	 0
$L73502:

; 6231 : 	
; 6232 : 	/********************************************************************/
; 6233 : 	/*  Resume if the text to speech system has been paused or this     */
; 6234 : 	/*  function will block here forever.                               */
; 6235 : 	/********************************************************************/
; 6236 : #ifndef OLEDECTALK
; 6237 : // MGS 02/15/2001 use the win32 code
; 6238 : //#if defined __osf__ || defined __linux__
; 6239 : //	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 6240 : //#endif
; 6241 : //#ifdef WIN32
; 6242 : 		if (
; 6243 : 			( ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 6244 : 			&&(!phTTS->bInReset)
; 6245 : 			)

  01e49	f7 46 78 00 00
	00 80		 test	 DWORD PTR [esi+120], -2147483648 ; 80000000H
  01e50	75 19		 jne	 SHORT $L73503
  01e52	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  01e58	85 c0		 test	 eax, eax
  01e5a	75 6a		 jne	 SHORT $L73511

; 6246 : //#endif
; 6247 : 			PA_Resume( phTTS->pAudioHandle );

  01e5c	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  01e62	50		 push	 eax
  01e63	e8 00 00 00 00	 call	 _PA_Resume
  01e68	83 c4 04	 add	 esp, 4
$L73503:

; 6248 : #endif //OLEDECTALK
; 6249 : 		/********************************************************************/
; 6250 : 		/*  Wait for the Text thread to complete all text queueing.         */
; 6251 : 		/********************************************************************/
; 6252 : //#ifdef WIN32
; 6253 : 		if (!phTTS->bInReset) // tek bats 385 merged 28jul97

  01e6b	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  01e71	85 c0		 test	 eax, eax
  01e73	75 51		 jne	 SHORT $L73511

; 6254 : //#endif
; 6255 : 		{
; 6256 : 			WaitForTextQueuingToComplete( phTTS, FALSE );

  01e75	6a 00		 push	 0
  01e77	56		 push	 esi
  01e78	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete

; 6257 : 		}
; 6258 : 		
; 6259 : 		/********************************************************************/
; 6260 : 		/*  Now that all the text is queued, make sure that it is purged.   */
; 6261 : 		/*  Four TTS_FORCE characters are used because of the way the       */
; 6262 : 		/*  WaitForEmptyPipes() function performs the wait.                 */
; 6263 : 		/********************************************************************/
; 6264 : 		
; 6265 : #ifdef WIN32
; 6266 : 		if (!phTTS->bInReset) // tek bats 385 merged 28jul97

  01e7d	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  01e83	83 c4 08	 add	 esp, 8
  01e86	85 c0		 test	 eax, eax
  01e88	75 3c		 jne	 SHORT $L73511

; 6267 : 		{
; 6268 : #ifdef UNDER_CE
; 6269 : 			TextToSpeechSpeak( phTTS, _T(""), TTS_FORCE );
; 6270 : 			TextToSpeechSpeak( phTTS, _T(""), TTS_FORCE );
; 6271 : #else
; 6272 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  01e8a	6a 01		 push	 1
  01e8c	68 00 00 00 00	 push	 OFFSET FLAT:$SG73506
  01e91	56		 push	 esi
  01e92	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 6273 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE ); /* tek 10jan97 don't need */
; 6274 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 6275 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  01e97	6a 01		 push	 1
  01e99	68 00 00 00 00	 push	 OFFSET FLAT:$SG73507
  01e9e	56		 push	 esi
  01e9f	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 6276 : #endif //UNDER_CE
; 6277 : 		}
; 6278 : #endif
; 6279 : #if defined __osf__ || defined __linux__
; 6280 : 	if (!phTTS->bInReset) 
; 6281 : 	{
; 6282 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 6283 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 6284 : 		//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 6285 : 		//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 6286 : 	}
; 6287 : #endif
; 6288 : 		
; 6289 : 		/********************************************************************/
; 6290 : 		/*  Now wait for all of the Text-To-Speech pipes to empty.          */
; 6291 : 		/********************************************************************/
; 6292 : 		/*  first, wait for the Text thread to complete all text queueing.  */
; 6293 : 		/*  (tek 10jan97)                                                   */
; 6294 : 		/********************************************************************/
; 6295 : //#ifdef WIN32
; 6296 : 		if (!phTTS->bInReset)	// tek bats 385 merged 28jul97

  01ea4	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  01eaa	83 c4 18	 add	 esp, 24			; 00000018H
  01ead	85 c0		 test	 eax, eax
  01eaf	75 15		 jne	 SHORT $L73511

; 6297 : 			WaitForTextQueuingToComplete( phTTS, FALSE );

  01eb1	6a 00		 push	 0
  01eb3	56		 push	 esi
  01eb4	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete

; 6298 : 		
; 6299 : 		// 28jul97 bats 385 merged
; 6300 : 		// this is where we think about exiting if we are in a reset;
; 6301 : 		// there is no need to do any of the subsequent waits, but we
; 6302 : 		// do want to hang here until the reset is done. 
; 6303 : 		if (phTTS->bInReset)

  01eb9	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  01ebf	83 c4 08	 add	 esp, 8
  01ec2	85 c0		 test	 eax, eax
  01ec4	74 18		 je	 SHORT $L73509
$L73511:

; 6304 : 		{
; 6305 : 			while (phTTS->bInReset)
; 6306 : 			{
; 6307 : 				OP_Sleep(SYNC_RESET_CHECK_INTERVAL);

  01ec6	6a 1e		 push	 30			; 0000001eH
  01ec8	e8 00 00 00 00	 call	 _OP_Sleep
  01ecd	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  01ed3	83 c4 04	 add	 esp, 4
  01ed6	85 c0		 test	 eax, eax
  01ed8	75 ec		 jne	 SHORT $L73511
$L73516:

; 6334 : 			}
; 6335 : 		}
; 6336 : 		return( MMSYSERR_NOERROR );

  01eda	33 c0		 xor	 eax, eax
  01edc	5e		 pop	 esi

; 6337 : }

  01edd	c3		 ret	 0
$L73509:

; 6308 : 			}
; 6309 : 			return (MMSYSERR_NOERROR);
; 6310 : 		}
; 6311 : //#endif
; 6312 : 		
; 6313 : 		mmStatus = WaitForEmptyPipes( phTTS,
; 6314 : 			MAXIMUM_SYNC_WAIT_TIME_IN_MSEC,
; 6315 : 			FALSE );

  01ede	6a 00		 push	 0
  01ee0	68 40 77 1b 00	 push	 1800000			; 001b7740H
  01ee5	56		 push	 esi
  01ee6	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  01eeb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6316 : 		
; 6317 : 		if ( mmStatus )

  01eee	85 c0		 test	 eax, eax
  01ef0	74 07		 je	 SHORT $L73513

; 6318 : 			return( MMSYSERR_ERROR );

  01ef2	b8 01 00 00 00	 mov	 eax, 1
  01ef7	5e		 pop	 esi

; 6337 : }

  01ef8	c3		 ret	 0
$L73513:

; 6319 : 		
; 6320 : 		/********************************************************************/
; 6321 : 		/*  Now that the pipes are all empty, wait for the audio to         */
; 6322 : 		/*  complete.                                                       */
; 6323 : 		/********************************************************************/
; 6324 : 		
; 6325 : 		if( ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  01ef9	f7 46 78 00 00
	00 80		 test	 DWORD PTR [esi+120], -2147483648 ; 80000000H
  01f00	75 d8		 jne	 SHORT $L73516

; 6326 : 		{
; 6327 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01f02	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01f08	85 c0		 test	 eax, eax
  01f0a	75 ce		 jne	 SHORT $L73516

; 6328 : 			{
; 6329 : #ifndef OLEDECTALK
; 6330 : 				mmStatus = PA_WaitForPlayToComplete( phTTS->pAudioHandle );

  01f0c	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]
  01f12	51		 push	 ecx
  01f13	e8 00 00 00 00	 call	 _PA_WaitForPlayToComplete
  01f18	83 c4 04	 add	 esp, 4

; 6331 : #endif //OLEDECTALK
; 6332 : 				if ( mmStatus )

  01f1b	85 c0		 test	 eax, eax
  01f1d	74 bb		 je	 SHORT $L73516

; 6333 : 					return( MMSYSERR_ERROR );

  01f1f	b8 01 00 00 00	 mov	 eax, 1
  01f24	5e		 pop	 esi

; 6337 : }

  01f25	c3		 ret	 0
_TextToSpeechSync ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetRate
_TEXT	SEGMENT
_phTTS$ = 8
_pdwRate$ = 12
_TextToSpeechGetRate PROC NEAR

; 6375 : {

  01f30	56		 push	 esi

; 6376 : 	/********************************************************************/
; 6377 : 	/*  Return error if invalid handle.                                 */
; 6378 : 	/********************************************************************/
; 6379 : 	
; 6380 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01f31	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01f35	6a 04		 push	 4
  01f37	56		 push	 esi
  01f38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01f3e	85 c0		 test	 eax, eax
  01f40	74 07		 je	 SHORT $L73522

; 6381 : 		return( MMSYSERR_INVALHANDLE );

  01f42	b8 05 00 00 00	 mov	 eax, 5
  01f47	5e		 pop	 esi

; 6394 : }

  01f48	c3		 ret	 0
$L73522:

; 6382 : 	
; 6383 : 	*pdwRate = (DWORD) phTTS->pKernelShareData->sprate ;

  01f49	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01f4c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pdwRate$[esp]
  01f50	0f bf 80 e6 03
	00 00		 movsx	 eax, WORD PTR [eax+998]

; 6384 : 	
; 6385 : 	/********************************************************************/
; 6386 : 	/*  The following range test should never fail, so the error return */
; 6387 : 	/*  is undocumented.                                                */
; 6388 : 	/********************************************************************/
; 6389 : 	
; 6390 : 	if (( *pdwRate < MIN_SPEAKING_RATE ) || ( *pdwRate > MAX_SPEAKING_RATE ))

  01f57	83 f8 32	 cmp	 eax, 50			; 00000032H
  01f5a	89 01		 mov	 DWORD PTR [ecx], eax
  01f5c	72 0b		 jb	 SHORT $L73525
  01f5e	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  01f63	77 04		 ja	 SHORT $L73525

; 6392 : 	
; 6393 : 	return( MMSYSERR_NOERROR );

  01f65	33 c0		 xor	 eax, eax
  01f67	5e		 pop	 esi

; 6394 : }

  01f68	c3		 ret	 0
$L73525:

; 6391 : 		return( MMSYSERR_ERROR );

  01f69	b8 01 00 00 00	 mov	 eax, 1
  01f6e	5e		 pop	 esi

; 6394 : }

  01f6f	c3		 ret	 0
_TextToSpeechGetRate ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetRate
_TEXT	SEGMENT
_phTTS$ = 8
_dwRate$ = 12
_TextToSpeechSetRate PROC NEAR

; 6432 : {

  01f70	56		 push	 esi

; 6433 : 	/********************************************************************/
; 6434 : 	/*  Return error if invalid handle.                                 */
; 6435 : 	/********************************************************************/
; 6436 : 	
; 6437 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01f71	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01f75	6a 04		 push	 4
  01f77	56		 push	 esi
  01f78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01f7e	85 c0		 test	 eax, eax
  01f80	74 07		 je	 SHORT $L73531

; 6438 : 		return( MMSYSERR_INVALHANDLE );

  01f82	b8 05 00 00 00	 mov	 eax, 5
  01f87	5e		 pop	 esi

; 6450 : }

  01f88	c3		 ret	 0
$L73531:

; 6439 : 	
; 6440 : 	/********************************************************************/
; 6441 : 	/*  Range test the speaking rate.                                   */
; 6442 : 	/********************************************************************/
; 6443 : 	
; 6444 : 	if (( dwRate < MIN_SPEAKING_RATE ) || ( dwRate > MAX_SPEAKING_RATE ))

  01f89	8b 44 24 0c	 mov	 eax, DWORD PTR _dwRate$[esp]
  01f8d	83 f8 32	 cmp	 eax, 50			; 00000032H
  01f90	72 15		 jb	 SHORT $L73533
  01f92	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  01f97	77 0e		 ja	 SHORT $L73533

; 6446 : 	
; 6447 : 	phTTS->pKernelShareData->sprate = (short)dwRate;

  01f99	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01f9c	5e		 pop	 esi
  01f9d	66 89 81 e6 03
	00 00		 mov	 WORD PTR [ecx+998], ax

; 6448 : 	
; 6449 : 	return( MMSYSERR_NOERROR );

  01fa4	33 c0		 xor	 eax, eax

; 6450 : }

  01fa6	c3		 ret	 0
$L73533:

; 6445 : 		return( MMSYSERR_INVALPARAM );

  01fa7	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01fac	5e		 pop	 esi

; 6450 : }

  01fad	c3		 ret	 0
_TextToSpeechSetRate ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetSpeaker
_TEXT	SEGMENT
_phTTS$ = 8
_pSpeaker$ = 12
_TextToSpeechGetSpeaker PROC NEAR

; 6487 : {

  01fb0	56		 push	 esi

; 6488 : 	/********************************************************************/
; 6489 : 	/*  Return error if invalid handle.                                 */
; 6490 : 	/********************************************************************/
; 6491 : 	
; 6492 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01fb1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01fb5	6a 04		 push	 4
  01fb7	56		 push	 esi
  01fb8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01fbe	85 c0		 test	 eax, eax
  01fc0	74 07		 je	 SHORT $L73540

; 6493 : 		return( MMSYSERR_INVALHANDLE );

  01fc2	b8 05 00 00 00	 mov	 eax, 5
  01fc7	5e		 pop	 esi

; 6505 : 		return( MMSYSERR_ERROR );
; 6506 : 	
; 6507 : 	return( MMSYSERR_NOERROR );
; 6508 : }

  01fc8	c3		 ret	 0
$L73540:

; 6494 : 	/* Also initialized new element in KSD for MI : MVP */
; 6495 : 	/* MGS 11/20/1998 BATS #571 Fixed TextToSpeechGetSpeaker */
; 6496 : 	//*pSpeaker = (SPEAKER_T)(phTTS->pKernelShareData->uiCurrentSpeaker);
; 6497 : 	*pSpeaker = (SPEAKER_T)(phTTS->pKernelShareData->last_voice);

  01fc9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01fcc	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pSpeaker$[esp]

; 6498 : 	
; 6499 : 	/********************************************************************/
; 6500 : 	/*  The following range test should never fail, so the error return */
; 6501 : 	/*  is undocumented.                                                */
; 6502 : 	/********************************************************************/
; 6503 : 	
; 6504 : 	if ( *pSpeaker > WENDY + 1 )

  01fd0	ba 09 00 00 00	 mov	 edx, 9
  01fd5	5e		 pop	 esi
  01fd6	0f bf 80 e4 03
	00 00		 movsx	 eax, WORD PTR [eax+996]
  01fdd	3b d0		 cmp	 edx, eax
  01fdf	89 01		 mov	 DWORD PTR [ecx], eax
  01fe1	1b c0		 sbb	 eax, eax
  01fe3	f7 d8		 neg	 eax

; 6505 : 		return( MMSYSERR_ERROR );
; 6506 : 	
; 6507 : 	return( MMSYSERR_NOERROR );
; 6508 : }

  01fe5	c3		 ret	 0
_TextToSpeechGetSpeaker ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetSpeaker
_TEXT	SEGMENT
_phTTS$ = 8
_Speaker$ = 12
_TextToSpeechSetSpeaker PROC NEAR

; 6546 : {

  01ff0	56		 push	 esi

; 6547 : 	/********************************************************************/
; 6548 : 	/*  Return error if invalid handle.                                 */
; 6549 : 	/********************************************************************/
; 6550 : 	
; 6551 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01ff1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01ff5	6a 04		 push	 4
  01ff7	56		 push	 esi
  01ff8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01ffe	85 c0		 test	 eax, eax
  02000	74 07		 je	 SHORT $L73548

; 6552 : 		return( MMSYSERR_INVALHANDLE );

  02002	b8 05 00 00 00	 mov	 eax, 5
  02007	5e		 pop	 esi

; 6568 : }

  02008	c3		 ret	 0
$L73548:

; 6553 : 	
; 6554 : 	/********************************************************************/
; 6555 : 	/*  Range test the speaker voice.                                   */
; 6556 : 	/********************************************************************/
; 6557 : 	
; 6558 : 	if (( Speaker < PAUL ) || ( Speaker > WENDY ))

  02009	8b 44 24 0c	 mov	 eax, DWORD PTR _Speaker$[esp]
  0200d	83 f8 08	 cmp	 eax, 8
  02010	77 0e		 ja	 SHORT $L73550

; 6560 : 	
; 6561 : 	/********************************************************************/
; 6562 : 	/*  Set voice change flag for phmain.c in the PH thread.            */
; 6563 : 	/********************************************************************/
; 6564 : 	
; 6565 : 	SetSpeaker( phTTS , Speaker );

  02012	50		 push	 eax
  02013	56		 push	 esi
  02014	e8 00 00 00 00	 call	 _SetSpeaker
  02019	83 c4 08	 add	 esp, 8

; 6566 : 	
; 6567 : 	return( MMSYSERR_NOERROR );

  0201c	33 c0		 xor	 eax, eax
  0201e	5e		 pop	 esi

; 6568 : }

  0201f	c3		 ret	 0
$L73550:

; 6559 : 		return( MMSYSERR_INVALPARAM );

  02020	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  02025	5e		 pop	 esi

; 6568 : }

  02026	c3		 ret	 0
_TextToSpeechSetSpeaker ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetLanguage
_TEXT	SEGMENT
_phTTS$ = 8
_pLanguage$ = 12
_TextToSpeechGetLanguage PROC NEAR

; 6606 : 	/********************************************************************/
; 6607 : 	/*  Return error if invalid handle.                                 */
; 6608 : 	/********************************************************************/
; 6609 : 	
; 6610 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02030	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  02034	6a 04		 push	 4
  02036	50		 push	 eax
  02037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0203d	85 c0		 test	 eax, eax
  0203f	74 06		 je	 SHORT $L73556

; 6611 : 		return( MMSYSERR_INVALHANDLE );

  02041	b8 05 00 00 00	 mov	 eax, 5

; 6616 : }

  02046	c3		 ret	 0
$L73556:

; 6612 : 	
; 6613 : 	*pLanguage = TTS_AMERICAN_ENGLISH;

  02047	8b 4c 24 08	 mov	 ecx, DWORD PTR _pLanguage$[esp-4]

; 6614 : 	
; 6615 : 	return( MMSYSERR_NOERROR );

  0204b	33 c0		 xor	 eax, eax
  0204d	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 6616 : }

  02053	c3		 ret	 0
_TextToSpeechGetLanguage ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetLanguage
_TEXT	SEGMENT
_phTTS$ = 8
_Language$ = 12
_TextToSpeechSetLanguage PROC NEAR

; 6656 : 	/********************************************************************/
; 6657 : 	/*  Return error if invalid handle.                                 */
; 6658 : 	/********************************************************************/
; 6659 : 	
; 6660 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02060	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  02064	6a 04		 push	 4
  02066	50		 push	 eax
  02067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0206d	85 c0		 test	 eax, eax
  0206f	74 06		 je	 SHORT $L73562

; 6661 : 		return( MMSYSERR_INVALHANDLE );

  02071	b8 05 00 00 00	 mov	 eax, 5

; 6664 : 		return( MMSYSERR_INVALPARAM );
; 6665 : 	
; 6666 : 	return( MMSYSERR_NOERROR );
; 6667 : }

  02076	c3		 ret	 0
$L73562:

; 6662 : 	
; 6663 : 	if ( Language != TTS_AMERICAN_ENGLISH )

  02077	8b 44 24 08	 mov	 eax, DWORD PTR _Language$[esp-4]
  0207b	48		 dec	 eax
  0207c	f7 d8		 neg	 eax
  0207e	1b c0		 sbb	 eax, eax
  02080	83 e0 0b	 and	 eax, 11			; 0000000bH

; 6664 : 		return( MMSYSERR_INVALPARAM );
; 6665 : 	
; 6666 : 	return( MMSYSERR_NOERROR );
; 6667 : }

  02083	c3		 ret	 0
_TextToSpeechSetLanguage ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetCaps
_TEXT	SEGMENT
_pTTScaps$ = 8
_TextToSpeechGetCaps PROC NEAR

; 6707 : 	if ( pTTScaps == NULL )

  02090	8b 44 24 04	 mov	 eax, DWORD PTR _pTTScaps$[esp-4]
  02094	85 c0		 test	 eax, eax
  02096	75 06		 jne	 SHORT $L73569

; 6708 : 		return( MMSYSERR_ERROR );

  02098	b8 01 00 00 00	 mov	 eax, 1

; 6724 : }

  0209d	c3		 ret	 0
$L73569:

; 6709 : 	
; 6710 : 	LanguageParamsArray[0].dwLanguage = TTS_AMERICAN_ENGLISH;

  0209e	b9 01 00 00 00	 mov	 ecx, 1
  020a3	89 0d 00 00 00
	00		 mov	 DWORD PTR _LanguageParamsArray, ecx

; 6711 : 	LanguageParamsArray[0].dwLanguageAttributes = PROPER_NAME_PRONUNCIATION;

  020a9	89 0d 04 00 00
	00		 mov	 DWORD PTR _LanguageParamsArray+4, ecx

; 6712 : 	
; 6713 : 	pTTScaps->dwNumberOfLanguages = 1;

  020af	89 08		 mov	 DWORD PTR [eax], ecx

; 6714 : 	pTTScaps->lpLanguageParamsArray = LanguageParamsArray;

  020b1	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:_LanguageParamsArray

; 6715 : 	pTTScaps->dwSampleRate = 11025;

  020b8	c7 40 08 11 2b
	00 00		 mov	 DWORD PTR [eax+8], 11025 ; 00002b11H

; 6716 : 	pTTScaps->dwMinimumSpeakingRate = MIN_SPEAKING_RATE;

  020bf	c7 40 0c 32 00
	00 00		 mov	 DWORD PTR [eax+12], 50	; 00000032H

; 6717 : 	pTTScaps->dwMaximumSpeakingRate = MAX_SPEAKING_RATE;

  020c6	c7 40 10 58 02
	00 00		 mov	 DWORD PTR [eax+16], 600	; 00000258H

; 6718 : 	pTTScaps->dwNumberOfPredefinedSpeakers = WENDY + 1;

  020cd	c7 40 14 09 00
	00 00		 mov	 DWORD PTR [eax+20], 9

; 6719 : 	pTTScaps->dwCharacterSet = TTS_ASCII;

  020d4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 6720 : 	/* GL 11/19/1998  BATS#827 use correct version number set in coop.h */
; 6721 : 	pTTScaps->Version = DTALK_MAJ_VERSION*100 + DTALK_MIN_VERSION;

  020db	c7 40 1c ce 01
	00 00		 mov	 DWORD PTR [eax+28], 462	; 000001ceH

; 6722 : 	
; 6723 : 	return( MMSYSERR_NOERROR );

  020e2	33 c0		 xor	 eax, eax

; 6724 : }

  020e4	c3		 ret	 0
_TextToSpeechGetCaps ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechLoadUserDictionary
EXTRN	_load_dictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_szFileName$ = 12
_TextToSpeechLoadUserDictionary PROC NEAR

; 6773 : {

  020f0	56		 push	 esi
  020f1	57		 push	 edi

; 6774 : 	// Added a local varaible to get the handle of current kernel_share_data handle :MVP
; 6775 : 	PKSD_T pKsd_t;
; 6776 : 
; 6777 : #ifdef UNDER_CE	//29oct99 mfg convert unicode string to char string for Windows CE
; 6778 : char chFileName[128];
; 6779 : WideStringtoAsciiString(chFileName, szFileName, 128);
; 6780 : #endif
; 6781 : 	
; 6782 : 	// Initialize with the pointer stored in phTTS :MVP */
; 6783 : 	pKsd_t = phTTS->pKernelShareData ;

  020f2	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]

; 6784 : 	
; 6785 : 	
; 6786 : 	/********************************************************************/
; 6787 : 	/*  Return error if invalid handle.                                 */
; 6788 : 	/********************************************************************/
; 6789 : 	
; 6790 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  020f6	6a 04		 push	 4
  020f8	57		 push	 edi
  020f9	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  020fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  02102	85 c0		 test	 eax, eax
  02104	74 08		 je	 SHORT $L73576
  02106	5f		 pop	 edi

; 6791 : 		return( MMSYSERR_INVALHANDLE );

  02107	b8 05 00 00 00	 mov	 eax, 5
  0210c	5e		 pop	 esi

; 6838 : #endif
; 6839 : }

  0210d	c3		 ret	 0
$L73576:

; 6792 : 	
; 6793 : 	/********************************************************************/
; 6794 : 	/*  Return error if a user dictionary is already loaded.            */
; 6795 : 	/********************************************************************/
; 6796 : 	/* Changed KS to pKsd_t :MVP */
; 6797 : 	/* GL 11/05/1997  for BATS#510 */
; 6798 : 	if ( pKsd_t->udic_entries[pKsd_t->lang_curr] != 0 )

  0210e	8b 86 b8 02 00
	00		 mov	 eax, DWORD PTR [esi+696]
  02114	8b 94 86 a8 00
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+168]
  0211b	8d 8c 86 a8 00
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+168]
  02122	85 d2		 test	 edx, edx
  02124	74 08		 je	 SHORT $L73577
  02126	5f		 pop	 edi

; 6799 : 		return( MMSYSERR_ERROR );

  02127	b8 01 00 00 00	 mov	 eax, 1
  0212c	5e		 pop	 esi

; 6838 : #endif
; 6839 : }

  0212d	c3		 ret	 0
$L73577:

; 6800 : 	
; 6801 : 	/********************************************************************/
; 6802 : 	/*  Load the user dictionary.                                       */
; 6803 : 	/********************************************************************/
; 6804 : 	
; 6805 : 	// this is very broken; should be phTTS not phTTS->hWnd!?!
; 6806 : 	/* GL 11/05/1997  for BATS#510 */
; 6807 : 	// ETT: fixme? why is the linux one different?????!
; 6808 : 
; 6809 : #if defined __osf__ || defined __linux__
; 6810 : return( load_dictionary((void **)&(pKsd_t->udic_index[pKsd_t->lang_curr]),
; 6811 : (void **)&(pKsd_t->udic_data[pKsd_t->lang_curr]),
; 6812 : (unsigned int *)&(pKsd_t->udic_entries[pKsd_t->lang_curr]),
; 6813 : (unsigned int *)&(pKsd_t->udic_bytes[pKsd_t->lang_curr]),
; 6814 : szFileName,
; 6815 : 1,
; 6816 : NULL,
; 6817 : NULL,
; 6818 : NULL,
; 6819 : MEMMAP_OFF));
; 6820 : #endif
; 6821 : #ifdef WIN32
; 6822 : 	return( load_dictionary( phTTS,
; 6823 : 		(void **)&(pKsd_t->udic_index[pKsd_t->lang_curr]),
; 6824 : 		(void **)&(pKsd_t->udic_data[pKsd_t->lang_curr]),
; 6825 : 		(unsigned int *)&(pKsd_t->udic_entries[pKsd_t->lang_curr]),
; 6826 : 		(unsigned int *)&(pKsd_t->udic_bytes[pKsd_t->lang_curr]),
; 6827 : #ifdef	UNDER_CE
; 6828 : 		chFileName,
; 6829 : #else
; 6830 : 		szFileName,
; 6831 : #endif
; 6832 : 		TRUE,
; 6833 : 		FALSE,
; 6834 : 		NULL,
; 6835 : 		NULL,
; 6836 : 		NULL,
; 6837 : 		MEMMAP_OFF));

  0212e	8b 54 24 10	 mov	 edx, DWORD PTR _szFileName$[esp+4]
  02132	6a 00		 push	 0
  02134	6a 00		 push	 0
  02136	6a 00		 push	 0
  02138	6a 00		 push	 0
  0213a	6a 00		 push	 0
  0213c	6a 01		 push	 1
  0213e	52		 push	 edx
  0213f	8d 94 86 c4 00
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+196]
  02146	52		 push	 edx
  02147	51		 push	 ecx
  02148	8d 8c 86 8c 00
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+140]
  0214f	8d 54 86 70	 lea	 edx, DWORD PTR [esi+eax*4+112]
  02153	51		 push	 ecx
  02154	52		 push	 edx
  02155	57		 push	 edi
  02156	e8 00 00 00 00	 call	 _load_dictionary
  0215b	83 c4 30	 add	 esp, 48			; 00000030H
  0215e	5f		 pop	 edi
  0215f	5e		 pop	 esi

; 6838 : #endif
; 6839 : }

  02160	c3		 ret	 0
_TextToSpeechLoadUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechUnloadUserDictionary
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechUnloadUserDictionary PROC NEAR

; 6872 : {

  02170	56		 push	 esi

; 6873 : 	/********************************************************************/
; 6874 : 	/*  Return error if invalid handle.                                 */
; 6875 : 	/********************************************************************/
; 6876 : 	
; 6877 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02171	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02175	6a 04		 push	 4
  02177	56		 push	 esi
  02178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0217e	85 c0		 test	 eax, eax
  02180	74 07		 je	 SHORT $L73588

; 6878 : 		return( MMSYSERR_INVALHANDLE );

  02182	b8 05 00 00 00	 mov	 eax, 5
  02187	5e		 pop	 esi

; 6892 : #ifdef WIN32
; 6893 : 	UNREFERENCED_PARAMETER( phTTS );
; 6894 : #endif
; 6895 : }

  02188	c3		 ret	 0
$L73588:

; 6879 : 	
; 6880 : 	/* GL 11/05/1997  for BATS#510 */
; 6881 : 	unload_dictionary((void **)&(phTTS->pKernelShareData->udic_index[phTTS->pKernelShareData->lang_curr]),
; 6882 : 		(void **)&(phTTS->pKernelShareData->udic_data[phTTS->pKernelShareData->lang_curr]),
; 6883 : 		(unsigned int *)&(phTTS->pKernelShareData->udic_entries[phTTS->pKernelShareData->lang_curr]),
; 6884 : 		(unsigned int *)&(phTTS->pKernelShareData->udic_bytes[phTTS->pKernelShareData->lang_curr]),
; 6885 : 		NULL,
; 6886 : 		NULL,
; 6887 : 		NULL,
; 6888 : 		MEMMAP_OFF 
; 6889 : 		);

  02189	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0218c	6a 00		 push	 0
  0218e	6a 00		 push	 0
  02190	6a 00		 push	 0
  02192	8b 88 b8 02 00
	00		 mov	 ecx, DWORD PTR [eax+696]
  02198	6a 00		 push	 0
  0219a	8d 94 88 c4 00
	00 00		 lea	 edx, DWORD PTR [eax+ecx*4+196]
  021a1	52		 push	 edx
  021a2	8d 94 88 a8 00
	00 00		 lea	 edx, DWORD PTR [eax+ecx*4+168]
  021a9	52		 push	 edx
  021aa	8d 94 88 8c 00
	00 00		 lea	 edx, DWORD PTR [eax+ecx*4+140]
  021b1	8d 44 88 70	 lea	 eax, DWORD PTR [eax+ecx*4+112]
  021b5	52		 push	 edx
  021b6	50		 push	 eax
  021b7	e8 00 00 00 00	 call	 _unload_dictionary
  021bc	83 c4 20	 add	 esp, 32			; 00000020H

; 6890 : 	
; 6891 : 	return( MMSYSERR_NOERROR );

  021bf	33 c0		 xor	 eax, eax
  021c1	5e		 pop	 esi

; 6892 : #ifdef WIN32
; 6893 : 	UNREFERENCED_PARAMETER( phTTS );
; 6894 : #endif
; 6895 : }

  021c2	c3		 ret	 0
_TextToSpeechUnloadUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenInMemory
_DATA	SEGMENT
	ORG $+1
$SG73621 DB	'DECtalkBufferMessage', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_dwFormat$ = 12
_TextToSpeechOpenInMemory PROC NEAR

; 6944 : {

  021d0	56		 push	 esi

; 6945 : 	P_PIPE buffer_pipe = NULL_PIPE;
; 6946 : //#ifdef WIN32
; 6947 : 	// tek bats385
; 6948 : 	// we need the "buffer delay pipe" to make sure that we 
; 6949 : 	// don't get stuck forever returning buffers if the
; 6950 : 	// user buffer callback routine immediately returns buffers
; 6951 : 	// during a reset.
; 6952 : 	P_PIPE buffer_delay_pipe = NULL_PIPE;
; 6953 : //#endif
; 6954 : 	MMRESULT mmStatus;
; 6955 : 	
; 6956 : 	/********************************************************************/
; 6957 : 	/*  Return error if invalid handle.                                 */
; 6958 : 	/********************************************************************/
; 6959 : 	
; 6960 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  021d1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  021d5	57		 push	 edi
  021d6	6a 04		 push	 4
  021d8	56		 push	 esi
  021d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  021df	85 c0		 test	 eax, eax
  021e1	74 08		 je	 SHORT $L73606
  021e3	5f		 pop	 edi

; 6961 : 		return( MMSYSERR_INVALHANDLE );

  021e4	b8 05 00 00 00	 mov	 eax, 5
  021e9	5e		 pop	 esi

; 7095 : }

  021ea	c3		 ret	 0
$L73606:

; 6962 : 	
; 6963 : 	/********************************************************************/
; 6964 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 6965 : 	/*  an error.                                                       */
; 6966 : 	/********************************************************************/
; 6967 : 	
; 6968 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 6969 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  021eb	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  021f1	85 c0		 test	 eax, eax
  021f3	74 0d		 je	 SHORT $L73607
  021f5	83 f8 04	 cmp	 eax, 4
  021f8	74 08		 je	 SHORT $L73607
  021fa	5f		 pop	 edi

; 6970 : 		return( MMSYSERR_ERROR );

  021fb	b8 01 00 00 00	 mov	 eax, 1
  02200	5e		 pop	 esi

; 7095 : }

  02201	c3		 ret	 0
$L73607:

; 6971 : 	
; 6972 : 	/********************************************************************/
; 6973 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 6974 : 	/*  function have completed.                                        */
; 6975 : 	/********************************************************************/
; 6976 : 	
; 6977 : 	mmStatus = TextToSpeechSync( phTTS );

  02202	56		 push	 esi
  02203	e8 00 00 00 00	 call	 _TextToSpeechSync
  02208	83 c4 04	 add	 esp, 4

; 6978 : 	
; 6979 : 	if ( mmStatus )

  0220b	85 c0		 test	 eax, eax

; 6980 : 		return( mmStatus );

  0220d	0f 85 db 00 00
	00		 jne	 $L73600

; 6981 : 	
; 6982 : 	/********************************************************************/
; 6983 : 	/*  If the dwFormat value is invalid then return an error.          */
; 6984 : 	/********************************************************************/
; 6985 : 	
; 6986 : 	switch( dwFormat )
; 6987 : 	{

  02213	8b 7c 24 10	 mov	 edi, DWORD PTR _dwFormat$[esp+4]
  02217	8b c7		 mov	 eax, edi
  02219	48		 dec	 eax
  0221a	74 19		 je	 SHORT $L73613
  0221c	83 e8 03	 sub	 eax, 3
  0221f	74 14		 je	 SHORT $L73613
  02221	83 e8 03	 sub	 eax, 3
  02224	74 08		 je	 SHORT $L73615
  02226	5f		 pop	 edi

; 7005 : 		
; 7006 : 	default:
; 7007 : 		
; 7008 : 		return( MMSYSERR_INVALPARAM );

  02227	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0222c	5e		 pop	 esi

; 7095 : }

  0222d	c3		 ret	 0
$L73615:

; 6997 : 		
; 6998 : 		break;
; 6999 : 		
; 7000 : 	case WAVE_FORMAT_08M08:
; 7001 : 		
; 7002 : 		SetSampleRate( phTTS, MULAW_SAMPLE_RATE );

  0222e	68 40 1f 00 00	 push	 8000			; 00001f40H

; 7003 : 		
; 7004 : 		break;

  02233	eb 05		 jmp	 SHORT $L74695
$L73613:

; 6988 : 	case WAVE_FORMAT_1M16:
; 6989 : 		
; 6990 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 6991 : 		
; 6992 : 		break;
; 6993 : 		
; 6994 : 	case WAVE_FORMAT_1M08:
; 6995 : 		
; 6996 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );

  02235	68 11 2b 00 00	 push	 11025			; 00002b11H
$L74695:
  0223a	56		 push	 esi
  0223b	e8 00 00 00 00	 call	 _SetSampleRate
  02240	83 c4 08	 add	 esp, 8

; 7009 : 	}
; 7010 : 	
; 7011 : 	phTTS->dwFormat = dwFormat;

  02243	89 be 84 00 00
	00		 mov	 DWORD PTR [esi+132], edi

; 7012 : 	
; 7013 : 	/********************************************************************/
; 7014 : 	/*  Create a pipe to send the buffer addresses to the VTM thread.   */
; 7015 : 	/********************************************************************/
; 7016 : 	
; 7017 : 	buffer_pipe = create_pipe( VOID_PTR_PIPE, BUFFER_PIPE_LENGTH );

  02249	68 00 01 00 00	 push	 256			; 00000100H
  0224e	6a 06		 push	 6
  02250	e8 00 00 00 00	 call	 _create_pipe
  02255	83 c4 08	 add	 esp, 8

; 7018 : 	
; 7019 : 	if ( buffer_pipe == NULL )

  02258	85 c0		 test	 eax, eax
  0225a	75 08		 jne	 SHORT $L73618
  0225c	5f		 pop	 edi

; 7020 : 	{
; 7021 : 		return( MMSYSERR_NOMEM );

  0225d	b8 07 00 00 00	 mov	 eax, 7
  02262	5e		 pop	 esi

; 7095 : }

  02263	c3		 ret	 0
$L73618:

; 7022 : 	}
; 7023 : 	
; 7024 : 	phTTS->pKernelShareData->buffer_pipe = buffer_pipe;

  02264	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 7025 : 	
; 7026 : //#ifdef WIN32
; 7027 : 	// 16jun97 tek bats 385 (buffer delay)
; 7028 : 	
; 7029 : 	/********************************************************************/
; 7030 : 	/*  Create a pipe to send the buffer addresses to the VTM thread.   */
; 7031 : 	/********************************************************************/
; 7032 : 	
; 7033 : 	buffer_delay_pipe = create_pipe( VOID_PTR_PIPE, BUFFER_PIPE_LENGTH );

  02267	68 00 01 00 00	 push	 256			; 00000100H
  0226c	6a 06		 push	 6
  0226e	89 81 a4 02 00
	00		 mov	 DWORD PTR [ecx+676], eax
  02274	e8 00 00 00 00	 call	 _create_pipe
  02279	83 c4 08	 add	 esp, 8

; 7034 : 	
; 7035 : 	if ( buffer_delay_pipe == NULL )

  0227c	85 c0		 test	 eax, eax
  0227e	75 08		 jne	 SHORT $L73620
  02280	5f		 pop	 edi

; 7036 : 	{
; 7037 : 		return( MMSYSERR_NOMEM );

  02281	b8 07 00 00 00	 mov	 eax, 7
  02286	5e		 pop	 esi

; 7095 : }

  02287	c3		 ret	 0
$L73620:

; 7038 : 	}
; 7039 : 	
; 7040 : 	phTTS->pKernelShareData->buffer_delay_pipe = buffer_delay_pipe;

  02288	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 7041 : 	
; 7042 : 	/********************************************************************/
; 7043 : 	/*  Get the DECtalk error message.                                  */
; 7044 : 	/********************************************************************/
; 7045 : 	
; 7046 : #ifdef CUP28PROJECT
; 7047 : 	phTTS->uiID_Buffer_Message = TTS_MSG_BUFFER;
; 7048 : #else
; 7049 : 
; 7050 : #ifdef WIN32
; 7051 : 	phTTS->uiID_Buffer_Message =
; 7052 : #ifdef UNDER_CE
; 7053 : 		RegisterWindowMessage(TEXT("DECtalkBufferMessage"));
; 7054 : #else
; 7055 : 		RegisterWindowMessage("DECtalkBufferMessage");

  0228b	68 00 00 00 00	 push	 OFFSET FLAT:$SG73621
  02290	89 82 a8 02 00
	00		 mov	 DWORD PTR [edx+680], eax
  02296	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4

; 7056 : #endif	/* UNDER_CE */
; 7057 : 	
; 7058 : 	if ( phTTS->uiID_Buffer_Message == 0 )

  0229c	85 c0		 test	 eax, eax
  0229e	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  022a1	75 08		 jne	 SHORT $L73622
  022a3	5f		 pop	 edi

; 7059 : 		return( MMSYSERR_ERROR );

  022a4	b8 01 00 00 00	 mov	 eax, 1
  022a9	5e		 pop	 esi

; 7095 : }

  022aa	c3		 ret	 0
$L73622:

; 7060 : 	
; 7061 : #endif // WIN32
; 7062 : #endif // CUP28PROJECT
; 7063 : 
; 7064 : 	/********************************************************************/
; 7065 : 	/*  Create the memory buffer critical section.                      */
; 7066 : 	/********************************************************************/
; 7067 : 	
; 7068 : #ifdef WIN32
; 7069 : 	phTTS->pcsMemoryBuffer =
; 7070 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  022ab	6a 18		 push	 24			; 00000018H
  022ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  022b3	83 c4 04	 add	 esp, 4
  022b6	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax

; 7071 : #endif
; 7072 : #if defined __osf__ || defined __linux__
; 7073 : 	phTTS->pcsMemoryBuffer = OP_CreateMutex();
; 7074 : #endif
; 7075 : 	
; 7076 : 	if ( phTTS->pcsMemoryBuffer == NULL )

  022bc	85 c0		 test	 eax, eax
  022be	75 11		 jne	 SHORT $L73626

; 7077 : 	{
; 7078 : 		DeleteTextToSpeechObjects( phTTS );

  022c0	56		 push	 esi
  022c1	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  022c6	83 c4 04	 add	 esp, 4

; 7079 : 		return( MMSYSERR_NOMEM );

  022c9	b8 07 00 00 00	 mov	 eax, 7
  022ce	5f		 pop	 edi
  022cf	5e		 pop	 esi

; 7095 : }

  022d0	c3		 ret	 0
$L73626:

; 7080 : 	}
; 7081 : 	
; 7082 : #ifdef WIN32
; 7083 : 	InitializeCriticalSection( phTTS->pcsMemoryBuffer );

  022d1	50		 push	 eax
  022d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 7084 : #endif
; 7085 : 	
; 7086 : 	/********************************************************************/
; 7087 : 	/*  Initialize the handle objects for memory output.                */
; 7088 : 	/********************************************************************/
; 7089 : 	
; 7090 : 	phTTS->pTTS_Buffer = NULL;

  022d8	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0

; 7091 : 	
; 7092 : 	phTTS->dwOutputState = STATE_OUTPUT_MEMORY;

  022e2	c7 86 88 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+136], 1

; 7093 : 	
; 7094 : 	return( MMSYSERR_NOERROR );

  022ec	33 c0		 xor	 eax, eax
$L73600:
  022ee	5f		 pop	 edi
  022ef	5e		 pop	 esi

; 7095 : }

  022f0	c3		 ret	 0
_TextToSpeechOpenInMemory ENDP
_phTTS$ = 8
_TextToSpeechCloseInMemory PROC NEAR

; 7131 : {

  02300	56		 push	 esi

; 7132 : 	/********************************************************************/
; 7133 : 	/*  Return error if invalid handle.                                 */
; 7134 : 	/********************************************************************/
; 7135 : 	
; 7136 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02301	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02305	6a 04		 push	 4
  02307	56		 push	 esi
  02308	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0230e	85 c0		 test	 eax, eax
  02310	74 07		 je	 SHORT $L73631

; 7137 : 		return( MMSYSERR_INVALHANDLE );

  02312	b8 05 00 00 00	 mov	 eax, 5
  02317	5e		 pop	 esi

; 7219 : }

  02318	c3		 ret	 0
$L73631:

; 7138 : 	
; 7139 : 	/********************************************************************/
; 7140 : 	/*  If not in MEMORY output state then return an error.             */
; 7141 : 	/********************************************************************/
; 7142 : 	
; 7143 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  02319	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0231f	b8 01 00 00 00	 mov	 eax, 1
  02324	3b c8		 cmp	 ecx, eax

; 7144 : 		return( MMSYSERR_ERROR );

  02326	0f 85 a4 00 00
	00		 jne	 $L73630

; 7145 : 	
; 7146 : #ifdef WIN32
; 7147 : 	// merged 28jul97 tek
; 7148 : 	// 16jun97 tek bats 385 sync will hang forever if we don't clear
; 7149 : 	// bInReset..
; 7150 : 
; 7151 : 	// MGS change this code.  if we are in reset, don't call Sync
; 7152 : //	phTTS->bInReset = FALSE;
; 7153 : 	if (!phTTS->bInReset)

  0232c	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  02332	85 c0		 test	 eax, eax
  02334	75 09		 jne	 SHORT $L73633

; 7154 : #endif
; 7155 : 	
; 7156 : 	/********************************************************************/
; 7157 : 	/*  Halt the system and flush all data.                             */
; 7158 : 	/********************************************************************/
; 7159 : 	
; 7160 : 	TextToSpeechSync( phTTS );

  02336	56		 push	 esi
  02337	e8 00 00 00 00	 call	 _TextToSpeechSync
  0233c	83 c4 04	 add	 esp, 4
$L73633:

; 7161 : 	
; 7162 : 	// MGS moved this code up so that the rescources would not be in use
; 7163 : 	// when freed below
; 7164 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  0233f	8b 46 78	 mov	 eax, DWORD PTR [esi+120]

; 7165 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 7166 : 	else
; 7167 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 7168 : 
; 7169 : 	EnterCriticalSection(phTTS->pcsBufferPipe);	

  02342	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  02348	c1 e8 1d	 shr	 eax, 29			; 0000001dH
  0234b	83 e0 04	 and	 eax, 4
  0234e	51		 push	 ecx
  0234f	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  02355	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7170 : 	
; 7171 : 	/********************************************************************/
; 7172 : 	/*  Delete the memory buffer critical section.                      */
; 7173 : 	/********************************************************************/
; 7174 : 	
; 7175 : 	if ( phTTS->pcsMemoryBuffer != NULL )

  0235b	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  02361	85 c0		 test	 eax, eax
  02363	74 17		 je	 SHORT $L73637

; 7176 : 	{
; 7177 : 
; 7178 : #ifdef WIN32
; 7179 : 		DeleteCriticalSection( phTTS->pcsMemoryBuffer );

  02365	50		 push	 eax
  02366	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 7180 : 		
; 7181 : 		free( phTTS->pcsMemoryBuffer );

  0236c	8b 96 b4 00 00
	00		 mov	 edx, DWORD PTR [esi+180]
  02372	52		 push	 edx
  02373	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02379	83 c4 04	 add	 esp, 4
$L73637:

; 7182 : #endif
; 7183 : #if defined __osf__ || defined __linux__
; 7184 : 		OP_DestroyMutex( phTTS->pcsMemoryBuffer );
; 7185 : #endif
; 7186 : 	}
; 7187 : 	
; 7188 : 	/********************************************************************/
; 7189 : 	/*  Delete the memory buffer pipe.                                  */
; 7190 : 	/********************************************************************/
; 7191 : 	
; 7192 : 	destroy_pipe( phTTS->pKernelShareData->buffer_pipe );

  0237c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0237f	8b 88 a4 02 00
	00		 mov	 ecx, DWORD PTR [eax+676]
  02385	51		 push	 ecx
  02386	e8 00 00 00 00	 call	 _destroy_pipe

; 7193 : 	// tek 30aug96 null the pointer.
; 7194 : 	phTTS->pKernelShareData->buffer_pipe = NULL;

  0238b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0238e	c7 82 a4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+676], 0

; 7195 : 	
; 7196 : #ifdef WIN32
; 7197 : 	// merged 28jul97 tek
; 7198 : 	// 16jun97 tek bats 385 (buffer delay)
; 7199 : 	destroy_pipe( phTTS->pKernelShareData->buffer_delay_pipe );

  02398	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0239b	8b 88 a8 02 00
	00		 mov	 ecx, DWORD PTR [eax+680]
  023a1	51		 push	 ecx
  023a2	e8 00 00 00 00	 call	 _destroy_pipe

; 7200 : 	phTTS->pKernelShareData->buffer_delay_pipe = NULL;

  023a7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  023aa	83 c4 08	 add	 esp, 8
  023ad	c7 82 a8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+680], 0

; 7201 : #endif
; 7202 : 	
; 7203 : 	/********************************************************************/
; 7204 : 	/*  Set the system output state to audio if it is enabled.          */
; 7205 : 	/********************************************************************/
; 7206 : 	
; 7207 : 	LeaveCriticalSection(phTTS->pcsBufferPipe);

  023b7	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  023bd	50		 push	 eax
  023be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7208 : 
; 7209 : 	phTTS->pTTS_Buffer = NULL;

  023c4	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0

; 7210 : 	
; 7211 : #ifdef MOVED_CODE_UP
; 7212 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 7213 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 7214 : 	else
; 7215 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 7216 : #endif
; 7217 : 
; 7218 : 	return( MMSYSERR_NOERROR );

  023ce	33 c0		 xor	 eax, eax
$L73630:
  023d0	5e		 pop	 esi

; 7219 : }

  023d1	c3		 ret	 0
_TextToSpeechCloseInMemory ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG73649 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pTTS_Buffer$ = 12
_pPipeArray$ = 8
_TextToSpeechAddBuffer PROC NEAR

; 7256 : {

  023e0	56		 push	 esi

; 7257 : 	LPTTS_BUFFER_T pPipeArray[1];
; 7258 : 	unsigned int uiI;
; 7259 : 	char szTemp[256]="";
; 7260 : 	
; 7261 : #ifdef API_DEBUG
; 7262 : 	OutputDebugString("TTSAddBuffer().\n");
; 7263 : 	
; 7264 : 	if (pTTS_Buffer == NULL)
; 7265 : 	{
; 7266 : 		OutputDebugString("  ..adding null buffer.\n");
; 7267 : 	}
; 7268 : 	else
; 7269 : 	{
; 7270 : 		OutputDebugString("  ..adding user buffer.\n");
; 7271 : 	}
; 7272 : #endif //API_DEBUG
; 7273 : 	
; 7274 : 	/********************************************************************/
; 7275 : 	/*  Return error if invalid handle.                                 */
; 7276 : 	/********************************************************************/
; 7277 : 	
; 7278 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  023e1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  023e5	6a 04		 push	 4
  023e7	56		 push	 esi
  023e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  023ee	85 c0		 test	 eax, eax
  023f0	74 07		 je	 SHORT $L73650

; 7279 : 		return( MMSYSERR_INVALHANDLE );

  023f2	b8 05 00 00 00	 mov	 eax, 5
  023f7	5e		 pop	 esi

; 7325 : }

  023f8	c3		 ret	 0
$L73650:

; 7280 : 	
; 7281 : 	/********************************************************************/
; 7282 : 	/*  If not in MEMORY output state then return an error.             */
; 7283 : 	/********************************************************************/
; 7284 : 	
; 7285 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  023f9	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  02400	74 07		 je	 SHORT $L73651

; 7286 : 		return( MMSYSERR_ERROR );

  02402	b8 01 00 00 00	 mov	 eax, 1
  02407	5e		 pop	 esi

; 7325 : }

  02408	c3		 ret	 0
$L73651:

; 7287 : 	
; 7288 : 	/********************************************************************/
; 7289 : 	/*  Send the wave header to the VTM thread.                         */
; 7290 : 	/********************************************************************/
; 7291 : 	
; 7292 : 	pPipeArray[0] = pTTS_Buffer;
; 7293 : 	
; 7294 : 	// tek 03sep96 add some debugging info here..
; 7295 : #ifdef WIN32
; 7296 : 	//LockPipe( phTTS->pKernelShareData->buffer_pipe );
; 7297 : 	OP_LockMutex( phTTS->pcsBufferPipe);

  02409	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  0240f	8b 44 24 0c	 mov	 eax, DWORD PTR _pTTS_Buffer$[esp]
  02413	51		 push	 ecx
  02414	89 44 24 0c	 mov	 DWORD PTR _pPipeArray$[esp+4], eax
  02418	e8 00 00 00 00	 call	 _OP_LockMutex

; 7298 : #endif
; 7299 : #if defined __osf__ || defined __linux__
; 7300 : 	OP_LockMutex( phTTS->pcsBufferPipe);
; 7301 : #endif
; 7302 : 	// check the state again as this could have been waiting on the mutex
; 7303 : 	// and it was locked by TextToSpeechCloseInMemory
; 7304 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  0241d	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  02423	83 c4 04	 add	 esp, 4
  02426	83 f8 01	 cmp	 eax, 1
  02429	74 16		 je	 SHORT $L73652

; 7305 : 	{
; 7306 : 		OP_UnlockMutex( phTTS->pcsBufferPipe );

  0242b	8b 96 cc 00 00
	00		 mov	 edx, DWORD PTR [esi+204]
  02431	52		 push	 edx
  02432	e8 00 00 00 00	 call	 _OP_UnlockMutex
  02437	83 c4 04	 add	 esp, 4

; 7307 : 		return( MMSYSERR_ERROR );

  0243a	b8 01 00 00 00	 mov	 eax, 1
  0243f	5e		 pop	 esi

; 7325 : }

  02440	c3		 ret	 0
$L73652:

; 7308 : 	}
; 7309 : 
; 7310 : 	write_pipe( phTTS->pKernelShareData->buffer_pipe, pPipeArray, 1 );

  02441	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02444	8d 44 24 08	 lea	 eax, DWORD PTR _pPipeArray$[esp]
  02448	6a 01		 push	 1
  0244a	50		 push	 eax
  0244b	8b 91 a4 02 00
	00		 mov	 edx, DWORD PTR [ecx+676]
  02451	52		 push	 edx
  02452	e8 00 00 00 00	 call	 _write_pipe

; 7311 : 	uiI = pipe_count( phTTS->pKernelShareData->buffer_pipe );

  02457	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0245a	8b 88 a4 02 00
	00		 mov	 ecx, DWORD PTR [eax+676]
  02460	51		 push	 ecx
  02461	e8 00 00 00 00	 call	 _pipe_count

; 7312 : #ifdef WIN32
; 7313 : #ifdef API_DEBUG
; 7314 : 	sprintf(szTemp,"Added buffer %08lx, count now %d\n",
; 7315 : 		pPipeArray[0], uiI);
; 7316 : 	OutputDebugString(szTemp);
; 7317 : #endif //API_DEBUG
; 7318 : 	OP_UnlockMutex( phTTS->pcsBufferPipe );

  02466	8b 96 cc 00 00
	00		 mov	 edx, DWORD PTR [esi+204]
  0246c	52		 push	 edx
  0246d	e8 00 00 00 00	 call	 _OP_UnlockMutex
  02472	83 c4 14	 add	 esp, 20			; 00000014H

; 7319 : //	UnlockPipe( phTTS->pKernelShareData->buffer_pipe );
; 7320 : #endif
; 7321 : #if defined __osf__ || defined __linux__
; 7322 : 	OP_UnlockMutex( phTTS->pcsBufferPipe );
; 7323 : #endif
; 7324 : 	return( MMSYSERR_NOERROR );

  02475	33 c0		 xor	 eax, eax
  02477	5e		 pop	 esi

; 7325 : }

  02478	c3		 ret	 0
_TextToSpeechAddBuffer ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReturnBuffer
_TEXT	SEGMENT
_phTTS$ = 8
_ppTTS_Buffer$ = 12
_TextToSpeechReturnBuffer PROC NEAR

; 7364 : {

  02480	56		 push	 esi

; 7365 : 	/********************************************************************/
; 7366 : 	/*  Return error if invalid handle.                                 */
; 7367 : 	/********************************************************************/
; 7368 : #ifdef API_DEBUG
; 7369 : 	OutputDebugString("TTSReturnBuffer() ?? \n");
; 7370 : #endif //API_DEBUG
; 7371 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02481	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02485	6a 04		 push	 4
  02487	56		 push	 esi
  02488	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0248e	85 c0		 test	 eax, eax
  02490	74 07		 je	 SHORT $L73658

; 7372 : 		return( MMSYSERR_INVALHANDLE );

  02492	b8 05 00 00 00	 mov	 eax, 5
  02497	5e		 pop	 esi

; 7398 : }

  02498	c3		 ret	 0
$L73658:

; 7373 : 	
; 7374 : 	/********************************************************************/
; 7375 : 	/*  If not in MEMORY output state then return an error.             */
; 7376 : 	/********************************************************************/
; 7377 : 	
; 7378 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  02499	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0249f	b8 01 00 00 00	 mov	 eax, 1
  024a4	3b c8		 cmp	 ecx, eax

; 7379 : 		return( MMSYSERR_ERROR );

  024a6	75 32		 jne	 SHORT $L73657

; 7380 : 	
; 7381 : 	/********************************************************************/
; 7382 : 	/*  Return the last buffer to the application.                      */
; 7383 : 	/*  Block if the buffer is busy.                                    */
; 7384 : 	/********************************************************************/
; 7385 : 
; 7386 : 	EnterCriticalSection( phTTS->pcsMemoryBuffer );

  024a8	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  024ae	50		 push	 eax
  024af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7387 : 
; 7388 : 	*ppTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  024b5	8b 54 24 0c	 mov	 edx, DWORD PTR _ppTTS_Buffer$[esp]
  024b9	8b 8e a4 00 00
	00		 mov	 ecx, DWORD PTR [esi+164]
  024bf	89 0a		 mov	 DWORD PTR [edx], ecx

; 7389 : 	phTTS->pTTS_Buffer = NULL;
; 7390 : 	
; 7391 : 	/********************************************************************/
; 7392 : 	/*  Release the buffer.                                             */
; 7393 : 	/********************************************************************/
; 7394 : 
; 7395 : 	LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  024c1	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  024c7	50		 push	 eax
  024c8	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0
  024d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7396 : 
; 7397 : 	return( MMSYSERR_NOERROR );

  024d8	33 c0		 xor	 eax, eax
$L73657:
  024da	5e		 pop	 esi

; 7398 : }

  024db	c3		 ret	 0
_TextToSpeechReturnBuffer ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenLogFile
_DATA	SEGMENT
	ORG $+3
$SG73677 DB	'w', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pszFileName$ = 12
_dwFlags$ = 16
_TextToSpeechOpenLogFile PROC NEAR

; 7460 : {

  024e0	53		 push	 ebx
  024e1	56		 push	 esi

; 7461 : 	MMRESULT mmStatus;
; 7462 : 	
; 7463 : 	/********************************************************************/
; 7464 : 	/*  Return error if invalid handle.                                 */
; 7465 : 	/********************************************************************/
; 7466 : 	
; 7467 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  024e2	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  024e6	57		 push	 edi
  024e7	6a 04		 push	 4
  024e9	56		 push	 esi
  024ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  024f0	85 c0		 test	 eax, eax
  024f2	74 09		 je	 SHORT $L73670
  024f4	5f		 pop	 edi
  024f5	5e		 pop	 esi

; 7468 : 		return( MMSYSERR_INVALHANDLE );

  024f6	b8 05 00 00 00	 mov	 eax, 5
  024fb	5b		 pop	 ebx

; 7551 : }

  024fc	c3		 ret	 0
$L73670:

; 7469 : 	
; 7470 : 	/********************************************************************/
; 7471 : 	/*  If a file is already open, then don't try to open another one.  */
; 7472 : 	/********************************************************************/
; 7473 : 	
; 7474 : 
; 7475 : 	EnterCriticalSection( phTTS->pcsLogFile );

  024fd	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  02503	50		 push	 eax
  02504	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7476 : 
; 7477 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE )

  0250a	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  02510	83 f8 03	 cmp	 eax, 3
  02513	75 16		 jne	 SHORT $L73671

; 7478 : 	{
; 7479 : 
; 7480 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  02515	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  0251b	51		 push	 ecx
  0251c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02522	5f		 pop	 edi
  02523	5e		 pop	 esi

; 7481 : 
; 7482 : 		return( MMSYSERR_ALLOCATED );

  02524	b8 04 00 00 00	 mov	 eax, 4
  02529	5b		 pop	 ebx

; 7551 : }

  0252a	c3		 ret	 0
$L73671:

; 7483 : 	}
; 7484 : 	
; 7485 : 	/********************************************************************/
; 7486 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 7487 : 	/*  an error.                                                       */
; 7488 : 	/********************************************************************/
; 7489 : 	
; 7490 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 7491 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  0252b	85 c0		 test	 eax, eax
  0252d	74 1b		 je	 SHORT $L73672
  0252f	83 f8 04	 cmp	 eax, 4
  02532	74 16		 je	 SHORT $L73672

; 7492 : 	{
; 7493 : 
; 7494 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  02534	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  0253a	52		 push	 edx
  0253b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02541	5f		 pop	 edi
  02542	5e		 pop	 esi

; 7495 : 
; 7496 : 		return( MMSYSERR_ERROR );

  02543	b8 01 00 00 00	 mov	 eax, 1
  02548	5b		 pop	 ebx

; 7551 : }

  02549	c3		 ret	 0
$L73672:

; 7497 : 	}
; 7498 : 	
; 7499 : 	/********************************************************************/
; 7500 : 	/*  Make sure the arguments are valid.                              */
; 7501 : 	/********************************************************************/
; 7502 : 	
; 7503 : 	if ( dwFlags & ~( LOG_TEXT | LOG_PHONEMES | LOG_SYLLABLES ))

  0254a	8b 5c 24 18	 mov	 ebx, DWORD PTR _dwFlags$[esp+8]
  0254e	f7 c3 ec ff ff
	ff		 test	 ebx, -20		; ffffffecH
  02554	74 16		 je	 SHORT $L73673

; 7504 : 	{
; 7505 : 
; 7506 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  02556	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  0255c	50		 push	 eax
  0255d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02563	5f		 pop	 edi
  02564	5e		 pop	 esi

; 7507 : 
; 7508 : 		return( MMSYSERR_INVALPARAM );

  02565	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0256a	5b		 pop	 ebx

; 7551 : }

  0256b	c3		 ret	 0
$L73673:

; 7509 : 	}
; 7510 : 	
; 7511 : 	/********************************************************************/
; 7512 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 7513 : 	/*  function have completed.                                        */
; 7514 : 	/********************************************************************/
; 7515 : 	
; 7516 : 	mmStatus = TextToSpeechSync( phTTS );

  0256c	56		 push	 esi
  0256d	e8 00 00 00 00	 call	 _TextToSpeechSync
  02572	8b f8		 mov	 edi, eax
  02574	83 c4 04	 add	 esp, 4

; 7517 : 	
; 7518 : 	if ( mmStatus )

  02577	85 ff		 test	 edi, edi
  02579	74 13		 je	 SHORT $L73674

; 7519 : 	{
; 7520 : 
; 7521 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  0257b	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  02581	51		 push	 ecx
  02582	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7522 : 
; 7523 : 		return( mmStatus );

  02588	8b c7		 mov	 eax, edi
  0258a	5f		 pop	 edi
  0258b	5e		 pop	 esi
  0258c	5b		 pop	 ebx

; 7551 : }

  0258d	c3		 ret	 0
$L73674:

; 7524 : 	}
; 7525 : 	
; 7526 : 	/********************************************************************/
; 7527 : 	/*  Open the log file.                                              */
; 7528 : 	/********************************************************************/
; 7529 : 	
; 7530 : #ifdef UNDER_CE
; 7531 : 	if (( phTTS->pLogFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)) == NULL )
; 7532 : #else
; 7533 : 	if (( phTTS->pLogFile = fopen( pszFileName, "w" )) == NULL )

  0258e	8b 54 24 14	 mov	 edx, DWORD PTR _pszFileName$[esp+8]
  02592	68 00 00 00 00	 push	 OFFSET FLAT:$SG73677
  02597	52		 push	 edx
  02598	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0259e	83 c4 08	 add	 esp, 8
  025a1	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  025a7	85 c0		 test	 eax, eax
  025a9	75 16		 jne	 SHORT $L73676

; 7534 : #endif
; 7535 : 	{
; 7536 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  025ab	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  025b1	50		 push	 eax
  025b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  025b8	5f		 pop	 edi
  025b9	5e		 pop	 esi

; 7537 : 
; 7538 : 		return( MMSYSERR_ERROR );

  025ba	b8 01 00 00 00	 mov	 eax, 1
  025bf	5b		 pop	 ebx

; 7551 : }

  025c0	c3		 ret	 0
$L73676:

; 7539 : 	}
; 7540 : 	
; 7541 : 	/********************************************************************/
; 7542 : 	/*  Set the log file control variables.                             */
; 7543 : 	/********************************************************************/
; 7544 : 	
; 7545 : 	phTTS->pKernelShareData->logflag = dwFlags;

  025c1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  025c4	89 99 c4 03 00
	00		 mov	 DWORD PTR [ecx+964], ebx

; 7546 : 	phTTS->dwOutputState = STATE_OUTPUT_LOG_FILE;
; 7547 : 	
; 7548 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  025ca	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  025d0	52		 push	 edx
  025d1	c7 86 88 00 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+136], 3
  025db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  025e1	5f		 pop	 edi
  025e2	5e		 pop	 esi

; 7549 : 
; 7550 : 	return( MMSYSERR_NOERROR );

  025e3	33 c0		 xor	 eax, eax
  025e5	5b		 pop	 ebx

; 7551 : }

  025e6	c3		 ret	 0
_TextToSpeechOpenLogFile ENDP
_TEXT	ENDS
EXTRN	__imp___flushall:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechCloseLogFile PROC NEAR

; 7587 : {

  025f0	56		 push	 esi

; 7588 : 	MMRESULT mmStatus;
; 7589 : 	
; 7590 : 	/********************************************************************/
; 7591 : 	/*  Return error if invalid handle.                                 */
; 7592 : 	/********************************************************************/
; 7593 : 	
; 7594 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  025f1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  025f5	57		 push	 edi
  025f6	6a 04		 push	 4
  025f8	56		 push	 esi
  025f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  025ff	85 c0		 test	 eax, eax
  02601	74 08		 je	 SHORT $L73682
  02603	5f		 pop	 edi

; 7595 : 		return( MMSYSERR_INVALHANDLE );

  02604	b8 05 00 00 00	 mov	 eax, 5
  02609	5e		 pop	 esi

; 7680 : }

  0260a	c3		 ret	 0
$L73682:

; 7596 : 
; 7597 : 	/********************************************************************/
; 7598 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 7599 : 	/*  function have completed.                                        */
; 7600 : 	/********************************************************************/
; 7601 : 	// tek 29jan99 bats 849: this must be done before the logflag is cleared.
; 7602 : 	mmStatus = TextToSpeechSync( phTTS );

  0260b	56		 push	 esi
  0260c	e8 00 00 00 00	 call	 _TextToSpeechSync
  02611	8b f8		 mov	 edi, eax

; 7603 : 	
; 7604 : 	if ( mmStatus )
; 7605 : 		mmStatus = MMSYSERR_ERROR;
; 7606 : 	else
; 7607 : 		mmStatus = MMSYSERR_NOERROR;
; 7608 : 		
; 7609 : #ifdef WIN32
; 7610 : 	/********************************************************************/
; 7611 : 	/*  Disable writing to the log file.                                */
; 7612 : 	/********************************************************************/
; 7613 : 	
; 7614 : 	phTTS->pKernelShareData->logflag = 0;       /* BATS#120 FIX TK & JL */

  02613	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02616	83 c4 04	 add	 esp, 4
  02619	f7 df		 neg	 edi
  0261b	c7 80 c4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+964], 0

; 7615 : #endif
; 7616 : 	
; 7617 : 	/********************************************************************/
; 7618 : 	/*  If a file is not open, then exit.                               */
; 7619 : 	/********************************************************************/
; 7620 : 	
; 7621 : 
; 7622 : 	EnterCriticalSection( phTTS->pcsLogFile );

  02625	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  0262b	1b ff		 sbb	 edi, edi
  0262d	51		 push	 ecx
  0262e	f7 df		 neg	 edi
  02630	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7623 : 
; 7624 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_LOG_FILE )

  02636	83 be 88 00 00
	00 03		 cmp	 DWORD PTR [esi+136], 3
  0263d	74 15		 je	 SHORT $L73685

; 7625 : 	{
; 7626 : 
; 7627 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  0263f	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  02645	52		 push	 edx
  02646	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0264c	5f		 pop	 edi

; 7628 : 
; 7629 : 		return( MMSYSERR_ERROR );

  0264d	b8 01 00 00 00	 mov	 eax, 1
  02652	5e		 pop	 esi

; 7680 : }

  02653	c3		 ret	 0
$L73685:

; 7630 : 	}
; 7631 : 	
; 7632 : 
; 7633 : #ifdef WIN32
; 7634 : 	/********************************************************************/
; 7635 : 	/*  Make sure data has been written to the file.                    */
; 7636 : 	/********************************************************************/
; 7637 : 
; 7638 : #if (UNDER_CE == 211) || (UNDER_CE == 200)
; 7639 : 	_flushall; 
; 7640 : #else
; 7641 : 	_flushall();

  02654	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___flushall

; 7642 : #endif // (UNDER_CE == 211) || (UNDER_CE == 200)
; 7643 : 
; 7644 : 
; 7645 : #endif // WIN32
; 7646 : #if defined __osf__ || defined __linux__
; 7647 : 	/********************************************************************/
; 7648 : 	/*  Disable writing to the log file.                                */
; 7649 : 	/********************************************************************/
; 7650 : 	
; 7651 : 	phTTS->pKernelShareData->logflag = 0;
; 7652 : #endif
; 7653 : 	
; 7654 : 	/********************************************************************/
; 7655 : 	/*  Set the system output state to audio if it is enabled.          */
; 7656 : 	/********************************************************************/
; 7657 : 	
; 7658 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  0265a	f7 46 78 00 00
	00 80		 test	 DWORD PTR [esi+120], -2147483648 ; 80000000H
  02661	75 17		 jne	 SHORT $L73686

; 7659 : 	{
; 7660 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 7661 : 		TextToSpeechReset(phTTS,FALSE); // tek 28jan99 bats 849: this resets the counters..

  02663	6a 00		 push	 0
  02665	56		 push	 esi
  02666	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0
  02670	e8 00 00 00 00	 call	 _TextToSpeechReset
  02675	83 c4 08	 add	 esp, 8

; 7662 : 	}
; 7663 : 	else

  02678	eb 0a		 jmp	 SHORT $L73687
$L73686:

; 7664 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;

  0267a	c7 86 88 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+136], 4
$L73687:

; 7665 : 	
; 7666 : 	/********************************************************************/
; 7667 : 	/*  Close the log file.                                             */
; 7668 : 	/********************************************************************/
; 7669 : 	
; 7670 : #ifdef UNDER_CE
; 7671 : 	if ( CloseHandle( phTTS->pLogFile)==0)
; 7672 : #else
; 7673 : 	if ( fclose( phTTS->pLogFile ))

  02684	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0268a	50		 push	 eax
  0268b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  02691	83 c4 04	 add	 esp, 4
  02694	85 c0		 test	 eax, eax
  02696	74 05		 je	 SHORT $L73688

; 7674 : #endif
; 7675 : 		mmStatus = MMSYSERR_ERROR;

  02698	bf 01 00 00 00	 mov	 edi, 1
$L73688:

; 7676 : 	
; 7677 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  0269d	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  026a3	51		 push	 ecx
  026a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7678 : 	
; 7679 : 	return( mmStatus );

  026aa	8b c7		 mov	 eax, edi
  026ac	5f		 pop	 edi
  026ad	5e		 pop	 esi

; 7680 : }

  026ae	c3		 ret	 0
_TextToSpeechCloseLogFile ENDP
_TEXT	ENDS
PUBLIC	_LinearToMuLaw
PUBLIC	_QueueToMemory
_TEXT	SEGMENT
_phTTS$ = 8
_pSamples$ = 12
_dwNumberOfSamples$ = 16
_QueueToMemory PROC NEAR

; 7721 : 	unsigned int i;                        /*MVP : Not a static */
; 7722 : 	DWORD dwBytesLeft;             /*MVP : Not a static */
; 7723 : 	DWORD dwWordsLeft;             /*MVP : Not a static */
; 7724 : 	unsigned char * pBuffer;       /*MVP : Not a static */
; 7725 : 	short * pShort;                /*tek/bh 29jul96 */
; 7726 : 	LPTTS_BUFFER_T pTTS_Buffer;/*MVP : Not a static */
; 7727 : 	
; 7728 : 	/********************************************************************/
; 7729 : 	/*  Loop until all samples have been moved into buffers.            */
; 7730 : 	/********************************************************************/
; 7731 : 	
; 7732 : 	while( dwNumberOfSamples )

  026b0	8b 44 24 0c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp-4]
  026b4	53		 push	 ebx
  026b5	55		 push	 ebp
  026b6	56		 push	 esi
  026b7	85 c0		 test	 eax, eax
  026b9	57		 push	 edi
  026ba	0f 84 4a 02 00
	00		 je	 $L73704

; 7754 : 		}
; 7755 : 		
; 7756 : 		/******************************************************************/
; 7757 : 		/*  Move as many samples as possible into the buffer.             */
; 7758 : 		/*  Get the current buffer pointer and the number of bytes left   */
; 7759 : 		/*  in the buffer.                                                */
; 7760 : 		/******************************************************************/
; 7761 : 		
; 7762 : 		pTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  026c0	8b 7c 24 18	 mov	 edi, DWORD PTR _pSamples$[esp+12]
$L73703:

; 7733 : 	{
; 7734 : 		/******************************************************************/
; 7735 : 		/*  Block if the TextToSpeechReturnBuffer() function is returning */
; 7736 : 		/*  the current buffer.                                           */
; 7737 : 		/******************************************************************/
; 7738 : 
; 7739 : 		EnterCriticalSection( phTTS->pcsMemoryBuffer );

  026c4	8b 74 24 14	 mov	 esi, DWORD PTR _phTTS$[esp+12]
  026c8	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  026ce	50		 push	 eax
  026cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7740 : 		
; 7741 : 		/******************************************************************/
; 7742 : 		/*  If a new Text-To-Speech buffer is needed then get one from    */
; 7743 : 		/*  the application. Block if one is not available.               */
; 7744 : 		/******************************************************************/
; 7745 : 		
; 7746 : 		if ( (phTTS->pTTS_Buffer == NULL )
; 7747 : 			&& !(phTTS->bMemoryReset) 
; 7748 : 			&& !(phTTS->pKernelShareData->halting) )

  026d5	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  026db	85 c0		 test	 eax, eax
  026dd	75 26		 jne	 SHORT $L73706
  026df	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  026e5	85 c0		 test	 eax, eax
  026e7	75 1c		 jne	 SHORT $L73706
  026e9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  026ec	8b 81 34 03 00
	00		 mov	 eax, DWORD PTR [ecx+820]
  026f2	85 c0		 test	 eax, eax
  026f4	75 0f		 jne	 SHORT $L73706

; 7749 : 		{
; 7750 : #ifdef API_DEBUG
; 7751 : 			OutputDebugString("Q2M getting buffer.\n");
; 7752 : #endif //API_DEBUG
; 7753 : 			phTTS->pTTS_Buffer = GetBuffer( phTTS );

  026f6	56		 push	 esi
  026f7	e8 00 00 00 00	 call	 _GetBuffer
  026fc	83 c4 04	 add	 esp, 4
  026ff	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
$L73706:

; 7754 : 		}
; 7755 : 		
; 7756 : 		/******************************************************************/
; 7757 : 		/*  Move as many samples as possible into the buffer.             */
; 7758 : 		/*  Get the current buffer pointer and the number of bytes left   */
; 7759 : 		/*  in the buffer.                                                */
; 7760 : 		/******************************************************************/
; 7761 : 		
; 7762 : 		pTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  02705	8b ae a4 00 00
	00		 mov	 ebp, DWORD PTR [esi+164]

; 7763 : 		
; 7764 : 		/******************************************************************/
; 7765 : 		/*  NULL buffers sent by reset to fix hang. WIH 3/27/95           */
; 7766 : 		/******************************************************************/
; 7767 : 		
; 7768 : 		/* tek 19aug96 Also, we should bail out here if we're doing a     */
; 7769 : 		/* reset.                                                         */
; 7770 : 		if ( (pTTS_Buffer == NULL))

  0270b	85 ed		 test	 ebp, ebp
  0270d	0f 84 b4 01 00
	00		 je	 $L74709

; 7774 : 	
; 7775 : #ifdef API_DEBUG
; 7776 : 			OutputDebugString("Q2M null bailout.\n");
; 7777 : #endif //API_DEBUG
; 7778 : 			return;
; 7779 : 		}
; 7780 : 		
; 7781 : 		if (phTTS->bMemoryReset)

  02713	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  02719	85 c0		 test	 eax, eax
  0271b	0f 85 b8 01 00
	00		 jne	 $L74710

; 7785 : 
; 7786 : 			SendBuffer(phTTS); //tek 03sep96
; 7787 : #ifdef API_DEBUG
; 7788 : 			OutputDebugString("Q2M reset bailout.\n");
; 7789 : #endif //API_DEBUG
; 7790 : 			return;
; 7791 : 		}       
; 7792 : 		
; 7793 : 		if  (phTTS->pKernelShareData->halting)

  02721	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02724	8b 82 34 03 00
	00		 mov	 eax, DWORD PTR [edx+820]
  0272a	85 c0		 test	 eax, eax
  0272c	0f 85 c2 01 00
	00		 jne	 $L74711

; 7799 : #ifdef API_DEBUG
; 7800 : 			OutputDebugString("Q2M halt bailout.\n");
; 7801 : #endif //API_DEBUG
; 7802 : 			return;
; 7803 : 		}
; 7804 : 		
; 7805 : 		pBuffer = (unsigned char *) pTTS_Buffer->lpData + pTTS_Buffer->dwBufferLength;

  02732	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  02735	8b 75 00	 mov	 esi, DWORD PTR [ebp]

; 7806 : 		
; 7807 : 		dwBytesLeft =
; 7808 : 			pTTS_Buffer->dwMaximumBufferLength - pTTS_Buffer->dwBufferLength;

  02738	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]
  0273b	03 f0		 add	 esi, eax
  0273d	2b d8		 sub	 ebx, eax

; 7809 : 		
; 7810 : 		/******************************************************************/
; 7811 : 		/*  Put the samples into the buffer in the proper format.         */
; 7812 : 		/******************************************************************/
; 7813 : 		
; 7814 : 		switch( phTTS->dwFormat )
; 7815 : 		{

  0273f	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  02743	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]
  02749	48		 dec	 eax
  0274a	0f 84 cd 00 00
	00		 je	 $L73727
  02750	83 e8 03	 sub	 eax, 3
  02753	74 74		 je	 SHORT $L73717
  02755	83 e8 03	 sub	 eax, 3
  02758	0f 85 12 01 00
	00		 jne	 $L73733

; 7865 : 			}
; 7866 : 			
; 7867 : 			break;
; 7868 : 			
; 7869 : 			/******************************************************************/
; 7870 : 			/*  Output 8 bit mu-law samples.                                  */
; 7871 : 			/******************************************************************/
; 7872 : 			
; 7873 : 		case WAVE_FORMAT_08M08:
; 7874 : 			
; 7875 : 			if ( dwNumberOfSamples >= dwBytesLeft )

  0275e	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
  02762	3b c3		 cmp	 eax, ebx
  02764	72 3c		 jb	 SHORT $L73739

; 7876 : 			{
; 7877 : 				for ( i = 0; i < dwBytesLeft; i++ )

  02766	85 db		 test	 ebx, ebx
  02768	76 25		 jbe	 SHORT $L73742
  0276a	89 5c 24 18	 mov	 DWORD PTR 12+[esp+12], ebx
$L73740:

; 7878 : 					*pBuffer++ = LinearToMuLaw( *pSamples++ );

  0276e	66 8b 07	 mov	 ax, WORD PTR [edi]
  02771	83 c7 02	 add	 edi, 2
  02774	50		 push	 eax
  02775	e8 00 00 00 00	 call	 _LinearToMuLaw
  0277a	88 06		 mov	 BYTE PTR [esi], al
  0277c	8b 44 24 1c	 mov	 eax, DWORD PTR 12+[esp+16]
  02780	83 c4 04	 add	 esp, 4
  02783	46		 inc	 esi
  02784	48		 dec	 eax
  02785	89 44 24 18	 mov	 DWORD PTR 12+[esp+12], eax
  02789	75 e3		 jne	 SHORT $L73740

; 7876 : 			{
; 7877 : 				for ( i = 0; i < dwBytesLeft; i++ )

  0278b	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
$L73742:

; 7879 : 				
; 7880 : 				pTTS_Buffer->dwBufferLength += dwBytesLeft;

  0278f	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  02792	03 d3		 add	 edx, ebx

; 7881 : 				dwNumberOfSamples = dwNumberOfSamples - dwBytesLeft;

  02794	2b c3		 sub	 eax, ebx
  02796	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  02799	89 44 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], eax

; 7882 : 			}
; 7883 : 			else

  0279d	e9 ce 00 00 00	 jmp	 $L73733
$L73739:

; 7884 : 			{
; 7885 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  027a2	85 c0		 test	 eax, eax
  027a4	76 1b		 jbe	 SHORT $L73746
  027a6	8b d8		 mov	 ebx, eax
$L73744:

; 7886 : 					*pBuffer++ = LinearToMuLaw( *pSamples++ );

  027a8	66 8b 07	 mov	 ax, WORD PTR [edi]
  027ab	83 c7 02	 add	 edi, 2
  027ae	50		 push	 eax
  027af	e8 00 00 00 00	 call	 _LinearToMuLaw
  027b4	83 c4 04	 add	 esp, 4
  027b7	88 06		 mov	 BYTE PTR [esi], al
  027b9	46		 inc	 esi
  027ba	4b		 dec	 ebx
  027bb	75 eb		 jne	 SHORT $L73744

; 7884 : 			{
; 7885 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  027bd	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
$L73746:

; 7887 : 				
; 7888 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples;

  027c1	01 45 18	 add	 DWORD PTR [ebp+24], eax

; 7889 : 				dwNumberOfSamples = 0;
; 7890 : 			}
; 7891 : 			
; 7892 : 			break;

  027c4	e9 9f 00 00 00	 jmp	 $L74719
$L73717:

; 7816 : 			/******************************************************************/
; 7817 : 			/*  Output 16 bit samples.                                        */
; 7818 : 			/******************************************************************/
; 7819 : 			
; 7820 : 		case WAVE_FORMAT_1M16:
; 7821 : 			
; 7822 : 			dwWordsLeft = dwBytesLeft >> 1;
; 7823 : 			pShort = (short *)pBuffer;      
; 7824 : 			
; 7825 : 			if ( dwNumberOfSamples >= dwWordsLeft )

  027c9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwNumberOfSamples$[esp+12]
  027cd	d1 eb		 shr	 ebx, 1
  027cf	3b cb		 cmp	 ecx, ebx
  027d1	72 28		 jb	 SHORT $L73719

; 7826 : 			{
; 7827 : 				for ( i = 0; i < dwWordsLeft; i++ )

  027d3	85 db		 test	 ebx, ebx
  027d5	76 11		 jbe	 SHORT $L73722
  027d7	8b c3		 mov	 eax, ebx
$L73720:

; 7828 : 					*pShort++ = *pSamples++;

  027d9	66 8b 17	 mov	 dx, WORD PTR [edi]
  027dc	83 c7 02	 add	 edi, 2
  027df	66 89 16	 mov	 WORD PTR [esi], dx
  027e2	83 c6 02	 add	 esi, 2
  027e5	48		 dec	 eax
  027e6	75 f1		 jne	 SHORT $L73720
$L73722:

; 7829 : 				
; 7830 : 				pTTS_Buffer->dwBufferLength += dwWordsLeft << 1;

  027e8	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  027eb	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  027ee	03 d0		 add	 edx, eax

; 7831 : 				dwNumberOfSamples = dwNumberOfSamples - dwWordsLeft;

  027f0	2b cb		 sub	 ecx, ebx
  027f2	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  027f5	89 4c 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], ecx

; 7832 : 			}
; 7833 : 			else

  027f9	eb 75		 jmp	 SHORT $L73733
$L73719:

; 7834 : 			{
; 7835 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  027fb	85 c9		 test	 ecx, ecx
  027fd	76 11		 jbe	 SHORT $L73726
  027ff	8b c1		 mov	 eax, ecx
$L73724:

; 7836 : 					*pShort++ = *pSamples++;

  02801	66 8b 17	 mov	 dx, WORD PTR [edi]
  02804	83 c7 02	 add	 edi, 2
  02807	66 89 16	 mov	 WORD PTR [esi], dx
  0280a	83 c6 02	 add	 esi, 2
  0280d	48		 dec	 eax
  0280e	75 f1		 jne	 SHORT $L73724
$L73726:

; 7837 : 				
; 7838 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples << 1;

  02810	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  02813	8b 4d 18	 mov	 ecx, DWORD PTR [ebp+24]
  02816	03 c8		 add	 ecx, eax
  02818	89 4d 18	 mov	 DWORD PTR [ebp+24], ecx

; 7839 : 				dwNumberOfSamples = 0;
; 7840 : 			}
; 7841 : 			
; 7842 : 			break;

  0281b	eb 4b		 jmp	 SHORT $L74719
$L73727:

; 7843 : 			
; 7844 : 			/******************************************************************/
; 7845 : 			/*  Output 8 bit samples.                                         */
; 7846 : 			/******************************************************************/
; 7847 : 			
; 7848 : 		case WAVE_FORMAT_1M08:
; 7849 : 			
; 7850 : 			if ( dwNumberOfSamples >= dwBytesLeft )

  0281d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwNumberOfSamples$[esp+12]
  02821	3b cb		 cmp	 ecx, ebx
  02823	72 28		 jb	 SHORT $L73728

; 7851 : 			{
; 7852 : 				for ( i = 0; i < dwBytesLeft; i++ )

  02825	85 db		 test	 ebx, ebx
  02827	76 14		 jbe	 SHORT $L73731
  02829	8b c3		 mov	 eax, ebx
$L73729:

; 7853 : 					*pBuffer++ = ((unsigned char)((*pSamples++) >> 8)) ^ 0x80;

  0282b	66 8b 17	 mov	 dx, WORD PTR [edi]
  0282e	83 c7 02	 add	 edi, 2
  02831	c1 fa 08	 sar	 edx, 8
  02834	80 f2 80	 xor	 dl, 128			; 00000080H
  02837	88 16		 mov	 BYTE PTR [esi], dl
  02839	46		 inc	 esi
  0283a	48		 dec	 eax
  0283b	75 ee		 jne	 SHORT $L73729
$L73731:

; 7854 : 				
; 7855 : 				pTTS_Buffer->dwBufferLength += dwBytesLeft;

  0283d	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  02840	03 d3		 add	 edx, ebx

; 7856 : 				dwNumberOfSamples = dwNumberOfSamples - dwBytesLeft;

  02842	2b cb		 sub	 ecx, ebx
  02844	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  02847	89 4c 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], ecx

; 7857 : 			}
; 7858 : 			else

  0284b	eb 23		 jmp	 SHORT $L73733
$L73728:

; 7859 : 			{
; 7860 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  0284d	85 c9		 test	 ecx, ecx
  0284f	76 14		 jbe	 SHORT $L73736
  02851	8b c1		 mov	 eax, ecx
$L73734:

; 7861 : 					*pBuffer++ = ((unsigned char)((*pSamples++) >> 8)) ^ 0x80;

  02853	66 8b 17	 mov	 dx, WORD PTR [edi]
  02856	83 c7 02	 add	 edi, 2
  02859	c1 fa 08	 sar	 edx, 8
  0285c	80 f2 80	 xor	 dl, 128			; 00000080H
  0285f	88 16		 mov	 BYTE PTR [esi], dl
  02861	46		 inc	 esi
  02862	48		 dec	 eax
  02863	75 ee		 jne	 SHORT $L73734
$L73736:

; 7862 : 				
; 7863 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples;

  02865	01 4d 18	 add	 DWORD PTR [ebp+24], ecx
$L74719:

; 7864 : 				dwNumberOfSamples = 0;

  02868	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], 0
$L73733:

; 7893 : 			
; 7894 : 		default:
; 7895 : 			
; 7896 : 			break;
; 7897 : 		}
; 7898 : 		
; 7899 : 		/******************************************************************/
; 7900 : 		/*  The buffer is full. Return it to the application.             */
; 7901 : 		/******************************************************************/
; 7902 : 		
; 7903 : 		if ( pTTS_Buffer->dwBufferLength >= pTTS_Buffer->dwMaximumBufferLength )

  02870	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  02873	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  02876	3b c1		 cmp	 eax, ecx

; 7904 : 		{
; 7905 : 			/****************************************************************/
; 7906 : 			/*  Release the buffer.                                         */
; 7907 : 			/****************************************************************/
; 7908 : 	
; 7909 : 
; 7910 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02878	8b 4c 24 14	 mov	 ecx, DWORD PTR _phTTS$[esp+12]
  0287c	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [ecx+180]
  02882	52		 push	 edx
  02883	72 0d		 jb	 SHORT $L73748
  02885	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7911 : 		
; 7912 : 			SendBuffer( phTTS );

  0288b	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  0288f	50		 push	 eax

; 7913 : 		}
; 7914 : 		else

  02890	eb 1c		 jmp	 SHORT $L74720
$L73748:

; 7915 : 		{
; 7916 : 
; 7917 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02892	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7918 : 			
; 7919 : 			/****************************************************************/
; 7920 : 			/*  tek 19aug96 if halting, release the buffer.                 */
; 7921 : 			/****************************************************************/
; 7922 : 			if (phTTS->pKernelShareData-> halting)

  02898	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  0289c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0289f	8b 81 34 03 00
	00		 mov	 eax, DWORD PTR [ecx+820]
  028a5	85 c0		 test	 eax, eax
  028a7	74 0d		 je	 SHORT $L73750

; 7923 : 				SendBuffer(phTTS);

  028a9	8b 54 24 14	 mov	 edx, DWORD PTR _phTTS$[esp+12]
  028ad	52		 push	 edx
$L74720:
  028ae	e8 00 00 00 00	 call	 _SendBuffer
  028b3	83 c4 04	 add	 esp, 4
$L73750:
  028b6	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
  028ba	85 c0		 test	 eax, eax
  028bc	0f 85 02 fe ff
	ff		 jne	 $L73703
  028c2	5f		 pop	 edi
  028c3	5e		 pop	 esi
  028c4	5d		 pop	 ebp
  028c5	5b		 pop	 ebx

; 7924 : 			
; 7925 : 		}
; 7926 :   }
; 7927 :   
; 7928 :   return;
; 7929 : }

  028c6	c3		 ret	 0
$L74709:

; 7771 : 		{ // tek I think we have to do a leaveCS here.. 
; 7772 : 	
; 7773 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  028c7	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  028cd	50		 push	 eax
  028ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  028d4	5f		 pop	 edi
  028d5	5e		 pop	 esi
  028d6	5d		 pop	 ebp
  028d7	5b		 pop	 ebx

; 7924 : 			
; 7925 : 		}
; 7926 :   }
; 7927 :   
; 7928 :   return;
; 7929 : }

  028d8	c3		 ret	 0
$L74710:

; 7782 : 		{ // tek I think we have to do a leaveCS here.. 
; 7783 : 
; 7784 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  028d9	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  028df	51		 push	 ecx

; 7794 : 		{ // tek I think we have to do a leaveCS here.. 
; 7795 : 
; 7796 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  028e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7797 : 
; 7798 : 			SendBuffer(phTTS); //tek 03sep96

  028e6	56		 push	 esi
  028e7	e8 00 00 00 00	 call	 _SendBuffer
  028ec	83 c4 04	 add	 esp, 4
  028ef	5f		 pop	 edi
  028f0	5e		 pop	 esi
  028f1	5d		 pop	 ebp
  028f2	5b		 pop	 ebx

; 7924 : 			
; 7925 : 		}
; 7926 :   }
; 7927 :   
; 7928 :   return;
; 7929 : }

  028f3	c3		 ret	 0
$L74711:

; 7794 : 		{ // tek I think we have to do a leaveCS here.. 
; 7795 : 
; 7796 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  028f4	8b 96 b4 00 00
	00		 mov	 edx, DWORD PTR [esi+180]
  028fa	52		 push	 edx
  028fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7797 : 
; 7798 : 			SendBuffer(phTTS); //tek 03sep96

  02901	56		 push	 esi
  02902	e8 00 00 00 00	 call	 _SendBuffer
  02907	83 c4 04	 add	 esp, 4
$L73704:
  0290a	5f		 pop	 edi
  0290b	5e		 pop	 esi
  0290c	5d		 pop	 ebp
  0290d	5b		 pop	 ebx

; 7924 : 			
; 7925 : 		}
; 7926 :   }
; 7927 :   
; 7928 :   return;
; 7929 : }

  0290e	c3		 ret	 0
_QueueToMemory ENDP
_TEXT	ENDS
EXTRN	_read_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pTTS_BufferArray$ = 8
_GetBuffer PROC NEAR

; 7958 : {

  02910	56		 push	 esi

; 7959 : 	LPTTS_BUFFER_T pTTS_BufferArray[1];  /*MVP : Not a static */
; 7960 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 7961 : 	
; 7962 : 	read_pipe( phTTS->pKernelShareData->buffer_pipe, &pTTS_BufferArray[0], 1 );

  02911	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02915	8d 44 24 08	 lea	 eax, DWORD PTR _pTTS_BufferArray$[esp]
  02919	6a 01		 push	 1
  0291b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0291e	50		 push	 eax
  0291f	8b 91 a4 02 00
	00		 mov	 edx, DWORD PTR [ecx+676]
  02925	52		 push	 edx
  02926	e8 00 00 00 00	 call	 _read_pipe

; 7963 : 	
; 7964 : 	pTTS_Buffer = pTTS_BufferArray[0];

  0292b	8b 44 24 14	 mov	 eax, DWORD PTR _pTTS_BufferArray$[esp+12]

; 7965 : 	
; 7966 : 	if ( pTTS_Buffer != NULL )

  0292f	33 c9		 xor	 ecx, ecx
  02931	83 c4 0c	 add	 esp, 12			; 0000000cH
  02934	3b c1		 cmp	 eax, ecx
  02936	74 18		 je	 SHORT $L73758

; 7967 : 	{
; 7968 : 		pTTS_Buffer->dwBufferLength = 0;

  02938	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 7969 : 		pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  0293b	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 7970 : 		pTTS_Buffer->dwNumberOfIndexMarks = 0;

  0293e	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 7971 : 		
; 7972 : 		if ( phTTS->dwFormat == WAVE_FORMAT_1M16 )

  02941	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  02947	83 f9 04	 cmp	 ecx, 4
  0294a	75 04		 jne	 SHORT $L73758

; 7973 : 			pTTS_Buffer->dwMaximumBufferLength &= 0xFFFFFFFE;

  0294c	83 60 0c fe	 and	 DWORD PTR [eax+12], -2	; fffffffeH
$L73758:
  02950	5e		 pop	 esi

; 7974 : 	}
; 7975 : 	return( pTTS_Buffer );
; 7976 : }

  02951	c3		 ret	 0
_GetBuffer ENDP
_TEXT	ENDS
PUBLIC	_Report_TTS_Status
_TEXT	SEGMENT
_phTTS$ = 8
_SendBuffer PROC NEAR

; 8004 : {

  02960	53		 push	 ebx
  02961	56		 push	 esi

; 8005 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 8006 : #ifdef API_DEBUG
; 8007 : 	OutputDebugString("SendBuffer().\n");
; 8008 : #endif //API_DEBUG
; 8009 : 	if ( (! phTTS->bMemoryReset)
; 8010 : 		&& (! phTTS->pKernelShareData->halting))

  02962	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  02966	33 db		 xor	 ebx, ebx
  02968	39 9e 90 00 00
	00		 cmp	 DWORD PTR [esi+144], ebx
  0296e	75 60		 jne	 SHORT $L73763
  02970	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02973	39 98 34 03 00
	00		 cmp	 DWORD PTR [eax+820], ebx
  02979	75 55		 jne	 SHORT $L73763

; 8011 : 	{
; 8012 : #ifdef API_DEBUG
; 8013 : 		OutputDebugString(" SB (!reset).\n");
; 8014 : #endif //API_DEBUG
; 8015 : 
; 8016 : 		if ( phTTS->pTTS_Buffer != NULL )

  0297b	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  02981	3b c3		 cmp	 eax, ebx
  02983	0f 84 da 00 00
	00		 je	 $L73773

; 8017 : 		{
; 8018 : 			pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;
; 8019 : 			
; 8020 : 			/****************************************************************/
; 8021 : 			/*  NULL buffers sent by reset to fix hang. WIH 3/27/95         */
; 8022 : 			/****************************************************************/
; 8023 : 			
; 8024 : 			if ( pTTS_Buffer != NULL )
; 8025 : 			{
; 8026 : 				
; 8027 : 				
; 8028 : 				/****************************************************************/
; 8029 : 				/*  It is possible to get here with nothing in the buffer if    */
; 8030 : 				/*  a force caused the buffer to be returned. Check the buffer  */
; 8031 : 				/*  to see if it has any sections full.                         */
; 8032 : 				/****************************************************************/
; 8033 : 				
; 8034 : 				if (( pTTS_Buffer->dwBufferLength > 0 )
; 8035 : 					|| ( pTTS_Buffer->dwNumberOfIndexMarks > 0 )
; 8036 : 					|| ( pTTS_Buffer->dwNumberOfPhonemeChanges > 0 ))

  02989	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  0298c	77 0e		 ja	 SHORT $L73770
  0298e	39 58 20	 cmp	 DWORD PTR [eax+32], ebx
  02991	77 09		 ja	 SHORT $L73770
  02993	39 58 1c	 cmp	 DWORD PTR [eax+28], ebx
  02996	0f 86 c7 00 00
	00		 jbe	 $L73773
$L73770:

; 8037 : 				{
; 8038 : 					phTTS->bSendingBuffer = TRUE;
; 8039 : 					/*
; 8040 : 					SendMessage( phTTS->hWnd,
; 8041 : 					phTTS->uiID_Buffer_Message,
; 8042 : 					0,
; 8043 : 					(LPARAM)phTTS->pTTS_Buffer );
; 8044 : 					*/
; 8045 : 					//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 8046 : #ifdef API_DEBUG
; 8047 : 					OutputDebugString("returning partial buffer.\n");
; 8048 : #endif //API_DEBUG
; 8049 : 					
; 8050 : 					Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)phTTS->pTTS_Buffer);

  0299c	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  0299f	50		 push	 eax
  029a0	53		 push	 ebx
  029a1	51		 push	 ecx
  029a2	56		 push	 esi
  029a3	c7 86 94 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+148], 1
  029ad	e8 00 00 00 00	 call	 _Report_TTS_Status

; 8051 : 					phTTS->pTTS_Buffer = NULL;
; 8052 : 					
; 8053 : 					phTTS->bSendingBuffer = FALSE;
; 8054 : 					
; 8055 : #ifdef WIN32
; 8056 : 					WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  029b2	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  029b5	83 c4 10	 add	 esp, 16			; 00000010H
  029b8	89 9e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ebx
  029be	89 9e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ebx
  029c4	6a ff		 push	 -1
  029c6	52		 push	 edx
  029c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  029cd	5e		 pop	 esi
  029ce	5b		 pop	 ebx

; 8146 : #endif
; 8147 : #if defined __osf__ || defined __linux__
; 8148 : 		OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 8149 : #endif
; 8150 : 	}
; 8151 : #ifdef API_DEBUG
; 8152 : 	OutputDebugString("SB done.\n");
; 8153 : #endif //API_DEBUG
; 8154 : 	return;
; 8155 : }

  029cf	c3		 ret	 0
$L73763:

; 8057 : #endif
; 8058 : #if defined __osf__ || defined __linux__
; 8059 : 					OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 8060 : #endif
; 8061 : 
; 8062 : 				}
; 8063 : 			}
; 8064 : 		}
; 8065 : 	}
; 8066 : 	else
; 8067 : 	{
; 8068 : #ifdef API_DEBUG
; 8069 : 		OutputDebugString("SB (reset)\n");
; 8070 : 		if (phTTS->pKernelShareData->halting)
; 8071 : 			OutputDebugString("SB halting.. \n");
; 8072 : 		if (phTTS->bMemoryReset)
; 8073 : 			OutputDebugString("SB memreset.. \n");
; 8074 : #endif //API_DEBUG
; 8075 : 		
; 8076 : 		/******************************************************************/
; 8077 : 		/*  Send the current buffer back.                                 */
; 8078 : 		/******************************************************************/
; 8079 : 		EnterCriticalSection( phTTS->pcsMemoryBuffer );

  029d0	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  029d6	57		 push	 edi
  029d7	50		 push	 eax
  029d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 8080 : 
; 8081 : 		pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;
; 8082 : 		phTTS->pTTS_Buffer=NULL;
; 8083 : 		
; 8084 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  029de	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  029e4	8b be a4 00 00
	00		 mov	 edi, DWORD PTR [esi+164]
  029ea	51		 push	 ecx
  029eb	89 9e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ebx
  029f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 8085 : 		
; 8086 : 		if ( pTTS_Buffer != NULL )

  029f7	3b fb		 cmp	 edi, ebx
  029f9	74 2b		 je	 SHORT $L73777

; 8087 : 		{
; 8088 : #ifdef API_DEBUG
; 8089 : 			OutputDebugString("SB return current buf. \n");
; 8090 : #endif //API_DEBUG
; 8091 : 			
; 8092 : 			/****************************************************************/
; 8093 : 			/*  NULL buffers sent by reset to fix hang. WIH 3/27/95         */
; 8094 : 			/*  This is needed in spite of previous "if" statement because  */
; 8095 : 			/*  the app is multip-threaded.                                 */
; 8096 : 			/****************************************************************/
; 8097 : 			
; 8098 : 				phTTS->bSendingBuffer = TRUE;
; 8099 : 				/*
; 8100 : 				SendMessage( phTTS->hWnd,
; 8101 : 				phTTS->uiID_Buffer_Message,
; 8102 : 				0,
; 8103 : 				(LPARAM)pTTS_Buffer );
; 8104 : 				*/
; 8105 : 				//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 8106 : #ifdef API_DEBUG
; 8107 : 				OutputDebugString(" returning a buffer.. \n");
; 8108 : #endif //API_DEBUG
; 8109 : 				
; 8110 : 				Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)pTTS_Buffer);

  029fb	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  029fe	57		 push	 edi
  029ff	53		 push	 ebx
  02a00	52		 push	 edx
  02a01	56		 push	 esi
  02a02	c7 86 94 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+148], 1
  02a0c	e8 00 00 00 00	 call	 _Report_TTS_Status

; 8111 : 				
; 8112 : 				phTTS->bSendingBuffer = FALSE;
; 8113 : 			
; 8114 : 
; 8115 : #ifdef WIN32
; 8116 : 				WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  02a11	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  02a14	83 c4 10	 add	 esp, 16			; 00000010H
  02a17	89 9e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ebx
  02a1d	6a ff		 push	 -1
  02a1f	50		 push	 eax
  02a20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$L73777:

; 8117 : #endif
; 8118 : #if defined __osf__ || defined __linux__
; 8119 : 				OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 8120 : #endif
; 8121 : 
; 8122 : 			
; 8123 : 		}
; 8124 : 
; 8125 : 		
; 8126 : 		// tek 03sep96 moved the return of remaining buffers out to 
; 8127 : 		// a separate routine.
; 8128 : 		ReturnRemainingBuffers(phTTS);

  02a26	56		 push	 esi
  02a27	e8 00 00 00 00	 call	 _ReturnRemainingBuffers

; 8129 : 		
; 8130 : 		// tek 29aug96 if we're in a flusg, put in another null buffer.. 
; 8131 : 		if (phTTS->pKernelShareData->halting  && phTTS->dwOutputState == STATE_OUTPUT_MEMORY)

  02a2c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02a2f	83 c4 04	 add	 esp, 4
  02a32	8b 81 34 03 00
	00		 mov	 eax, DWORD PTR [ecx+820]
  02a38	5f		 pop	 edi
  02a39	3b c3		 cmp	 eax, ebx
  02a3b	74 13		 je	 SHORT $L73779
  02a3d	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  02a44	75 0a		 jne	 SHORT $L73779

; 8132 : 			TextToSpeechAddBuffer(phTTS, NULL); // a dummy buffer.

  02a46	53		 push	 ebx
  02a47	56		 push	 esi
  02a48	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  02a4d	83 c4 08	 add	 esp, 8
$L73779:

; 8133 : 		/******************************************************************/
; 8134 : 		/*  Empty the VTM pipe in case there is still any data in it      */
; 8135 : 		/******************************************************************/
; 8136 : 		
; 8137 : 		InitializeVTM(phTTS);

  02a50	56		 push	 esi
  02a51	e8 00 00 00 00	 call	 _InitializeVTM

; 8138 : 		
; 8139 : 		//phTTS->pTTS_Buffer = NULL;
; 8140 : 		//tek 03sep96 we can't clear this flag here, because  vtm writes
; 8141 : 		// that sneak in at the 'right' time could prematurely clear it.
; 8142 : 		//phTTS->bMemoryReset = FALSE;
; 8143 : 		
; 8144 : #ifdef WIN32
; 8145 : 		SetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  02a56	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  02a59	83 c4 04	 add	 esp, 4
  02a5c	52		 push	 edx
  02a5d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L73773:
  02a63	5e		 pop	 esi
  02a64	5b		 pop	 ebx

; 8146 : #endif
; 8147 : #if defined __osf__ || defined __linux__
; 8148 : 		OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 8149 : #endif
; 8150 : 	}
; 8151 : #ifdef API_DEBUG
; 8152 : 	OutputDebugString("SB done.\n");
; 8153 : #endif //API_DEBUG
; 8154 : 	return;
; 8155 : }

  02a65	c3		 ret	 0
_SendBuffer ENDP
_phTTS$ = 8
_pPipeArray$ = 8
_ReturnRemainingBuffers PROC NEAR

; 8167 : {

  02a70	53		 push	 ebx
  02a71	55		 push	 ebp
  02a72	56		 push	 esi

; 8168 : 	LPTTS_BUFFER_T pPipeArray[1];        /*MVP : Not a static */
; 8169 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 8170 : #ifdef WIN32
; 8171 : 	UINT	uiPipeCount=0;				// 16jun97 tek bats 385 merged 28jul97
; 8172 : 	
; 8173 : #ifdef API_DEBUG
; 8174 : 	OutputDebugString("ReturnRemainingBuffers()\n");
; 8175 : #endif //API_DEBUG
; 8176 : #endif
; 8177 : 	
; 8178 :     /******************************************************************/
; 8179 : 	/*  Send all the remaining buffers back.                          */
; 8180 : 	/******************************************************************/
; 8181 : 	
; 8182 : 	// tek 03sep96 we need to lock the pipe to make sure nothing arrives
; 8183 :     // while we're dumping.. 
; 8184 : #ifdef WIN32
; 8185 : 	// 16jun97 tek bats 385: (merged 28jul97)
; 8186 : 	// the user callback may be coded to just return buffers, and that 
; 8187 : 	// would result in an infinite loop if we just tried to drain the pipe.
; 8188 : 	// Soooo.. we empty the pipe into an cache, and then return the buffers
; 8189 : 	// from the cache; this means the user callback is filling a different
; 8190 : 	// pipe and thus we won't loop forever.
; 8191 :     //LockPipe(phTTS->pKernelShareData->buffer_pipe);
; 8192 :     OP_LockMutex(phTTS->pcsBufferPipe);

  02a73	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  02a77	57		 push	 edi
  02a78	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  02a7e	50		 push	 eax
  02a7f	e8 00 00 00 00	 call	 _OP_LockMutex

; 8193 : #endif
; 8194 : #if defined __osf__ || defined __linux__
; 8195 :     OP_LockMutex(phTTS->pcsBufferPipe);
; 8196 : #endif
; 8197 : 	
; 8198 : 	while (pipe_count( phTTS->pKernelShareData->buffer_pipe )  && phTTS->dwOutputState == STATE_OUTPUT_MEMORY)

  02a84	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02a87	8b 91 a4 02 00
	00		 mov	 edx, DWORD PTR [ecx+676]
  02a8d	52		 push	 edx
  02a8e	e8 00 00 00 00	 call	 _pipe_count
  02a93	83 c4 08	 add	 esp, 8
  02a96	bb 01 00 00 00	 mov	 ebx, 1
  02a9b	85 c0		 test	 eax, eax
  02a9d	74 48		 je	 SHORT $L74728
$L73788:
  02a9f	39 9e 88 00 00
	00		 cmp	 DWORD PTR [esi+136], ebx
  02aa5	75 40		 jne	 SHORT $L74728

; 8199 : 	{
; 8200 : 		read_pipe( phTTS->pKernelShareData->buffer_pipe, &pPipeArray, 1 );

  02aa7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02aaa	8d 44 24 14	 lea	 eax, DWORD PTR _pPipeArray$[esp+12]
  02aae	53		 push	 ebx
  02aaf	50		 push	 eax
  02ab0	8b 91 a4 02 00
	00		 mov	 edx, DWORD PTR [ecx+676]
  02ab6	52		 push	 edx
  02ab7	e8 00 00 00 00	 call	 _read_pipe

; 8201 : #ifdef WIN32
; 8202 : 		write_pipe(phTTS->pKernelShareData->buffer_delay_pipe, pPipeArray, 1 );

  02abc	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02abf	8d 44 24 20	 lea	 eax, DWORD PTR _pPipeArray$[esp+24]
  02ac3	53		 push	 ebx
  02ac4	50		 push	 eax
  02ac5	8b 91 a8 02 00
	00		 mov	 edx, DWORD PTR [ecx+680]
  02acb	52		 push	 edx
  02acc	e8 00 00 00 00	 call	 _write_pipe
  02ad1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02ad4	8b 88 a4 02 00
	00		 mov	 ecx, DWORD PTR [eax+676]
  02ada	51		 push	 ecx
  02adb	e8 00 00 00 00	 call	 _pipe_count
  02ae0	83 c4 1c	 add	 esp, 28			; 0000001cH
  02ae3	85 c0		 test	 eax, eax
  02ae5	75 b8		 jne	 SHORT $L73788
$L74728:

; 8203 : 	}
; 8204 : //	OP_UnlockMutex(phTTS->pcsBufferPipe);
; 8205 : 	//UnlockPipe(phTTS->pKernelShareData->buffer_pipe);
; 8206 : 	
; 8207 : 	while (pipe_count( phTTS->pKernelShareData->buffer_delay_pipe ) && phTTS->dwOutputState == STATE_OUTPUT_MEMORY)

  02ae7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02aea	8b 82 a8 02 00
	00		 mov	 eax, DWORD PTR [edx+680]
  02af0	50		 push	 eax
  02af1	e8 00 00 00 00	 call	 _pipe_count
  02af6	83 c4 04	 add	 esp, 4
  02af9	85 c0		 test	 eax, eax
  02afb	0f 84 8e 00 00
	00		 je	 $L73792
  02b01	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__WaitForSingleObject@8
  02b07	33 ff		 xor	 edi, edi
$L73791:
  02b09	39 9e 88 00 00
	00		 cmp	 DWORD PTR [esi+136], ebx
  02b0f	75 7e		 jne	 SHORT $L73792

; 8208 : 	{
; 8209 : 		read_pipe( phTTS->pKernelShareData->buffer_delay_pipe, &pPipeArray, 1 );

  02b11	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02b14	8d 4c 24 14	 lea	 ecx, DWORD PTR _pPipeArray$[esp+12]
  02b18	53		 push	 ebx
  02b19	51		 push	 ecx
  02b1a	8b 82 a8 02 00
	00		 mov	 eax, DWORD PTR [edx+680]
  02b20	50		 push	 eax
  02b21	e8 00 00 00 00	 call	 _read_pipe

; 8210 : 		
; 8211 : #endif
; 8212 : //#if defined __osf__ || defined __linux__
; 8213 : 		OP_UnlockMutex(phTTS->pcsBufferPipe);

  02b26	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  02b2c	51		 push	 ecx
  02b2d	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 8214 : //#endif
; 8215 : 		pTTS_Buffer = pPipeArray[0];

  02b32	8b 44 24 24	 mov	 eax, DWORD PTR _pPipeArray$[esp+28]
  02b36	83 c4 10	 add	 esp, 16			; 00000010H

; 8216 : 		
; 8217 : 		if ( pTTS_Buffer != NULL )

  02b39	3b c7		 cmp	 eax, edi
  02b3b	74 2c		 je	 SHORT $L73794

; 8218 : 		{
; 8219 : 			pTTS_Buffer->dwBufferLength = 0;

  02b3d	89 78 18	 mov	 DWORD PTR [eax+24], edi

; 8220 : 			pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  02b40	89 78 1c	 mov	 DWORD PTR [eax+28], edi

; 8221 : 			pTTS_Buffer->dwNumberOfIndexMarks = 0;

  02b43	89 78 20	 mov	 DWORD PTR [eax+32], edi

; 8222 : 			
; 8223 : 			phTTS->bSendingBuffer = TRUE;
; 8224 : 			/*
; 8225 : 			SendMessage( phTTS->hWnd,
; 8226 : 			phTTS->uiID_Buffer_Message,
; 8227 : 			0,
; 8228 : 			(LPARAM)pTTS_Buffer );
; 8229 : 			*/
; 8230 : 			//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 8231 : #ifdef API_DEBUG
; 8232 : 			OutputDebugString(" returning a remaining buffer.. \n");
; 8233 : #endif //API_DEBUG
; 8234 : 			Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)pTTS_Buffer);

  02b46	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  02b49	50		 push	 eax
  02b4a	57		 push	 edi
  02b4b	52		 push	 edx
  02b4c	56		 push	 esi
  02b4d	89 9e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ebx
  02b53	e8 00 00 00 00	 call	 _Report_TTS_Status

; 8235 : 			
; 8236 : 			phTTS->bSendingBuffer = FALSE;
; 8237 : #ifdef WIN32
; 8238 : 			WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  02b58	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  02b5b	83 c4 10	 add	 esp, 16			; 00000010H
  02b5e	89 be 94 00 00
	00		 mov	 DWORD PTR [esi+148], edi
  02b64	6a ff		 push	 -1
  02b66	50		 push	 eax
  02b67	ff d5		 call	 ebp
$L73794:

; 8239 : #endif
; 8240 : #if defined __osf__ || defined __linux__
; 8241 : 			OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 8242 : #endif
; 8243 : 		}
; 8244 : 		// relock the pipe to atomically get a count and a buffer.
; 8245 : 		// LockPipe(phTTS->pKernelShareData->buffer_pipe);
; 8246 : //#if defined __osf__ || defined __linux__
; 8247 : 		OP_LockMutex(phTTS->pcsBufferPipe);

  02b69	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  02b6f	51		 push	 ecx
  02b70	e8 00 00 00 00	 call	 _OP_LockMutex
  02b75	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02b78	8b 82 a8 02 00
	00		 mov	 eax, DWORD PTR [edx+680]
  02b7e	50		 push	 eax
  02b7f	e8 00 00 00 00	 call	 _pipe_count
  02b84	83 c4 08	 add	 esp, 8
  02b87	85 c0		 test	 eax, eax
  02b89	0f 85 7a ff ff
	ff		 jne	 $L73791
$L73792:

; 8248 : //#endif
; 8249 : 	}
; 8250 : 	//  UnlockPipe(phTTS->pKernelShareData->buffer_pipe);
; 8251 : //#if defined __osf__ || defined __linux__
; 8252 : 	OP_UnlockMutex(phTTS->pcsBufferPipe);

  02b8f	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  02b95	51		 push	 ecx
  02b96	e8 00 00 00 00	 call	 _OP_UnlockMutex
  02b9b	83 c4 04	 add	 esp, 4
  02b9e	5f		 pop	 edi
  02b9f	5e		 pop	 esi
  02ba0	5d		 pop	 ebp
  02ba1	5b		 pop	 ebx

; 8253 : //#endif
; 8254 : } // ReturnRemainingBuffers()

  02ba2	c3		 ret	 0
_ReturnRemainingBuffers ENDP
_TEXT	ENDS
PUBLIC	_PutIndexMarkInBuffer
_BSS	SEGMENT
	ALIGN	4

_?pIndexArray@?1??PutIndexMarkInBuffer@@9@9 DD 01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_dwIndexValue$ = 12
_dwSampleNumber$ = 16
_PutIndexMarkInBuffer PROC NEAR

; 8291 : {

  02bb0	56		 push	 esi

; 8292 : 	UINT uiIndex;                                                      /*MVP : Not a static */
; 8293 : 	/*static LPTTS_BUFFER_T pPipeArray[1];*/               /*MVP : Never Used   */
; 8294 : 	LPTTS_BUFFER_T pTTS_Buffer;                                    /*MVP : Not a static */
; 8295 : 	static LPTTS_INDEX_T pIndexArray;                              /*MVP : Not a static */
; 8296 : 	
; 8297 : //#if defined __osf__ || defined __linux__ // remove this ifdef as all code should be checking this
; 8298 : 	/********************************************************************/
; 8299 : 	/*   If current in the Reset code, no need to continue              */
; 8300 : 	/********************************************************************/
; 8301 : 	if ( phTTS->bInReset )

  02bb1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02bb5	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  02bbb	85 c0		 test	 eax, eax
  02bbd	0f 85 a9 00 00
	00		 jne	 $L73819

; 8302 : 		return;
; 8303 : //#endif
; 8304 : 	
; 8305 : 	/********************************************************************/
; 8306 : 	/*  Block if the TextToSpeechReturnBuffer() function is returning   */
; 8307 : 	/*  the current buffer.                                             */
; 8308 : 	/********************************************************************/
; 8309 : 
; 8310 : 		EnterCriticalSection( phTTS->pcsMemoryBuffer );

  02bc3	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  02bc9	50		 push	 eax
  02bca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 8311 : 	
; 8312 : 	/********************************************************************/
; 8313 : 	/*  If a new Text-To-Speech buffer is needed then get one from      */
; 8314 : 	/*  the application. Block if one is not available.                 */
; 8315 : 	/********************************************************************/
; 8316 : 	
; 8317 : 	if ( phTTS->pTTS_Buffer == NULL )

  02bd0	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  02bd6	85 c0		 test	 eax, eax
  02bd8	75 0f		 jne	 SHORT $L73810

; 8318 : 	{
; 8319 : 		phTTS->pTTS_Buffer = GetBuffer( phTTS );

  02bda	56		 push	 esi
  02bdb	e8 00 00 00 00	 call	 _GetBuffer
  02be0	83 c4 04	 add	 esp, 4
  02be3	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
$L73810:

; 8320 : 	}
; 8321 : 	
; 8322 : 	pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

  02be9	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]

; 8323 : 	
; 8324 : 	/********************************************************************/
; 8325 : 	/*  NULL buffers sent by reset to fix hang. WIH 3/27/95             */
; 8326 : 	/********************************************************************/
; 8327 : 	
; 8328 : 	if ( pTTS_Buffer == NULL )

  02bef	85 c0		 test	 eax, eax

; 8329 : 	{
; 8330 : 
; 8331 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );
; 8332 : 
; 8333 : 		return;

  02bf1	74 6c		 je	 SHORT $L73815

; 8334 : 	}
; 8335 : 	
; 8336 : 	/********************************************************************/
; 8337 : 	/*  Put the index mark into the current buffer.                     */
; 8338 : 	/********************************************************************/
; 8339 : 	
; 8340 : 	pIndexArray = pTTS_Buffer->lpIndexArray;

  02bf3	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 8341 : 	
; 8342 : 	if ( pIndexArray != NULL )

  02bf6	85 d2		 test	 edx, edx
  02bf8	89 15 00 00 00
	00		 mov	 DWORD PTR _?pIndexArray@?1??PutIndexMarkInBuffer@@9@9, edx
  02bfe	74 5f		 je	 SHORT $L73815

; 8343 : 	{
; 8344 : 		uiIndex = pTTS_Buffer->dwNumberOfIndexMarks;

  02c00	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02c03	57		 push	 edi

; 8345 : 		
; 8346 : 		if ( pTTS_Buffer->dwMaximumNumberOfIndexMarks > 0 )

  02c04	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  02c07	85 ff		 test	 edi, edi
  02c09	76 22		 jbe	 SHORT $L73816

; 8347 : 		{
; 8348 : 			(pIndexArray+uiIndex)->dwIndexValue = dwIndexValue;

  02c0b	8b 7c 24 10	 mov	 edi, DWORD PTR _dwIndexValue$[esp+4]
  02c0f	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  02c12	c1 e1 02	 shl	 ecx, 2
  02c15	89 3c 11	 mov	 DWORD PTR [ecx+edx], edi

; 8349 : 			(pIndexArray+uiIndex)->dwIndexSampleNumber = dwSampleNumber;

  02c18	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _?pIndexArray@?1??PutIndexMarkInBuffer@@9@9
  02c1e	8b 54 24 14	 mov	 edx, DWORD PTR _dwSampleNumber$[esp+4]
  02c22	89 54 39 04	 mov	 DWORD PTR [ecx+edi+4], edx

; 8350 : 			pTTS_Buffer->dwNumberOfIndexMarks++;

  02c26	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02c29	41		 inc	 ecx
  02c2a	89 48 20	 mov	 DWORD PTR [eax+32], ecx
$L73816:

; 8351 : 		}
; 8352 : 		
; 8353 : 		/******************************************************************/
; 8354 : 		/*  If the index mark array is full then return it to the         */
; 8355 : 		/*  application.                                                  */
; 8356 : 		/******************************************************************/
; 8357 : 		
; 8358 : 		if ( pTTS_Buffer->dwNumberOfIndexMarks
; 8359 : 			>= pTTS_Buffer->dwMaximumNumberOfIndexMarks )

  02c2d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02c30	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  02c33	3b ca		 cmp	 ecx, edx
  02c35	5f		 pop	 edi
  02c36	72 18		 jb	 SHORT $L73817

; 8360 : 		{
; 8361 : 			/****************************************************************/
; 8362 : 			/*  Release the buffer.                                         */
; 8363 : 			/****************************************************************/
; 8364 : 			
; 8365 : 
; 8366 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02c38	8b 96 b4 00 00
	00		 mov	 edx, DWORD PTR [esi+180]
  02c3e	52		 push	 edx
  02c3f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 8367 : 			
; 8368 : 			SendBuffer( phTTS );

  02c45	56		 push	 esi
  02c46	e8 00 00 00 00	 call	 _SendBuffer
  02c4b	83 c4 04	 add	 esp, 4
  02c4e	5e		 pop	 esi

; 8388 : 
; 8389 : 	}
; 8390 : 	return;
; 8391 : }

  02c4f	c3		 ret	 0
$L73817:

; 8369 : 		}
; 8370 : 		else
; 8371 : 		{
; 8372 : 			/****************************************************************/
; 8373 : 			/*  Release the buffer.                                         */
; 8374 : 			/****************************************************************/
; 8375 : 			
; 8376 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02c50	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  02c56	50		 push	 eax

; 8377 : 
; 8378 : 		}
; 8379 : 	}
; 8380 : 	else
; 8381 : 	{
; 8382 : 		/******************************************************************/
; 8383 : 		/*  Release the buffer.                                           */
; 8384 : 		/******************************************************************/
; 8385 : 		
; 8386 : 
; 8387 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02c57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02c5d	5e		 pop	 esi

; 8388 : 
; 8389 : 	}
; 8390 : 	return;
; 8391 : }

  02c5e	c3		 ret	 0
$L73815:

; 8377 : 
; 8378 : 		}
; 8379 : 	}
; 8380 : 	else
; 8381 : 	{
; 8382 : 		/******************************************************************/
; 8383 : 		/*  Release the buffer.                                           */
; 8384 : 		/******************************************************************/
; 8385 : 		
; 8386 : 
; 8387 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02c5f	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  02c65	51		 push	 ecx
  02c66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L73819:
  02c6c	5e		 pop	 esi

; 8388 : 
; 8389 : 	}
; 8390 : 	return;
; 8391 : }

  02c6d	c3		 ret	 0
_PutIndexMarkInBuffer ENDP
_TEXT	ENDS
PUBLIC	_PutPhonemeInBuffer
_TEXT	SEGMENT
_phTTS$ = 8
_dwPhoneme$ = 12
_dwPhonemeDuration$ = 16
_dwSampleNumber$ = 20
_PutPhonemeInBuffer PROC NEAR

; 8428 : {

  02c70	56		 push	 esi

; 8429 : 	UINT uiIndex;                                                     /* MVP : Not a static */
; 8430 : 	/*static LPTTS_BUFFER_T pPipeArray[1];*/  /* MVP : Never Used   */
; 8431 : 	LPTTS_BUFFER_T pTTS_Buffer;                           /* MVP : Not a static */
; 8432 : 	LPTTS_PHONEME_T pPhonemeArray;                        /* MVP : Not a static */
; 8433 : 	
; 8434 : //#ifdef WIN32 // remove this ifdef as all code should be checking this
; 8435 : 	/********************************************************************/
; 8436 : 	/*   If current in the Reset code, no need to continue              */
; 8437 : 	/********************************************************************/
; 8438 : 	if ( phTTS->bInReset )

  02c71	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02c75	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  02c7b	85 c0		 test	 eax, eax
  02c7d	0f 85 a1 00 00
	00		 jne	 $L73844

; 8439 : 		return;
; 8440 : //#endif
; 8441 : 	
; 8442 : 	
; 8443 : 	/********************************************************************/
; 8444 : 	/*  Block if the TextToSpeechReturnBuffer() function is returning   */
; 8445 : 	/*  the current buffer.                                             */
; 8446 : 	/********************************************************************/
; 8447 : 
; 8448 : 	EnterCriticalSection( phTTS->pcsMemoryBuffer );

  02c83	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  02c89	50		 push	 eax
  02c8a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 8449 : 	
; 8450 : 	/********************************************************************/
; 8451 : 	/*  If a new Text-To-Speech buffer is needed then get one from      */
; 8452 : 	/*  the application. Block if one is not available.                 */
; 8453 : 	/********************************************************************/
; 8454 : 	
; 8455 : 	if ( phTTS->pTTS_Buffer == NULL )

  02c90	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  02c96	85 c0		 test	 eax, eax
  02c98	75 0f		 jne	 SHORT $L73835

; 8456 : 	{
; 8457 : 		phTTS->pTTS_Buffer = GetBuffer( phTTS );

  02c9a	56		 push	 esi
  02c9b	e8 00 00 00 00	 call	 _GetBuffer
  02ca0	83 c4 04	 add	 esp, 4
  02ca3	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
$L73835:

; 8458 : 	}
; 8459 : 	
; 8460 : 	/********************************************************************/
; 8461 : 	/*  Put the index mark into the current buffer.                     */
; 8462 : 	/********************************************************************/
; 8463 : 	
; 8464 : 	pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

  02ca9	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]

; 8465 : 	
; 8466 : 	/********************************************************************/
; 8467 : 	/*  NULL buffers sent by reset to fix hang. WIH 3/27/95             */
; 8468 : 	/********************************************************************/
; 8469 : 	
; 8470 : 	if ( pTTS_Buffer == NULL )

  02caf	85 c0		 test	 eax, eax

; 8471 : 	{
; 8472 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );
; 8473 : 		return;

  02cb1	74 64		 je	 SHORT $L73840

; 8474 : 	}
; 8475 : 	
; 8476 : 	pPhonemeArray = pTTS_Buffer->lpPhonemeArray;

  02cb3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 8477 : 	
; 8478 : 	if ( pPhonemeArray != NULL )

  02cb6	85 d2		 test	 edx, edx
  02cb8	74 5d		 je	 SHORT $L73840

; 8479 : 	{
; 8480 : 		uiIndex = pTTS_Buffer->dwNumberOfPhonemeChanges;

  02cba	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02cbd	57		 push	 edi

; 8481 : 		
; 8482 : 		if ( pTTS_Buffer->dwMaximumNumberOfPhonemeChanges > 0 )

  02cbe	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  02cc1	85 ff		 test	 edi, edi
  02cc3	5f		 pop	 edi
  02cc4	76 20		 jbe	 SHORT $L73841

; 8483 : 		{
; 8484 : 			(pPhonemeArray+uiIndex)->dwPhoneme = dwPhoneme;

  02cc6	c1 e1 04	 shl	 ecx, 4
  02cc9	03 ca		 add	 ecx, edx
  02ccb	8b 54 24 0c	 mov	 edx, DWORD PTR _dwPhoneme$[esp]
  02ccf	89 11		 mov	 DWORD PTR [ecx], edx

; 8485 : 			(pPhonemeArray+uiIndex)->dwPhonemeSampleNumber = dwSampleNumber;

  02cd1	8b 54 24 14	 mov	 edx, DWORD PTR _dwSampleNumber$[esp]
  02cd5	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 8486 : 			(pPhonemeArray+uiIndex)->dwPhonemeDuration = dwPhonemeDuration;

  02cd8	8b 54 24 10	 mov	 edx, DWORD PTR _dwPhonemeDuration$[esp]
  02cdc	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 8487 : 			pTTS_Buffer->dwNumberOfPhonemeChanges++;

  02cdf	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02ce2	41		 inc	 ecx
  02ce3	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L73841:

; 8488 : 		}
; 8489 : 		
; 8490 : 		/******************************************************************/
; 8491 : 		/*  If the phoneme array is full then return it to the            */
; 8492 : 		/*  application.                                                  */
; 8493 : 		/******************************************************************/
; 8494 : 		
; 8495 : 		if ( pTTS_Buffer->dwNumberOfPhonemeChanges
; 8496 : 			>= pTTS_Buffer->dwMaximumNumberOfPhonemeChanges )

  02ce6	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02ce9	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  02cec	3b ca		 cmp	 ecx, edx
  02cee	72 18		 jb	 SHORT $L73842

; 8497 : 		{
; 8498 : 			/****************************************************************/
; 8499 : 			/*  Release the buffer.                                         */
; 8500 : 			/****************************************************************/
; 8501 : 
; 8502 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02cf0	8b 96 b4 00 00
	00		 mov	 edx, DWORD PTR [esi+180]
  02cf6	52		 push	 edx
  02cf7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 8503 : 			SendBuffer( phTTS );

  02cfd	56		 push	 esi
  02cfe	e8 00 00 00 00	 call	 _SendBuffer
  02d03	83 c4 04	 add	 esp, 4
  02d06	5e		 pop	 esi

; 8520 : 	}
; 8521 : 	return;
; 8522 : }

  02d07	c3		 ret	 0
$L73842:

; 8504 : 		}
; 8505 : 		else
; 8506 : 		{
; 8507 : 			/****************************************************************/
; 8508 : 			/*  Release the buffer.                                         */
; 8509 : 			/****************************************************************/
; 8510 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02d08	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  02d0e	50		 push	 eax

; 8511 : 		}
; 8512 : 	}
; 8513 : 	else
; 8514 : 	{
; 8515 : 		/******************************************************************/
; 8516 : 		/*  Release the buffer.                                           */
; 8517 : 		/******************************************************************/
; 8518 : 
; 8519 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02d0f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02d15	5e		 pop	 esi

; 8520 : 	}
; 8521 : 	return;
; 8522 : }

  02d16	c3		 ret	 0
$L73840:

; 8511 : 		}
; 8512 : 	}
; 8513 : 	else
; 8514 : 	{
; 8515 : 		/******************************************************************/
; 8516 : 		/*  Release the buffer.                                           */
; 8517 : 		/******************************************************************/
; 8518 : 
; 8519 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02d17	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  02d1d	51		 push	 ecx
  02d1e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L73844:
  02d24	5e		 pop	 esi

; 8520 : 	}
; 8521 : 	return;
; 8522 : }

  02d25	c3		 ret	 0
_PutPhonemeInBuffer ENDP
_phTTS$ = 8
_Speaker$ = 12
_SetSpeaker PROC NEAR

; 8552 : 	/********************************************************************/
; 8553 : 	/*  Set voice change flag for phmain.c in the PH thread.            */
; 8554 : 	/********************************************************************/
; 8555 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  02d30	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 8556 : 	
; 8557 : 	pKsd_t->async_voice = Speaker;

  02d34	8b 4c 24 08	 mov	 ecx, DWORD PTR _Speaker$[esp-4]
  02d38	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  02d3b	89 88 04 04 00
	00		 mov	 DWORD PTR [eax+1028], ecx

; 8558 : 	pKsd_t->last_voice = (short)Speaker;

  02d41	66 89 88 e4 03
	00 00		 mov	 WORD PTR [eax+996], cx

; 8559 : 	pKsd_t->async_change |= ASYNC_voice;

  02d48	83 88 00 04 00
	00 01		 or	 DWORD PTR [eax+1024], 1

; 8560 : 	
; 8561 : }

  02d4f	c3		 ret	 0
_SetSpeaker ENDP
_TEXT	ENDS
EXTRN	__imp___endthreadex:NEAR
EXTRN	__imp__GetMessageA@16:NEAR
EXTRN	__imp__DispatchMessageA@4:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_msg$ = -28
_TextToSpeechThreadMain@4 PROC NEAR

; 8582 : {

  02d50	83 ec 1c	 sub	 esp, 28			; 0000001cH
  02d53	56		 push	 esi

; 8583 : 	MSG msg;
; 8584 : 	
; 8585 : 	/********************************************************************/
; 8586 : 	/*  Create the TextToSpeech window.                                 */
; 8587 : 	/********************************************************************/
; 8588 : 	
; 8589 : 	phTTS->hTextToSpeechWnd = InitTextToSpeechWindow( phTTS );

  02d54	8b 74 24 24	 mov	 esi, DWORD PTR _phTTS$[esp+28]
  02d58	56		 push	 esi
  02d59	e8 00 00 00 00	 call	 _InitTextToSpeechWindow
  02d5e	83 c4 04	 add	 esp, 4
  02d61	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 8590 : 	
; 8591 : 	if(phTTS->hTextToSpeechWnd == NULL)

  02d64	85 c0		 test	 eax, eax
  02d66	75 0c		 jne	 SHORT $L73857

; 8592 : 		return(MMSYSERR_ERROR);

  02d68	b8 01 00 00 00	 mov	 eax, 1
  02d6d	5e		 pop	 esi

; 8603 : }

  02d6e	83 c4 1c	 add	 esp, 28			; 0000001cH
  02d71	c2 04 00	 ret	 4
$L73857:

; 8593 : 	SetEvent(phTTS->hMallocSuccessEvent);    /*Got a hTextToSpeechWnd now */

  02d74	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  02d77	57		 push	 edi
  02d78	50		 push	 eax
  02d79	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 8594 : 	
; 8595 : 	while( GetMessage( &msg,
; 8596 : 		phTTS->hTextToSpeechWnd,
; 8597 : 		0L,
; 8598 : 		ID_TTS_Destroy ))

  02d7f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02d82	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetMessageA@16
  02d88	68 01 04 00 00	 push	 1025			; 00000401H
  02d8d	6a 00		 push	 0
  02d8f	8d 54 24 10	 lea	 edx, DWORD PTR _msg$[esp+44]
  02d93	51		 push	 ecx
  02d94	52		 push	 edx
  02d95	ff d7		 call	 edi
  02d97	85 c0		 test	 eax, eax
  02d99	74 25		 je	 SHORT $L73860
  02d9b	53		 push	 ebx
  02d9c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DispatchMessageA@4
$L73859:

; 8599 : 		DispatchMessage( &msg );

  02da2	8d 44 24 0c	 lea	 eax, DWORD PTR _msg$[esp+40]
  02da6	50		 push	 eax
  02da7	ff d3		 call	 ebx
  02da9	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02dac	68 01 04 00 00	 push	 1025			; 00000401H
  02db1	6a 00		 push	 0
  02db3	8d 54 24 14	 lea	 edx, DWORD PTR _msg$[esp+48]
  02db7	51		 push	 ecx
  02db8	52		 push	 edx
  02db9	ff d7		 call	 edi
  02dbb	85 c0		 test	 eax, eax
  02dbd	75 e3		 jne	 SHORT $L73859
  02dbf	5b		 pop	 ebx
$L73860:

; 8600 : 	
; 8601 : 	_endthreadex(msg.wParam);

  02dc0	8b 44 24 10	 mov	 eax, DWORD PTR _msg$[esp+44]
  02dc4	50		 push	 eax
  02dc5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___endthreadex
  02dcb	83 c4 04	 add	 esp, 4

; 8602 : 	return( FALSE );

  02dce	33 c0		 xor	 eax, eax
  02dd0	5f		 pop	 edi
  02dd1	5e		 pop	 esi

; 8603 : }

  02dd2	83 c4 1c	 add	 esp, 28			; 0000001cH
  02dd5	c2 04 00	 ret	 4
_TextToSpeechThreadMain@4 ENDP
_TEXT	ENDS
EXTRN	__imp__LoadIconA@8:NEAR
EXTRN	__imp__RegisterClassA@4:NEAR
EXTRN	__imp__SetWindowLongA@12:NEAR
EXTRN	__imp__CreateWindowExA@48:NEAR
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__LoadCursorA@8:NEAR
_DATA	SEGMENT
	ORG $+2
$SG73870 DB	'TextToSpeechWndClass', 00H
	ORG $+3
$SG73871 DB	'%s_%08X', 00H
$SG73885 DB	'TextToSpeech Output, v1.0', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_wc$ = -296
_wndclass$ = -256
_InitTextToSpeechWindow PROC NEAR

; 8789 : {

  02de0	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  02de6	56		 push	 esi
  02de7	57		 push	 edi

; 8790 : 	WNDCLASS wc;
; 8791 : 	HWND hWnd;
; 8792 : 	HINSTANCE hInstance;
; 8793 : 	char wndclass[255];
; 8794 : 	
; 8795 : 	/********************************************************************/
; 8796 : 	/*  Register a TextToSpeech Window Class.                           */
; 8797 : 	/*  Get the hInstance for the new Window.                           */
; 8798 : 	/********************************************************************/
; 8799 : 	
; 8800 : 	// tek 13nov97 why do we think the phTTS->hWnd is anything useful??
; 8801 : 	hInstance = NULL;
; 8802 : 	//hInstance = (HINSTANCE)GetWindowLong( phTTS->hWnd,
; 8803 : 	//					GWL_HINSTANCE );
; 8804 : 	
; 8805 : 	/********************************************************************/
; 8806 : 	/*  Register a TextToSpeech window class.                           */
; 8807 : 	/********************************************************************/
; 8808 : #ifdef UNDER_CE	
; 8809 : 	wsprintf(wndclass,TEXT("%s_%08X"),TEXTTOSPEECHWNDCLASS,(unsigned long int) phTTS);
; 8810 : #else
; 8811 : 	sprintf(wndclass,"%s_%08X",TEXTTOSPEECHWNDCLASS,(unsigned long int) phTTS);

  02de8	8b bc 24 34 01
	00 00		 mov	 edi, DWORD PTR _phTTS$[esp+300]
  02def	8d 44 24 30	 lea	 eax, DWORD PTR _wndclass$[esp+304]
  02df3	57		 push	 edi
  02df4	68 00 00 00 00	 push	 OFFSET FLAT:$SG73870
  02df9	68 00 00 00 00	 push	 OFFSET FLAT:$SG73871
  02dfe	50		 push	 eax
  02dff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  02e05	83 c4 10	 add	 esp, 16			; 00000010H

; 8812 : #endif
; 8813 : 	wc.lpszClassName = wndclass;

  02e08	8d 4c 24 30	 lea	 ecx, DWORD PTR _wndclass$[esp+304]
  02e0c	89 4c 24 2c	 mov	 DWORD PTR _wc$[esp+340], ecx

; 8814 : 	wc.lpfnWndProc =   TextToSpeechWndProc;

  02e10	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+308], OFFSET FLAT:_TextToSpeechWndProc@16

; 8815 : 	wc.hInstance =     hInstance;
; 8816 : #ifndef UNDER_CE
; 8817 : 	wc.hCursor =       LoadCursor( 0, IDC_ARROW );

  02e18	68 00 7f 00 00	 push	 32512			; 00007f00H
  02e1d	6a 00		 push	 0
  02e1f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+328], 0
  02e27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8

; 8818 : 	wc.hIcon =         LoadIcon( 0, IDI_APPLICATION );

  02e2d	68 00 7f 00 00	 push	 32512			; 00007f00H
  02e32	6a 00		 push	 0
  02e34	89 44 24 28	 mov	 DWORD PTR _wc$[esp+336], eax
  02e38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8

; 8819 : #else
; 8820 : 	wc.hCursor =       NULL;
; 8821 : 	wc.hIcon =         NULL;
; 8822 : #endif
; 8823 : 	wc.hbrBackground = (HBRUSH)( COLOR_APPWORKSPACE+1 );
; 8824 : 	wc.lpszMenuName =  NULL;
; 8825 : #ifndef UNDER_CE
; 8826 : 	wc.style =         CS_OWNDC;
; 8827 : #else
; 8828 : 	wc.style =         0;
; 8829 : #endif
; 8830 : 	wc.cbClsExtra =    0;
; 8831 : 	wc.cbWndExtra =    8;         /* MVP :To store phTTS through SetWindowLong */
; 8832 : 	
; 8833 : 	RegisterClass( &wc );

  02e3e	8d 54 24 08	 lea	 edx, DWORD PTR _wc$[esp+304]
  02e42	89 44 24 1c	 mov	 DWORD PTR _wc$[esp+324], eax
  02e46	52		 push	 edx
  02e47	c7 44 24 28 0d
	00 00 00	 mov	 DWORD PTR _wc$[esp+336], 13 ; 0000000dH
  02e4f	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+340], 0
  02e57	c7 44 24 0c 20
	00 00 00	 mov	 DWORD PTR _wc$[esp+308], 32 ; 00000020H
  02e5f	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+316], 0
  02e67	c7 44 24 18 08
	00 00 00	 mov	 DWORD PTR _wc$[esp+320], 8
  02e6f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4

; 8834 : 	
; 8835 : 	/********************************************************************/
; 8836 : 	/*  Create an Invisible TextToSpeech Window.                        */
; 8837 : 	/********************************************************************/
; 8838 : 	
; 8839 : #ifndef UNDER_CE
; 8840 : 	hWnd = CreateWindow( wndclass,
; 8841 : 		"TextToSpeech Output, v1.0",
; 8842 : 		WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW,
; 8843 : 		CW_USEDEFAULT,
; 8844 : 		CW_USEDEFAULT,
; 8845 : 		CW_USEDEFAULT,
; 8846 : 		CW_USEDEFAULT,
; 8847 : 		0,
; 8848 : 		0,
; 8849 : 		hInstance,
; 8850 : 		NULL);      /*MVP : was (LPVOID)phTTS ,This is changed to avoid

  02e75	6a 00		 push	 0
  02e77	6a 00		 push	 0
  02e79	6a 00		 push	 0
  02e7b	6a 00		 push	 0
  02e7d	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02e82	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02e87	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02e8c	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02e91	68 00 00 cf 02	 push	 47120384		; 02cf0000H
  02e96	8d 44 24 54	 lea	 eax, DWORD PTR _wndclass$[esp+340]
  02e9a	68 00 00 00 00	 push	 OFFSET FLAT:$SG73885
  02e9f	50		 push	 eax
  02ea0	6a 00		 push	 0
  02ea2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  02ea8	8b f0		 mov	 esi, eax

; 8851 : 					static declaration of this handle in TextToSpeechWndProc
; 8852 : 					Now this handle will be available through call to
; 8853 : 	GetWindowLong */
; 8854 : #else
; 8855 : 	hWnd = CreateWindow( wndclass,
; 8856 : 		TEXT("TextToSpeech Output, v1.0"),
; 8857 : 		WS_CLIPCHILDREN | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
; 8858 : 		CW_USEDEFAULT,
; 8859 : 		CW_USEDEFAULT,
; 8860 : 		CW_USEDEFAULT,
; 8861 : 		CW_USEDEFAULT,
; 8862 : 		NULL,
; 8863 : 		NULL,
; 8864 : 		hInstance,
; 8865 : 		NULL);      /*MVP : was (LPVOID)phTTS ,This is changed to avoid
; 8866 : 					static declaration of this handle in TextToSpeechWndProc
; 8867 : 					Now this handle will be available through call to
; 8868 : 	GetWindowLong */
; 8869 : #endif
; 8870 : 	
; 8871 : 	if( ! hWnd )

  02eaa	85 f6		 test	 esi, esi
  02eac	75 09		 jne	 SHORT $L73886
  02eae	5f		 pop	 edi
  02eaf	5e		 pop	 esi

; 8880 : }

  02eb0	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  02eb6	c3		 ret	 0
$L73886:

; 8872 : 		return( NULL );
; 8873 : 	
; 8874 : 	/*MVP : Store phTTS in Window extra memory for later use in Wndproc */
; 8875 : 	SetWindowLong(hWnd,GWL_USERDATA,(LONG)phTTS);

  02eb7	57		 push	 edi
  02eb8	6a eb		 push	 -21			; ffffffebH
  02eba	56		 push	 esi
  02ebb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 8876 : 	
; 8877 : 	ShowWindow( hWnd, SW_HIDE );

  02ec1	6a 00		 push	 0
  02ec3	56		 push	 esi
  02ec4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 8878 : 	
; 8879 : 	return( hWnd );

  02eca	8b c6		 mov	 eax, esi
  02ecc	5f		 pop	 edi
  02ecd	5e		 pop	 esi

; 8880 : }

  02ece	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  02ed4	c3		 ret	 0
_InitTextToSpeechWindow ENDP
_TEXT	ENDS
EXTRN	__imp__DefWindowProcA@16:NEAR
EXTRN	__imp__PostQuitMessage@4:NEAR
EXTRN	__imp__GetWindowLongA@8:NEAR
EXTRN	__imp__DestroyWindow@4:NEAR
_TEXT	SEGMENT
_hWnd$ = 8
_message$ = 12
_wParam$ = 16
_lParam$ = 20
_TextToSpeechWndProc@16 PROC NEAR

; 8898 : {

  02ee0	56		 push	 esi
  02ee1	57		 push	 edi

; 8899 : 	
; 8900 : LPTTS_HANDLE_T phTTS;                    /* MVP : Avoided static behaviour through
; 8901 : 										 using GetWindowLong to retrieve the handle 
; 8902 : 										 from window extra memory,which was set
; 8903 : when window was created */
; 8904 : 
; 8905 : phTTS = (LPTTS_HANDLE_T)GetWindowLong(hWnd,GWL_USERDATA);

  02ee2	8b 7c 24 0c	 mov	 edi, DWORD PTR _hWnd$[esp+4]
  02ee6	6a eb		 push	 -21			; ffffffebH
  02ee8	57		 push	 edi
  02ee9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8

; 8906 : 
; 8907 : switch( message )
; 8908 : {

  02eef	8b 74 24 10	 mov	 esi, DWORD PTR _message$[esp+4]
  02ef3	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  02ef9	77 33		 ja	 SHORT $L74741
  02efb	74 19		 je	 SHORT $L73905
  02efd	8b c6		 mov	 eax, esi
  02eff	48		 dec	 eax
  02f00	74 0d		 je	 SHORT $L73904
  02f02	48		 dec	 eax
  02f03	75 38		 jne	 SHORT $L73901

; 8932 : 	
; 8933 : case ID_TTS_Destroy:
; 8934 : 	
; 8935 : 	DestroyWindow( hWnd );
; 8936 : 	
; 8937 : 	break;
; 8938 : 	
; 8939 : 	/********************************************************************/
; 8940 : 	/*  The WM_DESTROY message is used to destroy a window.             */
; 8941 : 	/********************************************************************/
; 8942 : 	
; 8943 : case WM_DESTROY:
; 8944 : 	
; 8945 : 	PostQuitMessage(0);

  02f05	6a 00		 push	 0
  02f07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 8946 : 	
; 8947 : 	break;

  02f0d	eb 2e		 jmp	 SHORT $L73901
$L73904:
  02f0f	5f		 pop	 edi

; 8909 : 	/********************************************************************/
; 8910 : 	/*  TextToSpeech intialization occurs here.                         */
; 8911 : 	/********************************************************************/
; 8912 : 	
; 8913 : case WM_CREATE:
; 8914 : 	
; 8915 : 	/******************************************************************/
; 8916 : 	/*  Initialize pointer to the TextToSpeech parameter structure.   */
; 8917 : 	/******************************************************************/
; 8918 : 	/*MVP : Commented out, Value is retreived Through GetWindowLong */
; 8919 : 	/*phTTS = (LPTTS_HANDLE_T)(((LPCREATESTRUCT)lParam)->lpCreateParams);*/
; 8920 : 	
; 8921 : 	return( FALSE );

  02f10	33 c0		 xor	 eax, eax
  02f12	5e		 pop	 esi

; 8953 : }

  02f13	c2 10 00	 ret	 16			; 00000010H
$L73905:

; 8922 : 	
; 8923 : 	/********************************************************************/
; 8924 : 	/*  Process the TextToSpeech message.                               */
; 8925 : 	/********************************************************************/
; 8926 : 	
; 8927 : case ID_TTS_Queue_Text:
; 8928 : 	
; 8929 : 	Process_TTS_Message( phTTS, lParam );

  02f16	8b 4c 24 18	 mov	 ecx, DWORD PTR _lParam$[esp+4]
  02f1a	51		 push	 ecx
  02f1b	50		 push	 eax
  02f1c	e8 00 00 00 00	 call	 _Process_TTS_Message
  02f21	83 c4 08	 add	 esp, 8

; 8930 : 	
; 8931 : 	return( TRUE );

  02f24	b8 01 00 00 00	 mov	 eax, 1
  02f29	5f		 pop	 edi
  02f2a	5e		 pop	 esi

; 8953 : }

  02f2b	c2 10 00	 ret	 16			; 00000010H
$L74741:

; 8906 : 
; 8907 : switch( message )
; 8908 : {

  02f2e	81 fe 01 04 00
	00		 cmp	 esi, 1025		; 00000401H

; 8948 : 	
; 8949 : default:
; 8950 : 	break;

  02f34	75 07		 jne	 SHORT $L73901
  02f36	57		 push	 edi
  02f37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$L73901:

; 8951 : }
; 8952 : return( DefWindowProc( hWnd, message, wParam, lParam ));

  02f3d	8b 54 24 18	 mov	 edx, DWORD PTR _lParam$[esp+4]
  02f41	8b 44 24 14	 mov	 eax, DWORD PTR _wParam$[esp+4]
  02f45	52		 push	 edx
  02f46	50		 push	 eax
  02f47	56		 push	 esi
  02f48	57		 push	 edi
  02f49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  02f4f	5f		 pop	 edi
  02f50	5e		 pop	 esi

; 8953 : }

  02f51	c2 10 00	 ret	 16			; 00000010H
_TextToSpeechWndProc@16 ENDP
_phTTS$ = 8
_lParam$ = 12
_Process_TTS_Message PROC NEAR

; 8985 : {

  02f60	53		 push	 ebx
  02f61	55		 push	 ebp
  02f62	56		 push	 esi

; 8986 : 	UINT uiLength;
; 8987 : 	unsigned char * pText;
; 8988 : 	TEXT_MSG_T * pTextMsg;
; 8989 : 	
; 8990 : 	pTextMsg = (TEXT_MSG_T *)lParam;
; 8991 : 	//OutputDebugString("	Process_TTS_Message().\n");
; 8992 : #ifdef API_DEBUG //tek 12aug97
; 8993 : 	{
; 8994 : 		char szTemp[256]="";
; 8995 : 		sprintf(szTemp,"Process_TTS_Message #%u at %lu\n",
; 8996 : 			pTextMsg->uiMsgNumber,
; 8997 : 			timeGetTime());
; 8998 : 		OutputDebugString(szTemp);
; 8999 : 	}
; 9000 : #endif //API_DEBUG
; 9001 : 	
; 9002 : 	/********************************************************************/
; 9003 : 	/*  If the posted Text-To-Speech message number is less than the    */
; 9004 : 	/*  message number of the last flush message, then throw the        */
; 9005 : 	/*  Text-To-Speech message away.                                    */
; 9006 : 	/********************************************************************/
; 9007 : 	
; 9008 : 	EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  02f63	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  02f67	57		 push	 edi
  02f68	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  02f6e	50		 push	 eax
  02f6f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 9009 : 	
; 9010 : 	if ( pTextMsg->uiMsgNumber > phTTS->uiFlushMsgNumber )

  02f75	8b 5c 24 18	 mov	 ebx, DWORD PTR _lParam$[esp+12]
  02f79	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  02f7c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02f7e	3b c8		 cmp	 ecx, eax
  02f80	76 6f		 jbe	 SHORT $L73918

; 9011 : 	{
; 9012 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  02f82	8b 96 c0 00 00
	00		 mov	 edx, DWORD PTR [esi+192]
  02f88	52		 push	 edx
  02f89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 9013 : #ifdef API_DEBUG
; 9014 : 		OutputDebugString("  .. TTSMessage processing.\n");
; 9015 : #endif //API_DEBUG
; 9016 : 		uiLength = pTextMsg->uiLength;

  02f8f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 9017 : #ifdef TYPING_MODE // tek 17jun97
; 9018 : 		if (uiLength>0)

  02f92	85 ff		 test	 edi, edi
  02f94	76 0a		 jbe	 SHORT $L73919

; 9019 : 			phTTS->bInTypingMode = FALSE;

  02f96	c7 86 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+220], 0
$L73919:

; 9020 : #endif //TYPING_MODE
; 9021 : 		pText = pTextMsg->pText;

  02fa0	8b 6b 08	 mov	 ebp, DWORD PTR [ebx+8]

; 9022 : 		
; 9023 : 		/******************************************************************/
; 9024 : 		/*  Queue the text unless a TextToSpeechReset() forces an abort   */
; 9025 : 		/*  by setting the KS.halting flag.                               */
; 9026 : 		/******************************************************************/
; 9027 : 		/* we have to check for halting inside the loop, else we will hang */
; 9028 : 		/* if we have a lot of text to speak. We should probably also block*/
; 9029 : 		/* here, rather than in write_pipe(), on the pipe full condition, */
; 9030 : 		/* but that's probably chrome.. it would let us respond to a flush*/
; 9031 : 		/* a little faster. (tek 08jan97) */
; 9032 : 		
; 9033 : 		while (( uiLength > MAX_TEXT_WRITE_LENGTH ) 
; 9034 : 			&& ( ! (phTTS->pKernelShareData->halting))   // tek 08jan97
; 9035 : 			//      && ( ! (phTTS->pKernelShareData->halting))
; 9036 : 			)

  02fa3	83 ff 10	 cmp	 edi, 16			; 00000010H
  02fa6	76 2a		 jbe	 SHORT $L73922
$L73921:
  02fa8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02fab	8b 88 34 03 00
	00		 mov	 ecx, DWORD PTR [eax+820]
  02fb1	85 c9		 test	 ecx, ecx
  02fb3	75 1d		 jne	 SHORT $L73922

; 9037 : 		{
; 9038 : 			//OutputDebugString(" .. text to write_pipe \n");
; 9039 : 			write_pipe( phTTS->pKernelShareData->cmd_pipe, pText, MAX_TEXT_WRITE_LENGTH );

  02fb5	8b 80 98 02 00
	00		 mov	 eax, DWORD PTR [eax+664]
  02fbb	6a 10		 push	 16			; 00000010H
  02fbd	55		 push	 ebp
  02fbe	50		 push	 eax
  02fbf	e8 00 00 00 00	 call	 _write_pipe

; 9040 : 			uiLength -= MAX_TEXT_WRITE_LENGTH;

  02fc4	83 ef 10	 sub	 edi, 16			; 00000010H
  02fc7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9041 : 			pText += MAX_TEXT_WRITE_LENGTH;

  02fca	83 c5 10	 add	 ebp, 16			; 00000010H
  02fcd	83 ff 10	 cmp	 edi, 16			; 00000010H
  02fd0	77 d6		 ja	 SHORT $L73921
$L73922:

; 9042 : 		}
; 9043 : 		
; 9044 : 		if (( uiLength > 0 ) 
; 9045 : 			&& (uiLength <= MAX_TEXT_WRITE_LENGTH)	/* tek 08jan97 */
; 9046 : 			//      && ( ! phTTS->pKernelShareData->halting )
; 9047 : 			)

  02fd2	85 ff		 test	 edi, edi
  02fd4	76 28		 jbe	 SHORT $L73924
  02fd6	83 ff 10	 cmp	 edi, 16			; 00000010H
  02fd9	77 23		 ja	 SHORT $L73924

; 9048 : 		{
; 9049 : 			//OutputDebugString(" .. .. Text to write_pipe \n");
; 9050 : 			write_pipe( phTTS->pKernelShareData->cmd_pipe, pText, uiLength );

  02fdb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02fde	57		 push	 edi
  02fdf	55		 push	 ebp
  02fe0	8b 91 98 02 00
	00		 mov	 edx, DWORD PTR [ecx+664]
  02fe6	52		 push	 edx
  02fe7	e8 00 00 00 00	 call	 _write_pipe
  02fec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9051 : 		}
; 9052 : 	}
; 9053 : 	else

  02fef	eb 0d		 jmp	 SHORT $L73924
$L73918:

; 9054 : 	{
; 9055 : #ifdef API_DEBUG
; 9056 : 		OutputDebugString(" .. tossing textmsg due to flush.\n");
; 9057 : #endif //API_DEBUG
; 9058 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  02ff1	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  02ff7	50		 push	 eax
  02ff8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L73924:

; 9059 : 	}
; 9060 : 	
; 9061 : 	/********************************************************************/
; 9062 : 	/*  Subtract the characters queued from the queued character count. */
; 9063 : 	/********************************************************************/
; 9064 : 	
; 9065 : 	EnterCriticalSection( phTTS->pcsQueuedCharacterCount );

  02ffe	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  03004	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__EnterCriticalSection@4
  0300a	51		 push	 ecx
  0300b	ff d5		 call	 ebp

; 9066 : 	phTTS->uiQueuedCharacterCount -= pTextMsg->uiLength;

  0300d	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  03010	8b 7e 40	 mov	 edi, DWORD PTR [esi+64]

; 9067 : 	LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );

  03013	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  03019	2b fa		 sub	 edi, edx
  0301b	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  0301e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LeaveCriticalSection@4
  03024	50		 push	 eax
  03025	ff d7		 call	 edi

; 9068 : 	
; 9069 : 	/********************************************************************/
; 9070 : 	/*  Update the last queued message parameter for the                */
; 9071 : 	/*  TextToSpeechSync() function.                                    */
; 9072 : 	/********************************************************************/
; 9073 : 	
; 9074 : 	EnterCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  03027	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  0302d	51		 push	 ecx
  0302e	ff d5		 call	 ebp

; 9075 : 	phTTS->uiLastQueuedTextMsgNumber = pTextMsg->uiMsgNumber;
; 9076 : 	LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  03030	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  03036	8b 13		 mov	 edx, DWORD PTR [ebx]
  03038	50		 push	 eax
  03039	89 56 4c	 mov	 DWORD PTR [esi+76], edx
  0303c	ff d7		 call	 edi

; 9077 : 	
; 9078 : 	/********************************************************************/
; 9079 : 	/*  Free the text buffer and the text message structure.            */
; 9080 : 	/*  These were allocated in the TextToSpeechSpeak() function which  */
; 9081 : 	/*  runs in the applications thread !                               */
; 9082 : 	/********************************************************************/
; 9083 : 	
; 9084 : 	free( pTextMsg->pText );

  0303e	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  03041	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  03047	51		 push	 ecx
  03048	ff d6		 call	 esi

; 9085 : 	free( pTextMsg );

  0304a	53		 push	 ebx
  0304b	ff d6		 call	 esi
  0304d	83 c4 08	 add	 esp, 8
  03050	5f		 pop	 edi
  03051	5e		 pop	 esi
  03052	5d		 pop	 ebp
  03053	5b		 pop	 ebx

; 9086 : 	
; 9087 : 	return;
; 9088 : }

  03054	c3		 ret	 0
_Process_TTS_Message ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechErrorHandler
_TEXT	SEGMENT
_phTTS$ = 8
_uiErrorCode$ = 12
_mmStatus$ = 16
_TextToSpeechErrorHandler PROC NEAR

; 9125 : 	if ( phTTS->bEnableErrorMessage )

  03060	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03064	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0306a	85 c9		 test	 ecx, ecx
  0306c	74 21		 je	 SHORT $L73932

; 9126 : 	{
; 9127 : 		phTTS->bEnableErrorMessage = FALSE;
; 9128 : 		/*
; 9129 : 		SendMessage( phTTS->hWnd,
; 9130 : 		phTTS->uiID_Error_Message,
; 9131 : 		(WPARAM)uiErrorCode,
; 9132 : 		(LPARAM)mmStatus );
; 9133 : 		*/
; 9134 : 		//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code:
; 9135 : #ifdef API_DEBUG
; 9136 : 		OutputDebugString("returning error message. \n");
; 9137 : #endif //API_DEBUG
; 9138 : 		Report_TTS_Status(phTTS,phTTS->uiID_Error_Message,(WPARAM)uiErrorCode,(LPARAM)mmStatus);

  0306e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _mmStatus$[esp-4]
  03072	8b 54 24 08	 mov	 edx, DWORD PTR _uiErrorCode$[esp-4]
  03076	51		 push	 ecx
  03077	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0307a	52		 push	 edx
  0307b	51		 push	 ecx
  0307c	50		 push	 eax
  0307d	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+140], 0
  03087	e8 00 00 00 00	 call	 _Report_TTS_Status
  0308c	83 c4 10	 add	 esp, 16			; 00000010H
$L73932:

; 9139 : 		
; 9140 : 	}
; 9141 : 	return;
; 9142 : }

  0308f	c3		 ret	 0
_TextToSpeechErrorHandler ENDP
_TEXT	ENDS
PUBLIC	_WriteAudioToFile
_TEXT	SEGMENT
_phTTS$ = 8
_pBuffer$ = 12
_uiLength$ = 16
_WriteAudioToFile PROC NEAR

; 9210 : {

  03090	53		 push	 ebx

; 9211 : 	UINT i;
; 9212 : 	unsigned char * pByteDest;
; 9213 : 	LPSAMPLE_T pSource;
; 9214 : 	size_t Size;
; 9215 : #ifdef UNDER_CE
; 9216 :   	DWORD dwRW;
; 9217 : #endif	
; 9218 : 	/********************************************************************/
; 9219 : 	/*  Convert the 16 bit samples to the desired output format.        */
; 9220 : 	/********************************************************************/
; 9221 : 	
; 9222 : 	switch( phTTS->dwFormat )
; 9223 : 	{

  03091	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  03095	55		 push	 ebp
  03096	8b 6c 24 14	 mov	 ebp, DWORD PTR _uiLength$[esp+4]
  0309a	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [ebx+132]
  030a0	56		 push	 esi
  030a1	48		 dec	 eax
  030a2	74 48		 je	 SHORT $L73953
  030a4	83 e8 03	 sub	 eax, 3
  030a7	74 3c		 je	 SHORT $L73951
  030a9	83 e8 03	 sub	 eax, 3
  030ac	74 09		 je	 SHORT $L73960
  030ae	5e		 pop	 esi
  030af	5d		 pop	 ebp

; 9253 : 		
; 9254 : 	default:
; 9255 : 		
; 9256 : 		return( MMSYSERR_INVALHANDLE );

  030b0	b8 05 00 00 00	 mov	 eax, 5
  030b5	5b		 pop	 ebx

; 9272 : }

  030b6	c3		 ret	 0
$L73960:

; 9239 : 		
; 9240 : 		break;
; 9241 : 		
; 9242 : 	case WAVE_FORMAT_08M08:
; 9243 : 		
; 9244 : 		pSource = pBuffer;

  030b7	8b 74 24 14	 mov	 esi, DWORD PTR _pBuffer$[esp+8]
  030bb	57		 push	 edi

; 9245 : 		pByteDest = (unsigned char *)pBuffer;
; 9246 : 		
; 9247 : 		for ( i = 0; i < uiLength; i++ )

  030bc	85 ed		 test	 ebp, ebp
  030be	8b fe		 mov	 edi, esi
  030c0	76 1b		 jbe	 SHORT $L73964

; 9239 : 		
; 9240 : 		break;
; 9241 : 		
; 9242 : 	case WAVE_FORMAT_08M08:
; 9243 : 		
; 9244 : 		pSource = pBuffer;

  030c2	8b dd		 mov	 ebx, ebp
$L73962:

; 9248 : 			*pByteDest++ = LinearToMuLaw( *pSource++ );

  030c4	66 8b 06	 mov	 ax, WORD PTR [esi]
  030c7	83 c6 02	 add	 esi, 2
  030ca	50		 push	 eax
  030cb	e8 00 00 00 00	 call	 _LinearToMuLaw
  030d0	83 c4 04	 add	 esp, 4
  030d3	88 07		 mov	 BYTE PTR [edi], al
  030d5	47		 inc	 edi
  030d6	4b		 dec	 ebx
  030d7	75 eb		 jne	 SHORT $L73962

; 9245 : 		pByteDest = (unsigned char *)pBuffer;
; 9246 : 		
; 9247 : 		for ( i = 0; i < uiLength; i++ )

  030d9	8b 5c 24 14	 mov	 ebx, DWORD PTR _phTTS$[esp+12]
$L73964:

; 9249 : 		
; 9250 : 		Size = sizeof( unsigned char );

  030dd	b8 01 00 00 00	 mov	 eax, 1
  030e2	5f		 pop	 edi

; 9251 : 		
; 9252 : 		break;

  030e3	eb 2a		 jmp	 SHORT $L73948
$L73951:

; 9224 : 	case WAVE_FORMAT_1M16:
; 9225 : 		
; 9226 : 		Size = sizeof( short );

  030e5	b8 02 00 00 00	 mov	 eax, 2

; 9227 : 		
; 9228 : 		break;

  030ea	eb 23		 jmp	 SHORT $L73948
$L73953:

; 9229 : 		
; 9230 : 	case WAVE_FORMAT_1M08:
; 9231 : 		
; 9232 : 		pSource = pBuffer;

  030ec	8b 44 24 14	 mov	 eax, DWORD PTR _pBuffer$[esp+8]

; 9233 : 		pByteDest = (unsigned char *)pBuffer;
; 9234 : 		
; 9235 : 		for ( i = 0; i < uiLength; i++ )

  030f0	85 ed		 test	 ebp, ebp
  030f2	8b c8		 mov	 ecx, eax
  030f4	76 14		 jbe	 SHORT $L73957

; 9229 : 		
; 9230 : 	case WAVE_FORMAT_1M08:
; 9231 : 		
; 9232 : 		pSource = pBuffer;

  030f6	8b f5		 mov	 esi, ebp
$L73955:

; 9236 : 			*pByteDest++ = ((unsigned char)((*pSource++) >> 8)) ^ 0x80;

  030f8	66 8b 11	 mov	 dx, WORD PTR [ecx]
  030fb	83 c1 02	 add	 ecx, 2
  030fe	c1 fa 08	 sar	 edx, 8
  03101	80 f2 80	 xor	 dl, 128			; 00000080H
  03104	88 10		 mov	 BYTE PTR [eax], dl
  03106	40		 inc	 eax
  03107	4e		 dec	 esi
  03108	75 ee		 jne	 SHORT $L73955
$L73957:

; 9237 : 		
; 9238 : 		Size = sizeof( unsigned char );

  0310a	b8 01 00 00 00	 mov	 eax, 1
$L73948:

; 9257 : 	}
; 9258 : 	
; 9259 : 	/********************************************************************/
; 9260 : 	/*  Write the audio samples to the output file.                     */
; 9261 : 	/********************************************************************/
; 9262 : #ifdef UNDER_CE	
; 9263 : 	if( WriteFile(phTTS->pWaveFile,(char *)pBuffer,Size*uiLength,&dwRW,NULL) == 0 )
; 9264 : #else
; 9265 : 	if ( uiLength != fwrite( (char *)pBuffer, Size, (size_t)uiLength, phTTS->pWaveFile ) )

  0310f	8b 8b 98 00 00
	00		 mov	 ecx, DWORD PTR [ebx+152]
  03115	8b 54 24 14	 mov	 edx, DWORD PTR _pBuffer$[esp+8]
  03119	51		 push	 ecx
  0311a	55		 push	 ebp
  0311b	50		 push	 eax
  0311c	52		 push	 edx
  0311d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  03123	83 c4 10	 add	 esp, 16			; 00000010H
  03126	3b e8		 cmp	 ebp, eax
  03128	74 09		 je	 SHORT $L73969
  0312a	5e		 pop	 esi
  0312b	5d		 pop	 ebp

; 9266 : #endif
; 9267 : 		return( MMSYSERR_ERROR );

  0312c	b8 01 00 00 00	 mov	 eax, 1
  03131	5b		 pop	 ebx

; 9272 : }

  03132	c3		 ret	 0
$L73969:

; 9268 : 	
; 9269 : 	phTTS->dwFileSampleCount += uiLength;

  03133	8b 43 7c	 mov	 eax, DWORD PTR [ebx+124]
  03136	5e		 pop	 esi
  03137	03 c5		 add	 eax, ebp
  03139	5d		 pop	 ebp
  0313a	89 43 7c	 mov	 DWORD PTR [ebx+124], eax

; 9270 : 	
; 9271 : 	return( MMSYSERR_NOERROR );

  0313d	33 c0		 xor	 eax, eax
  0313f	5b		 pop	 ebx

; 9272 : }

  03140	c3		 ret	 0
_WriteAudioToFile ENDP
_wSample$ = 8
_LinearToMuLaw PROC NEAR

; 9311 : 	static short wExponentLut[256] = { 0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
; 9312 : 		4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
; 9313 : 		5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
; 9314 : 		5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
; 9315 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 9316 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 9317 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 9318 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 9319 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 9320 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 9321 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 9322 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 9323 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 9324 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 9325 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 9326 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 };
; 9327 : 	short wSign;
; 9328 : 	short wExponent;
; 9329 : 	short wMantissa;
; 9330 : 	unsigned char cMuLawByte;
; 9331 : 	
; 9332 : 	/********************************************************************/
; 9333 : 	/*  Get the sample into sign-magnitude.                             */
; 9334 : 	/*  First save the sign.                                            */
; 9335 : 	/********************************************************************/
; 9336 : 	
; 9337 : 	wSign = ( wSample >> 8 ) & 0x80;

  03150	8b 44 24 04	 mov	 eax, DWORD PTR _wSample$[esp-4]
  03154	53		 push	 ebx
  03155	8b d8		 mov	 ebx, eax
  03157	c1 fb 08	 sar	 ebx, 8
  0315a	81 e3 80 00 00
	00		 and	 ebx, 128		; 00000080H

; 9338 : 	
; 9339 : 	/********************************************************************/
; 9340 : 	/*  Get magnitude.                                                  */
; 9341 : 	/********************************************************************/
; 9342 : 	
; 9343 : 	if ( wSign != 0 )

  03160	66 85 db	 test	 bx, bx
  03163	74 02		 je	 SHORT $L73979

; 9344 : 		wSample = - wSample;

  03165	f7 d8		 neg	 eax
$L73979:

; 9345 : 	
; 9346 : 	/********************************************************************/
; 9347 : 	/*  Clip the magnitude.                                             */
; 9348 : 	/********************************************************************/
; 9349 : 	
; 9350 : 	if ( wSample > MULAW_CLIP_LEVEL )

  03167	66 3d 7b 7f	 cmp	 ax, 32635		; 00007f7bH
  0316b	7e 05		 jle	 SHORT $L73980

; 9351 : 		wSample = MULAW_CLIP_LEVEL;

  0316d	b8 7b 7f 00 00	 mov	 eax, 32635		; 00007f7bH
$L73980:

; 9352 : 	
; 9353 : 	/********************************************************************/
; 9354 : 	/*  Convert from 16 bit linear to mu-law.                           */
; 9355 : 	/********************************************************************/
; 9356 : 	
; 9357 : 	wSample = wSample + MULAW_BIAS;

  03172	05 84 00 00 00	 add	 eax, 132		; 00000084H

; 9358 : 	wExponent = wExponentLut[ ( wSample >> 7 ) & 0xFF ];

  03177	8b c8		 mov	 ecx, eax
  03179	c1 f9 07	 sar	 ecx, 7
  0317c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  03182	66 8b 14 4d 00
	00 00 00	 mov	 dx, WORD PTR _?wExponentLut@?1??LinearToMuLaw@@9@9[ecx*2]

; 9359 : 	wMantissa = ( wSample >> ( wExponent + 3 ) ) & 0x0F;

  0318a	66 8b ca	 mov	 cx, dx
  0318d	66 83 c1 03	 add	 cx, 3
  03191	66 d3 f8	 sar	 ax, cl

; 9360 : 	cMuLawByte = ~ ( wSign | ( wExponent << 4 ) | wMantissa );

  03194	c0 e2 04	 shl	 dl, 4
  03197	24 0f		 and	 al, 15			; 0000000fH

; 9361 : 	
; 9362 : 	/********************************************************************/
; 9363 : 	/*  Optional CCITT trap                                             */
; 9364 : 	/********************************************************************/
; 9365 : 	
; 9366 : #ifdef ZEROTRAP
; 9367 : 	if ( cMuLawByte == 0 )
; 9368 : 		cMuLawByte = 0x02;
; 9369 : #endif //ZEROTRAP
; 9370 : 	
; 9371 : 	return( cMuLawByte );

  03199	0a c2		 or	 al, dl
  0319b	0a c3		 or	 al, bl
  0319d	5b		 pop	 ebx
  0319e	f6 d0		 not	 al

; 9372 : }

  031a0	c3		 ret	 0
_LinearToMuLaw ENDP
_TEXT	ENDS
PUBLIC	_WaitForLtsFlush
_TEXT	SEGMENT
_phTTS$ = 8
_dwWaitTimeInMsec$ = 12
_uiPhCount$ = -4
_uiLtsCount$ = -4
_dwTotalTimeInMsec$ = -8
_WaitForLtsFlush PROC NEAR

; 9416 : {

  031b0	83 ec 08	 sub	 esp, 8

; 9417 : 	BOOL bPipesNotEmpty;
; 9418 : 	UINT uiSyncCount;
; 9419 : 	UINT uiVtmCount;
; 9420 : 	UINT uiPhCount;
; 9421 : 	UINT uiLtsCount;
; 9422 : #ifdef WIN32
; 9423 : 	UINT	uiSleepTime;
; 9424 : #endif
; 9425 : 	DWORD dwTotalTimeInMsec;
; 9426 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 9427 : 	* and initialize from phTTS structure
; 9428 : 	*/
; 9429 : 	PKSD_T pKsd_t = NULL;
; 9430 : 	
; 9431 : 	pKsd_t = phTTS->pKernelShareData;

  031b3	8b 44 24 0c	 mov	 eax, DWORD PTR _phTTS$[esp+4]
  031b7	53		 push	 ebx
  031b8	55		 push	 ebp
  031b9	56		 push	 esi
  031ba	57		 push	 edi

; 9432 : #ifdef TYPING_MODE
; 9433 : 	if (phTTS->bInTypingMode)

  031bb	8b b8 dc 00 00
	00		 mov	 edi, DWORD PTR [eax+220]
  031c1	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 9434 : 		uiSleepTime=1; // just reschedule
; 9435 : 	else
; 9436 : #endif //TYPING_MODE
; 9437 : #ifdef WIN32
; 9438 : 		uiSleepTime=WAIT_PIPE_SLEEP_TIME;
; 9439 : #endif
; 9440 : 	/********************************************************************/
; 9441 : 	/*  Wait for all the pipes to empty.                                */
; 9442 : 	/*  If the pipes are not empty then sleep for 100 msec. and check   */
; 9443 : 	/*  them again.                                                     */
; 9444 : 	/********************************************************************/
; 9445 : 	
; 9446 : 	dwTotalTimeInMsec = 0;

  031c4	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+24], 0
  031cc	f7 df		 neg	 edi
  031ce	1b ff		 sbb	 edi, edi
  031d0	83 e7 fc	 and	 edi, -4			; fffffffcH
  031d3	83 c7 05	 add	 edi, 5
$L73998:

; 9447 : 	bPipesNotEmpty = TRUE;
; 9448 : 	
; 9449 : 	while ( bPipesNotEmpty )
; 9450 : 	{
; 9451 : 		bPipesNotEmpty = FALSE;
; 9452 : 		
; 9453 : 		uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  031d6	8b 86 a0 02 00
	00		 mov	 eax, DWORD PTR [esi+672]
  031dc	50		 push	 eax
  031dd	e8 00 00 00 00	 call	 _pipe_count

; 9454 : 		uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  031e2	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  031e8	8b d8		 mov	 ebx, eax
  031ea	51		 push	 ecx
  031eb	e8 00 00 00 00	 call	 _pipe_count

; 9455 : 		uiPhCount = pipe_count( pKsd_t->ph_pipe );

  031f0	8b 96 94 02 00
	00		 mov	 edx, DWORD PTR [esi+660]
  031f6	8b e8		 mov	 ebp, eax
  031f8	52		 push	 edx
  031f9	e8 00 00 00 00	 call	 _pipe_count
  031fe	89 44 24 20	 mov	 DWORD PTR _uiPhCount$[esp+36], eax

; 9456 : 		uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03202	8b 86 90 02 00
	00		 mov	 eax, DWORD PTR [esi+656]
  03208	50		 push	 eax
  03209	e8 00 00 00 00	 call	 _pipe_count
  0320e	83 c4 10	 add	 esp, 16			; 00000010H

; 9457 : 		
; 9458 : 		if  (( uiSyncCount != 0 )
; 9459 : 			|| ( uiVtmCount != 0 )
; 9460 : 			|| ( uiPhCount != 0 )
; 9461 : 			|| ( uiLtsCount != 0 ))

  03211	85 db		 test	 ebx, ebx
  03213	75 5f		 jne	 SHORT $L74004
  03215	85 ed		 test	 ebp, ebp
  03217	75 5b		 jne	 SHORT $L74004
  03219	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiPhCount$[esp+24]
  0321d	85 c9		 test	 ecx, ecx
  0321f	75 53		 jne	 SHORT $L74004
  03221	85 c0		 test	 eax, eax

; 9462 : 			bPipesNotEmpty = TRUE;
; 9463 : 		
; 9464 : 		/******************************************************************/
; 9465 : 		/*  If bPipesNotEmpty is still FALSE here then the pipes are      */
; 9466 : 		/*  probably empty. It is possible that there is still data in    */
; 9467 : 		/*  the pipes, but that it moved out of a pipe we are about to    */
; 9468 : 		/*  check into a pipe we have we just checked. We now check the   */
; 9469 : 		/*  pipes in the reverse order.                                   */
; 9470 : 		/******************************************************************/
; 9471 : 		
; 9472 : 		if ( ! bPipesNotEmpty )

  03223	75 4f		 jne	 SHORT $L74004

; 9473 : 		{
; 9474 : 		/*
; 9475 : 		kernel_disable(pKsd_t);
; 9476 : 			*/
; 9477 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03225	8b 8e 90 02 00
	00		 mov	 ecx, DWORD PTR [esi+656]
  0322b	51		 push	 ecx
  0322c	e8 00 00 00 00	 call	 _pipe_count

; 9478 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  03231	8b 96 94 02 00
	00		 mov	 edx, DWORD PTR [esi+660]
  03237	89 44 24 18	 mov	 DWORD PTR _uiLtsCount$[esp+28], eax
  0323b	52		 push	 edx
  0323c	e8 00 00 00 00	 call	 _pipe_count
  03241	8b e8		 mov	 ebp, eax

; 9479 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  03243	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  03249	50		 push	 eax
  0324a	e8 00 00 00 00	 call	 _pipe_count

; 9480 : 			uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  0324f	8b 8e a0 02 00
	00		 mov	 ecx, DWORD PTR [esi+672]
  03255	8b d8		 mov	 ebx, eax
  03257	51		 push	 ecx
  03258	e8 00 00 00 00	 call	 _pipe_count
  0325d	83 c4 10	 add	 esp, 16			; 00000010H

; 9481 : 			/*
; 9482 : 			kernel_enable( pKsd_t, uiDummy );
; 9483 : 			*/
; 9484 : 			if  (( uiSyncCount != 0 )
; 9485 : 				|| ( uiVtmCount != 0 )
; 9486 : 				|| ( uiPhCount != 0 )
; 9487 : 				|| ( uiLtsCount != 0 ))

  03260	85 c0		 test	 eax, eax
  03262	75 10		 jne	 SHORT $L74004
  03264	85 db		 test	 ebx, ebx
  03266	75 0c		 jne	 SHORT $L74004
  03268	85 ed		 test	 ebp, ebp
  0326a	75 08		 jne	 SHORT $L74004
  0326c	8b 44 24 14	 mov	 eax, DWORD PTR _uiLtsCount$[esp+24]
  03270	85 c0		 test	 eax, eax
  03272	74 3d		 je	 SHORT $L73999
$L74004:

; 9488 : 				bPipesNotEmpty = TRUE;
; 9489 : 			else
; 9490 : 				bPipesNotEmpty = FALSE;
; 9491 : 		}
; 9492 : 		
; 9493 : 		/******************************************************************/
; 9494 : 		/*  Go to sleep for WAIT_PIPE_SLEEP_TIME msec.                    */
; 9495 : 		/******************************************************************/
; 9496 : 		
; 9497 : 		if ( bPipesNotEmpty )
; 9498 : 		{
; 9499 : #ifdef WIN32
; 9500 : 			PumpModeMessage(phTTS->pAudioHandle);

  03274	8b 54 24 1c	 mov	 edx, DWORD PTR _phTTS$[esp+20]
  03278	8b 82 d8 00 00
	00		 mov	 eax, DWORD PTR [edx+216]
  0327e	50		 push	 eax
  0327f	e8 00 00 00 00	 call	 _PumpModeMessage
  03284	83 c4 04	 add	 esp, 4

; 9501 : 			Sleep( uiSleepTime );

  03287	57		 push	 edi
  03288	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 9502 : 			dwTotalTimeInMsec += uiSleepTime;

  0328e	8b 44 24 10	 mov	 eax, DWORD PTR _dwTotalTimeInMsec$[esp+24]

; 9503 : #endif
; 9504 : #if defined __osf__ || defined __linux__
; 9505 : 			OP_Sleep( WAIT_PIPE_SLEEP_TIME );
; 9506 : 			dwTotalTimeInMsec += WAIT_PIPE_SLEEP_TIME;
; 9507 : #endif
; 9508 : 			
; 9509 : 			if ( dwTotalTimeInMsec > dwWaitTimeInMsec )

  03292	8b 4c 24 20	 mov	 ecx, DWORD PTR _dwWaitTimeInMsec$[esp+20]
  03296	03 c7		 add	 eax, edi
  03298	3b c1		 cmp	 eax, ecx
  0329a	89 44 24 10	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+24], eax
  0329e	0f 86 32 ff ff
	ff		 jbe	 $L73998
  032a4	5f		 pop	 edi
  032a5	5e		 pop	 esi
  032a6	5d		 pop	 ebp

; 9510 : 			{
; 9511 : 				return( MMSYSERR_ERROR );

  032a7	b8 01 00 00 00	 mov	 eax, 1
  032ac	5b		 pop	 ebx

; 9516 : }

  032ad	83 c4 08	 add	 esp, 8
  032b0	c3		 ret	 0
$L73999:
  032b1	5f		 pop	 edi
  032b2	5e		 pop	 esi
  032b3	5d		 pop	 ebp

; 9512 : 			}
; 9513 : 		}
; 9514 : 	}
; 9515 : 	return( MMSYSERR_NOERROR );

  032b4	33 c0		 xor	 eax, eax
  032b6	5b		 pop	 ebx

; 9516 : }

  032b7	83 c4 08	 add	 esp, 8
  032ba	c3		 ret	 0
_WaitForLtsFlush ENDP
_phTTS$ = 8
_uiLockedUpCount$ = -24
_uiLtsCount$ = 8
_uiCmdCount$ = -4
_uiOldVtmCount$ = -20
_uiOldPhCount$ = -16
_uiOldLtsCount$ = -12
_uiOldCmdCount$ = -8
_FixMemoryLockup PROC NEAR

; 9549 : {

  032c0	83 ec 18	 sub	 esp, 24			; 00000018H
  032c3	53		 push	 ebx

; 9550 : 	BOOL bPipesNotChanging;
; 9551 : 	UINT uiLockedUpCount;
; 9552 : 	UINT uiVtmCount;
; 9553 : 	UINT uiPhCount;
; 9554 : 	UINT uiLtsCount;
; 9555 : 	UINT uiCmdCount;
; 9556 : 	UINT uiOldVtmCount;
; 9557 : 	UINT uiOldPhCount;
; 9558 : 	UINT uiOldLtsCount;
; 9559 : 	UINT uiOldCmdCount;
; 9560 : #ifdef API_DEBUG
; 9561 : 	char szTemp[256]="";
; 9562 : 	ULONG ulStartTime, ulEndTime;
; 9563 : #endif //API_DEBUG
; 9564 : 	
; 9565 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 9566 : 	* and initialize from phTTS structure
; 9567 : 	*/
; 9568 : 	PKSD_T pKsd_t = NULL;
; 9569 : 	
; 9570 : #ifdef API_DEBUG
; 9571 : 	ulStartTime=timeGetTime();
; 9572 : 	sprintf(szTemp,"FixMemoryLockup() at %ld",ulStartTime);
; 9573 : 	OutputDebugString(szTemp);
; 9574 : #endif //API_DEBUG
; 9575 : 	
; 9576 : 	pKsd_t = phTTS->pKernelShareData;

  032c4	8b 5c 24 20	 mov	 ebx, DWORD PTR _phTTS$[esp+24]
  032c8	55		 push	 ebp
  032c9	56		 push	 esi

; 9577 : 	
; 9578 : 	/********************************************************************/
; 9579 : 	/*  Wait for all the pipes to change.                               */
; 9580 : 	/*  If the pipes are not changing then go to sleep                  */
; 9581 : 	/********************************************************************/
; 9582 : #ifdef WIN32
; 9583 : 	SetEvent( phTTS->hSyncEvent );

  032ca	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  032cd	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  032d0	57		 push	 edi
  032d1	50		 push	 eax
  032d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 9584 : #endif
; 9585 : #if defined __osf__ || defined __linux__
; 9586 : 	OP_SetEvent( phTTS->hSyncEvent );
; 9587 : #endif
; 9588 : 	
; 9589 : 	uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  032d8	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  032de	51		 push	 ecx
  032df	e8 00 00 00 00	 call	 _pipe_count

; 9590 : 	uiPhCount = pipe_count( pKsd_t->ph_pipe );

  032e4	8b 96 94 02 00
	00		 mov	 edx, DWORD PTR [esi+660]
  032ea	8b f8		 mov	 edi, eax
  032ec	52		 push	 edx
  032ed	e8 00 00 00 00	 call	 _pipe_count
  032f2	8b e8		 mov	 ebp, eax

; 9591 : 	uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  032f4	8b 86 90 02 00
	00		 mov	 eax, DWORD PTR [esi+656]
  032fa	50		 push	 eax
  032fb	e8 00 00 00 00	 call	 _pipe_count

; 9592 : 	uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  03300	8b 8e 98 02 00
	00		 mov	 ecx, DWORD PTR [esi+664]
  03306	89 44 24 38	 mov	 DWORD PTR _uiLtsCount$[esp+48], eax
  0330a	51		 push	 ecx
  0330b	e8 00 00 00 00	 call	 _pipe_count

; 9593 : 	
; 9594 : 	uiOldVtmCount = uiVtmCount;
; 9595 : 	uiOldPhCount = uiPhCount;
; 9596 : 	uiOldLtsCount = uiLtsCount;

  03310	8b 4c 24 3c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+52]
  03314	83 c4 10	 add	 esp, 16			; 00000010H

; 9597 : 	uiOldCmdCount = uiCmdCount;
; 9598 : 	
; 9599 : 	uiLockedUpCount = 0;
; 9600 : 	bPipesNotChanging = TRUE;
; 9601 : 	
; 9602 : 	if (
; 9603 : 		(uiVtmCount) || (uiPhCount) 
; 9604 : 		|| (uiLtsCount) || (uiCmdCount) 
; 9605 : 		)

  03317	85 ff		 test	 edi, edi
  03319	89 7c 24 14	 mov	 DWORD PTR _uiOldVtmCount$[esp+40], edi
  0331d	89 6c 24 18	 mov	 DWORD PTR _uiOldPhCount$[esp+40], ebp
  03321	89 4c 24 1c	 mov	 DWORD PTR _uiOldLtsCount$[esp+40], ecx
  03325	89 44 24 20	 mov	 DWORD PTR _uiOldCmdCount$[esp+40], eax
  03329	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _uiLockedUpCount$[esp+40], 0
  03331	75 10		 jne	 SHORT $L74026
  03333	85 ed		 test	 ebp, ebp
  03335	75 0c		 jne	 SHORT $L74026
  03337	85 c9		 test	 ecx, ecx
  03339	75 08		 jne	 SHORT $L74026
  0333b	85 c0		 test	 eax, eax
  0333d	0f 84 0c 01 00
	00		 je	 $L74028
$L74026:

; 9606 : 	{ 
; 9607 : 		while ( bPipesNotChanging )
; 9608 : 		{
; 9609 : 
; 9610 : 			PumpModeMessage(phTTS->pAudioHandle);

  03343	8b 93 d8 00 00
	00		 mov	 edx, DWORD PTR [ebx+216]
  03349	52		 push	 edx
  0334a	e8 00 00 00 00	 call	 _PumpModeMessage
  0334f	83 c4 04	 add	 esp, 4

; 9611 : 			Sleep( MEMORY_LOCKUP_SLEEP_TIME );

  03352	6a 14		 push	 20			; 00000014H
  03354	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 9612 : 			
; 9613 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  0335a	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  03360	50		 push	 eax
  03361	e8 00 00 00 00	 call	 _pipe_count

; 9614 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  03366	8b 8e 94 02 00
	00		 mov	 ecx, DWORD PTR [esi+660]
  0336c	8b f8		 mov	 edi, eax
  0336e	51		 push	 ecx
  0336f	e8 00 00 00 00	 call	 _pipe_count

; 9615 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03374	8b 96 90 02 00
	00		 mov	 edx, DWORD PTR [esi+656]
  0337a	8b e8		 mov	 ebp, eax
  0337c	52		 push	 edx
  0337d	e8 00 00 00 00	 call	 _pipe_count
  03382	89 44 24 38	 mov	 DWORD PTR _uiLtsCount$[esp+48], eax

; 9616 : 			uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  03386	8b 86 98 02 00
	00		 mov	 eax, DWORD PTR [esi+664]
  0338c	50		 push	 eax
  0338d	e8 00 00 00 00	 call	 _pipe_count
  03392	83 c4 10	 add	 esp, 16			; 00000010H
  03395	89 44 24 24	 mov	 DWORD PTR _uiCmdCount$[esp+40], eax

; 9617 : 			
; 9618 : 			/******************************************************************/
; 9619 : 			/*  Are any of the the pipes changing ?                           */
; 9620 : 			/******************************************************************/
; 9621 : 			
; 9622 : 			if (
; 9623 : 				(
; 9624 : 				(uiVtmCount) || (uiPhCount) 
; 9625 : 				|| (uiLtsCount) || (uiCmdCount) 
; 9626 : 				)
; 9627 : 				&&
; 9628 : 				(   ( uiVtmCount == uiOldVtmCount )
; 9629 : 				&& ( uiPhCount == uiOldPhCount )
; 9630 : 				&& ( uiLtsCount == uiOldLtsCount )
; 9631 : 				&& ( uiCmdCount == uiOldCmdCount )
; 9632 : 				)
; 9633 : 				)

  03399	85 ff		 test	 edi, edi
  0339b	75 14		 jne	 SHORT $L74029
  0339d	85 ed		 test	 ebp, ebp
  0339f	75 10		 jne	 SHORT $L74029
  033a1	8b 4c 24 2c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+36]
  033a5	85 c9		 test	 ecx, ecx
  033a7	75 08		 jne	 SHORT $L74029
  033a9	85 c0		 test	 eax, eax
  033ab	0f 84 9e 00 00
	00		 je	 $L74028
$L74029:
  033b1	3b 7c 24 14	 cmp	 edi, DWORD PTR _uiOldVtmCount$[esp+40]
  033b5	0f 85 94 00 00
	00		 jne	 $L74028
  033bb	3b 6c 24 18	 cmp	 ebp, DWORD PTR _uiOldPhCount$[esp+40]
  033bf	0f 85 8a 00 00
	00		 jne	 $L74028
  033c5	8b 4c 24 2c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+36]
  033c9	8b 54 24 1c	 mov	 edx, DWORD PTR _uiOldLtsCount$[esp+40]
  033cd	3b ca		 cmp	 ecx, edx
  033cf	75 7e		 jne	 SHORT $L74028
  033d1	3b 44 24 20	 cmp	 eax, DWORD PTR _uiOldCmdCount$[esp+40]
  033d5	75 78		 jne	 SHORT $L74028

; 9634 : 			{
; 9635 : 				bPipesNotChanging = TRUE;
; 9636 : 				// tek 29aug96make sure we didn't somehow end up with no place
; 9637 : 				// to go..
; 9638 : 				if((pKsd_t->buffer_pipe != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 2) )

  033d7	8b 86 a4 02 00
	00		 mov	 eax, DWORD PTR [esi+676]
  033dd	85 c0		 test	 eax, eax
  033df	74 19		 je	 SHORT $L74031
  033e1	50		 push	 eax
  033e2	e8 00 00 00 00	 call	 _pipe_count
  033e7	83 c4 04	 add	 esp, 4
  033ea	83 f8 02	 cmp	 eax, 2
  033ed	73 0b		 jae	 SHORT $L74031

; 9639 : 					TextToSpeechAddBuffer(phTTS, NULL);

  033ef	6a 00		 push	 0
  033f1	53		 push	 ebx
  033f2	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  033f7	83 c4 08	 add	 esp, 8
$L74031:

; 9640 : 				uiLockedUpCount++;

  033fa	8b 44 24 10	 mov	 eax, DWORD PTR _uiLockedUpCount$[esp+40]
  033fe	40		 inc	 eax

; 9641 : 				
; 9642 : 				if ( uiLockedUpCount > MEMORY_LOCKUP_COUNT )

  033ff	83 f8 02	 cmp	 eax, 2
  03402	89 44 24 10	 mov	 DWORD PTR _uiLockedUpCount$[esp+40], eax
  03406	76 2a		 jbe	 SHORT $L74033

; 9643 : 				{
; 9644 : 					/**************************************************************/
; 9645 : 					/*  Test to see if the vtm thread is blocked by a call to     */
; 9646 : 					/*  SendMessage().                                            */
; 9647 : 					/**************************************************************/
; 9648 : 					
; 9649 : #ifdef WIN32
; 9650 : 					ResetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  03408	8b 53 3c	 mov	 edx, DWORD PTR [ebx+60]
  0340b	52		 push	 edx
  0340c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 9651 : #endif
; 9652 : #if defined __osf__ || defined __linux__
; 9653 : 					OP_ResetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 9654 : #endif
; 9655 : 					
; 9656 : 					if ( phTTS->bSendingBuffer )

  03412	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [ebx+148]
  03418	85 c0		 test	 eax, eax
  0341a	74 0c		 je	 SHORT $L74034

; 9657 : 					{
; 9658 : 						EmptyVtmPipe(phTTS->pKernelShareData);

  0341c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0341f	50		 push	 eax
  03420	e8 00 00 00 00	 call	 _EmptyVtmPipe
  03425	83 c4 04	 add	 esp, 4
$L74034:

; 9659 : 					}
; 9660 : #ifdef WIN32
; 9661 : 					SetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  03428	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  0342b	51		 push	 ecx
  0342c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L74033:

; 9662 : #endif
; 9663 : #if defined __osf__ || defined __linux__
; 9664 : 					OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 9665 : #endif
; 9666 : 				}
; 9667 : 				
; 9668 : 				uiOldVtmCount = uiVtmCount;
; 9669 : 				uiOldPhCount = uiPhCount;
; 9670 : 				uiOldLtsCount = uiLtsCount;

  03432	8b 54 24 2c	 mov	 edx, DWORD PTR _uiLtsCount$[esp+36]

; 9671 : 				uiOldCmdCount = uiCmdCount;

  03436	8b 44 24 24	 mov	 eax, DWORD PTR _uiCmdCount$[esp+40]
  0343a	89 7c 24 14	 mov	 DWORD PTR _uiOldVtmCount$[esp+40], edi
  0343e	89 6c 24 18	 mov	 DWORD PTR _uiOldPhCount$[esp+40], ebp
  03442	89 54 24 1c	 mov	 DWORD PTR _uiOldLtsCount$[esp+40], edx
  03446	89 44 24 20	 mov	 DWORD PTR _uiOldCmdCount$[esp+40], eax

; 9672 : 			}
; 9673 : 			else

  0344a	e9 f4 fe ff ff	 jmp	 $L74026
$L74028:
  0344f	5f		 pop	 edi
  03450	5e		 pop	 esi
  03451	5d		 pop	 ebp
  03452	5b		 pop	 ebx

; 9674 : 			{
; 9675 : 				bPipesNotChanging = FALSE;
; 9676 : 			}
; 9677 : 		}
; 9678 : 	} // if pipes not empty
; 9679 : #ifdef API_DEBUG
; 9680 : 	ulEndTime=timeGetTime();
; 9681 : 	sprintf(szTemp,"FixMemoryLockup() exit %ld ms",ulEndTime-ulStartTime);
; 9682 : 	OutputDebugString(szTemp);
; 9683 : #endif //API_DEBUG
; 9684 : 	
; 9685 : 	return;
; 9686 : }

  03453	83 c4 18	 add	 esp, 24			; 00000018H
  03456	c3		 ret	 0
_FixMemoryLockup ENDP
_phTTS$ = 8
_dwWaitTimeInMsec$ = 12
_bReset$ = 16
_bPipesNotEmpty$ = -32
_uiLockedUpCount$ = -36
_uiVtmCount$ = -44
_uiPhCount$ = -40
_uiOldSyncCount$ = -20
_uiOldVtmCount$ = -16
_uiOldPhCount$ = -12
_uiOldLtsCount$ = -8
_uiOldCmdCount$ = -4
_uiSleepTime$ = -28
_dwTotalTimeInMsec$ = -24
_WaitForEmptyPipes PROC NEAR

; 9729 : {

  03460	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 9730 : 	BOOL bPipesNotEmpty;
; 9731 : 	UINT uiLockedUpCount;
; 9732 : 	UINT uiSyncCount;
; 9733 : 	UINT uiVtmCount;
; 9734 : 	UINT uiPhCount;
; 9735 : 	UINT uiLtsCount;
; 9736 : 	UINT uiCmdCount;
; 9737 : 	UINT uiOldSyncCount;
; 9738 : 	UINT uiOldVtmCount;
; 9739 : 	UINT uiOldPhCount;
; 9740 : 	UINT uiOldLtsCount;
; 9741 : 	UINT uiOldCmdCount;
; 9742 : 	UINT	uiSleepTime;
; 9743 : 	DWORD dwTotalTimeInMsec;
; 9744 : #ifdef API_DEBUG
; 9745 : 	char szTemp[256]="";
; 9746 : 	ULONG ulStartTime, ulEndTime;
; 9747 : #endif //API_DEBUG
; 9748 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 9749 : 	* and initialize from phTTS structure
; 9750 : 	*/
; 9751 : 	PKSD_T pKsd_t = NULL;
; 9752 : #ifdef API_DEBUG
; 9753 : 	ulStartTime=timeGetTime();
; 9754 : 	sprintf(szTemp,"WaitForEmptyPipes reset(%d) at %ld\n",bReset,ulStartTime);
; 9755 : 	OutputDebugString(szTemp);
; 9756 : #endif //API_DEBUG
; 9757 : 	
; 9758 : 	pKsd_t = phTTS->pKernelShareData;

  03463	8b 4c 24 30	 mov	 ecx, DWORD PTR _phTTS$[esp+40]
  03467	53		 push	 ebx
  03468	55		 push	 ebp
  03469	56		 push	 esi

; 9759 : #ifdef TYPING_MODE
; 9760 : 	if (phTTS->bInTypingMode)

  0346a	8b 81 dc 00 00
	00		 mov	 eax, DWORD PTR [ecx+220]
  03470	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  03473	f7 d8		 neg	 eax
  03475	1b c0		 sbb	 eax, eax

; 9761 : 		uiSleepTime=1;	// just reschedule
; 9762 : 	// Well, actually, we have to sleep
; 9763 : 	// a little.. otherwise PH and VTM won't get
; 9764 : 	// to run..
; 9765 : 	else
; 9766 : #endif //TYPING_MODE
; 9767 : 		uiSleepTime=WAIT_PIPE_SLEEP_TIME;
; 9768 : 	/********************************************************************/
; 9769 : 	/*  Wait for all the pipes to empty.                                */
; 9770 : 	/*  If the pipes are not empty then sleep for 100 msec. and check   */
; 9771 : 	/*  them again.                                                     */
; 9772 : 	/********************************************************************/
; 9773 : 	
; 9774 : 	dwTotalTimeInMsec = 0;

  03477	33 d2		 xor	 edx, edx
  03479	24 fc		 and	 al, -4			; fffffffcH
  0347b	57		 push	 edi
  0347c	83 c0 05	 add	 eax, 5
  0347f	89 54 24 24	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+60], edx
  03483	89 44 24 20	 mov	 DWORD PTR _uiSleepTime$[esp+60], eax

; 9775 : 	
; 9776 : 	uiOldSyncCount = 0xFFFFFFFF;

  03487	83 c8 ff	 or	 eax, -1
  0348a	89 44 24 28	 mov	 DWORD PTR _uiOldSyncCount$[esp+60], eax

; 9777 : 	uiOldVtmCount = 0xFFFFFFFF;

  0348e	89 44 24 2c	 mov	 DWORD PTR _uiOldVtmCount$[esp+60], eax

; 9778 : 	uiOldPhCount = 0xFFFFFFFF;

  03492	89 44 24 30	 mov	 DWORD PTR _uiOldPhCount$[esp+60], eax

; 9779 : 	uiOldLtsCount = 0xFFFFFFFF;

  03496	89 44 24 34	 mov	 DWORD PTR _uiOldLtsCount$[esp+60], eax

; 9780 : 	uiOldCmdCount = 0xFFFFFFFF;

  0349a	89 44 24 38	 mov	 DWORD PTR _uiOldCmdCount$[esp+60], eax

; 9781 : 	uiLockedUpCount = 0;

  0349e	89 54 24 18	 mov	 DWORD PTR _uiLockedUpCount$[esp+60], edx
  034a2	eb 04		 jmp	 SHORT $L74062
$L74774:
  034a4	8b 4c 24 40	 mov	 ecx, DWORD PTR _phTTS$[esp+56]
$L74062:

; 9782 : 	bPipesNotEmpty = TRUE;
; 9783 : 	
; 9784 : 	while ( bPipesNotEmpty )
; 9785 : 	{
; 9786 : 		bPipesNotEmpty = FALSE;
; 9787 : 		
; 9788 : 		if ( bReset )

  034a8	8b 44 24 48	 mov	 eax, DWORD PTR _bReset$[esp+56]
  034ac	85 c0		 test	 eax, eax
  034ae	74 0a		 je	 SHORT $L74064

; 9789 : #ifdef WIN32
; 9790 : 			SetEvent( phTTS->hSyncEvent );

  034b0	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  034b3	50		 push	 eax
  034b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L74064:

; 9791 : #endif
; 9792 : #if defined __osf__ || defined __linux__
; 9793 : 		OP_SetEvent( phTTS->hSyncEvent );
; 9794 : #endif
; 9795 : 		
; 9796 : 		uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  034ba	8b 8e a0 02 00
	00		 mov	 ecx, DWORD PTR [esi+672]
  034c0	51		 push	 ecx
  034c1	e8 00 00 00 00	 call	 _pipe_count

; 9797 : 		uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  034c6	8b 96 9c 02 00
	00		 mov	 edx, DWORD PTR [esi+668]
  034cc	8b f8		 mov	 edi, eax
  034ce	52		 push	 edx
  034cf	e8 00 00 00 00	 call	 _pipe_count
  034d4	89 44 24 18	 mov	 DWORD PTR _uiVtmCount$[esp+68], eax

; 9798 : 		uiPhCount = pipe_count( pKsd_t->ph_pipe );

  034d8	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  034de	50		 push	 eax
  034df	e8 00 00 00 00	 call	 _pipe_count

; 9799 : 		uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  034e4	8b 8e 90 02 00
	00		 mov	 ecx, DWORD PTR [esi+656]
  034ea	89 44 24 20	 mov	 DWORD PTR _uiPhCount$[esp+72], eax
  034ee	51		 push	 ecx
  034ef	e8 00 00 00 00	 call	 _pipe_count

; 9800 : 		uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  034f4	8b 96 98 02 00
	00		 mov	 edx, DWORD PTR [esi+664]
  034fa	8b e8		 mov	 ebp, eax
  034fc	52		 push	 edx
  034fd	e8 00 00 00 00	 call	 _pipe_count
  03502	83 c4 14	 add	 esp, 20			; 00000014H
  03505	8b d8		 mov	 ebx, eax

; 9801 : 		
; 9802 : 		if  (( uiSyncCount != 0 )
; 9803 : 			|| ( uiVtmCount != 0 )
; 9804 : 			|| ( uiPhCount != 0 )
; 9805 : 			|| ( uiLtsCount != 0 )
; 9806 : 			|| ( uiCmdCount != 0 ))

  03507	85 ff		 test	 edi, edi
  03509	0f 85 87 00 00
	00		 jne	 $L74066
  0350f	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+60]
  03513	85 c0		 test	 eax, eax
  03515	75 7f		 jne	 SHORT $L74066
  03517	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+60]
  0351b	85 c0		 test	 eax, eax
  0351d	75 77		 jne	 SHORT $L74066
  0351f	85 ed		 test	 ebp, ebp
  03521	75 73		 jne	 SHORT $L74066
  03523	85 db		 test	 ebx, ebx

; 9807 : 			bPipesNotEmpty = TRUE;
; 9808 : 		
; 9809 : 		/******************************************************************/
; 9810 : 		/*  If bPipesNotEmpty is still FALSE here then the pipes are      */
; 9811 : 		/*  probably empty. It is possible that there is still data in    */
; 9812 : 		/*  the pipes, but that it moved out of a pipe we are about to    */
; 9813 : 		/*  check into a pipe we have we just checked. We now check the   */
; 9814 : 		/*  pipes in the reverse order.                                   */
; 9815 : 		/******************************************************************/
; 9816 : 		
; 9817 : 		if ( ! bPipesNotEmpty )

  03525	75 6f		 jne	 SHORT $L74066

; 9818 : 		{
; 9819 : 		/*
; 9820 : 		kernel_disable(pKsd_t);
; 9821 : 			*/
; 9822 : 			uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  03527	8b 86 98 02 00
	00		 mov	 eax, DWORD PTR [esi+664]
  0352d	50		 push	 eax
  0352e	e8 00 00 00 00	 call	 _pipe_count

; 9823 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03533	8b 8e 90 02 00
	00		 mov	 ecx, DWORD PTR [esi+656]
  03539	8b d8		 mov	 ebx, eax
  0353b	51		 push	 ecx
  0353c	e8 00 00 00 00	 call	 _pipe_count

; 9824 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  03541	8b 96 94 02 00
	00		 mov	 edx, DWORD PTR [esi+660]
  03547	8b e8		 mov	 ebp, eax
  03549	52		 push	 edx
  0354a	e8 00 00 00 00	 call	 _pipe_count
  0354f	89 44 24 20	 mov	 DWORD PTR _uiPhCount$[esp+72], eax

; 9825 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  03553	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  03559	50		 push	 eax
  0355a	e8 00 00 00 00	 call	 _pipe_count

; 9826 : 			uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  0355f	8b 8e a0 02 00
	00		 mov	 ecx, DWORD PTR [esi+672]
  03565	89 44 24 20	 mov	 DWORD PTR _uiVtmCount$[esp+76], eax
  03569	51		 push	 ecx
  0356a	e8 00 00 00 00	 call	 _pipe_count
  0356f	8b f8		 mov	 edi, eax
  03571	83 c4 14	 add	 esp, 20			; 00000014H

; 9827 : 			/*
; 9828 : 			kernel_enable( pKsd_t, uiDummy );
; 9829 : 			*/
; 9830 : 			if  (( uiSyncCount != 0 )
; 9831 : 				|| ( uiVtmCount != 0 )
; 9832 : 				|| ( uiPhCount != 0 )
; 9833 : 				|| ( uiLtsCount != 0 )
; 9834 : 				|| ( uiCmdCount != 0 ))

  03574	85 ff		 test	 edi, edi
  03576	75 1e		 jne	 SHORT $L74066
  03578	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+60]
  0357c	85 c0		 test	 eax, eax
  0357e	75 16		 jne	 SHORT $L74066
  03580	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+60]
  03584	85 c0		 test	 eax, eax
  03586	75 0e		 jne	 SHORT $L74066
  03588	85 ed		 test	 ebp, ebp
  0358a	75 0a		 jne	 SHORT $L74066
  0358c	85 db		 test	 ebx, ebx
  0358e	75 06		 jne	 SHORT $L74066

; 9835 : 				bPipesNotEmpty = TRUE;
; 9836 : 			else
; 9837 : 				bPipesNotEmpty = FALSE;

  03590	89 5c 24 1c	 mov	 DWORD PTR _bPipesNotEmpty$[esp+60], ebx
  03594	eb 67		 jmp	 SHORT $L74075
$L74066:

; 9838 : 		}
; 9839 : 		
; 9840 : 		/******************************************************************/
; 9841 : 		/*  Go to sleep for WAIT_PIPE_SLEEP_TIME msec.                    */
; 9842 : 		/******************************************************************/
; 9843 : 		
; 9844 : 		if ( bPipesNotEmpty )
; 9845 : 		{
; 9846 : 			// tek 29aug96make sure we didn't somehow end up with no place
; 9847 : 			// to go.
; 9848 : 			if((pKsd_t->buffer_pipe  != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 1) )

  03596	8b 86 a4 02 00
	00		 mov	 eax, DWORD PTR [esi+676]
  0359c	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bPipesNotEmpty$[esp+60], 1
  035a4	85 c0		 test	 eax, eax
  035a6	74 1d		 je	 SHORT $L74073
  035a8	50		 push	 eax
  035a9	e8 00 00 00 00	 call	 _pipe_count
  035ae	83 c4 04	 add	 esp, 4
  035b1	83 f8 01	 cmp	 eax, 1
  035b4	73 0f		 jae	 SHORT $L74073

; 9849 : 				TextToSpeechAddBuffer(phTTS, NULL);

  035b6	8b 54 24 40	 mov	 edx, DWORD PTR _phTTS$[esp+56]
  035ba	6a 00		 push	 0
  035bc	52		 push	 edx
  035bd	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  035c2	83 c4 08	 add	 esp, 8
$L74073:

; 9850 : 			
; 9851 : #ifdef API_DEBUG
; 9852 : 			sprintf(szTemp,"WaitForEmptyPipes: c:%d l:%d p:%d v:%d s:%d at %ld\n",
; 9853 : 				uiCmdCount,
; 9854 : 				uiLtsCount,
; 9855 : 				uiPhCount,
; 9856 : 				uiVtmCount,
; 9857 : 				uiSyncCount,
; 9858 : 				timeGetTime());
; 9859 : 			OutputDebugString(szTemp);
; 9860 : #endif //API_DEBUG
; 9861 : 			
; 9862 : #ifdef WIN32
; 9863 : 			
; 9864 : 			PumpModeMessage(phTTS->pAudioHandle);

  035c5	8b 44 24 40	 mov	 eax, DWORD PTR _phTTS$[esp+56]
  035c9	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  035cf	51		 push	 ecx
  035d0	e8 00 00 00 00	 call	 _PumpModeMessage

; 9865 : 			Sleep( uiSleepTime );

  035d5	8b 54 24 24	 mov	 edx, DWORD PTR _uiSleepTime$[esp+64]
  035d9	83 c4 04	 add	 esp, 4
  035dc	52		 push	 edx
  035dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 9866 : 			
; 9867 : 			dwTotalTimeInMsec += (uiSleepTime);

  035e3	8b 44 24 24	 mov	 eax, DWORD PTR _dwTotalTimeInMsec$[esp+60]
  035e7	8b 54 24 20	 mov	 edx, DWORD PTR _uiSleepTime$[esp+60]

; 9868 : #endif
; 9869 : #if defined __osf__ || defined __linux__
; 9870 : 			OP_Sleep( WAIT_PIPE_SLEEP_TIME );
; 9871 : 			
; 9872 : 			dwTotalTimeInMsec += WAIT_PIPE_SLEEP_TIME;
; 9873 : #endif
; 9874 : 			
; 9875 : 			if ( dwTotalTimeInMsec > dwWaitTimeInMsec )

  035eb	8b 4c 24 44	 mov	 ecx, DWORD PTR _dwWaitTimeInMsec$[esp+56]
  035ef	03 c2		 add	 eax, edx
  035f1	3b c1		 cmp	 eax, ecx
  035f3	89 44 24 24	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+60], eax
  035f7	0f 87 ec 00 00
	00		 ja	 $L74770
$L74075:

; 9876 : 			{
; 9877 : #ifdef API_DEBUG
; 9878 : 				OutputDebugString("  ..WFPE() timed out!\n");
; 9879 : #endif //API_DEBUG
; 9880 : 				return( MMSYSERR_ERROR );
; 9881 : 			}
; 9882 : 		}
; 9883 : 		
; 9884 : 		/******************************************************************/
; 9885 : 		/*  If this is a reset then check to see if nothing is happening. */
; 9886 : 		/*  If any of the threads block then the pipe state may not       */
; 9887 : 		/*  change.                                                       */
; 9888 : 		/******************************************************************/
; 9889 : 		
; 9890 : 		if  (( bReset )  && (uiSyncCount || uiVtmCount || uiPhCount ||
; 9891 : 					uiLtsCount || uiCmdCount ) 
; 9892 : 			&& ( (uiSyncCount == uiOldSyncCount) )
; 9893 : 			&& ( (uiVtmCount == uiOldVtmCount) )
; 9894 : 			&& ( (uiPhCount == uiOldPhCount) )
; 9895 : 			&& ( (uiLtsCount == uiOldLtsCount) )
; 9896 : 			&& ( (uiCmdCount == uiOldCmdCount) ))

  035fd	8b 44 24 48	 mov	 eax, DWORD PTR _bReset$[esp+56]
  03601	85 c0		 test	 eax, eax
  03603	0f 84 86 00 00
	00		 je	 $L74076
  03609	85 ff		 test	 edi, edi
  0360b	75 18		 jne	 SHORT $L74077
  0360d	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+60]
  03611	85 c0		 test	 eax, eax
  03613	75 10		 jne	 SHORT $L74077
  03615	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+60]
  03619	85 c0		 test	 eax, eax
  0361b	75 08		 jne	 SHORT $L74077
  0361d	85 ed		 test	 ebp, ebp
  0361f	75 04		 jne	 SHORT $L74077
  03621	85 db		 test	 ebx, ebx
  03623	74 6a		 je	 SHORT $L74076
$L74077:
  03625	3b 7c 24 28	 cmp	 edi, DWORD PTR _uiOldSyncCount$[esp+60]
  03629	75 64		 jne	 SHORT $L74076
  0362b	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+60]
  0362f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _uiOldVtmCount$[esp+60]
  03633	3b c1		 cmp	 eax, ecx
  03635	75 58		 jne	 SHORT $L74076
  03637	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiPhCount$[esp+60]
  0363b	8b 44 24 30	 mov	 eax, DWORD PTR _uiOldPhCount$[esp+60]
  0363f	3b c8		 cmp	 ecx, eax
  03641	75 4c		 jne	 SHORT $L74076
  03643	3b 6c 24 34	 cmp	 ebp, DWORD PTR _uiOldLtsCount$[esp+60]
  03647	75 46		 jne	 SHORT $L74076
  03649	3b 5c 24 38	 cmp	 ebx, DWORD PTR _uiOldCmdCount$[esp+60]
  0364d	75 40		 jne	 SHORT $L74076

; 9897 : 		{
; 9898 : 			/****************************************************************/
; 9899 : 			/*  Perform an audio reset to immediately stop audio from       */
; 9900 : 			/*  playing and to make sure the VTM thread is not blocked.     */
; 9901 : 			/****************************************************************/
; 9902 : #ifdef API_DEBUG
; 9903 : 		OutputDebugString("WFEP resetting audio\n");	
; 9904 : #endif
; 9905 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  0364f	8b 44 24 40	 mov	 eax, DWORD PTR _phTTS$[esp+56]
  03653	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  03659	85 c9		 test	 ecx, ecx
  0365b	75 13		 jne	 SHORT $L74078

; 9906 : 			{
; 9907 : 				PA_Reset( phTTS->pAudioHandle );

  0365d	8b 90 d8 00 00
	00		 mov	 edx, DWORD PTR [eax+216]
  03663	52		 push	 edx
  03664	e8 00 00 00 00	 call	 _PA_Reset
  03669	8b 44 24 44	 mov	 eax, DWORD PTR _phTTS$[esp+60]
  0366d	83 c4 04	 add	 esp, 4
$L74078:

; 9908 : 			}
; 9909 : 			
; 9910 : 			uiLockedUpCount++;

  03670	8b 54 24 18	 mov	 edx, DWORD PTR _uiLockedUpCount$[esp+60]

; 9911 : 
; 9912 : 			
; 9913 : 			/****************************************************************/
; 9914 : 			/*  Fix hang when using speech-to-memory. WIH 4/6/95            */
; 9915 : 			/****************************************************************/
; 9916 : 			
; 9917 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  03674	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0367a	42		 inc	 edx
  0367b	83 f9 01	 cmp	 ecx, 1
  0367e	89 54 24 18	 mov	 DWORD PTR _uiLockedUpCount$[esp+60], edx
  03682	75 17		 jne	 SHORT $L74080

; 9918 : 			{
; 9919 : 				FixMemoryLockup( phTTS );

  03684	50		 push	 eax
  03685	e8 00 00 00 00	 call	 _FixMemoryLockup
  0368a	83 c4 04	 add	 esp, 4

; 9920 : 			}
; 9921 : 		}
; 9922 : 		else

  0368d	eb 08		 jmp	 SHORT $L74777
$L74076:

; 9923 : 		{
; 9924 : #ifdef API_DEBUG
; 9925 : 			OutputDebugString("Lockup set to 0\n");
; 9926 : #endif
; 9927 : 			uiLockedUpCount = 0;

  0368f	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _uiLockedUpCount$[esp+60], 0
$L74777:
  03697	8b 44 24 40	 mov	 eax, DWORD PTR _phTTS$[esp+56]
$L74080:

; 9928 : 		}
; 9929 : 		
; 9930 : 		uiOldSyncCount = uiSyncCount;
; 9931 : 		uiOldVtmCount = uiVtmCount;

  0369b	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiVtmCount$[esp+60]

; 9932 : 		uiOldPhCount = uiPhCount;

  0369f	8b 54 24 14	 mov	 edx, DWORD PTR _uiPhCount$[esp+60]
  036a3	89 4c 24 2c	 mov	 DWORD PTR _uiOldVtmCount$[esp+60], ecx

; 9933 : 		uiOldLtsCount = uiLtsCount;
; 9934 : 		uiOldCmdCount = uiCmdCount;
; 9935 : 		
; 9936 : 		if (uiLockedUpCount>=2)	

  036a7	8b 4c 24 18	 mov	 ecx, DWORD PTR _uiLockedUpCount$[esp+60]
  036ab	83 f9 02	 cmp	 ecx, 2
  036ae	89 7c 24 28	 mov	 DWORD PTR _uiOldSyncCount$[esp+60], edi
  036b2	89 54 24 30	 mov	 DWORD PTR _uiOldPhCount$[esp+60], edx
  036b6	89 6c 24 34	 mov	 DWORD PTR _uiOldLtsCount$[esp+60], ebp
  036ba	89 5c 24 38	 mov	 DWORD PTR _uiOldCmdCount$[esp+60], ebx
  036be	72 09		 jb	 SHORT $L74081

; 9937 : 		{
; 9938 : #ifdef API_DEBUG
; 9939 : 			OutputDebugString("  ..wfep() Forcing pipes\n");
; 9940 : #endif
; 9941 : 			DrainPipes(phTTS);

  036c0	50		 push	 eax
  036c1	e8 00 00 00 00	 call	 _DrainPipes
  036c6	83 c4 04	 add	 esp, 4
$L74081:

; 9942 : 		}
; 9943 : 		if ( uiLockedUpCount >= WAIT_PIPE_ABORT_COUNT )

  036c9	81 7c 24 18 2c
	01 00 00	 cmp	 DWORD PTR _uiLockedUpCount$[esp+60], 300 ; 0000012cH
  036d1	73 16		 jae	 SHORT $L74770
  036d3	8b 44 24 1c	 mov	 eax, DWORD PTR _bPipesNotEmpty$[esp+60]
  036d7	85 c0		 test	 eax, eax
  036d9	0f 85 c5 fd ff
	ff		 jne	 $L74774
  036df	5f		 pop	 edi
  036e0	5e		 pop	 esi
  036e1	5d		 pop	 ebp

; 9949 : 		}
; 9950 :   }
; 9951 : #ifdef API_DEBUG
; 9952 :   ulEndTime=timeGetTime();
; 9953 :   sprintf(szTemp,"WaitForEmptyPipes exit at %ld (%ld) ms\n",
; 9954 : 	  ulEndTime, ulEndTime - ulStartTime);
; 9955 :   OutputDebugString(szTemp);
; 9956 : #endif //API_DEBUG
; 9957 :   
; 9958 :   return( MMSYSERR_NOERROR );

  036e2	33 c0		 xor	 eax, eax
  036e4	5b		 pop	 ebx

; 9959 : }

  036e5	83 c4 2c	 add	 esp, 44			; 0000002cH
  036e8	c3		 ret	 0
$L74770:
  036e9	5f		 pop	 edi
  036ea	5e		 pop	 esi
  036eb	5d		 pop	 ebp

; 9944 : 		{
; 9945 : #ifdef API_DEBUG
; 9946 : 			OutputDebugString("  ..WFPE() lockup failure?\n");
; 9947 : #endif //API_DEBUG
; 9948 : 			return( MMSYSERR_ERROR );

  036ec	b8 01 00 00 00	 mov	 eax, 1
  036f1	5b		 pop	 ebx

; 9959 : }

  036f2	83 c4 2c	 add	 esp, 44			; 0000002cH
  036f5	c3		 ret	 0
_WaitForEmptyPipes ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG74093 DB	'DECtalkErrorMessage', 00H
_DATA	ENDS
_TEXT	SEGMENT
_aInstance$ = 12
_aMessage$ = 16
_aParam$ = 20
_PlayAudioCallbackRoutine PROC NEAR

; 9972 : 	// get the dectalk error mesage ID.. 
; 9973 : 	UINT uiID_Error_Msg;
; 9974 : 	
; 9975 : #ifdef API_DEBUG
; 9976 : 	OutputDebugString("PlayAudioCallbackRoutine().\n");
; 9977 : #endif //API_DEBUG
; 9978 : 	/********************************************************************/
; 9979 : 	/*  Get the DECtalk error message.                                  */
; 9980 : 	/********************************************************************/
; 9981 : #if defined __osf__ || defined __linux__
; 9982 : 	uiID_Error_Msg = ((LPTTS_HANDLE_T)aInstance)->uiID_Error_Message;
; 9983 : #endif
; 9984 : 	
; 9985 : #if defined WIN32 && !defined NOWIN
; 9986 : #ifdef UNDER_CE
; 9987 :    uiID_Error_Msg = RegisterWindowMessage(_T("DECtalkErrorMessage"));
; 9988 : #else
; 9989 :     uiID_Error_Msg = RegisterWindowMessage("DECtalkErrorMessage");

  03700	68 00 00 00 00	 push	 OFFSET FLAT:$SG74093
  03705	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4

; 9990 : #endif
; 9991 : #endif
; 9992 :     switch ( aMessage )
; 9993 : 	{

  0370b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aMessage$[esp-4]
  0370f	49		 dec	 ecx
  03710	83 f9 06	 cmp	 ecx, 6
  03713	77 7c		 ja	 SHORT $L74110
  03715	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L74781[ecx*4]
$L74098:

; 10029: 		break;
; 10030: 		
; 10031: 	case PA_GET_CAPS_ERROR:
; 10032: 		
; 10033: 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 10034: 			uiID_Error_Msg,
; 10035: 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 10036: 			aParam );

  0371c	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  03720	6a 00		 push	 0
  03722	6a 0c		 push	 12			; 0000000cH
  03724	50		 push	 eax
  03725	52		 push	 edx
  03726	e8 00 00 00 00	 call	 _Report_TTS_Status
  0372b	83 c4 10	 add	 esp, 16			; 00000010H

; 10037: 		break;
; 10038: 		
; 10039: 	default:
; 10040: 		
; 10041: 		break;
; 10042: 	}
; 10043: 	
; 10044: 	return FALSE;

  0372e	33 c0		 xor	 eax, eax

; 10045: }

  03730	c3		 ret	 0
$L74100:

; 9994 : 		
; 9995 : 	case PA_PLAY_START:
; 9996 : 		
; 9997 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 9998 : 			uiID_Error_Msg,
; 9999 : 			TTS_AUDIO_PLAY_START,
; 10000: 			MMSYSERR_NOERROR );
; 10001: 		break;
; 10002: 		
; 10003: 	case PA_PLAY_STOP:
; 10004: 		
; 10005: 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 10006: 			uiID_Error_Msg,
; 10007: 			TTS_AUDIO_PLAY_STOP,
; 10008: 			MMSYSERR_NOERROR );

  03731	6a 00		 push	 0
  03733	6a 0d		 push	 13			; 0000000dH
  03735	50		 push	 eax
  03736	8b 44 24 14	 mov	 eax, DWORD PTR _aInstance$[esp+8]
  0373a	50		 push	 eax

; 10029: 		break;
; 10030: 		
; 10031: 	case PA_GET_CAPS_ERROR:
; 10032: 		
; 10033: 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 10034: 			uiID_Error_Msg,
; 10035: 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 10036: 			aParam );

  0373b	e8 00 00 00 00	 call	 _Report_TTS_Status
  03740	83 c4 10	 add	 esp, 16			; 00000010H

; 10037: 		break;
; 10038: 		
; 10039: 	default:
; 10040: 		
; 10041: 		break;
; 10042: 	}
; 10043: 	
; 10044: 	return FALSE;

  03743	33 c0		 xor	 eax, eax

; 10045: }

  03745	c3		 ret	 0
$L74102:

; 10009: 		
; 10010: 		break;
; 10011: 		
; 10012: 	case PA_DEVICE_OPEN_FAILURE:
; 10013: 		
; 10014: 		if (((LPTTS_HANDLE_T)aInstance)->dwDeviceOptions & REPORT_OPEN_ERROR )

  03746	8b 4c 24 08	 mov	 ecx, DWORD PTR _aInstance$[esp-4]
  0374a	f6 41 78 02	 test	 BYTE PTR [ecx+120], 2
  0374e	74 41		 je	 SHORT $L74110

; 10015: 		{
; 10016: 			Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 10017: 				uiID_Error_Msg,
; 10018: 				ERROR_OPENING_WAVE_OUTPUT_DEVICE,
; 10019: 				aParam );

  03750	8b 54 24 10	 mov	 edx, DWORD PTR _aParam$[esp-4]
  03754	52		 push	 edx
  03755	6a 02		 push	 2
  03757	50		 push	 eax
  03758	51		 push	 ecx

; 10029: 		break;
; 10030: 		
; 10031: 	case PA_GET_CAPS_ERROR:
; 10032: 		
; 10033: 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 10034: 			uiID_Error_Msg,
; 10035: 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 10036: 			aParam );

  03759	e8 00 00 00 00	 call	 _Report_TTS_Status
  0375e	83 c4 10	 add	 esp, 16			; 00000010H

; 10037: 		break;
; 10038: 		
; 10039: 	default:
; 10040: 		
; 10041: 		break;
; 10042: 	}
; 10043: 	
; 10044: 	return FALSE;

  03761	33 c0		 xor	 eax, eax

; 10045: }

  03763	c3		 ret	 0
$L74106:

; 10020: 		}
; 10021: 		break;
; 10022: 		
; 10023: 	case PA_WRITE_ERROR:
; 10024: 		
; 10025: 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 10026: 			uiID_Error_Msg,
; 10027: 			ERROR_IN_AUDIO_WRITE,
; 10028: 			aParam );

  03764	8b 4c 24 10	 mov	 ecx, DWORD PTR _aParam$[esp-4]

; 10029: 		break;
; 10030: 		
; 10031: 	case PA_GET_CAPS_ERROR:
; 10032: 		
; 10033: 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 10034: 			uiID_Error_Msg,
; 10035: 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 10036: 			aParam );

  03768	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  0376c	51		 push	 ecx
  0376d	6a 01		 push	 1
  0376f	50		 push	 eax
  03770	52		 push	 edx
  03771	e8 00 00 00 00	 call	 _Report_TTS_Status
  03776	83 c4 10	 add	 esp, 16			; 00000010H

; 10037: 		break;
; 10038: 		
; 10039: 	default:
; 10040: 		
; 10041: 		break;
; 10042: 	}
; 10043: 	
; 10044: 	return FALSE;

  03779	33 c0		 xor	 eax, eax

; 10045: }

  0377b	c3		 ret	 0
$L74108:

; 10029: 		break;
; 10030: 		
; 10031: 	case PA_GET_CAPS_ERROR:
; 10032: 		
; 10033: 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 10034: 			uiID_Error_Msg,
; 10035: 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 10036: 			aParam );

  0377c	8b 4c 24 10	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  03780	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  03784	51		 push	 ecx
  03785	6a 03		 push	 3
  03787	50		 push	 eax
  03788	52		 push	 edx
  03789	e8 00 00 00 00	 call	 _Report_TTS_Status
  0378e	83 c4 10	 add	 esp, 16			; 00000010H
$L74110:

; 10037: 		break;
; 10038: 		
; 10039: 	default:
; 10040: 		
; 10041: 		break;
; 10042: 	}
; 10043: 	
; 10044: 	return FALSE;

  03791	33 c0		 xor	 eax, eax

; 10045: }

  03793	c3		 ret	 0
$L74781:
  03794	00 00 00 00	 DD	 $L74098
  03798	00 00 00 00	 DD	 $L74100
  0379c	00 00 00 00	 DD	 $L74102
  037a0	00 00 00 00	 DD	 $L74110
  037a4	00 00 00 00	 DD	 $L74110
  037a8	00 00 00 00	 DD	 $L74108
  037ac	00 00 00 00	 DD	 $L74106
_PlayAudioCallbackRoutine ENDP
_ttsHandle$ = 8
_uiMsg$ = 12
_lParam1$ = 16
_lParam2$ = 20
_Report_TTS_Status PROC NEAR

; 10060: {

  037b0	56		 push	 esi

; 10061: 	if (lParam1 == TTS_AUDIO_PLAY_START)	ttsHandle->IsSpeaking = TRUE;	// KSB - Used for start of speech

  037b1	8b 74 24 08	 mov	 esi, DWORD PTR _ttsHandle$[esp]
  037b5	57		 push	 edi
  037b6	8b 7c 24 14	 mov	 edi, DWORD PTR _lParam1$[esp+4]
  037ba	83 ff 0c	 cmp	 edi, 12			; 0000000cH
  037bd	75 0c		 jne	 SHORT $L74120
  037bf	c7 86 d0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+208], 1

; 10062: 	if (lParam1 == TTS_AUDIO_PLAY_STOP)	ttsHandle->IsSpeaking = FALSE;	// KSB - Used for end of speech

  037c9	eb 0f		 jmp	 SHORT $L74121
$L74120:
  037cb	83 ff 0d	 cmp	 edi, 13			; 0000000dH
  037ce	75 0a		 jne	 SHORT $L74121
  037d0	c7 86 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+208], 0
$L74121:

; 10063: 	
; 10064: 	if (ttsHandle->DtCallbackRoutine != NULL)

  037da	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  037e0	85 c0		 test	 eax, eax
  037e2	74 33		 je	 SHORT $L74123

; 10065: 	{
; 10066: #ifdef API_DEBUG
; 10067: 		char szTemp[256]="";
; 10068: 		sprintf(szTemp,"RTTSStatus(%08lx %08lx)\n",
; 10069: 			lParam1, lParam2);
; 10070: 		OutputDebugString(szTemp);
; 10071: #endif //API_DEBUG
; 10072: 		
; 10073: 		OP_LockMutex( ttsHandle->hmxCallback );

  037e4	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  037ea	50		 push	 eax
  037eb	e8 00 00 00 00	 call	 _OP_LockMutex

; 10074: 		(*ttsHandle->DtCallbackRoutine)( lParam1,
; 10075: 			lParam2,
; 10076: 			ttsHandle->dwTTSInstanceParameter,
; 10077: 			uiMsg);

  037f0	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiMsg$[esp+8]
  037f4	8b 96 ac 00 00
	00		 mov	 edx, DWORD PTR [esi+172]
  037fa	8b 44 24 1c	 mov	 eax, DWORD PTR _lParam2$[esp+8]
  037fe	51		 push	 ecx
  037ff	52		 push	 edx
  03800	50		 push	 eax
  03801	57		 push	 edi
  03802	ff 96 a8 00 00
	00		 call	 DWORD PTR [esi+168]

; 10078: 		
; 10079: 		OP_UnlockMutex( ttsHandle->hmxCallback );

  03808	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  0380e	51		 push	 ecx
  0380f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  03814	83 c4 18	 add	 esp, 24			; 00000018H
$L74123:
  03817	5f		 pop	 edi
  03818	5e		 pop	 esi

; 10080: 	}
; 10081: 	return;
; 10082: }

  03819	c3		 ret	 0
_Report_TTS_Status ENDP
_TEXT	ENDS
EXTRN	_SWFlushPipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_DrainPipes PROC NEAR

; 10106: {

  03820	56		 push	 esi

; 10107: 	// empty the CMD, LTS and PH pipes..
; 10108: 	SWFlushPipe(phTTS->pKernelShareData->cmd_pipe);

  03821	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  03825	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  03828	8b 88 98 02 00
	00		 mov	 ecx, DWORD PTR [eax+664]
  0382e	51		 push	 ecx
  0382f	e8 00 00 00 00	 call	 _SWFlushPipe

; 10109: 	SWFlushPipe(phTTS->pKernelShareData->lts_pipe);

  03834	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  03837	8b 82 90 02 00
	00		 mov	 eax, DWORD PTR [edx+656]
  0383d	50		 push	 eax
  0383e	e8 00 00 00 00	 call	 _SWFlushPipe

; 10110: 	SWFlushPipe(phTTS->pKernelShareData->ph_pipe);

  03843	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  03846	8b 91 94 02 00
	00		 mov	 edx, DWORD PTR [ecx+660]
  0384c	52		 push	 edx
  0384d	e8 00 00 00 00	 call	 _SWFlushPipe
  03852	83 c4 0c	 add	 esp, 12			; 0000000cH
  03855	5e		 pop	 esi

; 10111: 	
; 10112: }

  03856	c3		 ret	 0
_DrainPipes ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechVersion
_BSS	SEGMENT
_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9 DB 032H DUP (?)
	ALIGN	4

$SG74132 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG74133 DB	'v4.62 R002 ACCESS32', 00H
$SG74134 DB	'%s %s', 00H
_DATA	ENDS
_TEXT	SEGMENT
_VersionStr$ = 8
_TextToSpeechVersion PROC NEAR

; 10125: #ifdef UNDER_CE
; 10126: 	static wchar_t DECtalk_Version_String[50];
; 10127: 	wsprintf(DECtalk_Version_String,TEXT("%s %s"),DTALK_STR_VERSION, CUSTR_STR_VERSION);
; 10128: 	if (VersionStr != NULL) *VersionStr = DECtalk_Version_String;
; 10129: #else
; 10130: 	//removed unsigned form next line 11/12/96 cjl
; 10131: 	static char   DECtalk_Version_String[50];
; 10132: 			
; 10133: 
; 10134: 
; 10135: 	sprintf(DECtalk_Version_String,"%s %s",DTALK_STR_VERSION, CUSTR_STR_VERSION);

  03860	68 00 00 00 00	 push	 OFFSET FLAT:$SG74132
  03865	68 00 00 00 00	 push	 OFFSET FLAT:$SG74133
  0386a	68 00 00 00 00	 push	 OFFSET FLAT:$SG74134
  0386f	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9
  03874	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 10136: 	if (VersionStr != NULL) *VersionStr = DECtalk_Version_String;

  0387a	8b 44 24 14	 mov	 eax, DWORD PTR _VersionStr$[esp+12]
  0387e	83 c4 10	 add	 esp, 16			; 00000010H
  03881	85 c0		 test	 eax, eax
  03883	74 0c		 je	 SHORT $L74136
  03885	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9

; 10139: 
; 10140: 	// Add in dbg_version. NCS KSB
; 10141: #endif //UNDER_CE
; 10142: 
; 10143: #ifdef WIN32
; 10144: 	return (DTALK_DBG_VERSION << 31) + (DTALK_MAJ_VERSION << 24) + (DTALK_MIN_VERSION << 16) + (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;

  0388b	b8 03 02 3e 04	 mov	 eax, 71172611		; 043e0203H

; 10145: #endif
; 10146: #if defined __osf__ || defined __linux__
; 10147: 	return (DTALK_MAJ_VERSION << 24) + (DTALK_MIN_VERSION << 16) + (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;
; 10148: #endif
; 10149: }

  03890	c3		 ret	 0
$L74136:

; 10137: 	else
; 10138: 		return 0; //check for null return error

  03891	33 c0		 xor	 eax, eax

; 10145: #endif
; 10146: #if defined __osf__ || defined __linux__
; 10147: 	return (DTALK_MAJ_VERSION << 24) + (DTALK_MIN_VERSION << 16) + (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;
; 10148: #endif
; 10149: }

  03893	c3		 ret	 0
_TextToSpeechVersion ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechControlPanel
_TEXT	SEGMENT
_TextToSpeechControlPanel PROC NEAR

; 10153: #ifdef DTALK50
; 10154: 	if (ttsHandle == NULL)	return;
; 10155: 	CPShow(ttsHandle->CPanelThread);
; 10156: #else
; 10157: 	/* This function not supported in 4.4 */
; 10158: #endif
; 10159: 	return;
; 10160: }

  038a0	c3		 ret	 0
_TextToSpeechControlPanel ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetLastError
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechGetLastError PROC NEAR

; 10169: 	return phTTS->LastError;

  038b0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  038b4	8b 80 d4 00 00
	00		 mov	 eax, DWORD PTR [eax+212]

; 10170: }

  038ba	c3		 ret	 0
_TextToSpeechGetLastError ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechTyping
_TEXT	SEGMENT
_phTTS$ = 8
_key$ = 12
_tptPriority$ = -516
_phone$74156 = -512
_TextToSpeechTyping PROC NEAR

; 10193: void TextToSpeechTyping(LPTTS_HANDLE_T phTTS, unsigned char key) {  /* BATS#657 JL */

  038c0	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  038c6	53		 push	 ebx
  038c7	56		 push	 esi

; 10194: #else
; 10195: void TextToSpeechTyping(LPTTS_HANDLE_T phTTS, wchar_t key) {  /* BATS#657 JL */
; 10196: #endif
; 10197: #ifdef API_DEBUG
; 10198: 	char szTemp[256]="";
; 10199: 	ULONG ulStartTime,ulEndTime;
; 10200: #endif //API_DEBUG
; 10201: 	
; 10202: 	
; 10203: #ifdef TYPING_MODE
; 10204: #define TYPE_MAXPHONES (256)
; 10205: 	HANDLE hThisThread=NULL;
; 10206: 	THREAD_PRIORITY_T tptPriority=0;
; 10207: 
; 10208: 	if(phTTS == NULL) return;	//for a NULL handle

  038c8	8b b4 24 10 02
	00 00		 mov	 esi, DWORD PTR _phTTS$[esp+520]
  038cf	57		 push	 edi
  038d0	33 ff		 xor	 edi, edi
  038d2	3b f7		 cmp	 esi, edi
  038d4	89 7c 24 0c	 mov	 DWORD PTR _tptPriority$[esp+528], edi
  038d8	0f 84 9d 00 00
	00		 je	 $L74163

; 10209: 
; 10210: 	hThisThread = GetCurrentThread();

  038de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  038e4	8b d8		 mov	 ebx, eax

; 10211: 	if (hThisThread)

  038e6	3b df		 cmp	 ebx, edi
  038e8	74 15		 je	 SHORT $L74154

; 10212: 	{
; 10213: #ifndef UNDER_CE
; 10214: 		tptPriority = OP_GetThreadPriority(hThisThread);

  038ea	53		 push	 ebx
  038eb	e8 00 00 00 00	 call	 _OP_GetThreadPriority

; 10215: 		OP_SetThreadPriority(hThisThread,OP_PRIORITY_HIGHEST);

  038f0	6a 02		 push	 2
  038f2	53		 push	 ebx
  038f3	89 44 24 18	 mov	 DWORD PTR _tptPriority$[esp+540], eax
  038f7	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  038fc	83 c4 0c	 add	 esp, 12			; 0000000cH
$L74154:

; 10216: #endif
; 10217: 	}
; 10218: #ifdef API_DEBUG
; 10219: 	ulStartTime=timeGetTime();
; 10220: 	sprintf(szTemp, "TTSTyping(%c) at %ld.\n", key, ulStartTime);
; 10221: 	OutputDebugString(szTemp);
; 10222: #endif //API_DEBUG
; 10223: 	TextToSpeechReset(phTTS,FALSE);

  038ff	57		 push	 edi
  03900	56		 push	 esi
  03901	e8 00 00 00 00	 call	 _TextToSpeechReset

; 10224: 	/**/
; 10225: 	// this is the type_out code from cm_util_type_out, modified to
; 10226: 	// do what we need here.
; 10227: 	{
; 10228: 		unsigned char _far *tp;
; 10229: 		DT_PIPE_T phone[TYPE_MAXPHONES];
; 10230: 		unsigned int i=0;
; 10231: 		PKSD_T pKsd_t = phTTS->pKernelShareData;

  03906	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 10232: 		
; 10233: 		for(tp = (unsigned char _far *)pKsd_t->typing_table[key];*tp;tp++)

  03909	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR _key$[esp+532]
  03910	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03915	83 c4 08	 add	 esp, 8
  03918	8b 8a 38 06 00
	00		 mov	 ecx, DWORD PTR [edx+1592]
  0391e	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  03921	8a 01		 mov	 al, BYTE PTR [ecx]
  03923	84 c0		 test	 al, al
  03925	74 25		 je	 SHORT $L74162
  03927	55		 push	 ebp
  03928	8d 74 24 14	 lea	 esi, DWORD PTR _phone$74156[esp+532]
$L74160:

; 10234: 		{
; 10235: 			phone[i++] = pKsd_t->reverse_ascky[(*tp) & 0xff];

  0392c	8b aa 28 06 00
	00		 mov	 ebp, DWORD PTR [edx+1576]
  03932	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03937	47		 inc	 edi
  03938	83 c6 02	 add	 esi, 2
  0393b	66 8b 44 85 00	 mov	 ax, WORD PTR [ebp+eax*4]
  03940	41		 inc	 ecx
  03941	66 89 46 fe	 mov	 WORD PTR [esi-2], ax
  03945	8a 01		 mov	 al, BYTE PTR [ecx]
  03947	84 c0		 test	 al, al
  03949	75 e1		 jne	 SHORT $L74160
  0394b	5d		 pop	 ebp
$L74162:

; 10236: 		}
; 10237: 		//phone[i++] = (PFUSA<<PSFONT) | COMMA;		
; 10238: 		phone[i++] = SYNC;

  0394c	66 c7 44 7c 10
	0a 1f		 mov	 WORD PTR _phone$74156[esp+edi*2+528], 7946 ; 00001f0aH

; 10239: 		write_pipe(pKsd_t->ph_pipe,phone,i);

  03953	8b 92 94 02 00
	00		 mov	 edx, DWORD PTR [edx+660]
  03959	47		 inc	 edi
  0395a	8d 4c 24 10	 lea	 ecx, DWORD PTR _phone$74156[esp+528]
  0395e	57		 push	 edi
  0395f	51		 push	 ecx
  03960	52		 push	 edx
  03961	e8 00 00 00 00	 call	 _write_pipe
  03966	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10240: 	}
; 10241: 	// end of type_out code
; 10242: 	
; 10243: 	
; 10244: #ifdef API_DEBUG
; 10245: 	ulEndTime=timeGetTime();
; 10246: 	sprintf(szTemp, "TTSTyping() exit %ld (%ld)\n", 
; 10247: 		ulEndTime, ulEndTime-ulStartTime);
; 10248: 	OutputDebugString(szTemp);
; 10249: #endif //API_DEBUG	
; 10250: #ifndef UNDER_CE
; 10251: 	if (hThisThread)

  03969	85 db		 test	 ebx, ebx
  0396b	74 0e		 je	 SHORT $L74163

; 10252: 		OP_SetThreadPriority(hThisThread,tptPriority);

  0396d	8b 44 24 0c	 mov	 eax, DWORD PTR _tptPriority$[esp+528]
  03971	50		 push	 eax
  03972	53		 push	 ebx
  03973	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  03978	83 c4 08	 add	 esp, 8
$L74163:
  0397b	5f		 pop	 edi
  0397c	5e		 pop	 esi
  0397d	5b		 pop	 ebx

; 10253: #endif
; 10254: #endif TYPING_MODE
; 10255: 	return;
; 10256: }

  0397e	81 c4 04 02 00
	00		 add	 esp, 516		; 00000204H
  03984	c3		 ret	 0
_TextToSpeechTyping ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved1
EXTRN	_paul_8:BYTE
EXTRN	_betty_8:BYTE
EXTRN	_harry_8:BYTE
EXTRN	_frank_8:BYTE
EXTRN	_kit_8:BYTE
EXTRN	_ursula_8:BYTE
EXTRN	_rita_8:BYTE
EXTRN	_wendy_8:BYTE
EXTRN	_dennis_8:BYTE
EXTRN	_paul:BYTE
EXTRN	_betty:BYTE
EXTRN	_harry:BYTE
EXTRN	_frank:BYTE
EXTRN	_kit:BYTE
EXTRN	_ursula:BYTE
EXTRN	_rita:BYTE
EXTRN	_wendy:BYTE
EXTRN	_dennis:BYTE
_TEXT	SEGMENT
_voices$ = 8
_voice$ = 12
_bEightk$ = 16
_bReadData$ = 20
_TextToSpeechReserved1 PROC NEAR

; 10260: 	short *sdef;
; 10261: 	
; 10262: 	if (bEightk == FALSE) {	// High-quality

  03990	8b 44 24 0c	 mov	 eax, DWORD PTR _bEightk$[esp-4]
  03994	85 c0		 test	 eax, eax

; 10263: 		
; 10264: 		switch (voice) {

  03996	8b 44 24 08	 mov	 eax, DWORD PTR _voice$[esp-4]
  0399a	75 5a		 jne	 SHORT $L74175
  0399c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  039a1	83 f8 08	 cmp	 eax, 8
  039a4	0f 87 21 01 00
	00		 ja	 $L74189
  039aa	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L74792[eax*4]
$L74180:

; 10265: 		case 0:	sdef = paul;	break;

  039b1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_paul
  039b6	e9 8d 00 00 00	 jmp	 $L74192
$L74181:

; 10266: 		case 1:	sdef = betty;	break;

  039bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_betty
  039c0	e9 83 00 00 00	 jmp	 $L74192
$L74182:

; 10267: 		case 2:	sdef = harry;	break;

  039c5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_harry
  039ca	eb 7c		 jmp	 SHORT $L74192
$L74183:

; 10268: 		case 3:	sdef = frank;	break;

  039cc	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_frank
  039d1	eb 75		 jmp	 SHORT $L74192
$L74184:

; 10269: 		case 4:	sdef = dennis;	break;

  039d3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_dennis
  039d8	eb 6e		 jmp	 SHORT $L74192
$L74185:

; 10270: 		case 5:	sdef = kit;		break;

  039da	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_kit
  039df	eb 67		 jmp	 SHORT $L74192
$L74186:

; 10271: 		case 6:	sdef = ursula;	break;

  039e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ursula
  039e6	eb 60		 jmp	 SHORT $L74192
$L74187:

; 10272: 		case 7:	sdef = rita;	break;

  039e8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_rita
  039ed	eb 59		 jmp	 SHORT $L74192
$L74188:

; 10273: 		case 8:	sdef = wendy;	break;

  039ef	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wendy

; 10274: 		default:	return 0;
; 10275: 		}
; 10276: 	} else {

  039f4	eb 52		 jmp	 SHORT $L74192
$L74175:

; 10277: 		switch (voice) {

  039f6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  039fb	83 f8 08	 cmp	 eax, 8
  039fe	0f 87 c7 00 00
	00		 ja	 $L74189
  03a04	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L74793[eax*4]
$L74195:

; 10278: 		case 0:	sdef = paul_8;		break;

  03a0b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_paul_8
  03a10	eb 36		 jmp	 SHORT $L74192
$L74196:

; 10279: 		case 1:	sdef = betty_8;		break;

  03a12	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_betty_8
  03a17	eb 2f		 jmp	 SHORT $L74192
$L74197:

; 10280: 		case 2:	sdef = harry_8;		break;

  03a19	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_harry_8
  03a1e	eb 28		 jmp	 SHORT $L74192
$L74198:

; 10281: 		case 3:	sdef = frank_8;		break;

  03a20	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_frank_8
  03a25	eb 21		 jmp	 SHORT $L74192
$L74199:

; 10282: 		case 4:	sdef = dennis_8;	break;

  03a27	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_dennis_8
  03a2c	eb 1a		 jmp	 SHORT $L74192
$L74200:

; 10283: 		case 5:	sdef = kit_8;		break;

  03a2e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_kit_8
  03a33	eb 13		 jmp	 SHORT $L74192
$L74201:

; 10284: 		case 6:	sdef = ursula_8;	break;

  03a35	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ursula_8
  03a3a	eb 0c		 jmp	 SHORT $L74192
$L74202:

; 10285: 		case 7:	sdef = rita_8;		break;

  03a3c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_rita_8
  03a41	eb 05		 jmp	 SHORT $L74192
$L74203:

; 10286: 		case 8:	sdef = wendy_8;		break;

  03a43	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wendy_8
$L74192:

; 10288: 		}
; 10289: 	}
; 10290: 	
; 10291: 	if (bReadData) {

  03a48	8b 4c 24 10	 mov	 ecx, DWORD PTR _bReadData$[esp-4]
  03a4c	85 c9		 test	 ecx, ecx
  03a4e	74 33		 je	 SHORT $L74205

; 10292: 		voices[0] = (unsigned char)sdef[SPD_GV]; // NAL warning removal

  03a50	8b 4c 24 04	 mov	 ecx, DWORD PTR _voices$[esp-4]
  03a54	8a 50 24	 mov	 dl, BYTE PTR [eax+36]
  03a57	88 11		 mov	 BYTE PTR [ecx], dl

; 10293: 		voices[1] = (unsigned char)sdef[SPD_GN];

  03a59	8a 50 26	 mov	 dl, BYTE PTR [eax+38]
  03a5c	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 10294: 		voices[2] = (unsigned char)sdef[SPD_G1];

  03a5f	8a 50 28	 mov	 dl, BYTE PTR [eax+40]
  03a62	88 51 02	 mov	 BYTE PTR [ecx+2], dl

; 10295: 		voices[3] = (unsigned char)sdef[SPD_G2];

  03a65	8a 50 2a	 mov	 dl, BYTE PTR [eax+42]
  03a68	88 51 03	 mov	 BYTE PTR [ecx+3], dl

; 10296: 		voices[4] = (unsigned char)sdef[SPD_G3];

  03a6b	8a 50 2c	 mov	 dl, BYTE PTR [eax+44]
  03a6e	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 10297: 		voices[5] = (unsigned char)sdef[SPD_G4];

  03a71	8a 50 2e	 mov	 dl, BYTE PTR [eax+46]
  03a74	88 51 05	 mov	 BYTE PTR [ecx+5], dl

; 10298: 		voices[6] = (unsigned char)sdef[SPD_LO];

  03a77	8a 40 30	 mov	 al, BYTE PTR [eax+48]
  03a7a	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 10307: 	}
; 10308: 	return 7;

  03a7d	b8 07 00 00 00	 mov	 eax, 7

; 10309: }

  03a82	c3		 ret	 0
$L74205:

; 10299: 	} else {
; 10300: 		sdef[SPD_GV] = voices[0];

  03a83	8b 4c 24 04	 mov	 ecx, DWORD PTR _voices$[esp-4]
  03a87	66 0f b6 11	 movzx	 dx, BYTE PTR [ecx]
  03a8b	66 89 50 24	 mov	 WORD PTR [eax+36], dx

; 10301: 		sdef[SPD_GN] = voices[1];

  03a8f	66 0f b6 51 01	 movzx	 dx, BYTE PTR [ecx+1]
  03a94	66 89 50 26	 mov	 WORD PTR [eax+38], dx

; 10302: 		sdef[SPD_G1] = voices[2];

  03a98	66 0f b6 51 02	 movzx	 dx, BYTE PTR [ecx+2]
  03a9d	66 89 50 28	 mov	 WORD PTR [eax+40], dx

; 10303: 		sdef[SPD_G2] = voices[3];

  03aa1	66 0f b6 51 03	 movzx	 dx, BYTE PTR [ecx+3]
  03aa6	66 89 50 2a	 mov	 WORD PTR [eax+42], dx

; 10304: 		sdef[SPD_G3] = voices[4];

  03aaa	66 0f b6 51 04	 movzx	 dx, BYTE PTR [ecx+4]
  03aaf	66 89 50 2c	 mov	 WORD PTR [eax+44], dx

; 10305: 		sdef[SPD_G4] = voices[5];

  03ab3	66 0f b6 51 05	 movzx	 dx, BYTE PTR [ecx+5]
  03ab8	66 89 50 2e	 mov	 WORD PTR [eax+46], dx

; 10306: 		sdef[SPD_LO] = voices[6];

  03abc	66 0f b6 49 06	 movzx	 cx, BYTE PTR [ecx+6]
  03ac1	66 89 48 30	 mov	 WORD PTR [eax+48], cx

; 10307: 	}
; 10308: 	return 7;

  03ac5	b8 07 00 00 00	 mov	 eax, 7

; 10309: }

  03aca	c3		 ret	 0
$L74189:

; 10287: 		default:	return 0;

  03acb	33 c0		 xor	 eax, eax

; 10309: }

  03acd	c3		 ret	 0
  03ace	8b ff		 npad	 2
$L74792:
  03ad0	00 00 00 00	 DD	 $L74180
  03ad4	00 00 00 00	 DD	 $L74181
  03ad8	00 00 00 00	 DD	 $L74182
  03adc	00 00 00 00	 DD	 $L74183
  03ae0	00 00 00 00	 DD	 $L74184
  03ae4	00 00 00 00	 DD	 $L74185
  03ae8	00 00 00 00	 DD	 $L74186
  03aec	00 00 00 00	 DD	 $L74187
  03af0	00 00 00 00	 DD	 $L74188
$L74793:
  03af4	00 00 00 00	 DD	 $L74195
  03af8	00 00 00 00	 DD	 $L74196
  03afc	00 00 00 00	 DD	 $L74197
  03b00	00 00 00 00	 DD	 $L74198
  03b04	00 00 00 00	 DD	 $L74199
  03b08	00 00 00 00	 DD	 $L74200
  03b0c	00 00 00 00	 DD	 $L74201
  03b10	00 00 00 00	 DD	 $L74202
  03b14	00 00 00 00	 DD	 $L74203
_TextToSpeechReserved1 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved2
_TEXT	SEGMENT
_TextToSpeechReserved2 PROC NEAR

; 10312: #ifdef API_DEBUG
; 10313: 	PVTM_T pVtm_t = phTTS->pVTMThreadData;
; 10314: 	int i;
; 10315: 	
; 10316: 	for (i = 0; i < 7; i++)	gains[i] = pVtm_t->TunerData[i];
; 10317: 	return 7;
; 10318: #else
; 10319: 	return 0;

  03b20	33 c0		 xor	 eax, eax

; 10320: #endif
; 10321: }

  03b22	c3		 ret	 0
_TextToSpeechReserved2 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechVersionEx
PUBLIC	_TextToSpeechGetFeatures
_BSS	SEGMENT
	ALIGN	4

_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9 DB 032H DUP (?)
	ALIGN	4

_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9 DB 032H DUP (?)
	ALIGN	4

$SG74227 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+2
$SG74228 DB	'v4.62 R002 ACCESS32', 00H
$SG74229 DB	'%s %s', 00H
	ORG $+2
$SG74230 DB	'ER: Error', 00H
	ORG $+2
$SG74231 DB	'US: American English', 00H
_DATA	ENDS
_TEXT	SEGMENT
_ver$ = 8
_TextToSpeechVersionEx PROC NEAR

; 10330: {

  03b30	56		 push	 esi

; 10331: #ifdef UNDER_CE
; 10332: 	static wchar_t DECtalk_Language_String[50];
; 10333: 	static wchar_t DECtalk_Version_String[50];
; 10334: 	// CAB 8/07/200 Big %S since value are type char not Unicode
; 10335: 	wsprintf(DECtalk_Version_String, TEXT("%S %S"), DTALK_STR_VERSION, CUSTR_STR_VERSION);
; 10336: 	wsprintf(DECtalk_Language_String, TEXT("ER: Error"));
; 10337: #else
; 10338: 				static char DECtalk_Language_String[50];
; 10339: 				static char DECtalk_Version_String[50];
; 10340: 				
; 10341: 				sprintf(DECtalk_Version_String,"%s %s",DTALK_STR_VERSION, CUSTR_STR_VERSION);

  03b31	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__sprintf
  03b37	68 00 00 00 00	 push	 OFFSET FLAT:$SG74227
  03b3c	68 00 00 00 00	 push	 OFFSET FLAT:$SG74228
  03b41	68 00 00 00 00	 push	 OFFSET FLAT:$SG74229
  03b46	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9
  03b4b	ff d6		 call	 esi

; 10342: 				sprintf(DECtalk_Language_String, "ER: Error");

  03b4d	68 00 00 00 00	 push	 OFFSET FLAT:$SG74230
  03b52	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9
  03b57	ff d6		 call	 esi

; 10343: #endif // UNDER_CE
; 10344: 
; 10345: #ifdef ENGLISH_US
; 10346: #ifdef UNDER_CE
; 10347: 	wsprintf(DECtalk_Language_String, TEXT("US: American English"));
; 10348: #else
; 10349: 				sprintf(DECtalk_Language_String, "US: American English");

  03b59	68 00 00 00 00	 push	 OFFSET FLAT:$SG74231
  03b5e	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9
  03b63	ff d6		 call	 esi

; 10350: #endif
; 10351: #endif
; 10352: #ifdef SPANISH_LA
; 10353: 				sprintf(DECtalk_Language_String, "LA: Latin American Spanish");
; 10354: #endif
; 10355: #ifdef SPANISH_SP
; 10356: 				sprintf(DECtalk_Language_String, "SP: Castillian Spanish");
; 10357: #endif
; 10358: #ifdef GERMAN
; 10359: 				sprintf(DECtalk_Language_String, "GR: German");
; 10360: #endif
; 10361: #ifdef FRENCH
; 10362: 				sprintf(DECtalk_Language_String, "FR: French");
; 10363: #endif
; 10364: #ifdef SWAHILI
; 10365: 				sprintf(DECtalk_Language_String, "SW: Swahili");
; 10366: #endif
; 10367: #ifdef ENGLISH_UK
; 10368: 				sprintf(DECtalk_Language_String, "UK: British English");
; 10369: #endif
; 10370: 
; 10371: 	if ((*ver = (LPVERSION_INFO)malloc(sizeof(VERSION_INFO))) == NULL)	return 0;

  03b65	6a 18		 push	 24			; 00000018H
  03b67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  03b6d	8b 74 24 2c	 mov	 esi, DWORD PTR _ver$[esp+36]
  03b71	83 c4 24	 add	 esp, 36			; 00000024H
  03b74	85 c0		 test	 eax, eax
  03b76	89 06		 mov	 DWORD PTR [esi], eax
  03b78	75 02		 jne	 SHORT $L74235
  03b7a	5e		 pop	 esi

; 10380: }

  03b7b	c3		 ret	 0
$L74235:

; 10372: 				(*ver)->StructSize = sizeof(VERSION_INFO);

  03b7c	c7 00 18 00 00
	00		 mov	 DWORD PTR [eax], 24	; 00000018H

; 10373: 				(*ver)->StructVersion = VERSION_STRUCT_VER;

  03b82	8b 06		 mov	 eax, DWORD PTR [esi]
  03b84	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 10374: 				(*ver)->DLLVersion = (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;

  03b8b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  03b8d	66 c7 41 08 03
	02		 mov	 WORD PTR [ecx+8], 515	; 00000203H

; 10375: 				(*ver)->DTalkVersion = (DTALK_DBG_VERSION << 15) + (DTALK_MAJ_VERSION << 8) + DTALK_MIN_VERSION;

  03b93	8b 16		 mov	 edx, DWORD PTR [esi]
  03b95	66 c7 42 0a 3e
	04		 mov	 WORD PTR [edx+10], 1086	; 0000043eH

; 10376: 				(*ver)->VerString = DECtalk_Version_String;

  03b9b	8b 06		 mov	 eax, DWORD PTR [esi]
  03b9d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9

; 10377: 				(*ver)->Language = DECtalk_Language_String;

  03ba4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  03ba6	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9

; 10378: 				(*ver)->Features = TextToSpeechGetFeatures();

  03bad	e8 00 00 00 00	 call	 _TextToSpeechGetFeatures
  03bb2	8b 16		 mov	 edx, DWORD PTR [esi]
  03bb4	5e		 pop	 esi
  03bb5	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 10379: 				return (sizeof(VERSION_INFO));

  03bb8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H

; 10380: }

  03bbd	c3		 ret	 0
_TextToSpeechVersionEx ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechStartLang
_TEXT	SEGMENT
_TextToSpeechStartLang PROC NEAR

; 10389: 				return TTS_NOT_SUPPORTED;

  03bc0	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 10390: }

  03bc5	c3		 ret	 0
_TextToSpeechStartLang ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechCloseLang
_TEXT	SEGMENT
_TextToSpeechCloseLang PROC NEAR

; 10392: 				return FALSE;

  03bd0	33 c0		 xor	 eax, eax

; 10393: }

  03bd2	c3		 ret	 0
_TextToSpeechCloseLang ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSelectLang
_TEXT	SEGMENT
_TextToSpeechSelectLang PROC NEAR

; 10407: 				return FALSE;

  03be0	33 c0		 xor	 eax, eax

; 10408: }

  03be2	c3		 ret	 0
_TextToSpeechSelectLang ENDP
_TextToSpeechGetFeatures PROC NEAR

; 10419: 	unsigned long int feats;
; 10420: 	
; 10421: #ifdef ACCESS32
; 10422: 	feats = TTS_FEATS_TYPINGMODE;
; 10423: #else
; 10424: 	feats = 0;
; 10425: #endif
; 10426: 	return feats;

  03bf0	b8 02 00 00 00	 mov	 eax, 2

; 10427: }

  03bf5	c3		 ret	 0
_TextToSpeechGetFeatures ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechEnumLangs
_TEXT	SEGMENT
_langs$ = 8
_verinfo$ = -4
_TextToSpeechEnumLangs PROC NEAR

; 10456: DWORD TextToSpeechEnumLangs(LPLANG_ENUM *langs) {

  03c00	51		 push	 ecx
  03c01	56		 push	 esi

; 10457: 	LPVERSION_INFO verinfo;
; 10458: 	int len = 0;		// CAB - Size of string
; 10459: 	
; 10460: 	if (((*langs) = malloc(sizeof(LANG_ENUM))) == NULL)	return 0;

  03c02	6a 0c		 push	 12			; 0000000cH
  03c04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  03c0a	8b 74 24 10	 mov	 esi, DWORD PTR _langs$[esp+8]
  03c0e	83 c4 04	 add	 esp, 4
  03c11	85 c0		 test	 eax, eax
  03c13	89 06		 mov	 DWORD PTR [esi], eax
  03c15	74 4b		 je	 SHORT $L74802

; 10461: 	(*langs)->Languages = 1;

  03c17	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 10462: 	(*langs)->MultiLang = FALSE;

  03c1d	8b 06		 mov	 eax, DWORD PTR [esi]

; 10463: 	if (((*langs)->Entries = calloc(1, sizeof(LANG_ENTRY))) == NULL) {

  03c1f	6a 2b		 push	 43			; 0000002bH
  03c21	6a 01		 push	 1
  03c23	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  03c2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  03c30	8b 0e		 mov	 ecx, DWORD PTR [esi]
  03c32	83 c4 08	 add	 esp, 8
  03c35	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  03c38	8b 16		 mov	 edx, DWORD PTR [esi]
  03c3a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  03c3d	85 c0		 test	 eax, eax

; 10464: 		free(langs);
; 10465: 		(*langs) = NULL;
; 10466: 		return 0;

  03c3f	74 11		 je	 SHORT $L74801

; 10467: 	}
; 10468: 	if (TextToSpeechVersionEx(&verinfo) == 0) {

  03c41	8d 44 24 04	 lea	 eax, DWORD PTR _verinfo$[esp+8]
  03c45	50		 push	 eax
  03c46	e8 00 00 00 00	 call	 _TextToSpeechVersionEx
  03c4b	83 c4 04	 add	 esp, 4
  03c4e	85 c0		 test	 eax, eax
  03c50	75 15		 jne	 SHORT $L74264
$L74801:

; 10469: 		free(langs);

  03c52	56		 push	 esi
  03c53	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  03c59	83 c4 04	 add	 esp, 4

; 10470: 		(*langs) = NULL;

  03c5c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$L74802:

; 10471: 		return 0;

  03c62	33 c0		 xor	 eax, eax
  03c64	5e		 pop	 esi

; 10488: }

  03c65	59		 pop	 ecx
  03c66	c3		 ret	 0
$L74264:

; 10472: 	}
; 10473: 	// CAB DISPLAY LANG menu with check mark  5/10/00
; 10474: #ifdef UNDER_CE
; 10475: 	// Converts char to w_char
; 10476: 	mbstowcs((*langs)->Entries[0].lang_code, verinfo->Language, 2);
; 10477: #else
; 10478: 	memcpy((*langs)->Entries[0].lang_code,verinfo->Language,2);

  03c67	8b 4c 24 04	 mov	 ecx, DWORD PTR _verinfo$[esp+8]
  03c6b	8b 06		 mov	 eax, DWORD PTR [esi]
  03c6d	57		 push	 edi
  03c6e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  03c71	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  03c74	66 8b 12	 mov	 dx, WORD PTR [edx]
  03c77	66 89 11	 mov	 WORD PTR [ecx], dx

; 10479: #endif
; 10480: 	(*langs)->Entries[0].lang_code[2] = '\0';

  03c7a	8b 06		 mov	 eax, DWORD PTR [esi]
  03c7c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  03c7f	c6 41 02 00	 mov	 BYTE PTR [ecx+2], 0

; 10481: #ifdef UNDER_CE
; 10482: 	len = strlen(verinfo->Language+4);
; 10483: 	mbstowcs((*langs)->Entries[0].lang_name, verinfo->Language+4,len);
; 10484: #else
; 10485: 	strcpy((*langs)->Entries[0].lang_name,verinfo->Language+4);

  03c83	8b 54 24 08	 mov	 edx, DWORD PTR _verinfo$[esp+12]
  03c87	8b 06		 mov	 eax, DWORD PTR [esi]
  03c89	83 c9 ff	 or	 ecx, -1
  03c8c	8b 7a 10	 mov	 edi, DWORD PTR [edx+16]
  03c8f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  03c92	83 c7 04	 add	 edi, 4
  03c95	33 c0		 xor	 eax, eax
  03c97	83 c2 03	 add	 edx, 3
  03c9a	f2 ae		 repne scasb
  03c9c	f7 d1		 not	 ecx
  03c9e	2b f9		 sub	 edi, ecx
  03ca0	8b c1		 mov	 eax, ecx
  03ca2	8b f7		 mov	 esi, edi
  03ca4	8b fa		 mov	 edi, edx
  03ca6	c1 e9 02	 shr	 ecx, 2
  03ca9	f3 a5		 rep movsd
  03cab	8b c8		 mov	 ecx, eax

; 10486: #endif
; 10487: 	return (sizeof(LANG_ENUM));

  03cad	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  03cb2	83 e1 03	 and	 ecx, 3
  03cb5	f3 a4		 rep movsb
  03cb7	5f		 pop	 edi
  03cb8	5e		 pop	 esi

; 10488: }

  03cb9	59		 pop	 ecx
  03cba	c3		 ret	 0
_TextToSpeechEnumLangs ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved3
EXTRN	_GetNumUserEntries:NEAR
EXTRN	_GetUserEntry:NEAR
EXTRN	_UserDictionaryHit:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_type$ = 12
_data$ = 16
_max_size$ = 20
_entry$ = -132
_TextToSpeechReserved3 PROC NEAR

; 10500: 	struct dic_entry entry; /* used to find a user dictionary entry's index, JAW 8/7/98 */
; 10501: 	
; 10502: 	PKSD_T  pKsd_t;
; 10503: 	pKsd_t = phTTS->pKernelShareData;
; 10504: 	
; 10505: 	switch (type)
; 10506: 	{

  03cc0	8b 44 24 08	 mov	 eax, DWORD PTR _type$[esp-4]
  03cc4	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  03cca	48		 dec	 eax
  03ccb	53		 push	 ebx
  03ccc	8b 9c 24 8c 00
	00 00		 mov	 ebx, DWORD PTR _phTTS$[esp+132]
  03cd3	56		 push	 esi
  03cd4	83 f8 06	 cmp	 eax, 6
  03cd7	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  03cda	57		 push	 edi
  03cdb	0f 87 12 01 00
	00		 ja	 $L74301
  03ce1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L74804[eax*4]
$L74305:

; 10507: 	case 1: 
; 10508: 		/* return the size of the arpabet table */
; 10509: 		return(pKsd_t->arpa_size);
; 10510: 	case 2:
; 10511: 		/* return the arpabet table */
; 10512: 		if (max_size<pKsd_t->arpa_size)

  03ce8	8b 82 30 06 00
	00		 mov	 eax, DWORD PTR [edx+1584]
  03cee	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  03cf5	3b c8		 cmp	 ecx, eax
  03cf7	7d 0c		 jge	 SHORT $L74306
  03cf9	5f		 pop	 edi
  03cfa	5e		 pop	 esi

; 10513: 		{
; 10514: 			return(-pKsd_t->arpa_size);

  03cfb	f7 d8		 neg	 eax
  03cfd	5b		 pop	 ebx

; 10550: }

  03cfe	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03d04	c3		 ret	 0
$L74306:

; 10515: 		}
; 10516: 		else
; 10517: 		{
; 10518: 			memcpy(data,pKsd_t->arpabet,pKsd_t->arpa_size);

  03d05	8b b2 2c 06 00
	00		 mov	 esi, DWORD PTR [edx+1580]
  03d0b	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  03d12	8b c8		 mov	 ecx, eax
  03d14	c1 e9 02	 shr	 ecx, 2
  03d17	f3 a5		 rep movsd
  03d19	8b c8		 mov	 ecx, eax
  03d1b	83 e1 03	 and	 ecx, 3
  03d1e	f3 a4		 rep movsb
$L74304:

; 10519: 			return(pKsd_t->arpa_size);

  03d20	8b 82 30 06 00
	00		 mov	 eax, DWORD PTR [edx+1584]
  03d26	5f		 pop	 edi
  03d27	5e		 pop	 esi
  03d28	5b		 pop	 ebx

; 10550: }

  03d29	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03d2f	c3		 ret	 0
$L74307:
  03d30	5f		 pop	 edi
  03d31	5e		 pop	 esi

; 10520: 		}
; 10521: 	case 3:
; 10522: 		/* return the number of entries the the asky conversion table */
; 10523: 		return(sizeof(ptab));

  03d32	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  03d37	5b		 pop	 ebx

; 10550: }

  03d38	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03d3e	c3		 ret	 0
$L74309:

; 10524: 	case 4:
; 10525: 		/* return the asky conversion table */
; 10526: 		if (max_size<sizeof(ptab))

  03d3f	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  03d46	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  03d4b	3b c8		 cmp	 ecx, eax
  03d4d	73 0f		 jae	 SHORT $L74310
  03d4f	5f		 pop	 edi
  03d50	5e		 pop	 esi

; 10527: 		{
; 10528: 			return(-(int)sizeof(ptab));

  03d51	b8 7e ff ff ff	 mov	 eax, -130		; ffffff7eH
  03d56	5b		 pop	 ebx

; 10550: }

  03d57	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03d5d	c3		 ret	 0
$L74310:

; 10529: 		}
; 10530: 		else
; 10531: 		{
; 10532: 			memcpy(data,(char *)ptab,sizeof(ptab));

  03d5e	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  03d65	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  03d6a	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_ptab
  03d6f	f3 a5		 rep movsd
  03d71	66 a5		 movsw
  03d73	5f		 pop	 edi
  03d74	5e		 pop	 esi
  03d75	5b		 pop	 ebx

; 10550: }

  03d76	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03d7c	c3		 ret	 0
$L74312:

; 10533: 			return(sizeof(ptab));
; 10534: 		}
; 10535: 	case 5:
; 10536: 		/* return number of user dictionary entries */
; 10537: 		return GetNumUserEntries(phTTS); /* GetNumUserEntries is defined in ls_dict.c */

  03d7d	53		 push	 ebx
  03d7e	e8 00 00 00 00	 call	 _GetNumUserEntries
  03d83	83 c4 04	 add	 esp, 4
  03d86	5f		 pop	 edi
  03d87	5e		 pop	 esi
  03d88	5b		 pop	 ebx

; 10550: }

  03d89	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03d8f	c3		 ret	 0
$L74315:

; 10538: 	case 6:
; 10539: 		/* return the grapheme/phoneme string for the user dictionary entry at max_size in data 
; 10540: 		   (don't let the variable name confuse you; max_size is simply being used as an index)
; 10541: 		   */
; 10542: 		return GetUserEntry(phTTS, data, max_size); /* GetUserEntry is defined in ls_dict.c,

  03d90	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  03d97	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR _data$[esp+140]
  03d9e	51		 push	 ecx
  03d9f	52		 push	 edx
  03da0	53		 push	 ebx
  03da1	e8 00 00 00 00	 call	 _GetUserEntry
  03da6	83 c4 0c	 add	 esp, 12			; 0000000cH
  03da9	5f		 pop	 edi
  03daa	5e		 pop	 esi
  03dab	5b		 pop	 ebx

; 10550: }

  03dac	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03db2	c3		 ret	 0
$L74316:

; 10543: 													   and it returns the starting index of the
; 10544: 													   phoneme. */
; 10545: 	case 7:
; 10546: 		strcpy(entry.text, data);

  03db3	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  03dba	83 c9 ff	 or	 ecx, -1
  03dbd	33 c0		 xor	 eax, eax
  03dbf	8d 54 24 10	 lea	 edx, DWORD PTR _entry$[esp+148]
  03dc3	f2 ae		 repne scasb
  03dc5	f7 d1		 not	 ecx
  03dc7	2b f9		 sub	 edi, ecx
  03dc9	8b c1		 mov	 eax, ecx
  03dcb	8b f7		 mov	 esi, edi
  03dcd	8b fa		 mov	 edi, edx
  03dcf	c1 e9 02	 shr	 ecx, 2
  03dd2	f3 a5		 rep movsd
  03dd4	8b c8		 mov	 ecx, eax
  03dd6	83 e1 03	 and	 ecx, 3
  03dd9	f3 a4		 rep movsb

; 10547: 		return UserDictionaryHit(phTTS, &entry); /* returns the index of the entry */

  03ddb	8d 4c 24 0c	 lea	 ecx, DWORD PTR _entry$[esp+144]
  03ddf	51		 push	 ecx
  03de0	53		 push	 ebx
  03de1	e8 00 00 00 00	 call	 _UserDictionaryHit
  03de6	83 c4 08	 add	 esp, 8
  03de9	5f		 pop	 edi
  03dea	5e		 pop	 esi
  03deb	5b		 pop	 ebx

; 10550: }

  03dec	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03df2	c3		 ret	 0
$L74301:
  03df3	5f		 pop	 edi
  03df4	5e		 pop	 esi

; 10548: 	}
; 10549: 	return(-1);

  03df5	83 c8 ff	 or	 eax, -1
  03df8	5b		 pop	 ebx

; 10550: }

  03df9	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03dff	c3		 ret	 0
$L74804:
  03e00	00 00 00 00	 DD	 $L74304
  03e04	00 00 00 00	 DD	 $L74305
  03e08	00 00 00 00	 DD	 $L74307
  03e0c	00 00 00 00	 DD	 $L74309
  03e10	00 00 00 00	 DD	 $L74312
  03e14	00 00 00 00	 DD	 $L74315
  03e18	00 00 00 00	 DD	 $L74316
_TextToSpeechReserved3 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetPhVdefParams
EXTRN	_GetPhVdefParams:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_index$ = 12
_TextToSpeechGetPhVdefParams PROC NEAR

; 10567: 	return GetPhVdefParams(phTTS, index);

  03e20	8b 44 24 08	 mov	 eax, DWORD PTR _index$[esp-4]
  03e24	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]
  03e28	50		 push	 eax
  03e29	51		 push	 ecx
  03e2a	e8 00 00 00 00	 call	 _GetPhVdefParams
  03e2f	83 c4 08	 add	 esp, 8

; 10568: }

  03e32	c3		 ret	 0
_TextToSpeechGetPhVdefParams ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetSpeakerParams
EXTRN	_GetSpeakerParams:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_uiIndex$ = 12
_ppspCur$ = 16
_ppspLoLimit$ = 20
_ppspHiLimit$ = 24
_ppspDefault$ = 28
_TextToSpeechGetSpeakerParams PROC NEAR

; 10589: 	return GetSpeakerParams(phTTS, uiIndex, ppspCur, ppspLoLimit, ppspHiLimit, ppspDefault);

  03e40	8b 44 24 18	 mov	 eax, DWORD PTR _ppspDefault$[esp-4]
  03e44	8b 4c 24 14	 mov	 ecx, DWORD PTR _ppspHiLimit$[esp-4]
  03e48	8b 54 24 10	 mov	 edx, DWORD PTR _ppspLoLimit$[esp-4]
  03e4c	50		 push	 eax
  03e4d	8b 44 24 10	 mov	 eax, DWORD PTR _ppspCur$[esp]
  03e51	51		 push	 ecx
  03e52	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiIndex$[esp+4]
  03e56	52		 push	 edx
  03e57	8b 54 24 10	 mov	 edx, DWORD PTR _phTTS$[esp+8]
  03e5b	50		 push	 eax
  03e5c	51		 push	 ecx
  03e5d	52		 push	 edx
  03e5e	e8 00 00 00 00	 call	 _GetSpeakerParams
  03e63	83 c4 18	 add	 esp, 24			; 00000018H

; 10590: }

  03e66	c3		 ret	 0
_TextToSpeechGetSpeakerParams ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetSpeakerParams
EXTRN	_SetSpeakerParams:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pspSet$ = 12
_TextToSpeechSetSpeakerParams PROC NEAR

; 10607: 	return SetSpeakerParams(phTTS, pspSet);

  03e70	8b 44 24 08	 mov	 eax, DWORD PTR _pspSet$[esp-4]
  03e74	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]
  03e78	50		 push	 eax
  03e79	51		 push	 ecx
  03e7a	e8 00 00 00 00	 call	 _SetSpeakerParams
  03e7f	83 c4 08	 add	 esp, 8

; 10608: }

  03e82	c3		 ret	 0
_TextToSpeechSetSpeakerParams ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDictionaryHit
EXTRN	_DictionaryHit:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechDictionaryHit PROC NEAR

; 10624: 	long i;
; 10625: 	
; 10626: 	
; 10627: 	if (phTTS == NULL)

  03e90	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03e94	85 c0		 test	 eax, eax
  03e96	75 04		 jne	 SHORT $L74406

; 10628: 		return -1;

  03e98	83 c8 ff	 or	 eax, -1

; 10632: 		return 0;
; 10633: 	return 1;
; 10634: }

  03e9b	c3		 ret	 0
$L74406:

; 10629: 	
; 10630: 	i = DictionaryHit(phTTS, entry);

  03e9c	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03ea0	51		 push	 ecx
  03ea1	50		 push	 eax
  03ea2	e8 00 00 00 00	 call	 _DictionaryHit
  03ea7	83 c4 08	 add	 esp, 8

; 10631: 	if (i == -1)

  03eaa	33 d2		 xor	 edx, edx
  03eac	83 f8 ff	 cmp	 eax, -1
  03eaf	0f 95 c2	 setne	 dl
  03eb2	8b c2		 mov	 eax, edx

; 10632: 		return 0;
; 10633: 	return 1;
; 10634: }

  03eb4	c3		 ret	 0
_TextToSpeechDictionaryHit ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDumpDictionary
EXTRN	_DumpDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechDumpDictionary PROC NEAR

; 10639: 	if (phTTS == NULL)

  03ec0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03ec4	85 c0		 test	 eax, eax
  03ec6	75 06		 jne	 SHORT $L74414

; 10640: 		return MMSYSERR_INVALHANDLE;

  03ec8	b8 05 00 00 00	 mov	 eax, 5

; 10643: }

  03ecd	c3		 ret	 0
$L74414:

; 10641: 	
; 10642: 	return DumpDictionary(phTTS, filename);

  03ece	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03ed2	51		 push	 ecx
  03ed3	50		 push	 eax
  03ed4	e8 00 00 00 00	 call	 _DumpDictionary
  03ed9	83 c4 08	 add	 esp, 8

; 10643: }

  03edc	c3		 ret	 0
_TextToSpeechDumpDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechUserDictionaryHit
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechUserDictionaryHit PROC NEAR

; 10648: 	long i;
; 10649: 	
; 10650: 	
; 10651: 	if (phTTS == NULL)

  03ee0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03ee4	85 c0		 test	 eax, eax
  03ee6	75 04		 jne	 SHORT $L74422

; 10652: 		return -1;

  03ee8	83 c8 ff	 or	 eax, -1

; 10656: 		return 0;
; 10657: 	return 1;
; 10658: }

  03eeb	c3		 ret	 0
$L74422:

; 10653: 	
; 10654: 	i = UserDictionaryHit(phTTS, entry);

  03eec	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03ef0	51		 push	 ecx
  03ef1	50		 push	 eax
  03ef2	e8 00 00 00 00	 call	 _UserDictionaryHit
  03ef7	83 c4 08	 add	 esp, 8

; 10655: 	if (i == -1)

  03efa	33 d2		 xor	 edx, edx
  03efc	83 f8 ff	 cmp	 eax, -1
  03eff	0f 95 c2	 setne	 dl
  03f02	8b c2		 mov	 eax, edx

; 10656: 		return 0;
; 10657: 	return 1;
; 10658: }

  03f04	c3		 ret	 0
_TextToSpeechUserDictionaryHit ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDumpUserDictionary
EXTRN	_DumpUserDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechDumpUserDictionary PROC NEAR

; 10663: 	if (phTTS == NULL)

  03f10	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03f14	85 c0		 test	 eax, eax
  03f16	75 06		 jne	 SHORT $L74430

; 10664: 		return MMSYSERR_INVALHANDLE;

  03f18	b8 05 00 00 00	 mov	 eax, 5

; 10667: }

  03f1d	c3		 ret	 0
$L74430:

; 10665: 	
; 10666: 	return DumpUserDictionary(phTTS, filename);

  03f1e	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03f22	51		 push	 ecx
  03f23	50		 push	 eax
  03f24	e8 00 00 00 00	 call	 _DumpUserDictionary
  03f29	83 c4 08	 add	 esp, 8

; 10667: }

  03f2c	c3		 ret	 0
_TextToSpeechDumpUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechAddUserEntry
EXTRN	_AddUserEntry:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechAddUserEntry PROC NEAR

; 10672: 	if (phTTS == NULL)

  03f30	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03f34	85 c0		 test	 eax, eax
  03f36	75 06		 jne	 SHORT $L74437

; 10673: 		return MMSYSERR_INVALHANDLE;

  03f38	b8 05 00 00 00	 mov	 eax, 5

; 10676: }

  03f3d	c3		 ret	 0
$L74437:

; 10674: 	
; 10675: 	return AddUserEntry(phTTS, entry);

  03f3e	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03f42	51		 push	 ecx
  03f43	50		 push	 eax
  03f44	e8 00 00 00 00	 call	 _AddUserEntry
  03f49	83 c4 08	 add	 esp, 8

; 10676: }

  03f4c	c3		 ret	 0
_TextToSpeechAddUserEntry ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDeleteUserEntry
EXTRN	_DeleteUserEntry:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechDeleteUserEntry PROC NEAR

; 10681: 	if (phTTS == NULL)

  03f50	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03f54	85 c0		 test	 eax, eax
  03f56	75 06		 jne	 SHORT $L74444

; 10682: 		return MMSYSERR_INVALHANDLE;																

  03f58	b8 05 00 00 00	 mov	 eax, 5

; 10685: }

  03f5d	c3		 ret	 0
$L74444:

; 10683: 	
; 10684: 	return DeleteUserEntry(phTTS, entry);

  03f5e	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03f62	51		 push	 ecx
  03f63	50		 push	 eax
  03f64	e8 00 00 00 00	 call	 _DeleteUserEntry
  03f69	83 c4 08	 add	 esp, 8

; 10685: }

  03f6c	c3		 ret	 0
_TextToSpeechDeleteUserEntry ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechChangeUserPhoneme
EXTRN	_ChangeUserPhoneme:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_new_phoneme$ = 16
_TextToSpeechChangeUserPhoneme PROC NEAR

; 10691: 	if (phTTS == NULL)

  03f70	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03f74	85 c0		 test	 eax, eax
  03f76	75 06		 jne	 SHORT $L74453

; 10692: 		return MMSYSERR_INVALHANDLE;

  03f78	b8 05 00 00 00	 mov	 eax, 5

; 10695: }

  03f7d	c3		 ret	 0
$L74453:

; 10693: 	
; 10694: 	return ChangeUserPhoneme(phTTS, entry, new_phoneme);

  03f7e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _new_phoneme$[esp-4]
  03f82	8b 54 24 08	 mov	 edx, DWORD PTR _entry$[esp-4]
  03f86	51		 push	 ecx
  03f87	52		 push	 edx
  03f88	50		 push	 eax
  03f89	e8 00 00 00 00	 call	 _ChangeUserPhoneme
  03f8e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10695: }

  03f91	c3		 ret	 0
_TextToSpeechChangeUserPhoneme ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSaveUserDictionary
EXTRN	_SaveUserDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechSaveUserDictionary PROC NEAR

; 10711: 	if (phTTS == NULL)

  03fa0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03fa4	85 c0		 test	 eax, eax
  03fa6	75 06		 jne	 SHORT $L74465

; 10712: 		return MMSYSERR_INVALHANDLE;

  03fa8	b8 05 00 00 00	 mov	 eax, 5

; 10715: }

  03fad	c3		 ret	 0
$L74465:

; 10713: 
; 10714: 	return SaveUserDictionary(phTTS, filename);

  03fae	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03fb2	51		 push	 ecx
  03fb3	50		 push	 eax
  03fb4	e8 00 00 00 00	 call	 _SaveUserDictionary
  03fb9	83 c4 08	 add	 esp, 8

; 10715: }

  03fbc	c3		 ret	 0
_TextToSpeechSaveUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechConvertToPhonemes
EXTRN	__imp__IsBadReadPtr@8:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_szPhonemeBuf$ = 12
_dwBufSize$ = 16
_szText$ = 24
_dwCvtFlags$ = 32
_TextToSpeechConvertToPhonemes PROC NEAR

; 10729: {

  03fc0	53		 push	 ebx
  03fc1	55		 push	 ebp
  03fc2	56		 push	 esi

; 10730: 	if (phTTS == NULL)

  03fc3	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  03fc7	33 db		 xor	 ebx, ebx
  03fc9	57		 push	 edi
  03fca	3b f3		 cmp	 esi, ebx
  03fcc	75 0a		 jne	 SHORT $L74482
  03fce	5f		 pop	 edi
  03fcf	5e		 pop	 esi
  03fd0	5d		 pop	 ebp

; 10731: 		return MMSYSERR_INVALHANDLE;

  03fd1	b8 05 00 00 00	 mov	 eax, 5
  03fd6	5b		 pop	 ebx

; 10762: }

  03fd7	c3		 ret	 0
$L74482:

; 10732: 	if (   IsBadReadPtr(szText,1)
; 10733: 		|| IsBadReadPtr(dwBufSize,1)
; 10734: 		|| IsBadWritePtr(szPhonemeBuf,*dwBufSize) )

  03fd8	8b 44 24 24	 mov	 eax, DWORD PTR _szText$[esp+12]
  03fdc	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__IsBadReadPtr@8
  03fe2	6a 01		 push	 1
  03fe4	50		 push	 eax
  03fe5	ff d5		 call	 ebp
  03fe7	85 c0		 test	 eax, eax
  03fe9	0f 85 94 00 00
	00		 jne	 $L74484
  03fef	8b 7c 24 1c	 mov	 edi, DWORD PTR _dwBufSize$[esp+12]
  03ff3	6a 01		 push	 1
  03ff5	57		 push	 edi
  03ff6	ff d5		 call	 ebp
  03ff8	85 c0		 test	 eax, eax
  03ffa	0f 85 83 00 00
	00		 jne	 $L74484
  04000	8b 0f		 mov	 ecx, DWORD PTR [edi]
  04002	8b 6c 24 18	 mov	 ebp, DWORD PTR _szPhonemeBuf$[esp+12]
  04006	51		 push	 ecx
  04007	55		 push	 ebp
  04008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0400e	85 c0		 test	 eax, eax
  04010	75 71		 jne	 SHORT $L74484

; 10737: 	}
; 10738: 
; 10739: 	// come to a complete stop;
; 10740: 	TextToSpeechSync(phTTS);

  04012	56		 push	 esi
  04013	e8 00 00 00 00	 call	 _TextToSpeechSync

; 10741: 	// Set up to log phonemes
; 10742: 	phTTS->dwPhonemeBufferPtr = 0;
; 10743: 	phTTS->dwPhonemeBufferSize = *dwBufSize;
; 10744: 	phTTS->dwPhonemeCvtFlags = dwCvtFlags;
; 10745: 	phTTS->szPhonemeBuffer = szPhonemeBuf;
; 10746: 
; 10747: 	// send along the text
; 10748: 	TextToSpeechSpeak( phTTS, szText, TTS_FORCE);

  04018	8b 4c 24 28	 mov	 ecx, DWORD PTR _szText$[esp+16]
  0401c	8b 44 24 30	 mov	 eax, DWORD PTR _dwCvtFlags$[esp+16]
  04020	89 9e f0 00 00
	00		 mov	 DWORD PTR [esi+240], ebx
  04026	8b 17		 mov	 edx, DWORD PTR [edi]
  04028	6a 01		 push	 1
  0402a	51		 push	 ecx
  0402b	56		 push	 esi
  0402c	89 96 ec 00 00
	00		 mov	 DWORD PTR [esi+236], edx
  04032	89 86 f4 00 00
	00		 mov	 DWORD PTR [esi+244], eax
  04038	89 ae e8 00 00
	00		 mov	 DWORD PTR [esi+232], ebp
  0403e	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 10749: 	// wait for completion
; 10750: 	TextToSpeechSync(phTTS);

  04043	56		 push	 esi
  04044	e8 00 00 00 00	 call	 _TextToSpeechSync

; 10751: 	// clear the flags to the VTM
; 10752: 	phTTS->dwPhonemeCvtFlags = 0;
; 10753: 	// vtmiont leaves enough space for a terminating null..
; 10754: 	phTTS->szPhonemeBuffer[phTTS->dwPhonemeBufferPtr++]='\0';

  04049	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR [esi+240]
  0404f	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  04055	89 9e f4 00 00
	00		 mov	 DWORD PTR [esi+244], ebx
  0405b	83 c4 14	 add	 esp, 20			; 00000014H
  0405e	88 1c 02	 mov	 BYTE PTR [edx+eax], bl
  04061	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  04067	40		 inc	 eax
  04068	89 86 f0 00 00
	00		 mov	 DWORD PTR [esi+240], eax

; 10755: 	// return the count in the BufSize arg
; 10756: 	*dwBufSize = phTTS->dwPhonemeBufferPtr;

  0406e	89 07		 mov	 DWORD PTR [edi], eax

; 10757: 	// stop logging
; 10758: 	phTTS->szPhonemeBuffer = NULL;

  04070	89 9e e8 00 00
	00		 mov	 DWORD PTR [esi+232], ebx

; 10759: 	phTTS->dwPhonemeBufferSize = 0;

  04076	89 9e ec 00 00
	00		 mov	 DWORD PTR [esi+236], ebx
  0407c	5f		 pop	 edi
  0407d	5e		 pop	 esi
  0407e	5d		 pop	 ebp

; 10760: 
; 10761: 	return MMSYSERR_NOERROR;

  0407f	33 c0		 xor	 eax, eax
  04081	5b		 pop	 ebx

; 10762: }

  04082	c3		 ret	 0
$L74484:
  04083	5f		 pop	 edi
  04084	5e		 pop	 esi
  04085	5d		 pop	 ebp

; 10735: 	{
; 10736: 		return MMSYSERR_INVALPARAM;

  04086	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0408b	5b		 pop	 ebx

; 10762: }

  0408c	c3		 ret	 0
_TextToSpeechConvertToPhonemes ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechTuning
_TEXT	SEGMENT
_phTTS$ = 8
_iFunction$ = 12
_pvtdArg$ = 16
_TextToSpeechTuning PROC NEAR

; 10778: 	PVTM_T pVtm_t = phTTS->pVTMThreadData;

  04090	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  04094	53		 push	 ebx

; 10779: 
; 10780: 	// make sure we haven't been handed junk..
; 10781: 	if (IsBadWritePtr(phTTS, sizeof(LPTTS_HANDLE_T)))

  04095	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__IsBadWritePtr@8
  0409b	56		 push	 esi
  0409c	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0409f	57		 push	 edi
  040a0	6a 04		 push	 4
  040a2	50		 push	 eax
  040a3	ff d3		 call	 ebx
  040a5	85 c0		 test	 eax, eax
  040a7	74 09		 je	 SHORT $L74496
  040a9	5f		 pop	 edi
  040aa	5e		 pop	 esi

; 10782: 	{
; 10783: 		// bad handle
; 10784: 		return MMSYSERR_INVALHANDLE;

  040ab	b8 05 00 00 00	 mov	 eax, 5
  040b0	5b		 pop	 ebx

; 10842: 
; 10843: } // TextToSpeechTuning

  040b1	c3		 ret	 0
$L74496:

; 10785: 	}
; 10786: 
; 10787: 	// decide what to do..
; 10788: 	switch (iFunction)
; 10789: 	{

  040b2	8b 44 24 14	 mov	 eax, DWORD PTR _iFunction$[esp+8]
  040b6	48		 dec	 eax
  040b7	74 48		 je	 SHORT $L74501
  040b9	48		 dec	 eax
  040ba	74 35		 je	 SHORT $L74502
  040bc	48		 dec	 eax
  040bd	74 09		 je	 SHORT $L74503
  040bf	5f		 pop	 edi
  040c0	5e		 pop	 esi

; 10835: 		break;
; 10836: 
; 10837: 	default:
; 10838: 		return MMSYSERR_INVALPARAM; // bad function request.

  040c1	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  040c6	5b		 pop	 ebx

; 10842: 
; 10843: } // TextToSpeechTuning

  040c7	c3		 ret	 0
$L74503:

; 10824: 		break;
; 10825: 
; 10826: 	case TTSTUNING_GET_RESULTS:
; 10827: 		// tek 01dec98
; 10828: 		if (IsBadWritePtr(pvtdArg, sizeof(VTM_TUNER_DATA)))

  040c8	8b 7c 24 18	 mov	 edi, DWORD PTR _pvtdArg$[esp+8]
  040cc	6a 34		 push	 52			; 00000034H
  040ce	57		 push	 edi
  040cf	ff d3		 call	 ebx
  040d1	85 c0		 test	 eax, eax
  040d3	74 09		 je	 SHORT $L74505
  040d5	5f		 pop	 edi
  040d6	5e		 pop	 esi

; 10829: 		{
; 10830: 			// bad handle
; 10831: 			return MMSYSERR_INVALPARAM;

  040d7	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  040dc	5b		 pop	 ebx

; 10842: 
; 10843: } // TextToSpeechTuning

  040dd	c3		 ret	 0
$L74505:

; 10832: 		}
; 10833: 		// do the copy
; 10834: 		memcpy(pvtdArg, &pVtm_t->vtdTuneResults, sizeof(VTM_TUNER_DATA));

  040de	81 c6 70 01 00
	00		 add	 esi, 368		; 00000170H
  040e4	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  040e9	f3 a5		 rep movsd
  040eb	5f		 pop	 edi
  040ec	5e		 pop	 esi

; 10839: 
; 10840: 	} // switch (iFunction)
; 10841: 	return MMSYSERR_NOERROR; 

  040ed	33 c0		 xor	 eax, eax
  040ef	5b		 pop	 ebx

; 10842: 
; 10843: } // TextToSpeechTuning

  040f0	c3		 ret	 0
$L74502:

; 10819: 		break;
; 10820: 
; 10821: 	case TTSTUNING_DISABLE:
; 10822: 		// clear the switch
; 10823: 		pVtm_t->bDoTuning = FALSE;

  040f1	c7 86 34 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+564], 0
  040fb	5f		 pop	 edi
  040fc	5e		 pop	 esi

; 10839: 
; 10840: 	} // switch (iFunction)
; 10841: 	return MMSYSERR_NOERROR; 

  040fd	33 c0		 xor	 eax, eax
  040ff	5b		 pop	 ebx

; 10842: 
; 10843: } // TextToSpeechTuning

  04100	c3		 ret	 0
$L74501:

; 10790: 	case TTSTUNING_ENABLE:
; 10791: 		// clear all the old data
; 10792: 		pVtm_t->vtdTuneResults.rnpmax=0;      /*maximum value within filter of casade rnp*/

  04101	33 c0		 xor	 eax, eax

; 10793: 		pVtm_t->vtdTuneResults.rnzmax=0;      /*maximum value within filter of casade rnz*/
; 10794: 		pVtm_t->vtdTuneResults.c1max=0;       /*maximum value within filter of casade 1*/
; 10795: 		pVtm_t->vtdTuneResults.c2max=0;       /*maximum value within filter of casade 2*/
; 10796: 		pVtm_t->vtdTuneResults.c3max=0;       /*maximum value within filter of casade 3*/
; 10797: 		pVtm_t->vtdTuneResults.c4max=0;       /*maximum value within filter of casade 4*/
; 10798: 		pVtm_t->vtdTuneResults.c5max=0;       /*maximum value within filter of casade 5*/
; 10799: 		pVtm_t->vtdTuneResults.purevmax=0;    /*maximum value of downsampled voice */
; 10800: 		pVtm_t->vtdTuneResults.r2pd1=0;    /*  Last output sample from parallel 2nd formant        */
; 10801: 		pVtm_t->vtdTuneResults.r3pd1=0;    /*  Last output sample from parallel 3rd formant        */
; 10802: 		pVtm_t->vtdTuneResults.r4pd1=0;    /*  Last output sample from parallel 4th formant        */
; 10803: 		pVtm_t->vtdTuneResults.r5pd1=0;    /*  Last output sample from parallel 5th formant        */
; 10804: 	
; 10805: 		pVtm_t->vtdTuneResults.bDidOverload=0;	/* true if we trapped an overload */
; 10806: 		pVtm_t->vtdTuneResults.dwThisPhoneme=0;	/* the phoneme we overloaded on */
; 10807: 		pVtm_t->vtdTuneResults.dwLastPhoneme=0;	/* the phoneme we overloaded on */
; 10808: 
; 10809: 		pVtm_t->vtdTuneResults.r1cd2=0;
; 10810: 		pVtm_t->vtdTuneResults.r2cd2=0;
; 10811: 		pVtm_t->vtdTuneResults.r3cd2=0;
; 10812: 		pVtm_t->vtdTuneResults.r4cd2=0;
; 10813: 		pVtm_t->vtdTuneResults.r5cd2=0;
; 10814: 		pVtm_t->vtdTuneResults.rnpd2=0;
; 10815: 		pVtm_t->vtdTuneResults.rnzd2=0;
; 10816: 		pVtm_t->vtdTuneResults.rlpd2=0;
; 10817: 		// set the enable bit 
; 10818: 		pVtm_t->bDoTuning = TRUE;

  04103	c7 86 34 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+564], 1
  0410d	66 89 86 70 01
	00 00		 mov	 WORD PTR [esi+368], ax
  04114	66 89 86 72 01
	00 00		 mov	 WORD PTR [esi+370], ax
  0411b	66 89 86 74 01
	00 00		 mov	 WORD PTR [esi+372], ax
  04122	66 89 86 76 01
	00 00		 mov	 WORD PTR [esi+374], ax
  04129	66 89 86 78 01
	00 00		 mov	 WORD PTR [esi+376], ax
  04130	66 89 86 7a 01
	00 00		 mov	 WORD PTR [esi+378], ax
  04137	66 89 86 7c 01
	00 00		 mov	 WORD PTR [esi+380], ax
  0413e	66 89 86 7e 01
	00 00		 mov	 WORD PTR [esi+382], ax
  04145	66 89 86 80 01
	00 00		 mov	 WORD PTR [esi+384], ax
  0414c	66 89 86 82 01
	00 00		 mov	 WORD PTR [esi+386], ax
  04153	66 89 86 84 01
	00 00		 mov	 WORD PTR [esi+388], ax
  0415a	66 89 86 86 01
	00 00		 mov	 WORD PTR [esi+390], ax
  04161	89 86 88 01 00
	00		 mov	 DWORD PTR [esi+392], eax
  04167	89 86 8c 01 00
	00		 mov	 DWORD PTR [esi+396], eax
  0416d	89 86 90 01 00
	00		 mov	 DWORD PTR [esi+400], eax
  04173	66 89 86 94 01
	00 00		 mov	 WORD PTR [esi+404], ax
  0417a	66 89 86 96 01
	00 00		 mov	 WORD PTR [esi+406], ax
  04181	66 89 86 98 01
	00 00		 mov	 WORD PTR [esi+408], ax
  04188	66 89 86 9a 01
	00 00		 mov	 WORD PTR [esi+410], ax
  0418f	66 89 86 9c 01
	00 00		 mov	 WORD PTR [esi+412], ax
  04196	66 89 86 9e 01
	00 00		 mov	 WORD PTR [esi+414], ax
  0419d	66 89 86 a0 01
	00 00		 mov	 WORD PTR [esi+416], ax
  041a4	66 89 86 a2 01
	00 00		 mov	 WORD PTR [esi+418], ax
  041ab	5f		 pop	 edi
  041ac	5e		 pop	 esi
  041ad	5b		 pop	 ebx

; 10842: 
; 10843: } // TextToSpeechTuning

  041ae	c3		 ret	 0
_TextToSpeechTuning ENDP
_PumpModeMessage PROC NEAR

; 10863: 	return(TRUE);

  041b0	b8 01 00 00 00	 mov	 eax, 1

; 10864: }

  041b5	c3		 ret	 0
_PumpModeMessage ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenSapi5Output
_TEXT	SEGMENT
_TextToSpeechOpenSapi5Output PROC NEAR

; 10872: #ifndef SAPI5DECTALK
; 10873: 	return( MMSYSERR_NOERROR );

  041c0	33 c0		 xor	 eax, eax

; 10874: #else
; 10875: 	MMRESULT mmStatus;
; 10876: 	
; 10877: 	/********************************************************************/
; 10878: 	/*  Return error if invalid handle.                                 */
; 10879: 	/********************************************************************/
; 10880: 	
; 10881: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 10882: 		return( MMSYSERR_INVALHANDLE );
; 10883: 	
; 10884: 	/********************************************************************/
; 10885: 	/*  If not in NULL output state or AUDIO Output state then return   */
; 10886: 	/*  an error.                                                       */
; 10887: 	/********************************************************************/
; 10888: 	
; 10889: 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 10890: 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))
; 10891: 		return( MMSYSERR_ERROR );
; 10892: 	
; 10893: 	/********************************************************************/
; 10894: 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 10895: 	/*  function have completed.                                        */
; 10896: 	/********************************************************************/
; 10897: 	
; 10898: 	mmStatus = TextToSpeechSync( phTTS );
; 10899: 	
; 10900: 	if ( mmStatus )
; 10901: 		return( mmStatus );
; 10902: 	
; 10903: 	/********************************************************************/
; 10904: 	/*  If the dwFormat value is invalid then return an error.          */
; 10905: 	/********************************************************************/
; 10906: 	
; 10907: 	switch( dwFormat )
; 10908: 	{
; 10909: 	case WAVE_FORMAT_1M16:
; 10910: 		// 11.025 KHz 16 bit
; 10911: 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 10912: 		phTTS->OutputIsText=0;
; 10913: 		phTTS->pAudioHandle->dMsecPerSample = (double)(1000)/(double)(22050);  // 11025 *2
; 10914: 		phTTS->pAudioHandle->bAudioIsEightBit=FALSE;
; 10915: 		phTTS->pAudioHandle->bAudioIsMulaw=FALSE;
; 10916: 		
; 10917: 		break;
; 10918: 		
; 10919: 	case WAVE_FORMAT_1M08:
; 10920: 		// 11.025 KHz 8 bit
; 10921: 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 10922: 		phTTS->OutputIsText=0;
; 10923: 		phTTS->pAudioHandle->dMsecPerSample = (double)(1000)/(double)(11025); 
; 10924: 		phTTS->pAudioHandle->bAudioIsEightBit=TRUE;
; 10925: 		phTTS->pAudioHandle->bAudioIsMulaw=FALSE;
; 10926: 		
; 10927: 		break;
; 10928: 		
; 10929: 	case WAVE_FORMAT_08M08:
; 10930: 		// 8.000 KHz 8 bit mulaw
; 10931: 		SetSampleRate( phTTS, MULAW_SAMPLE_RATE );
; 10932: 		phTTS->OutputIsText=0;
; 10933: 		phTTS->pAudioHandle->dMsecPerSample = (double)(1000)/(double)(8000);  
; 10934: 		phTTS->pAudioHandle->bAudioIsEightBit=TRUE;
; 10935: 		phTTS->pAudioHandle->bAudioIsMulaw=TRUE;
; 10936: 		break;
; 10937: 
; 10938: 	case WAVE_FORMAT_NULL:
; 10939: 		phTTS->OutputIsText=1;
; 10940: 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 10941: 		phTTS->pAudioHandle->dMsecPerSample = (double)(1000)/(double)(22050);  // 11025 *2
; 10942: 		phTTS->pAudioHandle->bAudioIsEightBit=FALSE;
; 10943: 		phTTS->pAudioHandle->bAudioIsMulaw=FALSE;
; 10944: 		break;
; 10945: 		
; 10946: 	default:
; 10947: 		
; 10948: 		return( MMSYSERR_INVALPARAM );
; 10949: 	}
; 10950: 	phTTS->SkippingForward=0;
; 10951: 	phTTS->pAudioHandle->bInAudioReset=0;
; 10952: 	phTTS->pAudioHandle->bSendSamplesRequested=0;
; 10953: 	phTTS->pAudioHandle->bAudioRanDry=0;
; 10954: 	phTTS->pAudioHandle->bAudioIsFile=0;
; 10955: 	phTTS->pAudioHandle->bPipesNotEmpty=0;
; 10956: 
; 10957: 	phTTS->pKernelShareData->volume=100;
; 10958: 	phTTS->dwFormat = dwFormat;
; 10959: 
; 10960: 	phTTS->CTTSEngObj=pSapiEngine;
; 10961: 	phTTS->dwQueuedSampleCount=0;
; 10962: 
; 10963: 	phTTS->dwOutputState = STATE_OUTPUT_SAPI5;
; 10964: 
; 10965: 	
; 10966: 	return( MMSYSERR_NOERROR );
; 10967: #endif
; 10968: }

  041c2	c3		 ret	 0
_TextToSpeechOpenSapi5Output ENDP
_TextToSpeechCloseSapi5Output PROC NEAR

; 10972: #ifndef SAPI5DECTALK
; 10973: 	return( MMSYSERR_NOERROR );

  041d0	33 c0		 xor	 eax, eax

; 10974: #else
; 10975: 	/********************************************************************/
; 10976: 	/*  Return error if invalid handle.                                 */
; 10977: 	/********************************************************************/
; 10978: 	
; 10979: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 10980: 		return( MMSYSERR_INVALHANDLE );
; 10981: 	
; 10982: 	/********************************************************************/
; 10983: 	/*  If not in MEMORY output state then return an error.             */
; 10984: 	/********************************************************************/
; 10985: 	
; 10986: 	if ( phTTS->dwOutputState != STATE_OUTPUT_SAPI5 )
; 10987: 		return( MMSYSERR_ERROR );
; 10988: 	
; 10989: #ifdef WIN32
; 10990: 	// merged 28jul97 tek
; 10991: 	// 16jun97 tek bats 385 sync will hang forever if we don't clear
; 10992: 	// bInReset..
; 10993: 	phTTS->bInReset = FALSE;
; 10994: #endif
; 10995: 	
; 10996: 	/********************************************************************/
; 10997: 	/*  Halt the system and flush all data.                             */
; 10998: 	/********************************************************************/
; 10999: 	
; 11000: 	TextToSpeechSync( phTTS );
; 11001: 	
; 11002: 	/********************************************************************/
; 11003: 	/*  Delete the memory buffer critical section.                      */
; 11004: 	/********************************************************************/
; 11005: 
; 11006: 	phTTS->CTTSEngObj=NULL;
; 11007: 
; 11008: 	phTTS->OutputIsText=0;
; 11009: 
; 11010: 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 11011: 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 11012: 	else
; 11013: 		phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 11014: 	
; 11015: 	return( MMSYSERR_NOERROR );
; 11016: #endif
; 11017: }

  041d2	c3		 ret	 0
_TextToSpeechCloseSapi5Output ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetVolume
_TEXT	SEGMENT
_phTTS$ = 8
_type$ = 12
_volume$ = 16
_TextToSpeechSetVolume PROC NEAR

; 11020: {

  041e0	56		 push	 esi

; 11021: #ifndef SAPI5DECTALK
; 11022: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  041e1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  041e5	6a 04		 push	 4
  041e7	56		 push	 esi
  041e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  041ee	85 c0		 test	 eax, eax
  041f0	74 07		 je	 SHORT $L74528

; 11023: 		return( MMSYSERR_INVALHANDLE );

  041f2	b8 05 00 00 00	 mov	 eax, 5
  041f7	5e		 pop	 esi

; 11041: #else
; 11042: 	/********************************************************************/
; 11043: 	/*  Return error if invalid handle.                                 */
; 11044: 	/********************************************************************/
; 11045: 	
; 11046: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 11047: 		return( MMSYSERR_INVALHANDLE );
; 11048: 
; 11049: 	if (volume>100)
; 11050: 	{
; 11051: 		volume=100;
; 11052: 	}
; 11053: 	else if (volume<0)
; 11054: 	{
; 11055: 		volume=0;
; 11056: 	}
; 11057: 	phTTS->pKernelShareData->volume=volume;
; 11058: 
; 11059: 	return( MMSYSERR_NOERROR );
; 11060: #endif
; 11061: }

  041f8	c3		 ret	 0
$L74528:

; 11024: 
; 11025: 	if (volume>100 || volume <0)

  041f9	8b 44 24 10	 mov	 eax, DWORD PTR _volume$[esp]
  041fd	83 f8 64	 cmp	 eax, 100		; 00000064H
  04200	7f 28		 jg	 SHORT $L74530
  04202	85 c0		 test	 eax, eax
  04204	7c 24		 jl	 SHORT $L74530

; 11028: 	}
; 11029: 	switch (type)
; 11030: 	{

  04206	8b 4c 24 0c	 mov	 ecx, DWORD PTR _type$[esp]
  0420a	49		 dec	 ecx
  0420b	74 10		 je	 SHORT $L74535
  0420d	49		 dec	 ecx

; 11033: 		break;
; 11034: 	case VOLUME_ATTENUATION:
; 11035: 		phTTS->pKernelShareData->vol_att=volume;
; 11036: 		break;
; 11037: 	default:
; 11038: 		return MMSYSERR_INVALPARAM;

  0420e	75 1a		 jne	 SHORT $L74530
  04210	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  04213	5e		 pop	 esi
  04214	89 81 e0 03 00
	00		 mov	 DWORD PTR [ecx+992], eax

; 11039: 	}
; 11040: 	return( MMSYSERR_NOERROR );

  0421a	33 c0		 xor	 eax, eax

; 11041: #else
; 11042: 	/********************************************************************/
; 11043: 	/*  Return error if invalid handle.                                 */
; 11044: 	/********************************************************************/
; 11045: 	
; 11046: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 11047: 		return( MMSYSERR_INVALHANDLE );
; 11048: 
; 11049: 	if (volume>100)
; 11050: 	{
; 11051: 		volume=100;
; 11052: 	}
; 11053: 	else if (volume<0)
; 11054: 	{
; 11055: 		volume=0;
; 11056: 	}
; 11057: 	phTTS->pKernelShareData->volume=volume;
; 11058: 
; 11059: 	return( MMSYSERR_NOERROR );
; 11060: #endif
; 11061: }

  0421c	c3		 ret	 0
$L74535:

; 11031: 	case VOLUME_MAIN:
; 11032: 		phTTS->pKernelShareData->volume=volume;

  0421d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  04220	5e		 pop	 esi
  04221	89 82 dc 03 00
	00		 mov	 DWORD PTR [edx+988], eax

; 11039: 	}
; 11040: 	return( MMSYSERR_NOERROR );

  04227	33 c0		 xor	 eax, eax

; 11041: #else
; 11042: 	/********************************************************************/
; 11043: 	/*  Return error if invalid handle.                                 */
; 11044: 	/********************************************************************/
; 11045: 	
; 11046: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 11047: 		return( MMSYSERR_INVALHANDLE );
; 11048: 
; 11049: 	if (volume>100)
; 11050: 	{
; 11051: 		volume=100;
; 11052: 	}
; 11053: 	else if (volume<0)
; 11054: 	{
; 11055: 		volume=0;
; 11056: 	}
; 11057: 	phTTS->pKernelShareData->volume=volume;
; 11058: 
; 11059: 	return( MMSYSERR_NOERROR );
; 11060: #endif
; 11061: }

  04229	c3		 ret	 0
$L74530:

; 11026: 	{
; 11027: 		return MMSYSERR_INVALPARAM;

  0422a	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0422f	5e		 pop	 esi

; 11041: #else
; 11042: 	/********************************************************************/
; 11043: 	/*  Return error if invalid handle.                                 */
; 11044: 	/********************************************************************/
; 11045: 	
; 11046: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 11047: 		return( MMSYSERR_INVALHANDLE );
; 11048: 
; 11049: 	if (volume>100)
; 11050: 	{
; 11051: 		volume=100;
; 11052: 	}
; 11053: 	else if (volume<0)
; 11054: 	{
; 11055: 		volume=0;
; 11056: 	}
; 11057: 	phTTS->pKernelShareData->volume=volume;
; 11058: 
; 11059: 	return( MMSYSERR_NOERROR );
; 11060: #endif
; 11061: }

  04230	c3		 ret	 0
_TextToSpeechSetVolume ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetVolume
_TEXT	SEGMENT
_phTTS$ = 8
_type$ = 12
_volume$ = 16
_TextToSpeechGetVolume PROC NEAR

; 11064: {

  04240	56		 push	 esi

; 11065: #ifndef SAPI5DECTALK
; 11066: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  04241	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  04245	6a 04		 push	 4
  04247	56		 push	 esi
  04248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0424e	85 c0		 test	 eax, eax
  04250	74 07		 je	 SHORT $L74545

; 11067: 		return( MMSYSERR_INVALHANDLE );

  04252	b8 05 00 00 00	 mov	 eax, 5
  04257	5e		 pop	 esi

; 11081: #else
; 11082: 	/********************************************************************/
; 11083: 	/*  Return error if invalid handle.                                 */
; 11084: 	/********************************************************************/
; 11085: 	
; 11086: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 11087: 		return( MMSYSERR_INVALHANDLE );
; 11088: 
; 11089: 	*volume=phTTS->pKernelShareData->volume;
; 11090: 
; 11091: 	return( MMSYSERR_NOERROR );
; 11092: #endif
; 11093: }

  04258	c3		 ret	 0
$L74545:

; 11068: 
; 11069: 	switch (type)
; 11070: 	{

  04259	8b 44 24 0c	 mov	 eax, DWORD PTR _type$[esp]
  0425d	48		 dec	 eax
  0425e	74 1d		 je	 SHORT $L74550
  04260	48		 dec	 eax
  04261	74 07		 je	 SHORT $L74551

; 11076: 		break;
; 11077: 	default:
; 11078: 		return MMSYSERR_INVALPARAM;

  04263	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  04268	5e		 pop	 esi

; 11081: #else
; 11082: 	/********************************************************************/
; 11083: 	/*  Return error if invalid handle.                                 */
; 11084: 	/********************************************************************/
; 11085: 	
; 11086: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 11087: 		return( MMSYSERR_INVALHANDLE );
; 11088: 
; 11089: 	*volume=phTTS->pKernelShareData->volume;
; 11090: 
; 11091: 	return( MMSYSERR_NOERROR );
; 11092: #endif
; 11093: }

  04269	c3		 ret	 0
$L74551:

; 11073: 		break;
; 11074: 	case VOLUME_ATTENUATION:
; 11075: 		*volume=phTTS->pKernelShareData->vol_att;

  0426a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0426d	8b 54 24 10	 mov	 edx, DWORD PTR _volume$[esp]
  04271	5e		 pop	 esi
  04272	8b 88 e0 03 00
	00		 mov	 ecx, DWORD PTR [eax+992]

; 11079: 	}
; 11080: 	return( MMSYSERR_NOERROR );

  04278	33 c0		 xor	 eax, eax
  0427a	89 0a		 mov	 DWORD PTR [edx], ecx

; 11081: #else
; 11082: 	/********************************************************************/
; 11083: 	/*  Return error if invalid handle.                                 */
; 11084: 	/********************************************************************/
; 11085: 	
; 11086: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 11087: 		return( MMSYSERR_INVALHANDLE );
; 11088: 
; 11089: 	*volume=phTTS->pKernelShareData->volume;
; 11090: 
; 11091: 	return( MMSYSERR_NOERROR );
; 11092: #endif
; 11093: }

  0427c	c3		 ret	 0
$L74550:

; 11071: 	case VOLUME_MAIN:
; 11072: 		*volume=phTTS->pKernelShareData->volume;

  0427d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  04280	8b 54 24 10	 mov	 edx, DWORD PTR _volume$[esp]
  04284	5e		 pop	 esi
  04285	8b 88 dc 03 00
	00		 mov	 ecx, DWORD PTR [eax+988]

; 11079: 	}
; 11080: 	return( MMSYSERR_NOERROR );

  0428b	33 c0		 xor	 eax, eax
  0428d	89 0a		 mov	 DWORD PTR [edx], ecx

; 11081: #else
; 11082: 	/********************************************************************/
; 11083: 	/*  Return error if invalid handle.                                 */
; 11084: 	/********************************************************************/
; 11085: 	
; 11086: 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 11087: 		return( MMSYSERR_INVALHANDLE );
; 11088: 
; 11089: 	*volume=phTTS->pKernelShareData->volume;
; 11090: 
; 11091: 	return( MMSYSERR_NOERROR );
; 11092: #endif
; 11093: }

  0428f	c3		 ret	 0
_TextToSpeechGetVolume ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechVisualMarks
_TEXT	SEGMENT
_TextToSpeechVisualMarks PROC NEAR

; 11097: #if defined __osf__ || defined __linux__
; 11098: 	if (value)
; 11099: 	{
; 11100: 		phTTS->uiID_Visual_Message=TTS_MSG_VISUAL ;
; 11101: 	}
; 11102: 	else
; 11103: 	{
; 11104: 		phTTS->uiID_Visual_Message=0xDEADC0DE;
; 11105: 	}
; 11106: #endif
; 11107: 	return(0);

  04290	33 c0		 xor	 eax, eax

; 11108: }

  04292	c3		 ret	 0
_TextToSpeechVisualMarks ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved4
_TEXT	SEGMENT
_TextToSpeechReserved4 PROC NEAR

; 11111: 	return;
; 11112: }

  042a0	c3		 ret	 0
_TextToSpeechReserved4 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved6
_TEXT	SEGMENT
_TextToSpeechReserved6 PROC NEAR

; 11114: 	return;
; 11115: }

  042b0	c3		 ret	 0
_TextToSpeechReserved6 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved5
_TEXT	SEGMENT
_TextToSpeechReserved5 PROC NEAR

; 11118: 
; 11119: }

  042c0	c3		 ret	 0
_TextToSpeechReserved5 ENDP
_TEXT	ENDS
END
