	TITLE	D:\work\product\dapi\src\api\ttsapi.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_gnInstanceCounter
PUBLIC	_tl_gnInstanceCounter
PUBLIC	_gpufdic
PUBLIC	_gufdic_entries
PUBLIC	_szLicenseKey
PUBLIC	_gszA32Id
PUBLIC	_hMapObject
_DATA	SEGMENT
COMM	_LanguageParamsArray:QWORD
_DATA	ENDS
_BSS	SEGMENT
_gnInstanceCounter DD 01H DUP (?)
_tl_gnInstanceCounter DB 0cH DUP (?)
_gpufdic DD	01H DUP (?)
_gufdic_entries DD 01H DUP (?)
_gszA32Id DB	0100H DUP (?)
_guiLoadedLicenseShare DD 01H DUP (?)
_lpvMemLicense DD 01H DUP (?)
_hMapObject DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_szLicenseKey DB 'Software\DECtalk Software\DECtalk\4.60', 00H
	ORG $+1
_?wExponentLut@?1??LinearToMuLaw@@9@9 DW 00H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	06H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
_ptab	DB	065H
	DB	03H
	DB	061H
	DB	06H
	DB	069H
	DB	01H
	DB	045H
	DB	04H
	DB	041H
	DB	07H
	DB	049H
	DB	02H
	DB	04fH
	DB	0cH
	DB	06fH
	DB	0bH
	DB	075H
	DB	0eH
	DB	05eH
	DB	09H
	DB	057H
	DB	08H
	DB	059H
	DB	010H
	DB	052H
	DB	0fH
	DB	063H
	DB	0aH
	DB	040H
	DB	05H
	DB	055H
	DB	0dH
	DB	07cH
	DB	012H
	DB	078H
	DB	011H
	DB	070H
	DB	02dH
	DB	074H
	DB	02fH
	DB	06bH
	DB	031H
	DB	066H
	DB	025H
	DB	054H
	DB	027H
	DB	073H
	DB	029H
	DB	053H
	DB	02bH
	DB	043H
	DB	036H
	DB	077H
	DB	018H
	DB	079H
	DB	019H
	DB	068H
	DB	01cH
	DB	06cH
	DB	01bH
	DB	04cH
	DB	022H
	DB	04eH
	DB	024H
	DB	062H
	DB	02eH
	DB	064H
	DB	030H
	DB	067H
	DB	032H
	DB	076H
	DB	026H
	DB	044H
	DB	028H
	DB	07aH
	DB	02aH
	DB	05aH
	DB	02cH
	DB	04aH
	DB	037H
	DB	06dH
	DB	01fH
	DB	06eH
	DB	020H
	DB	047H
	DB	021H
	DB	072H
	DB	01aH
	DB	071H
	DB	035H
	DB	051H
	DB	034H
	DB	026H
	DB	033H
	DB	046H
	DB	038H
	DB	042H
	DB	013H
	DB	04bH
	DB	014H
	DB	050H
	DB	015H
	DB	04dH
	DB	016H
	DB	06aH
	DB	017H
	DB	02cH
	DB	073H
	DB	020H
	DB	06fH
	DB	09H
	DB	06fH
	DB	027H
	DB	067H
	DB	060H
	DB	066H
	DB	022H
	DB	068H
	DB	023H
	DB	06eH
	DB	028H
	DB	070H
	DB	029H
	DB	071H
	DB	02aH
	DB	06dH
	DB	07eH
	DB	064H
	DB	02dH
	DB	06cH
_DATA	ENDS
PUBLIC	_LibMain@12
_TEXT	SEGMENT
_LibMain@12 PROC NEAR

; 623  : 	switch(ul_reason_being_called)
; 624  : 	{
; 625  : 	/*
; 626  : 	* DLL is attaching to a process.It could be
; 627  : 	* while process getting loaded (The process 
; 628  : 	* might have used load-time dynamic linking i.e
; 629  : 	* built using dectalk.lib import library)
; 630  : 	* OR   
; 631  : 	* Process made a call to LoadLibrary(dectalk.dll)
; 632  : 		*/
; 633  : 	case DLL_PROCESS_ATTACH :
; 634  : 		//#ifdef LICENSES
; 635  : 		//              if (!AddLicenseRef())
; 636  : 		//                      return FALSE; // no licenses.
; 637  : 		//#endif
; 638  : 		break;
; 639  : 	case DLL_THREAD_ATTACH:
; 640  : 		break;
; 641  : 	case DLL_THREAD_DETACH:
; 642  : 		break;
; 643  : 	case DLL_PROCESS_DETACH :
; 644  : 		//#ifdef LICENSES
; 645  : 		//              ReleaseLicenseRef();
; 646  : 		//#endif
; 647  : 		break;
; 648  : 	}
; 649  : 	
; 650  : 	return(TRUE);

  00000	b8 01 00 00 00	 mov	 eax, 1

; 651  : 	//  return( 1 );
; 652  : 	//  UNREFERENCED_PARAMETER( hInst );
; 653  : 	//  UNREFERENCED_PARAMETER( ul_reason_being_called );
; 654  : 	//  UNREFERENCED_PARAMETER( lpReserved );
; 655  : }

  00005	c2 0c 00	 ret	 12			; 0000000cH
_LibMain@12 ENDP
_TEXT	ENDS
PUBLIC	_AddLicenseRef
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	__imp__CreateFileMappingA@24:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	__imp__fclose:NEAR
EXTRN	__imp__fflush:NEAR
EXTRN	__imp__fopen:NEAR
EXTRN	__imp__fprintf:NEAR
EXTRN	__imp__MapViewOfFile@20:NEAR
EXTRN	_decryptString:NEAR
EXTRN	__imp__UnmapViewOfFile@4:NEAR
EXTRN	__strdate:NEAR
EXTRN	__strtime:NEAR
_BSS	SEGMENT
$SG71542 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+2
$SG71517 DB	'a+', 00H
	ORG $+1
$SG71518 DB	'\dtlic.log', 00H
	ORG $+1
$SG71524 DB	'%s %s : Text-to-speech license information invalid!', 0aH
	DB	00H
	ORG $+3
$SG71529 DB	'a32DECtalkDllFileMap', 00H
	ORG $+3
$SG71556 DB	'a+', 00H
	ORG $+1
$SG71557 DB	'\dtlic.log', 00H
	ORG $+1
$SG71561 DB	'%s %s : Insufficient Text-to-Speech Run-time Licenses.', 0aH
	DB	00H
_DATA	ENDS
_TEXT	SEGMENT
_szDateBuf$71520 = -640
_szTimeBuf$71521 = -576
_szEncryptedString$71541 = -512
_szDateBuf$71559 = -576
_szTimeBuf$71560 = -640
_AddLicenseRef PROC NEAR

; 731  : {

  00010	81 ec 80 02 00
	00		 sub	 esp, 640		; 00000280H
  00016	53		 push	 ebx
  00017	56		 push	 esi

; 732  : 	BOOL fInit,fIgnore;
; 733  : 	DWORD dwMAXRunTimeLicenses ;
; 734  : 	DWORD dwLicenseCount;
; 735  : 	
; 736  : 
; 737  : 	dwMAXRunTimeLicenses = GetFromSomeWhere();

  00018	e8 00 00 00 00	 call	 _GetFromSomeWhere
  0001d	8b d8		 mov	 ebx, eax

; 738  : 	
; 739  : 	if(dwMAXRunTimeLicenses == LICENSE_KEY_ERROR)

  0001f	83 fb ff	 cmp	 ebx, -1
  00022	75 5f		 jne	 SHORT $L71515

; 740  : 	{
; 741  : #ifndef UNDER_CE
; 742  : #ifdef DEBUG // removed message box from release code BATS#741
; 743  : 		MessageBox(NULL,"Text-to-speech license information invalid!",
; 744  : 			"LicenseKey",MB_ICONSTOP|MB_OK);
; 745  : #endif
; 746  : 		{
; 747  : 			FILE *outfile;
; 748  : 			outfile=fopen("\\dtlic.log","a+");

  00024	68 00 00 00 00	 push	 OFFSET FLAT:$SG71517
  00029	68 00 00 00 00	 push	 OFFSET FLAT:$SG71518
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00034	8b f0		 mov	 esi, eax
  00036	83 c4 08	 add	 esp, 8

; 749  : 			if (outfile)

  00039	85 f6		 test	 esi, esi
  0003b	74 3b		 je	 SHORT $L71558

; 750  : 			{
; 751  : 				char szDateBuf[64];
; 752  : 				char szTimeBuf[64];
; 753  : 			   // log the pertinent info
; 754  : 			   _strdate(szDateBuf);

  0003d	8d 44 24 08	 lea	 eax, DWORD PTR _szDateBuf$71520[esp+648]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 __strdate

; 755  : 			   _strtime(szTimeBuf);

  00047	8d 4c 24 4c	 lea	 ecx, DWORD PTR _szTimeBuf$71521[esp+652]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 __strtime

; 756  : 			   fprintf(outfile,"%s %s : Text-to-speech license information invalid!\n",
; 757  : 				   szDateBuf, szTimeBuf);

  00051	8d 54 24 50	 lea	 edx, DWORD PTR _szTimeBuf$71521[esp+656]
  00055	8d 44 24 10	 lea	 eax, DWORD PTR _szDateBuf$71520[esp+656]
  00059	52		 push	 edx
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:$SG71524
$L73176:
  00060	56		 push	 esi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf

; 758  : 			   fflush(outfile);

  00067	56		 push	 esi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush

; 759  : 			   fclose(outfile);

  0006e	56		 push	 esi
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00075	83 c4 20	 add	 esp, 32			; 00000020H
$L71558:
  00078	5e		 pop	 esi

; 760  : 			}
; 761  : 		}
; 762  : 
; 763  : #else
; 764  : #ifdef DEBUG // removed message box from release code BATS#790
; 765  : 
; 766  : 		MessageBox(NULL,_T("Text-to-speech license information invalid!"),
; 767  : 			_T("LicenseKey"),MB_ICONSTOP|MB_OK);
; 768  : #endif
; 769  : #endif
; 770  : 		return FALSE;  // Don't load DLL

  00079	33 c0		 xor	 eax, eax
  0007b	5b		 pop	 ebx

; 922  : 	}
; 923  : 	
; 924  : }

  0007c	81 c4 80 02 00
	00		 add	 esp, 640		; 00000280H
  00082	c3		 ret	 0
$L71515:

; 771  : 	}
; 772  : 	/* Create a named file mapping object */ 
; 773  : 	// 0 means Unlimited Licenses :Just return from DllEntry function.
; 774  : 	if(!dwMAXRunTimeLicenses)     

  00083	85 db		 test	 ebx, ebx

; 775  : 		return TRUE;

  00085	0f 84 b3 01 00
	00		 je	 $L71551

; 776  : 	if (!guiLoadedLicenseShare)			 /* tek 08Jan97 BATS 205*/

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _guiLoadedLicenseShare
  00090	85 c0		 test	 eax, eax
  00092	0f 85 13 01 00
	00		 jne	 $L71526

; 777  : 	{
; 778  : 		hMapObject = CreateFileMapping( 
; 779  : 			(HANDLE) 0xFFFFFFFF, /* use paging file    */ 
; 780  : 			NULL,                /* no security attr.  */ 
; 781  : 			PAGE_READWRITE,      /* read/write access  */ 
; 782  : 			0,                   /* size: high 32-bits */ 
; 783  : 			SHMEMSIZE,           /* size: low 32-bits  */
; 784  : #ifndef ACI_LICENSE	//tek 01may97
; 785  : #ifdef WILLOWPOND
; 786  : 			"wpDECtalkDllLicensememfilemap");    /* name of map object */
; 787  : #else // not aci, not willowpond
; 788  : #ifdef ACCESS32 // tek 15sep97
; 789  : #ifdef UNDER_CE
; 790  : 		TEXT("a32DECtalkDllFileMap"));/* support for WinCE mfg 12/04/99 */
; 791  : #else
; 792  : 		"a32DECtalkDllFileMap");/* name of map object */

  00098	68 00 00 00 00	 push	 OFFSET FLAT:$SG71529
  0009d	6a 0a		 push	 10			; 0000000aH
  0009f	6a 00		 push	 0
  000a1	6a 04		 push	 4
  000a3	6a 00		 push	 0
  000a5	6a ff		 push	 -1
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingA@24

; 793  : #endif
; 794  : #else // not aci, not willowpond, not access32
; 795  : 		"DECtalkDllLicensememfilemap");    /* name of map object */
; 796  : #endif //ACCESS32
; 797  : #endif //WILLOWPOND
; 798  : #else
; 799  : 		"AciSpeechLicenseMemFileMap");	/* name of map object */
; 800  : #endif
; 801  : 		
; 802  : 		if (hMapObject == NULL) 

  000ad	85 c0		 test	 eax, eax
  000af	a3 00 00 00 00	 mov	 DWORD PTR _hMapObject, eax
  000b4	75 09		 jne	 SHORT $L71531
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx

; 922  : 	}
; 923  : 	
; 924  : }

  000b8	81 c4 80 02 00
	00		 add	 esp, 640		; 00000280H
  000be	c3		 ret	 0
$L71531:

; 803  : 			return FALSE; 
; 804  : 		
; 805  : 		/* The first process to attach initializes memory. */ 
; 806  : 		
; 807  : 		fInit = (GetLastError() != ERROR_ALREADY_EXISTS); 

  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000c5	33 c9		 xor	 ecx, ecx
  000c7	3d b7 00 00 00	 cmp	 eax, 183		; 000000b7H
  000cc	0f 95 c1	 setne	 cl
  000cf	8b c1		 mov	 eax, ecx

; 808  : #ifdef ACCESS32 //tek 15sep97 SMIT licensing
; 809  : 		// ACCESS32 requires the SMITxx code to do the init..
; 810  : 		if (fInit)      // false if the section already exists

  000d1	85 c0		 test	 eax, eax
  000d3	74 18		 je	 SHORT $L71532

; 811  : 		{
; 812  : 			// get rid of the handle
; 813  : 			CloseHandle(hMapObject);

  000d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hMapObject
  000db	52		 push	 edx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000e2	5e		 pop	 esi

; 814  : 			// return a license failure.
; 815  : 			return FALSE;

  000e3	33 c0		 xor	 eax, eax
  000e5	5b		 pop	 ebx

; 922  : 	}
; 923  : 	
; 924  : }

  000e6	81 c4 80 02 00
	00		 add	 esp, 640		; 00000280H
  000ec	c3		 ret	 0
$L71532:

; 816  : 		} // if (fInit)
; 817  : #endif //ACCESS32
; 818  : 		/* Get a pointer to the file-mapped shared memory. */
; 819  : 		
; 820  : 		lpvMemLicense = MapViewOfFile( 
; 821  : 			hMapObject,     /* object to map view of    */ 
; 822  : 			FILE_MAP_WRITE, /* read/write access        */ 
; 823  : 			0,              /* high offset:   map from  */ 
; 824  : 			0,              /* low offset:    beginning */ 
; 825  : 			0);             /* default: map entire file */ 

  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  000f2	6a 00		 push	 0
  000f4	6a 00		 push	 0
  000f6	6a 00		 push	 0
  000f8	6a 02		 push	 2
  000fa	50		 push	 eax
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20
  00101	8b d0		 mov	 edx, eax

; 826  : 		if (lpvMemLicense == NULL) 

  00103	85 d2		 test	 edx, edx
  00105	89 15 00 00 00
	00		 mov	 DWORD PTR _lpvMemLicense, edx
  0010b	75 09		 jne	 SHORT $L71535
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx

; 922  : 	}
; 923  : 	
; 924  : }

  0010f	81 c4 80 02 00
	00		 add	 esp, 640		; 00000280H
  00115	c3		 ret	 0
$L71535:

; 827  : 			return FALSE; 
; 828  : 		
; 829  : 		/* Initialize memory if this is the first process. */ 
; 830  : 		if (fInit)
; 831  : 		{
; 832  : 			//memset(lpvMemLicense, '\0', SHMEMSIZE);
; 833  : 			*(PDWORD)lpvMemLicense = (DWORD)0;
; 834  : 			// To set the Number of Licenses
; 835  : 			
; 836  : 		}
; 837  : #ifdef ACCESS32 //tek 15sep97 SMIT licensing
; 838  :         else
; 839  :         {
; 840  : 			char *szMemLicense=NULL;
; 841  : 			char szEncryptedString[512]="";

  00116	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR $SG71542
  0011c	57		 push	 edi
  0011d	88 8c 24 8c 00
	00 00		 mov	 BYTE PTR _szEncryptedString$71541[esp+652], cl
  00124	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00129	33 c0		 xor	 eax, eax
  0012b	8d bc 24 8d 00
	00 00		 lea	 edi, DWORD PTR _szEncryptedString$71541[esp+653]
  00132	f3 ab		 rep stosd
  00134	66 ab		 stosw
  00136	aa		 stosb

; 842  : 			UINT uiResult=0;
; 843  : 			// we have to check that the memory area is valid..
; 844  : 			szMemLicense = (char *)(lpvMemLicense);
; 845  : 			strcpy(szEncryptedString,&szMemLicense[4]);     // this is [4], because the

  00137	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  0013a	83 c9 ff	 or	 ecx, -1
  0013d	33 c0		 xor	 eax, eax
  0013f	8d 94 24 8c 00
	00 00		 lea	 edx, DWORD PTR _szEncryptedString$71541[esp+652]
  00146	f2 ae		 repne scasb
  00148	f7 d1		 not	 ecx
  0014a	2b f9		 sub	 edi, ecx

; 846  : 			// first DWORD is the license
; 847  : 			// count.
; 848  : 			// decrypt it..
; 849  : 			uiResult = decryptString(szEncryptedString,
; 850  : 				DEFAULT_ACCESS32_KEY,
; 851  : 				gszA32Id);

  0014c	68 00 00 00 00	 push	 OFFSET FLAT:_gszA32Id
  00151	8b c1		 mov	 eax, ecx
  00153	8b f7		 mov	 esi, edi
  00155	8b fa		 mov	 edi, edx
  00157	68 6f 2b 00 00	 push	 11119			; 00002b6fH
  0015c	c1 e9 02	 shr	 ecx, 2
  0015f	f3 a5		 rep movsd
  00161	8b c8		 mov	 ecx, eax
  00163	83 e1 03	 and	 ecx, 3
  00166	f3 a4		 rep movsb
  00168	8d 8c 24 94 00
	00 00		 lea	 ecx, DWORD PTR _szEncryptedString$71541[esp+660]
  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 _decryptString
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH

; 852  : 			
; 853  : 			if (!uiResult)

  00178	85 c0		 test	 eax, eax
  0017a	5f		 pop	 edi
  0017b	75 24		 jne	 SHORT $L71545

; 854  : 			{
; 855  : 				// unmap the section
; 856  : 				UnmapViewOfFile(lpvMemLicense);

  0017d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpvMemLicense
  00183	52		 push	 edx
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 857  : 				// get rid of the handle
; 858  : 				CloseHandle(hMapObject);

  0018a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  0018f	50		 push	 eax
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00196	5e		 pop	 esi

; 859  : 				// return a license failure.
; 860  : 				return FALSE;

  00197	33 c0		 xor	 eax, eax
  00199	5b		 pop	 ebx

; 922  : 	}
; 923  : 	
; 924  : }

  0019a	81 c4 80 02 00
	00		 add	 esp, 640		; 00000280H
  001a0	c3		 ret	 0
$L71545:

; 861  : 			}
; 862  :         }
; 863  : 		
; 864  : #endif //ACCESS32
; 865  : 		
; 866  : 		guiLoadedLicenseShare = TRUE;

  001a1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 1
$L71526:

; 867  : 	}
; 868  : 	/* tek 08jan97, BATS 205 */
; 869  : 	/* make sure we have the section.. */
; 870  : 	if (lpvMemLicense == NULL) 

  001ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  001b0	85 c0		 test	 eax, eax
  001b2	75 09		 jne	 SHORT $L71547
  001b4	5e		 pop	 esi
  001b5	5b		 pop	 ebx

; 922  : 	}
; 923  : 	
; 924  : }

  001b6	81 c4 80 02 00
	00		 add	 esp, 640		; 00000280H
  001bc	c3		 ret	 0
$L71547:

; 871  : 		return FALSE; 
; 872  : 	
; 873  : 	// Increment Run-time License Counter.(i.e How many Processes are using DECtalk.dll)
; 874  : 	(*(PDWORD)lpvMemLicense)++;

  001bd	8b 30		 mov	 esi, DWORD PTR [eax]
  001bf	46		 inc	 esi
  001c0	89 30		 mov	 DWORD PTR [eax], esi

; 875  : 	dwLicenseCount =  (*(PDWORD)lpvMemLicense);
; 876  : 	
; 877  : 	if(*(PDWORD)lpvMemLicense > dwMAXRunTimeLicenses)

  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpvMemLicense
  001c8	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ca	3b c3		 cmp	 eax, ebx
  001cc	76 70		 jbe	 SHORT $L71551

; 878  : 	{
; 879  : 		// Decrement Run-time License Counter.(i.e How many Processes are using DECtalk.dll)
; 880  : 		(*(PDWORD)lpvMemLicense)--;

  001ce	48		 dec	 eax
  001cf	89 01		 mov	 DWORD PTR [ecx], eax

; 881  : 		/* tek 08jan97 BATS 205 */
; 882  : 		/* only unmap the section if the count is zero - which */
; 883  : 		/* should never happen, I think.. */
; 884  : 		if (*(PDWORD)lpvMemLicense == 0)

  001d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  001d6	83 38 00	 cmp	 DWORD PTR [eax], 0
  001d9	75 1e		 jne	 SHORT $L71554

; 885  : 		{
; 886  : 			/* Unmap shared memory from the process's address space. */ 
; 887  : 			fIgnore = UnmapViewOfFile(lpvMemLicense); 

  001db	50		 push	 eax
  001dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 888  : 			/* Close the process's handle to the file-mapping object. */ 
; 889  : 			fIgnore = CloseHandle(hMapObject); 

  001e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hMapObject
  001e8	51		 push	 ecx
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 890  : 			guiLoadedLicenseShare = FALSE;

  001ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 0
$L71554:

; 891  : 		}
; 892  : 		
; 893  : #ifndef UNDER_CE
; 894  : #ifdef DEBUG // removed message box from release code BATS#741
; 895  : 		 MessageBox(NULL,"Insufficient Text-to-Speech Run-time Licenses.","Licenses",MB_ICONSTOP|MB_OK);
; 896  : #endif
; 897  :  		{
; 898  : 			FILE *outfile;
; 899  : 			outfile=fopen("\\dtlic.log","a+");

  001f9	68 00 00 00 00	 push	 OFFSET FLAT:$SG71556
  001fe	68 00 00 00 00	 push	 OFFSET FLAT:$SG71557
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00209	8b f0		 mov	 esi, eax
  0020b	83 c4 08	 add	 esp, 8

; 900  : 			if (outfile)

  0020e	85 f6		 test	 esi, esi
  00210	0f 84 62 fe ff
	ff		 je	 $L71558

; 901  : 			{
; 902  : 				char szDateBuf[64];
; 903  : 				char szTimeBuf[64];
; 904  : 			   // log the pertinent info
; 905  : 			   _strdate(szDateBuf);

  00216	8d 54 24 48	 lea	 edx, DWORD PTR _szDateBuf$71559[esp+648]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 __strdate

; 906  : 			   _strtime(szTimeBuf);

  00220	8d 44 24 0c	 lea	 eax, DWORD PTR _szTimeBuf$71560[esp+652]
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 __strtime

; 907  : 			   fprintf(outfile,"%s %s : Insufficient Text-to-Speech Run-time Licenses.\n",
; 908  : 				   szDateBuf, szTimeBuf);

  0022a	8d 4c 24 10	 lea	 ecx, DWORD PTR _szTimeBuf$71560[esp+656]
  0022e	8d 54 24 50	 lea	 edx, DWORD PTR _szDateBuf$71559[esp+656]
  00232	51		 push	 ecx
  00233	52		 push	 edx
  00234	68 00 00 00 00	 push	 OFFSET FLAT:$SG71561

; 909  : 			   fflush(outfile);
; 910  : 			   fclose(outfile);
; 911  : 			}
; 912  : 		}
; 913  : 
; 914  : #else
; 915  : 		MessageBox(NULL,_T("Insufficient Text-to-Speech Run-time Licenses."),_T("Licenses"),MB_ICONSTOP|MB_OK);
; 916  : #endif
; 917  : 		return FALSE; //Don't load DLL

  00239	e9 22 fe ff ff	 jmp	 $L73176
$L71551:
  0023e	5e		 pop	 esi

; 918  : 	}
; 919  : 	else
; 920  : 	{
; 921  : 		return TRUE;

  0023f	b8 01 00 00 00	 mov	 eax, 1
  00244	5b		 pop	 ebx

; 922  : 	}
; 923  : 	
; 924  : }

  00245	81 c4 80 02 00
	00		 add	 esp, 640		; 00000280H
  0024b	c3		 ret	 0
_AddLicenseRef ENDP
_GetFromSomeWhere PROC NEAR

; 665  : #ifdef ACCESS32 // tek 15sep97 SMIT licensing
; 666  : #define ACCESS32_LICENSE_COUNT (4)
; 667  : 	return ACCESS32_LICENSE_COUNT;

  00250	b8 04 00 00 00	 mov	 eax, 4

; 668  : #else //ACCESS32
; 669  : 	HKEY hKeyLicense = NULL;
; 670  : 	// tek 01may97 key now comes from coop.h
; 671  : 	CHAR szLicensesEncrypted[MAX_STR];
; 672  : #ifdef UNDER_CE //mfg 09jan99 Windows CE support
; 673  : 	TCHAR wszLicensesEncrypted[MAX_STR/2];
; 674  : #endif
; 675  : 	char szLicenses[64];
; 676  : 	DWORD dwType,cbData;
; 677  : 	
; 678  : 	if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
; 679  : 		szLicenseKey,
; 680  : 		0,
; 681  : 		KEY_QUERY_VALUE,
; 682  : 		&hKeyLicense ) != ERROR_SUCCESS )
; 683  : 	{
; 684  : 		return LICENSE_KEY_ERROR;
; 685  : 	}
; 686  : 	else
; 687  : 	{
; 688  : 		cbData = MAX_STR;
; 689  : 		if ( RegQueryValueEx( hKeyLicense,
; 690  : #ifndef UNDER_CE //mfg 09jan99 Windows CE support
; 691  : 			"Licenses",
; 692  : #else
; 693  : 			TEXT("Licenses"),
; 694  : #endif
; 695  : 			NULL,
; 696  : 			&dwType,
; 697  : #ifndef UNDER_CE //mfg 09jan99 Windows CE support
; 698  : 			(LPBYTE)szLicensesEncrypted,
; 699  : #else
; 700  : 			(LPBYTE)wszLicensesEncrypted,
; 701  : #endif
; 702  : 			&cbData ) != ERROR_SUCCESS )
; 703  : 		{
; 704  : 			return LICENSE_KEY_ERROR;
; 705  : 		}       
; 706  : #ifdef UNDER_CE	//mfg 09jan99 Windows CE support
; 707  : WideStringtoAsciiString(szLicensesEncrypted, wszLicensesEncrypted, MAX_STR);
; 708  : #endif		
; 709  : 		RegCloseKey( hKeyLicense );
; 710  : 	}
; 711  : 	
; 712  : 	if (decryptString((const unsigned char *)szLicensesEncrypted,LICENSE_KEY,(unsigned char *)szLicenses))
; 713  : 	{
; 714  : 		return(atol(szLicenses));
; 715  : 	}
; 716  : 	return(LICENSE_KEY_ERROR);
; 717  : #endif //ACCESS32
; 718  : }

  00255	c3		 ret	 0
_GetFromSomeWhere ENDP
_TEXT	ENDS
PUBLIC	_ReleaseLicenseRef
_TEXT	SEGMENT
_ReleaseLicenseRef PROC NEAR

; 933  : #ifndef LICENSES
; 934  : 	return;
; 935  : #else
; 936  : 	BOOL    fIgnore;
; 937  : 	DWORD dwMAXRunTimeLicenses ;
; 938  : 	dwMAXRunTimeLicenses = GetFromSomeWhere();

  00260	e8 00 00 00 00	 call	 _GetFromSomeWhere

; 939  : 	if(dwMAXRunTimeLicenses == LICENSE_KEY_ERROR)

  00265	83 f8 ff	 cmp	 eax, -1
  00268	74 35		 je	 SHORT $L71571

; 940  : 		return;
; 941  : 	if(!dwMAXRunTimeLicenses)  //MVP: For '0'licenses return.   

  0026a	85 c0		 test	 eax, eax
  0026c	74 31		 je	 SHORT $L71571

; 942  : 		return;
; 943  : 	// Decrement Run-time license counter.
; 944  : 	(*(PDWORD)lpvMemLicense)--;

  0026e	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  00273	8b 10		 mov	 edx, DWORD PTR [eax]
  00275	4a		 dec	 edx
  00276	89 10		 mov	 DWORD PTR [eax], edx

; 945  : 	if (*(PDWORD)lpvMemLicense == 0)  /* tek 08jan96 BATS 205 */

  00278	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpvMemLicense
  0027d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00280	75 1d		 jne	 SHORT $L71571

; 946  : 	{
; 947  : 		/* Unmap shared memory from the process's address space. */ 
; 948  : 		fIgnore = UnmapViewOfFile(lpvMemLicense); 

  00282	50		 push	 eax
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 949  : 		/* Close the process's handle to the file-mapping object. */ 
; 950  : 		fIgnore = CloseHandle(hMapObject); 

  00289	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  0028e	50		 push	 eax
  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 951  : 		guiLoadedLicenseShare = FALSE;

  00295	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _guiLoadedLicenseShare, 0
$L71571:

; 952  : 	}
; 953  : #endif // LICENSES ( above GetFromSomeWhere() )
; 954  : }

  0029f	c3		 ret	 0
_ReleaseLicenseRef ENDP
_TEXT	ENDS
PUBLIC	__real@8@4008fa00000000000000
PUBLIC	_TextToSpeechStartupEx
PUBLIC	_PlayAudioCallbackRoutine
PUBLIC	_TextToSpeechReset
EXTRN	__imp__calloc:NEAR
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__InitializeCriticalSection@4:NEAR
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	_create_pipe:NEAR
EXTRN	__imp__RegisterWindowMessageA@4:NEAR
EXTRN	__fltused:NEAR
EXTRN	_PA_CreatePlayHandle:NEAR
EXTRN	_PA_GetFormat:NEAR
EXTRN	_cmd_main@4:NEAR
EXTRN	_lts_main@4:NEAR
EXTRN	_ph_main@4:NEAR
EXTRN	_vtm_main@4:NEAR
EXTRN	_sync_main@4:NEAR
EXTRN	_OP_SetThreadPriority:NEAR
EXTRN	_OP_CreateMutex:NEAR
_DATA	SEGMENT
$SG71705 DB	'DECtalkErrorMessage', 00H
$SG71707 DB	'DECtalkIndexMessage', 00H
$SG71709 DB	'DECtalkBookmarkMessage', 00H
	ORG $+1
$SG71711 DB	'DECtalkWordposMessage', 00H
	ORG $+2
$SG71713 DB	'DECtalkStartMessage', 00H
$SG71715 DB	'DECtalkStopMessage', 00H
	ORG $+1
$SG71717 DB	'DECtalkVisualMessage', 00H
	ORG $+3
$SG71719 DB	'DECtalkBufferMessage', 00H
_DATA	ENDS
;	COMDAT __real@8@4008fa00000000000000
; File D:\work\product\dapi\src\api\ttsapi.c
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_pphTTS$ = 8
_uiDeviceNumber$ = 12
_dwDeviceOptions$ = 16
_DtCallbackRoutine$ = 20
_dwTTSInstanceParameter$ = 24
_pPlayAudio$ = -16
_cmd_pipe$ = 20
_lts_pipe$ = -8
_vtm_pipe$ = 24
_sync_pipe$ = -12
_TextToSpeechStartupEx PROC NEAR

; 1056 : {

  002a0	83 ec 10	 sub	 esp, 16			; 00000010H
  002a3	53		 push	 ebx
  002a4	55		 push	 ebp
  002a5	56		 push	 esi
  002a6	57		 push	 edi

; 1057 : 	MMRESULT mmStatus;
; 1058 : 	UINT i;
; 1059 : #if defined __osf__ || defined __linux__
; 1060 : 	int  productIndex; /* Index into product license list */
; 1061 : #endif
; 1062 : 	
; 1063 : #ifdef OLEDECTALK
; 1064 : 	LPAUDIO_HANDLE_T pPlayAudio;
; 1065 : #else
; 1066 : 	HPLAY_AUDIO_T pPlayAudio;         //New audio Integration
; 1067 : #endif //OLEDECTALK
; 1068 : 	
; 1069 : 	LPWAVEFORMATEX pWaveFormat;	// 01aug97 bats423: now used for both SAPI and DAPI
; 1070 : 	
; 1071 : 	LPTTS_HANDLE_T phTTS;
; 1072 : 	int nReturnCode;           /*MVP : a variable to hold the return value of this API*/
; 1073 : 	
; 1074 : 	P_PIPE cmd_pipe = NULL_PIPE;
; 1075 : 	P_PIPE lts_pipe = NULL_PIPE;
; 1076 : 	P_PIPE ph_pipe  = NULL_PIPE;
; 1077 : 	P_PIPE vtm_pipe = NULL_PIPE;
; 1078 : 	P_PIPE sync_pipe = NULL_PIPE;
; 1079 : 
; 1080 : #ifdef NEW_TRANSPORT
; 1081 : 	P_PIPE new_lts_pipe = NULL_PIPE;
; 1082 : #endif
; 1083 : 
; 1084 : 	/* Define a variable for kernel_share_data to allocate after dynamically :MVP
; 1085 : 	*/
; 1086 : 	PKSD_T pKsd_t = NULL;
; 1087 : 	
; 1088 : #ifdef LICENSES
; 1089 : #ifdef WIN32
; 1090 : #define MAX_INSTANCES_EXCEEDED  (MMSYSERR_ALLOCATED) // tek 29jul96
; 1091 : 	if (!AddLicenseRef())

  002a7	e8 00 00 00 00	 call	 _AddLicenseRef
  002ac	85 c0		 test	 eax, eax
  002ae	75 0d		 jne	 SHORT $L71605
  002b0	5f		 pop	 edi
  002b1	5e		 pop	 esi
  002b2	5d		 pop	 ebp

; 1092 : 	{
; 1093 : 		return MAX_INSTANCES_EXCEEDED;

  002b3	b8 04 00 00 00	 mov	 eax, 4
  002b8	5b		 pop	 ebx

; 2224 : }

  002b9	83 c4 10	 add	 esp, 16			; 00000010H
  002bc	c3		 ret	 0
$L71605:

; 1094 : 	}
; 1095 : #else
; 1096 : 	/* Check for a valid license */
; 1097 : 	mmStatus = CheckLicenses();
; 1098 : 	if (mmStatus)
; 1099 : 	{
; 1100 : 		if (mmStatus == LIC_NO_MORE_UNITS)
; 1101 : 			return (MMSYSERR_ALLOCATED);
; 1102 : 		else
; 1103 : 			if (mmStatus == LIC_NO_PAK)
; 1104 : 				return (MMSYSERR_NOTENABLED);
; 1105 : 			else
; 1106 : 				return (MMSYSERR_ERROR);
; 1107 : 	}
; 1108 : #endif /* WIN32 */
; 1109 : #endif //LICENSES
; 1110 : 	
; 1111 : 	/********************************************************************/
; 1112 : 	/*  Set default parameters.                                         */
; 1113 : 	/********************************************************************/
; 1114 : 	
; 1115 : 	/* 
; 1116 : 	* Allocate kernel_share_data structure to make unique for each instance MVP
; 1117 : 	*/
; 1118 : 	
; 1119 : 	if((pKsd_t = (PKSD_T) calloc(1,sizeof(KSD_T))) == NULL)

  002bd	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__calloc
  002c3	bd 01 00 00 00	 mov	 ebp, 1
  002c8	68 90 04 00 00	 push	 1168			; 00000490H
  002cd	55		 push	 ebp
  002ce	ff d6		 call	 esi
  002d0	8b d8		 mov	 ebx, eax
  002d2	33 ff		 xor	 edi, edi
  002d4	83 c4 08	 add	 esp, 8
  002d7	3b df		 cmp	 ebx, edi

; 1120 : 	{
; 1121 : #ifdef WIN32
; 1122 : #ifdef LICENSES
; 1123 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1124 : #endif //LICENSES
; 1125 : 		return( MMSYSERR_NOMEM );

  002d9	0f 84 38 04 00
	00		 je	 $L73188

; 1126 : #endif /* WIN32 */
; 1127 : 	}
; 1128 : 	
; 1129 : 	/* GL 09/25/1997 initialize the dictionary entry */
; 1130 : 	for (i=0; i < MAX_languages; ++i)

  002df	8d 43 38	 lea	 eax, DWORD PTR [ebx+56]
  002e2	b9 07 00 00 00	 mov	 ecx, 7
$L71610:

; 1131 : 	{
; 1132 : 		pKsd_t->adic[i] = 0;

  002e7	89 78 38	 mov	 DWORD PTR [eax+56], edi

; 1133 : 		pKsd_t->udic[i] = 0;

  002ea	89 38		 mov	 DWORD PTR [eax], edi

; 1134 : 		pKsd_t->fdic[i] = 0;

  002ec	89 78 c8	 mov	 DWORD PTR [eax-56], edi

; 1135 : 		pKsd_t->adic_entries[i] = 0;

  002ef	89 78 54	 mov	 DWORD PTR [eax+84], edi

; 1136 : 		pKsd_t->udic_entries[i] = 0;

  002f2	89 78 1c	 mov	 DWORD PTR [eax+28], edi

; 1137 : 		pKsd_t->fdic_entries[i] = 0;

  002f5	89 78 e4	 mov	 DWORD PTR [eax-28], edi
  002f8	83 c0 04	 add	 eax, 4
  002fb	49		 dec	 ecx
  002fc	75 e9		 jne	 SHORT $L71610

; 1138 : 	}
; 1139 : 	
; 1140 : 	pKsd_t->cmd_flush = FALSE;
; 1141 : 	pKsd_t->spc_flush = FALSE;
; 1142 : 	pKsd_t->halting = FALSE;
; 1143 : 	pKsd_t->logflag  = 0;
; 1144 : 	/* GL 11/15/1996 set defaulted Spanish to Latin */
; 1145 : #ifdef SPANISH_LA
; 1146 : 	pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
; 1147 : #else
; 1148 : 	pKsd_t->modeflag = MODE_CITATION;
; 1149 : #endif //SPANISH_LA
; 1150 : 	pKsd_t->sayflag = SAY_CLAUSE;
; 1151 : 	pKsd_t->pronflag = 0;
; 1152 : 	pKsd_t->wbreak = FALSE;
; 1153 : 	pKsd_t->text_flush = FALSE;
; 1154 : 	pKsd_t->async_change = FALSE;
; 1155 : 	pKsd_t->SamplePeriod = 9.07029478458E-5 ;  /* Initialize sample period */
; 1156 : 	pKsd_t->spc_pkt_save = NULL_SPC_PACKET;
; 1157 : 	pKsd_t->loaded_languages = NULL;           //MVP:05/10/96 Fixed an exception(When DECtalk runs on a machine without audio card)
; 1158 : 	/********************************************************************/
; 1159 : 	/*  Create the TTS handle.                                          */
; 1160 : 	/********************************************************************/
; 1161 : 	
; 1162 : 	phTTS = (LPTTS_HANDLE_T )calloc(1,sizeof(TTS_HANDLE_T));

  002fe	68 f0 00 00 00	 push	 240			; 000000f0H
  00303	c7 83 30 02 00
	00 07 f0 51 c7	 mov	 DWORD PTR [ebx+560], -950931449 ; c751f007H
  0030d	55		 push	 ebp
  0030e	89 bb 6c 01 00
	00		 mov	 DWORD PTR [ebx+364], edi
  00314	89 bb a4 01 00
	00		 mov	 DWORD PTR [ebx+420], edi
  0031a	89 bb 74 01 00
	00		 mov	 DWORD PTR [ebx+372], edi
  00320	89 bb 04 02 00
	00		 mov	 DWORD PTR [ebx+516], edi
  00326	c7 83 00 02 00
	00 00 01 00 00	 mov	 DWORD PTR [ebx+512], 256 ; 00000100H
  00330	89 bb 08 02 00
	00		 mov	 DWORD PTR [ebx+520], edi
  00336	89 bb 0c 02 00
	00		 mov	 DWORD PTR [ebx+524], edi
  0033c	89 bb 14 02 00
	00		 mov	 DWORD PTR [ebx+532], edi
  00342	89 bb 70 01 00
	00		 mov	 DWORD PTR [ebx+368], edi
  00348	89 bb 38 02 00
	00		 mov	 DWORD PTR [ebx+568], edi
  0034e	c7 83 34 02 00
	00 f8 c6 17 3f	 mov	 DWORD PTR [ebx+564], 1058522872 ; 3f17c6f8H
  00358	89 bb 7c 01 00
	00		 mov	 DWORD PTR [ebx+380], edi
  0035e	89 bb 54 04 00
	00		 mov	 DWORD PTR [ebx+1108], edi
  00364	ff d6		 call	 esi
  00366	8b f0		 mov	 esi, eax
  00368	83 c4 08	 add	 esp, 8

; 1163 : 	
; 1164 : 	if ( phTTS == NULL )

  0036b	3b f7		 cmp	 esi, edi
  0036d	75 1c		 jne	 SHORT $L71618

; 1165 : 	{
; 1166 : #ifdef WIN32
; 1167 : #ifdef LICENSES
; 1168 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0036f	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 1169 : #endif //LICENSES
; 1170 : #endif /* WIN32 */
; 1171 : 		free(pKsd_t);			// tek 23sep96 plug memory leak

  00374	53		 push	 ebx
  00375	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0037b	83 c4 04	 add	 esp, 4

; 1896 : #endif //LICENSES
; 1897 : #endif
; 1898 : 			return( MMSYSERR_NOMEM );

  0037e	b8 07 00 00 00	 mov	 eax, 7
  00383	5f		 pop	 edi
  00384	5e		 pop	 esi
  00385	5d		 pop	 ebp
  00386	5b		 pop	 ebx

; 2224 : }

  00387	83 c4 10	 add	 esp, 16			; 00000010H
  0038a	c3		 ret	 0
$L71618:

; 1172 : 		pKsd_t = NULL;
; 1173 : 		return( MMSYSERR_NOMEM );
; 1174 : 	}
; 1175 : 	// tek 20aug98 fill in the back pointer in kernel_share
; 1176 : 	pKsd_t->phTTS = phTTS;
; 1177 : 	
; 1178 : 	phTTS->dwDeviceOptions = dwDeviceOptions;

  0038b	8b 44 24 2c	 mov	 eax, DWORD PTR _dwDeviceOptions$[esp+28]
  0038f	89 b3 88 04 00
	00		 mov	 DWORD PTR [ebx+1160], esi

; 1179 : #ifdef WIN32
; 1180 : 	// tek 13nov97 bats whatever: fix use of instance parameter as window
; 1181 : 	if (dwDeviceOptions&TTSSTARTUP_USING_DEFAULT_CALLBACK)

  00395	8b c8		 mov	 ecx, eax
  00397	89 46 74	 mov	 DWORD PTR [esi+116], eax
  0039a	8b 44 24 34	 mov	 eax, DWORD PTR _dwTTSInstanceParameter$[esp+28]
  0039e	81 e1 00 00 00
	08		 and	 ecx, 134217728		; 08000000H
  003a4	f7 d9		 neg	 ecx
  003a6	1b c9		 sbb	 ecx, ecx

; 1182 : 	{
; 1183 : #endif
; 1184 : 		phTTS->hWnd = (HWND)dwTTSInstanceParameter;  //Backward compatibilty for TextToSpeechStartupEx
; 1185 : #ifdef WIN32
; 1186 : 	}
; 1187 : 	else
; 1188 : 	{
; 1189 : 		phTTS->hWnd = NULL; // the instance param is just that!
; 1190 : 	}
; 1191 : #endif
; 1192 : 	
; 1193 : 	phTTS->uiCurrentMsgNumber = 1;
; 1194 : 	phTTS->uiLastTextMsgNumber = 0;
; 1195 : 	phTTS->uiFlushMsgNumber = 0;
; 1196 : #if defined __osf__ || defined __linux__ 
; 1197 : 	phTTS->uiLastQueuedTextMsgNumber = 0; // tek 01sep98
; 1198 : 	phTTS->uiTextThreadExit = FALSE;
; 1199 : 	phTTS->bInReset = FALSE;
; 1200 : 	phTTS->uiID_Error_Message = TTS_MSG_STATUS;
; 1201 : 	phTTS->uiID_Index_Message = TTS_MSG_INDEX_MARK;
; 1202 : 	phTTS->uiID_Buffer_Message = TTS_MSG_BUFFER;
; 1203 : 	phTTS->uiID_Error_Message = TTS_MSG_STATUS;
; 1204 : 	phTTS->uiID_Index_Message = TTS_MSG_INDEX_MARK;
; 1205 : 	phTTS->uiID_Buffer_Message = TTS_MSG_BUFFER;
; 1206 : 	phTTS->bInReset = FALSE;
; 1207 : #endif
; 1208 : 	phTTS->dwQueuedSampleCount = 0;
; 1209 : 	phTTS->uiQueuedCharacterCount = 0;
; 1210 : 	phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 1211 : 	phTTS->bEnableErrorMessage = TRUE;
; 1212 : 	phTTS->bMemoryReset = FALSE;
; 1213 : 	phTTS->szPhonemeBuffer = NULL; // tek 19aug98 ConvertToPhonemes
; 1214 : 	phTTS->dwPhonemeCvtFlags = 0;	// 20aug98 ConvertToPhonemes
; 1215 : 	/* Initialize new element "pKernelShareData" for MI :MVP */
; 1216 : 	phTTS->pKernelShareData = pKsd_t;
; 1217 : 	/********************************************************************/
; 1218 : 	/*  Initialize all of the handle objects to NULL.                   */
; 1219 : 	/********************************************************************/
; 1220 : 	
; 1221 : 	phTTS->pAudioHandle = NULL;
; 1222 : 	phTTS->hSyncEvent = NULL;
; 1223 : 	phTTS->hNotEmptyingVtmPipeEvent = NULL;
; 1224 : 	phTTS->pcsLogFile = NULL;
; 1225 : 	phTTS->pcsQueuedCharacterCount = NULL;
; 1226 : 	phTTS->pcsFlushMsgNumber = NULL;
; 1227 : 	phTTS->pcsLastQueuedTextMsgNumber = NULL;
; 1228 : 	phTTS->pcsQueuedSampleCount = NULL;
; 1229 : 	phTTS->pcsMemoryBuffer = NULL;
; 1230 : 	phTTS->hThread_TXT = NULL;
; 1231 : 	phTTS->hThread_CMD = NULL;
; 1232 : 	phTTS->hThread_LTS = NULL;
; 1233 : 	phTTS->hThread_PH = NULL;
; 1234 : 	phTTS->hThread_VTM = NULL;
; 1235 : 	phTTS->hThread_SYNC = NULL;	
; 1236 : #if defined __osf__ || defined __linux__
; 1237 : 	phTTS->hTextInQueueEvent = NULL;
; 1238 : 	phTTS->pcsTextMsgList = NULL;
; 1239 : 	phTTS->pcsBufferPipe = NULL;
; 1240 : #endif
; 1241 : 
; 1242 : 	/*************************************************************************/
; 1243 : 	/*  Initialize all of the Thread specific data structure pointers to NULL*/
; 1244 : 	/*  Murthy Parakala : for multiple instances                             */
; 1245 : 	/*************************************************************************/
; 1246 : 	phTTS->pCMDThreadData = NULL;            /*CMD Thread */
; 1247 : 	phTTS->pLTSThreadData = NULL;            /*LTS Thread */ 
; 1248 : 	phTTS->pVTMThreadData = NULL;            /*VTM Thread */
; 1249 : 	phTTS->pPHThreadData = NULL;             /*PH  Thread */
; 1250 : 	phTTS->hMallocSuccessEvent = NULL;   /* Event handle for successful memory allocations*/
; 1251 : #ifdef TYPING_MODE	//09jun97 tek
; 1252 : 	phTTS->wTypingFrameCount=0;
; 1253 : #endif //TYPING_MODE  
; 1254 : 	/*****************************************************************/
; 1255 : 	/*  Initialize Instance specific CallbackFunction,Instance parameter
; 1256 : 	/*  MVP : 05/08/96
; 1257 : 	/*****************************************************************/
; 1258 : 	phTTS->DtCallbackRoutine = DtCallbackRoutine;

  003a8	8b 54 24 30	 mov	 edx, DWORD PTR _DtCallbackRoutine$[esp+28]
  003ac	23 c8		 and	 ecx, eax

; 1259 : 	phTTS->dwTTSInstanceParameter = dwTTSInstanceParameter;
; 1260 : #ifdef WIN32
; 1261 : 	phTTS->hmxCallback = NULL;
; 1262 : #endif /* WIN32 */
; 1263 : #if defined __osf__ || defined __linux__
; 1264 : 	phTTS->pcsCallback = NULL;
; 1265 : #endif /* osf || __linux__ */
; 1266 : 	/********************************************************************/
; 1267 : 	/*  Create the queued sample count critical section.                */
; 1268 : 	/********************************************************************/
; 1269 : #ifdef WIN32
; 1270 : 	phTTS->pcsQueuedSampleCount =
; 1271 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  003ae	6a 18		 push	 24			; 00000018H
  003b0	89 0e		 mov	 DWORD PTR [esi], ecx
  003b2	89 6e 44	 mov	 DWORD PTR [esi+68], ebp
  003b5	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  003b8	89 7e 50	 mov	 DWORD PTR [esi+80], edi
  003bb	89 7e 7c	 mov	 DWORD PTR [esi+124], edi
  003be	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  003c1	c7 86 84 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+132], 4
  003cb	89 ae 88 00 00
	00		 mov	 DWORD PTR [esi+136], ebp
  003d1	89 be 8c 00 00
	00		 mov	 DWORD PTR [esi+140], edi
  003d7	89 be e0 00 00
	00		 mov	 DWORD PTR [esi+224], edi
  003dd	89 be ec 00 00
	00		 mov	 DWORD PTR [esi+236], edi
  003e3	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  003e6	89 be d0 00 00
	00		 mov	 DWORD PTR [esi+208], edi
  003ec	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  003ef	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
  003f2	89 be c4 00 00
	00		 mov	 DWORD PTR [esi+196], edi
  003f8	89 be c0 00 00
	00		 mov	 DWORD PTR [esi+192], edi
  003fe	89 be bc 00 00
	00		 mov	 DWORD PTR [esi+188], edi
  00404	89 be b8 00 00
	00		 mov	 DWORD PTR [esi+184], edi
  0040a	89 be b4 00 00
	00		 mov	 DWORD PTR [esi+180], edi
  00410	89 be b0 00 00
	00		 mov	 DWORD PTR [esi+176], edi
  00416	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  00419	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0041c	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  0041f	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  00422	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00425	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  00428	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0042b	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0042e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00431	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  00434	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00437	66 89 be d8 00
	00 00		 mov	 WORD PTR [esi+216], di
  0043e	89 96 a4 00 00
	00		 mov	 DWORD PTR [esi+164], edx
  00444	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax
  0044a	89 be ac 00 00
	00		 mov	 DWORD PTR [esi+172], edi
  00450	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00456	83 c4 04	 add	 esp, 4

; 1272 : #endif /* WIN32 */
; 1273 : #if defined __osf__ || defined __linux__
; 1274 : 	phTTS->pcsQueuedSampleCount = OP_CreateMutex();
; 1275 : #endif /* osf */
; 1276 : 	if ( phTTS->pcsQueuedSampleCount == NULL )

  00459	3b c7		 cmp	 eax, edi
  0045b	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax

; 1277 : 	{
; 1278 : 		DeleteTextToSpeechObjects( phTTS );
; 1279 : #ifdef WIN32
; 1280 : #ifdef LICENSES
; 1281 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1282 : #endif //LICENSES
; 1283 : #endif /* WIN32 */
; 1284 : 		return( MMSYSERR_NOMEM );

  00461	0f 84 a7 02 00
	00		 je	 $L73186

; 1285 : 	}
; 1286 : 	
; 1287 : #ifdef WIN32
; 1288 : #ifdef DTALK50
; 1289 : 	phTTS->CPanelThread = CPInitAPI();
; 1290 : #endif //DTALK50
; 1291 : 	
; 1292 : 	InitializeCriticalSection( phTTS->pcsQueuedSampleCount );

  00467	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__InitializeCriticalSection@4
  0046d	50		 push	 eax
  0046e	ff d5		 call	 ebp

; 1293 : #endif /* WIN32 */
; 1294 : 
; 1295 : #if defined __osf__ || defined __linux__
; 1296 : 	/********************************************************************/
; 1297 : 	/*  Create the 'Buffer Pipe' mutex.                                 */
; 1298 : 	/********************************************************************/
; 1299 : 	
; 1300 : 	phTTS->pcsBufferPipe = OP_CreateMutex();
; 1301 : 	
; 1302 : 	if ( phTTS->pcsBufferPipe == NULL )
; 1303 : 	{
; 1304 : 		DeleteTextToSpeechObjects( phTTS );
; 1305 : 		return( MMSYSERR_NOMEM );
; 1306 : 	}
; 1307 : 	
; 1308 : 	/********************************************************************/
; 1309 : 	/*  Create the 'Text List' mutex.                                   */
; 1310 : 	/********************************************************************/
; 1311 : 	
; 1312 : 	phTTS->pcsTextMsgList = OP_CreateMutex();
; 1313 : 	
; 1314 : 	if ( phTTS->pcsTextMsgList == NULL )
; 1315 : 	{
; 1316 : 		DeleteTextToSpeechObjects( phTTS );
; 1317 : 		return( MMSYSERR_NOMEM );
; 1318 : 	}
; 1319 : #endif /* __osf__ || __linux__ */
; 1320 : 	
; 1321 : 	/********************************************************************/
; 1322 : 	/*  Create the last queued text message number critical section.    */
; 1323 : 	/********************************************************************/
; 1324 : #ifdef WIN32
; 1325 : 	phTTS->pcsLastQueuedTextMsgNumber =
; 1326 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  00470	6a 18		 push	 24			; 00000018H
  00472	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00478	83 c4 04	 add	 esp, 4

; 1327 : #endif
; 1328 : #if defined __osf__ || defined __linux__
; 1329 : 	phTTS->pcsLastQueuedTextMsgNumber = OP_CreateMutex();
; 1330 : #endif /* __osf__ */
; 1331 : 	
; 1332 : 	if ( phTTS->pcsLastQueuedTextMsgNumber == NULL )

  0047b	3b c7		 cmp	 eax, edi
  0047d	89 86 b8 00 00
	00		 mov	 DWORD PTR [esi+184], eax

; 1333 : 	{
; 1334 : 		DeleteTextToSpeechObjects( phTTS );
; 1335 : #ifdef WIN32
; 1336 : #ifdef LICENSES
; 1337 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1338 : #endif //LICENSES
; 1339 : #endif /* WIN32 */
; 1340 : 		return( MMSYSERR_NOMEM );

  00483	0f 84 85 02 00
	00		 je	 $L73186

; 1341 : 	}
; 1342 : 	
; 1343 : #ifdef WIN32
; 1344 : 	InitializeCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  00489	50		 push	 eax
  0048a	ff d5		 call	 ebp

; 1345 : #endif /* WIN32 */
; 1346 : 	
; 1347 : 	/********************************************************************/
; 1348 : 	/*  Create the flush message number critical section.               */
; 1349 : 	/********************************************************************/
; 1350 : 	
; 1351 : #ifdef WIN32
; 1352 : 	phTTS->pcsFlushMsgNumber =
; 1353 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  0048c	6a 18		 push	 24			; 00000018H
  0048e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00494	83 c4 04	 add	 esp, 4

; 1354 : #endif /* WIN32 */
; 1355 : #if defined __osf__ || defined __linux__
; 1356 : 	phTTS->pcsFlushMsgNumber = OP_CreateMutex();
; 1357 : #endif /* __osf__ */
; 1358 : 	
; 1359 : 	
; 1360 : 	if ( phTTS->pcsFlushMsgNumber == NULL )

  00497	3b c7		 cmp	 eax, edi
  00499	89 86 bc 00 00
	00		 mov	 DWORD PTR [esi+188], eax

; 1361 : 	{
; 1362 : 		DeleteTextToSpeechObjects( phTTS );
; 1363 : #ifdef WIN32
; 1364 : #ifdef LICENSES
; 1365 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1366 : #endif //LICENSES
; 1367 : #endif /* WIN32 */
; 1368 : 		return( MMSYSERR_NOMEM );

  0049f	0f 84 69 02 00
	00		 je	 $L73186

; 1369 : 	}
; 1370 : 	
; 1371 : #ifdef WIN32
; 1372 : 	InitializeCriticalSection( phTTS->pcsFlushMsgNumber );

  004a5	50		 push	 eax
  004a6	ff d5		 call	 ebp

; 1373 : #endif /* WIN32 */
; 1374 : 	/********************************************************************/
; 1375 : 	/*  Create the queued character count critical section.             */
; 1376 : 	/********************************************************************/
; 1377 : 	
; 1378 : #ifdef WIN32
; 1379 : 	phTTS->pcsQueuedCharacterCount =
; 1380 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  004a8	6a 18		 push	 24			; 00000018H
  004aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  004b0	83 c4 04	 add	 esp, 4

; 1381 : #endif /* WIN32 */
; 1382 : #if defined __osf__ || defined __linux__
; 1383 : 	phTTS->pcsQueuedCharacterCount = OP_CreateMutex();
; 1384 : #endif /* __osf__ || __linux__*/
; 1385 : 	
; 1386 : 	if ( phTTS->pcsQueuedCharacterCount == NULL )

  004b3	3b c7		 cmp	 eax, edi
  004b5	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax

; 1387 : 	{
; 1388 : 		DeleteTextToSpeechObjects( phTTS );
; 1389 : #ifdef WIN32
; 1390 : #ifdef LICENSES
; 1391 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1392 : #endif //LICENSES
; 1393 : #endif /* WIN32 */
; 1394 : 		return( MMSYSERR_NOMEM );

  004bb	0f 84 4d 02 00
	00		 je	 $L73186

; 1395 : 	}
; 1396 : 	
; 1397 : #ifdef WIN32
; 1398 : 	InitializeCriticalSection( phTTS->pcsQueuedCharacterCount );

  004c1	50		 push	 eax
  004c2	ff d5		 call	 ebp

; 1399 : #endif /* WIN32 */
; 1400 : 	
; 1401 : #ifdef WIN32
; 1402 : 	/* tek 6mar97 bats 278 */
; 1403 : 	/********************************************************************/
; 1404 : 	/*  Create the index list critical section.                         */
; 1405 : 	/********************************************************************/
; 1406 : 	
; 1407 : 	pKsd_t->pcsSpcPktSave =
; 1408 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  004c4	6a 18		 push	 24			; 00000018H
  004c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  004cc	83 c4 04	 add	 esp, 4

; 1409 : 	
; 1410 : 	if ( pKsd_t->pcsSpcPktSave == NULL )

  004cf	3b c7		 cmp	 eax, edi
  004d1	89 83 80 01 00
	00		 mov	 DWORD PTR [ebx+384], eax
  004d7	75 1b		 jne	 SHORT $L71665

; 1411 : 	{
; 1412 : 		ReleaseLicenseRef(); // tek 23sep96

  004d9	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 1413 : 		DeleteTextToSpeechObjects( phTTS );

  004de	56		 push	 esi
  004df	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  004e4	83 c4 04	 add	 esp, 4

; 1896 : #endif //LICENSES
; 1897 : #endif
; 1898 : 			return( MMSYSERR_NOMEM );

  004e7	b8 07 00 00 00	 mov	 eax, 7
  004ec	5f		 pop	 edi
  004ed	5e		 pop	 esi
  004ee	5d		 pop	 ebp
  004ef	5b		 pop	 ebx

; 2224 : }

  004f0	83 c4 10	 add	 esp, 16			; 00000010H
  004f3	c3		 ret	 0
$L71665:

; 1414 : 		return( MMSYSERR_NOMEM );
; 1415 : 	}
; 1416 : 	
; 1417 : 	InitializeCriticalSection( pKsd_t->pcsSpcPktSave );

  004f4	50		 push	 eax
  004f5	ff d5		 call	 ebp

; 1418 : 	
; 1419 : 	/* end 6mar97 bats 278 */
; 1420 : 	
; 1421 : 	/********************************************************************/
; 1422 : 	/*  Create the vtm pipe read critical section.                      */
; 1423 : 	/********************************************************************/
; 1424 : 	// tek 09jun97 needed to allow fast flushing of the  VTM
; 1425 : 	pKsd_t->pcsVtmPipeRead =
; 1426 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  004f7	6a 18		 push	 24			; 00000018H
  004f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  004ff	83 c4 04	 add	 esp, 4

; 1427 : 	
; 1428 : 	if ( pKsd_t->pcsVtmPipeRead == NULL )

  00502	3b c7		 cmp	 eax, edi
  00504	89 83 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], eax
  0050a	75 1b		 jne	 SHORT $L71669

; 1429 : 	{
; 1430 : 		ReleaseLicenseRef(); // tek 23sep96

  0050c	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 1431 : 		DeleteTextToSpeechObjects( phTTS );

  00511	56		 push	 esi
  00512	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  00517	83 c4 04	 add	 esp, 4

; 1896 : #endif //LICENSES
; 1897 : #endif
; 1898 : 			return( MMSYSERR_NOMEM );

  0051a	b8 07 00 00 00	 mov	 eax, 7
  0051f	5f		 pop	 edi
  00520	5e		 pop	 esi
  00521	5d		 pop	 ebp
  00522	5b		 pop	 ebx

; 2224 : }

  00523	83 c4 10	 add	 esp, 16			; 00000010H
  00526	c3		 ret	 0
$L71669:

; 1432 : 		return( MMSYSERR_NOMEM );
; 1433 : 	}
; 1434 : 	
; 1435 : 	InitializeCriticalSection( pKsd_t->pcsVtmPipeRead );

  00527	50		 push	 eax
  00528	ff d5		 call	 ebp

; 1436 : #endif /* WIN32 */
; 1437 : 	
; 1438 : 	/********************************************************************/
; 1439 : 	/*  Create the log file critical section.                           */
; 1440 : 	/********************************************************************/
; 1441 : #ifdef WIN32
; 1442 : 	phTTS->pcsLogFile =
; 1443 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  0052a	6a 18		 push	 24			; 00000018H
  0052c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00532	83 c4 04	 add	 esp, 4

; 1444 : #endif /* WIN32 */
; 1445 : #if defined __osf__ || defined __linux__
; 1446 : 	phTTS->pcsLogFile = OP_CreateMutex();
; 1447 : #endif /* __osf__ */
; 1448 : 	
; 1449 : 	if ( phTTS->pcsLogFile == NULL )

  00535	3b c7		 cmp	 eax, edi
  00537	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax

; 1450 : 	{
; 1451 : 		DeleteTextToSpeechObjects( phTTS );
; 1452 : #ifdef WIN32
; 1453 : #ifdef LICENSES
; 1454 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1455 : #endif //LICENSES
; 1456 : #endif /* WIN32 */
; 1457 : 		return( MMSYSERR_NOMEM );

  0053d	0f 84 cb 01 00
	00		 je	 $L73186

; 1458 : 	}
; 1459 : 	
; 1460 : #ifdef WIN32
; 1461 : 	InitializeCriticalSection( phTTS->pcsLogFile );

  00543	50		 push	 eax
  00544	ff d5		 call	 ebp

; 1462 : #endif
; 1463 : 	/********************************************************************/
; 1464 : 	/*  Create a "Sync" event. The initial state is not signaled.       */
; 1465 : 	/********************************************************************/
; 1466 : 
; 1467 : 	phTTS->hSyncEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

  00546	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__CreateEventA@16
  0054c	57		 push	 edi
  0054d	57		 push	 edi
  0054e	6a 01		 push	 1
  00550	57		 push	 edi
  00551	ff d5		 call	 ebp

; 1468 : 	
; 1469 : 	if ( phTTS->hSyncEvent == NULL )

  00553	3b c7		 cmp	 eax, edi
  00555	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1470 : 	{
; 1471 : 		DeleteTextToSpeechObjects( phTTS );
; 1472 : #ifdef WIN32
; 1473 : #ifdef LICENSES
; 1474 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1475 : #endif //LICENSES
; 1476 : #endif /* WIN32 */
; 1477 : 		return( MMSYSERR_NOMEM );

  00558	0f 84 b0 01 00
	00		 je	 $L73186

; 1478 : 	}
; 1479 : 	
; 1480 : #if defined __osf__ || defined __linux__
; 1481 : 	
; 1482 : 	/********************************************************************/
; 1483 : 	/*  Create a "Text in Queue" event. The initial state is not signaled.*/
; 1484 : 	/********************************************************************/
; 1485 : 	
; 1486 : 	phTTS->hTextInQueueEvent = OP_CreateEvent( TRUE, FALSE );
; 1487 : 	
; 1488 : 	if ( phTTS->hTextInQueueEvent == NULL )
; 1489 : 	{
; 1490 : 		DeleteTextToSpeechObjects( phTTS );
; 1491 : 		return( MMSYSERR_NOMEM );
; 1492 : 	}
; 1493 : #endif /* __osf__ */
; 1494 : 	
; 1495 : 	/********************************************************************/
; 1496 : 	/*  Create a "Not Emptying Vtm Pipe" event. The initial state is    */
; 1497 : 	/*  signaled.                                                       */
; 1498 : 	/********************************************************************/
; 1499 : 	
; 1500 : 	phTTS->hNotEmptyingVtmPipeEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

  0055e	57		 push	 edi
  0055f	6a 01		 push	 1
  00561	6a 01		 push	 1
  00563	57		 push	 edi
  00564	ff d5		 call	 ebp

; 1501 : 
; 1502 : 	if ( phTTS->hNotEmptyingVtmPipeEvent == NULL )

  00566	3b c7		 cmp	 eax, edi
  00568	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 1503 : 	{
; 1504 : 		DeleteTextToSpeechObjects( phTTS );
; 1505 : #ifdef WIN32
; 1506 : #ifdef LICENSES
; 1507 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1508 : #endif //LICENSES
; 1509 : #endif /* WIN32 */
; 1510 : 		return( MMSYSERR_NOMEM );

  0056b	0f 84 9d 01 00
	00		 je	 $L73186

; 1511 : 	}
; 1512 : 	
; 1513 : 	/*******************************************************************/
; 1514 : 	/*  Create the TTS callback mutex.                                 */
; 1515 : 	/*******************************************************************/
; 1516 : 	
; 1517 : 	if ( DtCallbackRoutine != NULL )

  00571	39 7c 24 30	 cmp	 DWORD PTR _DtCallbackRoutine$[esp+28], edi
  00575	74 13		 je	 SHORT $L71685

; 1518 : 	{
; 1519 : #ifdef WIN32
; 1520 : 		phTTS->hmxCallback = OP_CreateMutex();

  00577	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1521 : 		if ( phTTS->hmxCallback == NULL )

  0057c	3b c7		 cmp	 eax, edi
  0057e	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax

; 1522 : #endif
; 1523 : #if defined __osf__ || defined __linux__
; 1524 : 			phTTS->pcsCallback = OP_CreateMutex();
; 1525 : 		if ( phTTS->pcsCallback == NULL )
; 1526 : #endif
; 1527 : 		{
; 1528 : 			DeleteTextToSpeechObjects( phTTS );
; 1529 : #ifdef WIN32
; 1530 : #ifdef LICENSES
; 1531 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1532 : #endif //LICENSES
; 1533 : #endif //WIN32
; 1534 : 			return MMSYSERR_NOMEM;

  00584	0f 84 84 01 00
	00		 je	 $L73186
$L71685:

; 1535 : 		}
; 1536 : 	}
; 1537 : 	
; 1538 : 	
; 1539 : 	/********************************************************************************/
; 1540 : 	/*  MVP :Create a "Successful Memory Allocation " event.                        */
; 1541 : 	/*  The event configuration is non-inheritable,AUTO RESET,not signaled, Unnamed */
; 1542 : 	/********************************************************************************/
; 1543 : 
; 1544 : 	phTTS->hMallocSuccessEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

  0058a	57		 push	 edi
  0058b	57		 push	 edi
  0058c	57		 push	 edi
  0058d	57		 push	 edi
  0058e	ff d5		 call	 ebp

; 1545 : 	
; 1546 : 	if ( phTTS->hMallocSuccessEvent == NULL )

  00590	3b c7		 cmp	 eax, edi
  00592	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 1547 : 	{
; 1548 : 		DeleteTextToSpeechObjects( phTTS );
; 1549 : #ifdef WIN32
; 1550 : #ifdef LICENSES
; 1551 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1552 : #endif //LICENSES
; 1553 : #endif
; 1554 : 		return( MMSYSERR_NOMEM );

  00595	0f 84 73 01 00
	00		 je	 $L73186

; 1555 : 	}
; 1556 : 	
; 1557 : 	/********************************************************************/
; 1558 : 	/*  Initialize the inter-thread communication pipes.                */
; 1559 : 	/********************************************************************/
; 1560 : 	
; 1561 : 	cmd_pipe = create_pipe( BYTE_PIPE, CMD_PIPE_LENGTH );

  0059b	6a 40		 push	 64			; 00000040H
  0059d	57		 push	 edi
  0059e	e8 00 00 00 00	 call	 _create_pipe
  005a3	83 c4 08	 add	 esp, 8

; 1562 : 	
; 1563 : 	if ( cmd_pipe == NULL )

  005a6	3b c7		 cmp	 eax, edi
  005a8	89 44 24 30	 mov	 DWORD PTR _cmd_pipe$[esp+28], eax

; 1564 : 	{
; 1565 : 		DeleteTextToSpeechObjects( phTTS );
; 1566 : #ifdef WIN32
; 1567 : #ifdef LICENSES
; 1568 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1569 : #endif //LICENSES
; 1570 : #endif
; 1571 : 		return( MMSYSERR_NOMEM );

  005ac	0f 84 5c 01 00
	00		 je	 $L73186

; 1572 : 	}
; 1573 : 	
; 1574 : 	lts_pipe = create_pipe( WORD_PIPE, LTS_PIPE_LENGTH );

  005b2	68 80 00 00 00	 push	 128			; 00000080H
  005b7	6a 01		 push	 1
  005b9	e8 00 00 00 00	 call	 _create_pipe
  005be	83 c4 08	 add	 esp, 8

; 1575 : 	
; 1576 : 	if ( lts_pipe == NULL )

  005c1	3b c7		 cmp	 eax, edi
  005c3	89 44 24 18	 mov	 DWORD PTR _lts_pipe$[esp+32], eax

; 1577 : 	{
; 1578 : 		DeleteTextToSpeechObjects( phTTS );
; 1579 : #ifdef WIN32
; 1580 : #ifdef LICENSES
; 1581 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1582 : #endif //LICENSES
; 1583 : #endif
; 1584 : 		return( MMSYSERR_NOMEM );

  005c7	0f 84 41 01 00
	00		 je	 $L73186

; 1585 : 	}
; 1586 : 	
; 1587 : #ifdef NEW_TRANSPORT
; 1588 : 	new_lts_pipe = create_pipe( DWORD_PIPE, LTS_PIPE_LENGTH );
; 1589 : 	
; 1590 : 	if ( new_lts_pipe == NULL )
; 1591 : 	{
; 1592 : 		DeleteTextToSpeechObjects( phTTS );
; 1593 : #ifdef WIN32
; 1594 : #ifdef LICENSES
; 1595 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1596 : #endif //LICENSES
; 1597 : #endif
; 1598 : 		return( MMSYSERR_NOMEM );
; 1599 : 	}
; 1600 : #endif
; 1601 : 
; 1602 : 
; 1603 : 	ph_pipe = create_pipe( WORD_PIPE, PH_PIPE_LENGTH );

  005cd	68 00 01 00 00	 push	 256			; 00000100H
  005d2	6a 01		 push	 1
  005d4	e8 00 00 00 00	 call	 _create_pipe
  005d9	8b e8		 mov	 ebp, eax
  005db	83 c4 08	 add	 esp, 8

; 1604 : 	
; 1605 : 	if ( ph_pipe == NULL )

  005de	3b ef		 cmp	 ebp, edi

; 1606 : 	{
; 1607 : 		DeleteTextToSpeechObjects( phTTS );
; 1608 : #ifdef WIN32
; 1609 : #ifdef LICENSES
; 1610 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1611 : #endif //LICENSES
; 1612 : #endif
; 1613 : 		return( MMSYSERR_NOMEM );

  005e0	0f 84 28 01 00
	00		 je	 $L73186

; 1614 : 	}
; 1615 : 	
; 1616 : 	vtm_pipe = create_pipe( WORD_PIPE, VTM_PIPE_LENGTH );

  005e6	68 00 40 00 00	 push	 16384			; 00004000H
  005eb	6a 01		 push	 1
  005ed	e8 00 00 00 00	 call	 _create_pipe
  005f2	83 c4 08	 add	 esp, 8

; 1617 : 	
; 1618 : 	if ( vtm_pipe == NULL )

  005f5	3b c7		 cmp	 eax, edi
  005f7	89 44 24 34	 mov	 DWORD PTR _vtm_pipe$[esp+28], eax

; 1619 : 	{
; 1620 : 		DeleteTextToSpeechObjects( phTTS );
; 1621 : #ifdef WIN32
; 1622 : #ifdef LICENSES
; 1623 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1624 : #endif //LICENSES
; 1625 : #endif
; 1626 : 		return( MMSYSERR_NOMEM );

  005fb	0f 84 0d 01 00
	00		 je	 $L73186

; 1627 : 	}
; 1628 : 	
; 1629 : 	sync_pipe = create_pipe( DWORD_PIPE, SYNC_PIPE_LENGTH );

  00601	68 00 08 00 00	 push	 2048			; 00000800H
  00606	6a 02		 push	 2
  00608	e8 00 00 00 00	 call	 _create_pipe
  0060d	83 c4 08	 add	 esp, 8

; 1630 : 	
; 1631 : 	if ( sync_pipe == NULL )

  00610	3b c7		 cmp	 eax, edi
  00612	89 44 24 14	 mov	 DWORD PTR _sync_pipe$[esp+32], eax

; 1632 : 	{
; 1633 : 		DeleteTextToSpeechObjects( phTTS );
; 1634 : #ifdef WIN32
; 1635 : #ifdef LICENSES
; 1636 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1637 : #endif //LICENSES
; 1638 : #endif
; 1639 : 		return( MMSYSERR_NOMEM );

  00616	0f 84 f2 00 00
	00		 je	 $L73186

; 1640 : 	}
; 1641 : 	
; 1642 : 	/********************************************************************/
; 1643 : 	/*  Set default pipe parameters.                                    */
; 1644 : 	/********************************************************************/
; 1645 : 	/* Comment out the below line for MI : MVP */
; 1646 : 	/*
; 1647 : 	kernel_share = &kernel_data;
; 1648 : 	*/
; 1649 : 	
; 1650 : 	for ( i = 0; i < MAX_languages; i++ )

  0061c	8d 93 34 01 00
	00		 lea	 edx, DWORD PTR [ebx+308]
  00622	b8 07 00 00 00	 mov	 eax, 7
  00627	8b ca		 mov	 ecx, edx
$L71700:

; 1651 : 	{
; 1652 : 		pKsd_t->lang_lts[i] = NULL_PIPE;

  00629	89 79 e4	 mov	 DWORD PTR [ecx-28], edi

; 1653 : 		pKsd_t->lang_ph[i]  = NULL_PIPE;

  0062c	89 39		 mov	 DWORD PTR [ecx], edi

; 1654 : 		pKsd_t->lang_ready[i] = 0;

  0062e	89 79 c8	 mov	 DWORD PTR [ecx-56], edi
  00631	83 c1 04	 add	 ecx, 4
  00634	48		 dec	 eax
  00635	75 f2		 jne	 SHORT $L71700

; 1655 : 	}
; 1656 : 	
; 1657 : 	/* GL 04/21/1997 add code to support the local language pipe */
; 1658 : 	pKsd_t->lang_lts[0] = lts_pipe;
; 1659 : 	pKsd_t->lang_ph[0] = ph_pipe;
; 1660 : 	
; 1661 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[0];
; 1662 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[0];
; 1663 : 	
; 1664 : 	pKsd_t->cmd_pipe = cmd_pipe;

  00637	8b 44 24 30	 mov	 eax, DWORD PTR _cmd_pipe$[esp+28]

; 1665 : 	pKsd_t->vtm_pipe = vtm_pipe;

  0063b	8b 4c 24 34	 mov	 ecx, DWORD PTR _vtm_pipe$[esp+28]
  0063f	89 83 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], eax

; 1666 : 	pKsd_t->sync_pipe = sync_pipe;

  00645	8b 44 24 14	 mov	 eax, DWORD PTR _sync_pipe$[esp+32]
  00649	89 83 e0 00 00
	00		 mov	 DWORD PTR [ebx+224], eax

; 1667 : 	
; 1668 : 	/*
; 1669 : 	GL 12/11/1996, set up the language flag pKsd_t->lang_curr
; 1670 : 	this flag will be used in CMD and phlog.c to pick up the language
; 1671 : 	depended code
; 1672 : 	*/
; 1673 : #ifdef ENGLISH_US
; 1674 : 	pKsd_t->lang_lts[LANG_english] = lts_pipe;

  0064f	8b 44 24 18	 mov	 eax, DWORD PTR _lts_pipe$[esp+32]
  00653	89 8b dc 00 00
	00		 mov	 DWORD PTR [ebx+220], ecx
  00659	89 83 18 01 00
	00		 mov	 DWORD PTR [ebx+280], eax

; 1675 : 	pKsd_t->lang_ph[LANG_english] = ph_pipe;
; 1676 : 	
; 1677 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_english];

  0065f	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax

; 1678 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_english];

  00665	89 ab d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ebp

; 1679 : 	pKsd_t->lang_curr = LANG_english;

  0066b	89 bb f8 00 00
	00		 mov	 DWORD PTR [ebx+248], edi

; 1680 : #endif //ENGLISH_US
; 1681 : #ifdef ENGLISH_UK
; 1682 : 	pKsd_t->lang_lts[LANG_british] = lts_pipe;
; 1683 : 	pKsd_t->lang_ph[LANG_british] = ph_pipe;
; 1684 : 	
; 1685 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_british];
; 1686 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_british];
; 1687 : 	pKsd_t->lang_curr = LANG_british;
; 1688 : #endif //ENGLISH_UK
; 1689 : 
; 1690 : #ifdef SPANISH_SP
; 1691 :   pKsd_t->lang_lts[LANG_spanish] = lts_pipe;
; 1692 :   pKsd_t->lang_ph[LANG_spanish] = ph_pipe;
; 1693 : 
; 1694 :   pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_spanish];
; 1695 :   pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_spanish];
; 1696 : 
; 1697 :   pKsd_t->lang_curr = LANG_spanish;
; 1698 : #endif //SPANISH_SP
; 1699 : #ifdef SPANISH_LA
; 1700 :   pKsd_t->lang_lts[LANG_latin_american] = lts_pipe;
; 1701 :   pKsd_t->lang_ph[LANG_latin_american] = ph_pipe;
; 1702 : 
; 1703 :   pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_latin_american];
; 1704 :   pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_latin_american];
; 1705 : 
; 1706 :   pKsd_t->lang_curr = LANG_latin_american;
; 1707 : #endif //SPANISH_LA
; 1708 : 
; 1709 : #ifdef GERMAN
; 1710 : 	pKsd_t->lang_lts[LANG_german] = lts_pipe;
; 1711 : 	pKsd_t->lang_ph[LANG_german] = ph_pipe;
; 1712 : 	
; 1713 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_german];
; 1714 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_german];
; 1715 : 	pKsd_t->lang_curr = LANG_german;
; 1716 : #endif //GERMAN
; 1717 : #ifdef FRENCH
; 1718 : 	pKsd_t->lang_lts[LANG_french] = lts_pipe;
; 1719 : 	pKsd_t->lang_ph[LANG_french] = ph_pipe;
; 1720 : 	
; 1721 : 	pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_french];
; 1722 : 	pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_french];
; 1723 : 	pKsd_t->lang_curr = LANG_french;
; 1724 : #endif //FRENCH
; 1725 : 
; 1726 : #ifdef NEW_TRANSPORT
; 1727 : 	pKsd_t->new_lts_pipe=new_lts_pipe;
; 1728 : #endif
; 1729 : 
; 1730 : #ifdef WIN32
; 1731 : 	/********************************************************************/
; 1732 : 	/*  Get the DECtalk error message.                                  */
; 1733 : 	/********************************************************************/
; 1734 : 	
; 1735 :   phTTS->uiID_Error_Message =
; 1736 : #if UNDER_CE //mfgce
; 1737 : 	  RegisterWindowMessage(TEXT("DECtalkErrorMessage"));
; 1738 : #else
; 1739 : 	  RegisterWindowMessage("DECtalkErrorMessage");

  00671	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__RegisterWindowMessageA@4
  00677	68 00 00 00 00	 push	 OFFSET FLAT:$SG71705
  0067c	89 2a		 mov	 DWORD PTR [edx], ebp
  0067e	ff d3		 call	 ebx

; 1740 : #endif
; 1741 : 	
; 1742 : 	if ( phTTS->uiID_Error_Message == 0 )

  00680	3b c7		 cmp	 eax, edi
  00682	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 1743 : 	{
; 1744 : 		DeleteTextToSpeechObjects( phTTS );
; 1745 : #ifdef LICENSES
; 1746 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1747 : #endif //LICENSES
; 1748 : 		return( MMSYSERR_NOMEM );

  00685	0f 84 83 00 00
	00		 je	 $L73186

; 1749 : 	}
; 1750 : 	
; 1751 : 	/********************************************************************/
; 1752 : 	/*  Get the DECtalk index mark message.                             */
; 1753 : 	/********************************************************************/
; 1754 : 	
; 1755 :   phTTS->uiID_Index_Message =
; 1756 : #if UNDER_CE //mfgce
; 1757 : 	RegisterWindowMessage(TEXT("DECtalkIndexMessage"));
; 1758 : #else
; 1759 :     RegisterWindowMessage("DECtalkIndexMessage");

  0068b	68 00 00 00 00	 push	 OFFSET FLAT:$SG71707
  00690	ff d3		 call	 ebx

; 1760 : #endif
; 1761 : 	
; 1762 : 	if ( phTTS->uiID_Index_Message == 0 )

  00692	3b c7		 cmp	 eax, edi
  00694	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 1763 : 	{
; 1764 : 		DeleteTextToSpeechObjects( phTTS );
; 1765 : #ifdef LICENSES
; 1766 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1767 : #endif //LICENSES
; 1768 : 		return( MMSYSERR_NOMEM );

  00697	74 75		 je	 SHORT $L73186

; 1769 : 	}
; 1770 : 	
; 1771 : 	// tek 01aug97 bats 404 register messages for 
; 1772 : 	// bookmark, wordpos, start, stop.
; 1773 : 	
; 1774 : phTTS->uiID_Bookmark_Message =
; 1775 : #if UNDER_CE //mfgce
; 1776 : 	RegisterWindowMessage(TEXT("DECtalkBookmarkMessage"));
; 1777 : #else
; 1778 :     RegisterWindowMessage("DECtalkBookmarkMessage");

  00699	68 00 00 00 00	 push	 OFFSET FLAT:$SG71709
  0069e	ff d3		 call	 ebx

; 1779 : #endif
; 1780 : 	
; 1781 : 	if ( phTTS->uiID_Bookmark_Message == 0 )

  006a0	3b c7		 cmp	 eax, edi
  006a2	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1782 : 	{
; 1783 : 		DeleteTextToSpeechObjects( phTTS );
; 1784 : #ifdef LICENSES
; 1785 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1786 : #endif //LICENSES
; 1787 : 		return( MMSYSERR_NOMEM );

  006a5	74 67		 je	 SHORT $L73186

; 1788 : 	}
; 1789 : 	
; 1790 : phTTS->uiID_Wordpos_Message =
; 1791 : #if UNDER_CE //mfgce
; 1792 : 	RegisterWindowMessage(TEXT("DECtalkWordposMessage"));
; 1793 : #else
; 1794 : 	RegisterWindowMessage("DECtalkWordposMessage");

  006a7	68 00 00 00 00	 push	 OFFSET FLAT:$SG71711
  006ac	ff d3		 call	 ebx

; 1795 : #endif
; 1796 : 	
; 1797 : 	if ( phTTS->uiID_Wordpos_Message == 0 )

  006ae	3b c7		 cmp	 eax, edi
  006b0	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 1798 : 	{
; 1799 : 		DeleteTextToSpeechObjects( phTTS );
; 1800 : #ifdef LICENSES
; 1801 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1802 : #endif //LICENSES
; 1803 : 		return( MMSYSERR_NOMEM );

  006b3	74 59		 je	 SHORT $L73186

; 1804 : 	}
; 1805 : 	
; 1806 : phTTS->uiID_Start_Message =
; 1807 : #if UNDER_CE //mfgce
; 1808 : 	RegisterWindowMessage(TEXT("DECtalkStartMessage"));
; 1809 : #else
; 1810 :     RegisterWindowMessage("DECtalkStartMessage");

  006b5	68 00 00 00 00	 push	 OFFSET FLAT:$SG71713
  006ba	ff d3		 call	 ebx

; 1811 : #endif
; 1812 : 	
; 1813 : 	if ( phTTS->uiID_Start_Message == 0 )

  006bc	3b c7		 cmp	 eax, edi
  006be	89 46 68	 mov	 DWORD PTR [esi+104], eax

; 1814 : 	{
; 1815 : 		DeleteTextToSpeechObjects( phTTS );
; 1816 : #ifdef LICENSES
; 1817 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1818 : #endif //LICENSES
; 1819 : 		return( MMSYSERR_NOMEM );

  006c1	74 4b		 je	 SHORT $L73186

; 1820 : 	}
; 1821 : 	
; 1822 : 	phTTS->uiID_Stop_Message =
; 1823 : #if UNDER_CE //mfgce
; 1824 : 	RegisterWindowMessage(TEXT("DECtalkStopMessage"));
; 1825 : #else
; 1826 : 	RegisterWindowMessage("DECtalkStopMessage");

  006c3	68 00 00 00 00	 push	 OFFSET FLAT:$SG71715
  006c8	ff d3		 call	 ebx

; 1827 : #endif
; 1828 : 	
; 1829 : 	if ( phTTS->uiID_Stop_Message == 0 )

  006ca	3b c7		 cmp	 eax, edi
  006cc	89 46 6c	 mov	 DWORD PTR [esi+108], eax

; 1830 : 	{
; 1831 : 		DeleteTextToSpeechObjects( phTTS );
; 1832 : #ifdef LICENSES
; 1833 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1834 : #endif //LICENSES
; 1835 : 		return( MMSYSERR_NOMEM );

  006cf	74 3d		 je	 SHORT $L73186

; 1836 : 	}
; 1837 : 	
; 1838 : 	// tek 27aug97 
; 1839 :   phTTS->uiID_Visual_Message =
; 1840 : #if UNDER_CE //mfgce
; 1841 : 	RegisterWindowMessage(TEXT("DECtalkVisualMessage"));
; 1842 : #else
; 1843 : 	RegisterWindowMessage("DECtalkVisualMessage");

  006d1	68 00 00 00 00	 push	 OFFSET FLAT:$SG71717
  006d6	ff d3		 call	 ebx

; 1844 : #endif
; 1845 : 	
; 1846 : 	if ( phTTS->uiID_Visual_Message == 0 )

  006d8	3b c7		 cmp	 eax, edi
  006da	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1847 : 	{
; 1848 : 		DeleteTextToSpeechObjects( phTTS );
; 1849 : #ifdef LICENSES
; 1850 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1851 : #endif //LICENSES
; 1852 : 		return( MMSYSERR_NOMEM );

  006dd	74 2f		 je	 SHORT $L73186

; 1853 : 	}
; 1854 : 	
; 1855 : 	
; 1856 : 	/********************************************************************/
; 1857 : 	/*  Get the DECtalk buffer message.                                 */
; 1858 : 	/********************************************************************/
; 1859 : 	
; 1860 :   phTTS->uiID_Buffer_Message =
; 1861 : #if UNDER_CE //mfgce
; 1862 : 	RegisterWindowMessage(TEXT("DECtalkBufferMessage"));
; 1863 : #else
; 1864 :     RegisterWindowMessage("DECtalkBufferMessage");

  006df	68 00 00 00 00	 push	 OFFSET FLAT:$SG71719
  006e4	ff d3		 call	 ebx

; 1865 : #endif
; 1866 : 	
; 1867 : 	if ( phTTS->uiID_Buffer_Message == 0 )

  006e6	3b c7		 cmp	 eax, edi
  006e8	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 1868 : 	{
; 1869 : 		DeleteTextToSpeechObjects( phTTS );
; 1870 : #ifdef LICENSES
; 1871 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 1872 : #endif //LICENSES
; 1873 : 		return( MMSYSERR_NOMEM );

  006eb	74 21		 je	 SHORT $L73186

; 1874 : 	}
; 1875 : 	
; 1876 : #endif /* WIN32 */
; 1877 : 	
; 1878 : 	/********************************************************************/
; 1879 : 	/*  Initialize the audio driver.                                    */
; 1880 : 	/********************************************************************/
; 1881 : 	
; 1882 : 	if (( dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  006ed	8b 6c 24 2c	 mov	 ebp, DWORD PTR _dwDeviceOptions$[esp+28]
  006f1	f7 c5 00 00 00
	80		 test	 ebp, -2147483648	; 80000000H
  006f7	0f 85 db 00 00
	00		 jne	 $L71721

; 1883 : 	{
; 1884 : 		/********************************************************************/
; 1885 : 		/*  Allocate memory for the local WAVEFORMATEX structure.           */
; 1886 : 		/********************************************************************/
; 1887 : 		// 01aug97 bats423: allocate this for both SAPI and DAPI
; 1888 : 		pWaveFormat = (LPWAVEFORMATEX)malloc(sizeof(WAVEFORMATEX));

  006fd	6a 12		 push	 18			; 00000012H
  006ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00705	8b d8		 mov	 ebx, eax
  00707	83 c4 04	 add	 esp, 4

; 1889 : 		
; 1890 : 		if ( pWaveFormat == NULL )

  0070a	3b df		 cmp	 ebx, edi
  0070c	75 1b		 jne	 SHORT $L71725
$L73186:

; 1891 : 		{
; 1892 : 			DeleteTextToSpeechObjects( phTTS );

  0070e	56		 push	 esi
  0070f	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  00714	83 c4 04	 add	 esp, 4
$L73188:

; 1893 : #ifdef WIN32
; 1894 : #ifdef LICENSES
; 1895 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00717	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  0071c	5f		 pop	 edi
  0071d	5e		 pop	 esi
  0071e	5d		 pop	 ebp

; 1896 : #endif //LICENSES
; 1897 : #endif
; 1898 : 			return( MMSYSERR_NOMEM );

  0071f	b8 07 00 00 00	 mov	 eax, 7
  00724	5b		 pop	 ebx

; 2224 : }

  00725	83 c4 10	 add	 esp, 16			; 00000010H
  00728	c3		 ret	 0
$L71725:

; 1899 : 		}
; 1900 : 		
; 1901 : #ifndef OLEDECTALK
; 1902 : 		/********************************************************************/
; 1903 : 		/*  Fill in all the required fields of the WAVEFORMATEX structure.  */
; 1904 : 		/********************************************************************/
; 1905 : 		
; 1906 : 		pWaveFormat->wFormatTag = WAVE_FORMAT_PCM;
; 1907 : 		pWaveFormat->nSamplesPerSec = PC_SAMPLE_RATE;
; 1908 : 		pWaveFormat->nChannels = 1;
; 1909 : 		pWaveFormat->wBitsPerSample = 16;
; 1910 : 		/********************************************************************/
; 1911 : 		/*  Open the audio device.                                          */
; 1912 : 		/********************************************************************/
; 1913 : 		
; 1914 : 		mmStatus = PA_CreatePlayHandle( &pPlayAudio,
; 1915 : 			uiDeviceNumber,
; 1916 : 			pWaveFormat,
; 1917 : 			dwDeviceOptions,
; 1918 : 			PlayAudioCallbackRoutine,
; 1919 : 			(ATYPE_T)phTTS);

  00729	8b 4c 24 28	 mov	 ecx, DWORD PTR _uiDeviceNumber$[esp+28]
  0072d	56		 push	 esi
  0072e	68 00 00 00 00	 push	 OFFSET FLAT:_PlayAudioCallbackRoutine
  00733	55		 push	 ebp
  00734	53		 push	 ebx
  00735	8d 54 24 20	 lea	 edx, DWORD PTR _pPlayAudio$[esp+48]
  00739	51		 push	 ecx
  0073a	52		 push	 edx
  0073b	66 c7 03 01 00	 mov	 WORD PTR [ebx], 1
  00740	c7 43 04 11 2b
	00 00		 mov	 DWORD PTR [ebx+4], 11025 ; 00002b11H
  00747	66 c7 43 02 01
	00		 mov	 WORD PTR [ebx+2], 1
  0074d	66 c7 43 0e 10
	00		 mov	 WORD PTR [ebx+14], 16	; 00000010H
  00753	e8 00 00 00 00	 call	 _PA_CreatePlayHandle
  00758	8b e8		 mov	 ebp, eax
  0075a	83 c4 18	 add	 esp, 24			; 00000018H

; 1920 : 		// bats423: free (pWaveFormat) done later
; 1921 : #else //OLEDECTALK
; 1922 : 		/*******************************************************/
; 1923 : 		/* Initialize the DECtalk audio system for OLE-DECTALK */
; 1924 : 		/*******************************************************/
; 1925 : 			      mmStatus = InitializeDECtalkAudio((HWND)dwTTSInstanceParameter,&pPlayAudio);
; 1926 : #endif //OLEDECTALK
; 1927 : 		
; 1928 : 		if ( mmStatus )

  0075d	3b ef		 cmp	 ebp, edi
  0075f	74 31		 je	 SHORT $L71729

; 1929 : 		{
; 1930 : #ifdef WIN32
; 1931 : #ifdef LICENSES
; 1932 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00761	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 1933 : #endif //LICENSES
; 1934 : #endif
; 1935 : 			DeleteTextToSpeechObjects( phTTS );

  00766	56		 push	 esi
  00767	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects

; 1936 : 
; 1937 : 			free( pWaveFormat ); // bats423

  0076c	53		 push	 ebx
  0076d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00773	83 c4 08	 add	 esp, 8

; 1938 : #ifdef API_DEBUG
; 1939 : 			OutputDebugString("ttsapi: error initializing audio\n");
; 1940 : #endif //API_DEBUG
; 1941 : 			if ( mmStatus == MMSYSERR_ERROR ) // tek 24sep96

  00776	83 fd 01	 cmp	 ebp, 1
  00779	75 0d		 jne	 SHORT $L71728
  0077b	5f		 pop	 edi
  0077c	5e		 pop	 esi
  0077d	5d		 pop	 ebp

; 1942 : 			{
; 1943 : 				return( MMSYSERR_NODRIVER );

  0077e	b8 06 00 00 00	 mov	 eax, 6
  00783	5b		 pop	 ebx

; 2224 : }

  00784	83 c4 10	 add	 esp, 16			; 00000010H
  00787	c3		 ret	 0
$L71728:
  00788	5f		 pop	 edi

; 1944 : 			}
; 1945 : #ifdef DONT_RETURN_BADFORMAT
; 1946 : 			else if (mmStatus == WAVERR_BADFORMAT)
; 1947 : 			{	// tek 24sep96 we'd really like to return BADFORMAT here
; 1948 : 				// but that will break existing users. Baggage..
; 1949 : 				return (MMSYSERR_NODRIVER);
; 1950 : 			} 
; 1951 : #endif //DONT_RETURN_BADFORMAT
; 1952 : 			else
; 1953 : 				return( mmStatus );

  00789	8b c5		 mov	 eax, ebp
  0078b	5e		 pop	 esi
  0078c	5d		 pop	 ebp
  0078d	5b		 pop	 ebx

; 2224 : }

  0078e	83 c4 10	 add	 esp, 16			; 00000010H
  00791	c3		 ret	 0
$L71729:

; 1954 : 		}
; 1955 : 		
; 1956 : 		phTTS->pAudioHandle = pPlayAudio;

  00792	8b 44 24 10	 mov	 eax, DWORD PTR _pPlayAudio$[esp+32]

; 1957 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 1958 : 		// tek 01aug97 bats423 init some stuff for later use here..
; 1959 : #ifdef OLEDECTALK
; 1960 : 		phTTS->pAudioHandle->pcMode = NULL; // this gets filled in later.
; 1961 : #endif //OLEDECTALK
; 1962 : 		// get the sample rate and stash it away.. 
; 1963 : 		PA_GetFormat(pPlayAudio,pWaveFormat);

  00796	53		 push	 ebx
  00797	89 86 d0 00 00
	00		 mov	 DWORD PTR [esi+208], eax
  0079d	89 be 84 00 00
	00		 mov	 DWORD PTR [esi+132], edi
  007a3	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+36]
  007a7	51		 push	 ecx
  007a8	e8 00 00 00 00	 call	 _PA_GetFormat

; 1964 : 		pPlayAudio->dMsecPerSample = 
; 1965 : 			(double)(1000)/(double)(pWaveFormat->nAvgBytesPerSec);

  007ad	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  007b0	89 7c 24 24	 mov	 DWORD PTR -8+[esp+44], edi
  007b4	89 54 24 20	 mov	 DWORD PTR -8+[esp+40], edx
  007b8	8b 44 24 18	 mov	 eax, DWORD PTR _pPlayAudio$[esp+40]
  007bc	df 6c 24 20	 fild	 QWORD PTR -8+[esp+40]

; 1966 : 		free( pWaveFormat );

  007c0	53		 push	 ebx
  007c1	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@8@4008fa00000000000000
  007c7	dd 98 b0 00 00
	00		 fstp	 QWORD PTR [eax+176]
  007cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  007d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1967 : 		
; 1968 : 	}
; 1969 : 	else // tek 01jul97/01aug97 bats 423

  007d6	eb 06		 jmp	 SHORT $L71732
$L71721:

; 1970 : 		//have to deal with the DO_NOT_USE_AUDIO_DEVICE
; 1971 : 		// case for DAPI..  (well, not really, but doing this here 
; 1972 : 		// reminds us that there IS another case..
; 1973 : 	{
; 1974 : 		phTTS->pAudioHandle = NULL;

  007d8	89 be d0 00 00
	00		 mov	 DWORD PTR [esi+208], edi
$L71732:

; 1975 : 	}
; 1976 : 	
; 1977 : 	/********************************************************************/
; 1978 : 	/*  Start the Synchronization thread.                               */
; 1979 : 	/********************************************************************/
; 1980 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_SYNC),
; 1981 : #ifdef WIN32
; 1982 : 		FALSE,(start_address)sync_main))== MMSYSERR_NOMEM)

  007de	68 00 00 00 00	 push	 OFFSET FLAT:_sync_main@4
  007e3	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  007e6	57		 push	 edi
  007e7	50		 push	 eax
  007e8	56		 push	 esi
  007e9	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  007ee	83 c4 10	 add	 esp, 16			; 00000010H
  007f1	83 f8 07	 cmp	 eax, 7
  007f4	75 12		 jne	 SHORT $L71735

; 1983 : #endif
; 1984 : #if defined __osf__ || defined __linux__
; 1985 : 		FALSE, sync_main))== MMSYSERR_NOMEM)
; 1986 : #endif
; 1987 : 	{
; 1988 : #ifdef WIN32
; 1989 : #ifdef LICENSES
; 1990 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  007f6	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  007fb	5f		 pop	 edi
  007fc	5e		 pop	 esi
  007fd	5d		 pop	 ebp

; 1991 : #endif // LICENSES
; 1992 : #endif
; 1993 : 		return(MMSYSERR_NOMEM);

  007fe	b8 07 00 00 00	 mov	 eax, 7
  00803	5b		 pop	 ebx

; 2224 : }

  00804	83 c4 10	 add	 esp, 16			; 00000010H
  00807	c3		 ret	 0
$L71735:

; 1994 : 	}
; 1995 : 	
; 1996 : 	/********************************************************************/
; 1997 : 	/*  Start the Vocal Tract Model thread.                             */
; 1998 : 	/********************************************************************/
; 1999 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_VTM),
; 2000 : #ifdef WIN32
; 2001 : 		TRUE,(start_address)vtm_main))== MMSYSERR_NOMEM)

  00808	68 00 00 00 00	 push	 OFFSET FLAT:_vtm_main@4
  0080d	8d 6e 30	 lea	 ebp, DWORD PTR [esi+48]
  00810	6a 01		 push	 1
  00812	55		 push	 ebp
  00813	56		 push	 esi
  00814	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  00819	83 c4 10	 add	 esp, 16			; 00000010H
  0081c	83 f8 07	 cmp	 eax, 7
  0081f	75 12		 jne	 SHORT $L71737

; 2002 : #endif
; 2003 : #if defined __osf__ || defined __linux__
; 2004 : 		TRUE, vtm_main))== MMSYSERR_NOMEM)
; 2005 : #endif
; 2006 : 	{
; 2007 : #ifdef WIN32
; 2008 : #ifdef LICENSES
; 2009 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  00821	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  00826	5f		 pop	 edi
  00827	5e		 pop	 esi
  00828	5d		 pop	 ebp

; 2010 : #endif //LICENSES
; 2011 : #endif
; 2012 : 		return(MMSYSERR_NOMEM);

  00829	b8 07 00 00 00	 mov	 eax, 7
  0082e	5b		 pop	 ebx

; 2224 : }

  0082f	83 c4 10	 add	 esp, 16			; 00000010H
  00832	c3		 ret	 0
$L71737:

; 2013 : 	}
; 2014 : 	
; 2015 : 	/********************************************************************/
; 2016 : 	/*  Start the Phonetic processing thread.                           */
; 2017 : 	/********************************************************************/
; 2018 : 	if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_PH),
; 2019 : #ifdef WIN32
; 2020 : 		TRUE, (start_address)ph_main))== MMSYSERR_NOMEM)

  00833	68 00 00 00 00	 push	 OFFSET FLAT:_ph_main@4
  00838	8d 5e 2c	 lea	 ebx, DWORD PTR [esi+44]
  0083b	6a 01		 push	 1
  0083d	53		 push	 ebx
  0083e	56		 push	 esi
  0083f	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  00844	83 c4 10	 add	 esp, 16			; 00000010H
  00847	83 f8 07	 cmp	 eax, 7
  0084a	75 12		 jne	 SHORT $L71739

; 2021 : #endif
; 2022 : #if defined __osf__ || defined __linux__
; 2023 : 		TRUE, ph_main))== MMSYSERR_NOMEM)
; 2024 : #endif
; 2025 : 	{
; 2026 : #ifdef WIN32
; 2027 : #ifdef LICENSES
; 2028 : 		ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0084c	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  00851	5f		 pop	 edi
  00852	5e		 pop	 esi
  00853	5d		 pop	 ebp

; 2029 : #endif //LICENSES
; 2030 : #endif 
; 2031 : 		return(MMSYSERR_NOMEM);

  00854	b8 07 00 00 00	 mov	 eax, 7
  00859	5b		 pop	 ebx

; 2224 : }

  0085a	83 c4 10	 add	 esp, 16			; 00000010H
  0085d	c3		 ret	 0
$L71739:

; 2032 : 	}
; 2033 : 	
; 2034 : #ifdef TYPING_MODE	 //09jun97 tek
; 2035 : 	// elevate the PH and VTM thread priority
; 2036 : 	if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)

  0085e	39 be 84 00 00
	00		 cmp	 DWORD PTR [esi+132], edi
  00864	75 18		 jne	 SHORT $L71740

; 2037 : 	{
; 2038 : 		// 19nov97 VTM adjusts the priority of both PH and VTM, so we
; 2039 : 		// set it high to start and then let it back down automagically
; 2040 : #ifndef UNDER_CE
; 2041 : 		OP_SetThreadPriority((phTTS->hThread_PH),OP_PRIORITY_HIGHEST);

  00866	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00868	6a 02		 push	 2
  0086a	51		 push	 ecx
  0086b	e8 00 00 00 00	 call	 _OP_SetThreadPriority

; 2042 : 		OP_SetThreadPriority((phTTS->hThread_VTM),OP_PRIORITY_HIGHEST);

  00870	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00873	6a 02		 push	 2
  00875	52		 push	 edx
  00876	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  0087b	83 c4 10	 add	 esp, 16			; 00000010H
$L71740:

; 2043 : #endif
; 2044 : 	}
; 2045 : #ifndef UNDER_CE
; 2046 : 	OP_SetThreadPriority((phTTS->hThread_SYNC),OP_PRIORITY_ABOVE_NORMAL);

  0087e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00881	6a 01		 push	 1
  00883	50		 push	 eax
  00884	e8 00 00 00 00	 call	 _OP_SetThreadPriority

; 2047 : #endif
; 2048 : #endif //TYPING_MODE
; 2049 : 	
; 2050 : 	/********************************************************************/
; 2051 : 	/*  Start the Letter To Sound thread.                               */
; 2052 : 	/********************************************************************/
; 2053 : 	nReturnCode = StartDecTalkSystemThread(phTTS, &(phTTS->hThread_LTS),
; 2054 : #ifdef WIN32
; 2055 : 		TRUE,(start_address)lts_main);

  00889	68 00 00 00 00	 push	 OFFSET FLAT:_lts_main@4
  0088e	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00891	6a 01		 push	 1
  00893	50		 push	 eax
  00894	56		 push	 esi
  00895	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  0089a	8b d8		 mov	 ebx, eax
  0089c	83 c4 18	 add	 esp, 24			; 00000018H

; 2056 : #endif
; 2057 : #if defined __osf__ || defined __linux__
; 2058 : 		TRUE, lts_main);			
; 2059 : #endif
; 2060 : 		if(nReturnCode == MMSYSERR_NOMEM ||
; 2061 : 			nReturnCode == MMSYSERR_INVALPARAM ||
; 2062 : 			nReturnCode == MMSYSERR_ERROR )

  0089f	83 fb 07	 cmp	 ebx, 7
  008a2	0f 84 82 00 00
	00		 je	 $L71743
  008a8	83 fb 0b	 cmp	 ebx, 11			; 0000000bH
  008ab	74 7d		 je	 SHORT $L71743
  008ad	83 fb 01	 cmp	 ebx, 1
  008b0	74 78		 je	 SHORT $L71743

; 2070 : 		}
; 2071 : 		
; 2072 : 		/********************************************************************/
; 2073 : 		/*  Start the Command thread.                                       */
; 2074 : 		/********************************************************************/
; 2075 : 		if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_CMD),
; 2076 : #ifdef WIN32
; 2077 : 			TRUE,(start_address)cmd_main))== MMSYSERR_NOMEM)

  008b2	68 00 00 00 00	 push	 OFFSET FLAT:_cmd_main@4
  008b7	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  008ba	6a 01		 push	 1
  008bc	50		 push	 eax
  008bd	56		 push	 esi
  008be	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  008c3	83 c4 10	 add	 esp, 16			; 00000010H
  008c6	83 f8 07	 cmp	 eax, 7
  008c9	75 12		 jne	 SHORT $L71745

; 2078 : #endif
; 2079 : #if defined __osf__ || defined __linux__
; 2080 : 			TRUE, cmd_main))== MMSYSERR_NOMEM)
; 2081 : #endif
; 2082 : 		{
; 2083 : #ifdef WIN32
; 2084 : #ifdef LICENSES
; 2085 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  008cb	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  008d0	5f		 pop	 edi
  008d1	5e		 pop	 esi
  008d2	5d		 pop	 ebp

; 2086 : #endif //LICENSES
; 2087 : #endif
; 2088 : 			return(MMSYSERR_NOMEM);

  008d3	b8 07 00 00 00	 mov	 eax, 7
  008d8	5b		 pop	 ebx

; 2224 : }

  008d9	83 c4 10	 add	 esp, 16			; 00000010H
  008dc	c3		 ret	 0
$L71745:

; 2089 : 		}
; 2090 : 		
; 2091 : 		/********************************************************************/
; 2092 : 		/*  Start the Text Queueing thread.                                 */
; 2093 : 		/********************************************************************/
; 2094 : 		phTTS->hTextToSpeechWnd = (int)NULL;
; 2095 : 		
; 2096 : 		nReturnCode = StartDecTalkSystemThread(phTTS, &(phTTS->hThread_TXT),
; 2097 : #ifdef WIN32
; 2098 : 			TRUE,(start_address)TextToSpeechThreadMain);

  008dd	68 00 00 00 00	 push	 OFFSET FLAT:_TextToSpeechThreadMain@4
  008e2	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  008e5	6a 01		 push	 1
  008e7	50		 push	 eax
  008e8	56		 push	 esi
  008e9	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  008ec	e8 00 00 00 00	 call	 _StartDecTalkSystemThread
  008f1	8b f8		 mov	 edi, eax
  008f3	83 c4 10	 add	 esp, 16			; 00000010H

; 2099 : #endif
; 2100 : #if defined __osf__ || defined __linux__
; 2101 : 		TRUE, TextToSpeechThreadMain);
; 2102 : #endif
; 2103 : 		if(nReturnCode == MMSYSERR_NOMEM ||
; 2104 : 			nReturnCode == MMSYSERR_ERROR)

  008f6	83 ff 07	 cmp	 edi, 7
  008f9	74 20		 je	 SHORT $L71750
  008fb	83 ff 01	 cmp	 edi, 1
  008fe	74 1b		 je	 SHORT $L71750

; 2112 : 		}
; 2113 : 		
; 2114 : #ifdef OLD
; 2115 : 		phTTS->hThread_TXT = CreateThread( NULL,
; 2116 : 			0,
; 2117 : 			(LPTHREAD_START_ROUTINE)TextToSpeechThreadMain,
; 2118 : 			(LPVOID)phTTS,
; 2119 : 			0,
; 2120 : 			&ID_Thread_TXT );
; 2121 : 		
; 2122 : 		/********************************************************************/
; 2123 : 		/*  Wait here until the LTS thread loads the dictionary.            */
; 2124 : 		/********************************************************************/
; 2125 : 		/* GL 11/05/1997  for BATS#510 */
; 2126 : 		for ( i = 0; pKsd_t->fdic_entries[pKsd_t->lang_curr] == 0; i++ )
; 2127 : 		{
; 2128 : 			Sleep( STARTUP_LOOP_WAIT_TIME );
; 2129 : 			if ( i > MAX_STARTUP_WAIT_COUNT )
; 2130 : 			{                                                            
; 2131 : 				DeleteTextToSpeechObjects( phTTS );
; 2132 : #ifdef WIN32            
; 2133 : #ifdef LICENSES
; 2134 : 				ReleaseLicenseRef();	
; 2135 : /* tek 23sep96 give back the license unit */
; 2136 : #endif //LICENSES
; 2137 : #endif
; 2138 : 				return( MMSYSERR_ERROR );
; 2139 : 			}
; 2140 : 		}
; 2141 : 		
; 2142 : 		/********************************************************************/
; 2143 : 		/*  If the dictionary length was set to 0xFFFFFFFF then the         */
; 2144 : 		/*  dictionary file was not found. Return an error.                 */
; 2145 : 		/********************************************************************/
; 2146 : 		
; 2147 : 		/* GL 11/05/1997  for BATS#510 */
; 2148 : 		if ( pKsd_t->fdic_entries[pKsd_t->lang_curr] == 0xFFFFFFFF )
; 2149 : 		{
; 2150 : #ifdef WIN32  
; 2151 : #ifdef LICENSES
; 2152 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2153 : #endif //LICENSES
; 2154 : #endif
; 2155 : 			return( MMSYSERR_ERROR );
; 2156 : 		}
; 2157 : 		
; 2158 : 		/********************************************************************/
; 2159 : 		/*  Wait here until the Text-To-Speech main thread initializes the  */
; 2160 : 		/*  Text-To-Speech window handle.                                   */
; 2161 : /********************************************************************/
; 2162 : 
; 2163 : 		for ( i = 0; phTTS->hTextToSpeechWnd == NULL; i++ )
; 2164 : 		{
; 2165 : 			Sleep( STARTUP_LOOP_WAIT_TIME );
; 2166 : 			if ( i > MAX_STARTUP_WAIT_COUNT )
; 2167 : 			{
; 2168 : 				DeleteTextToSpeechObjects( phTTS );
; 2169 : #ifdef WIN32 
; 2170 : #ifdef LICENSES
; 2171 : 				ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2172 : #endif //LICENSES
; 2173 : #endif
; 2174 : 				return( MMSYSERR_NOMEM );
; 2175 : 			}
; 2176 : 		}
; 2177 : 		
; 2178 : 		if ( phTTS->hThread_TXT == NULL )
; 2179 : 		{
; 2180 : 			DeleteTextToSpeechObjects( phTTS );
; 2181 : #ifdef WIN32 
; 2182 : #ifdef LICENSES
; 2183 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit
; 2184 : #endif //LICENSES
; 2185 : #endif
; 2186 : 			return( MMSYSERR_NOMEM );
; 2187 : 		}
; 2188 : 		
; 2189 : #endif //OLD
; 2190 : 		
; 2191 : 		
; 2192 : 		/********************************************************************/
; 2193 : 		/*  MVP:06/19/96 Initialize the TextToSpeech handle the function        */
; 2194 : 		/*  returns through pphTTS argument.                                */
; 2195 : 		/********************************************************************/
; 2196 : 		
; 2197 : 		*pphTTS = phTTS;

  00900	8b 4c 24 24	 mov	 ecx, DWORD PTR _pphTTS$[esp+28]

; 2198 : 		
; 2199 : 		/******************************************************************/
; 2200 : 		/*  Put the system into a known state.                            */
; 2201 : 		/******************************************************************/
; 2202 : 		
; 2203 : 		TextToSpeechReset( phTTS, TRUE );

  00904	6a 01		 push	 1
  00906	56		 push	 esi
  00907	89 31		 mov	 DWORD PTR [ecx], esi
  00909	e8 00 00 00 00	 call	 _TextToSpeechReset
  0090e	83 c4 08	 add	 esp, 8

; 2204 : 		
; 2205 : 		//MVP: Increment InstanceCounter on successful creation of a speech object.
; 2206 : 		//gnInstanceCounter++; // tek bats 668 12may98 this is done by the dic loader.
; 2207 : #if defined __osf__ || defined __linux__
; 2208 : 		gnInstanceCounter++;
; 2209 : #endif
; 2210 : 		
; 2211 : #ifdef DECTALKBETA430        //MVP:04/09/96 A message will be spoken for Beta releases.
; 2212 : #ifdef ENGLISH
; 2213 : 		TextToSpeechSpeak(phTTS, "DECtalk beta S D K version 4.4a is running. For evaluation only. ", TTS_FORCE);
; 2214 : #endif //ENGLISH
; 2215 : #ifdef SPANISH
; 2216 : 		TextToSpeechSpeak(phTTS, "DECtalk beta S d k versin 4.4a est corriendo. Para evaluacin solamente.", TTS_FORCE);
; 2217 : #endif //SPANISH
; 2218 : #ifdef GERMAN
; 2219 : 		TextToSpeechSpeak(phTTS, "Dies ist das DECtalk S D K, beta Version 4.4 A. Unlizensierte Testversion.", TTS_FORCE);
; 2220 : #endif //GERMAN
; 2221 : #endif //DECTALKBETA430
; 2222 : 		
; 2223 : 		return( MMSYSERR_NOERROR );

  00911	33 c0		 xor	 eax, eax
  00913	5f		 pop	 edi
  00914	5e		 pop	 esi
  00915	5d		 pop	 ebp
  00916	5b		 pop	 ebx

; 2224 : }

  00917	83 c4 10	 add	 esp, 16			; 00000010H
  0091a	c3		 ret	 0
$L71750:

; 2105 : 		{
; 2106 : #ifdef WIN32
; 2107 : #ifdef LICENSES
; 2108 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0091b	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 2109 : #endif //LICENSES
; 2110 : #endif
; 2111 : 			return(nReturnCode);

  00920	8b c7		 mov	 eax, edi
  00922	5f		 pop	 edi
  00923	5e		 pop	 esi
  00924	5d		 pop	 ebp
  00925	5b		 pop	 ebx

; 2224 : }

  00926	83 c4 10	 add	 esp, 16			; 00000010H
  00929	c3		 ret	 0
$L71743:

; 2063 : 		{
; 2064 : #ifdef WIN32
; 2065 : #ifdef LICENSES
; 2066 : 			ReleaseLicenseRef();	// tek 23sep96 give back the license unit

  0092a	e8 00 00 00 00	 call	 _ReleaseLicenseRef
  0092f	5f		 pop	 edi
  00930	5e		 pop	 esi

; 2067 : #endif //LICENSES
; 2068 : #endif
; 2069 : 			return(nReturnCode);

  00931	8b c3		 mov	 eax, ebx
  00933	5d		 pop	 ebp
  00934	5b		 pop	 ebx

; 2224 : }

  00935	83 c4 10	 add	 esp, 16			; 00000010H
  00938	c3		 ret	 0
_TextToSpeechStartupEx ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechStartup
PUBLIC	_DefaultTTSCallbackRoutine
_TEXT	SEGMENT
_hWnd$ = 8
_pphTTS$ = 12
_uiDeviceNumber$ = 16
_dwDeviceOptions$ = 20
_TextToSpeechStartup PROC NEAR

; 2327 : 	// tek 13nov97 flag that we're using the default callback, so that
; 2328 : 	// we know that the instance param is actually hWnd..
; 2329 : 	return(TextToSpeechStartupEx(pphTTS,
; 2330 : 		uiDeviceNumber,
; 2331 : 		dwDeviceOptions|TTSSTARTUP_USING_DEFAULT_CALLBACK,
; 2332 : 		DefaultTTSCallbackRoutine,
; 2333 : 		(LONG)hWnd));

  00940	8b 44 24 04	 mov	 eax, DWORD PTR _hWnd$[esp-4]
  00944	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwDeviceOptions$[esp-4]
  00948	8b 54 24 0c	 mov	 edx, DWORD PTR _uiDeviceNumber$[esp-4]
  0094c	50		 push	 eax
  0094d	8b 44 24 0c	 mov	 eax, DWORD PTR _pphTTS$[esp]
  00951	81 c9 00 00 00
	08		 or	 ecx, 134217728		; 08000000H
  00957	68 00 00 00 00	 push	 OFFSET FLAT:_DefaultTTSCallbackRoutine
  0095c	51		 push	 ecx
  0095d	52		 push	 edx
  0095e	50		 push	 eax
  0095f	e8 00 00 00 00	 call	 _TextToSpeechStartupEx
  00964	83 c4 14	 add	 esp, 20			; 00000014H

; 2334 : 
; 2335 : /* GL 11/19/1998, the following codes never get used */
; 2336 : #if 0
; 2337 : 
; 2338 : 	/********************************************************************/
; 2339 : 	/*  Get the DECtalk error message.                                  */
; 2340 : 	/********************************************************************/
; 2341 : 	
; 2342 : 	phTTS->uiID_Error_Message =
; 2343 : 	  RegisterWindowMessage("DECtalkErrorMessage");
; 2344 : 	
; 2345 : 	if ( phTTS->uiID_Error_Message == 0 )
; 2346 : 	{
; 2347 : 	    DeleteTextToSpeechObjects( phTTS );
; 2348 : 	    return( MMSYSERR_NOMEM );
; 2349 : 	}
; 2350 : 	
; 2351 : 	/********************************************************************/
; 2352 : 	/*  Get the DECtalk index mark message.                             */
; 2353 : 	/********************************************************************/
; 2354 : 	
; 2355 : 	phTTS->uiID_Index_Message =
; 2356 : 	  RegisterWindowMessage("DECtalkIndexMessage");
; 2357 : 	
; 2358 : 	if ( phTTS->uiID_Index_Message == 0 )
; 2359 : 	{
; 2360 : 	    DeleteTextToSpeechObjects( phTTS );
; 2361 : 	    return( MMSYSERR_NOMEM );
; 2362 : 	}
; 2363 : 	
; 2364 : 	/********************************************************************/
; 2365 : 	/*  Get the DECtalk buffer message.                                 */
; 2366 : 	/********************************************************************/
; 2367 : 	
; 2368 : 	phTTS->uiID_Buffer_Message =
; 2369 : 	  RegisterWindowMessage("DECtalkBufferMessage");
; 2370 : 	
; 2371 : 	if ( phTTS->uiID_Buffer_Message == 0 )
; 2372 : 	{
; 2373 : 	    DeleteTextToSpeechObjects( phTTS );
; 2374 : 	    return( MMSYSERR_NOMEM );
; 2375 : 	}
; 2376 : #endif
; 2377 : 
; 2378 : }

  00967	c3		 ret	 0
_TextToSpeechStartup ENDP
_TEXT	ENDS
EXTRN	__imp__PostMessageA@16:NEAR
_TEXT	SEGMENT
_lParam1$ = 8
_lParam2$ = 12
_dwInstanceParam$ = 16
_uiMsg$ = 20
_DefaultTTSCallbackRoutine PROC NEAR

; 2386 : #ifdef API_DEBUG
; 2387 : 	char szTemp[256]="";
; 2388 : 	ULONG ulStartTime,ulEndTime;
; 2389 : 	ulStartTime=timeGetTime();
; 2390 : 	sprintf(szTemp, "DTTSCallback(%ld) at %ld.\n", lParam1,ulStartTime);
; 2391 : 	OutputDebugString(szTemp);
; 2392 : #endif //API_DEBUG
; 2393 : 	
; 2394 : 	switch( lParam1 )
; 2395 : 	{

  00970	8b 4c 24 04	 mov	 ecx, DWORD PTR _lParam1$[esp-4]
  00974	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00977	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0097a	77 0f		 ja	 SHORT $L71774
  0097c	33 d2		 xor	 edx, edx
  0097e	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L73192[eax]
  00984	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L73193[edx*4]
$L71774:

; 2396 : 	case TTS_AUDIO_PLAY_START:
; 2397 : 	case TTS_AUDIO_PLAY_STOP:
; 2398 : 	case ERROR_OPENING_WAVE_OUTPUT_DEVICE:
; 2399 : 	case ERROR_IN_AUDIO_WRITE:
; 2400 : 	case ERROR_GETTING_DEVICE_CAPABILITIES:
; 2401 : 		PostMessage((HWND)dwInstanceParam,uiMsg,lParam1,lParam2);
; 2402 : 		break;
; 2403 : 		
; 2404 : 	default:
; 2405 : 		// tek 19aug96 must this be a post?
; 2406 : 		PostMessage((HWND)dwInstanceParam,uiMsg,lParam1,lParam2);

  0098b	8b 44 24 08	 mov	 eax, DWORD PTR _lParam2$[esp-4]
  0098f	8b 54 24 0c	 mov	 edx, DWORD PTR _dwInstanceParam$[esp-4]
  00993	50		 push	 eax
  00994	51		 push	 ecx
  00995	8b 4c 24 18	 mov	 ecx, DWORD PTR _uiMsg$[esp+4]
  00999	51		 push	 ecx
  0099a	52		 push	 edx
  0099b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 2407 : 		break;
; 2408 : 	}
; 2409 : }

  009a1	c3		 ret	 0
  009a2	8b ff		 npad	 2
$L73193:
  009a4	00 00 00 00	 DD	 $L71774
  009a8	00 00 00 00	 DD	 $L71774
$L73192:
  009ac	00		 DB	 0
  009ad	00		 DB	 0
  009ae	00		 DB	 0
  009af	01		 DB	 1
  009b0	01		 DB	 1
  009b1	01		 DB	 1
  009b2	01		 DB	 1
  009b3	01		 DB	 1
  009b4	01		 DB	 1
  009b5	01		 DB	 1
  009b6	01		 DB	 1
  009b7	00		 DB	 0
  009b8	00		 DB	 0
_DefaultTTSCallbackRoutine ENDP
_TEXT	ENDS
EXTRN	__imp__WaitForMultipleObjects@16:NEAR
EXTRN	__imp___beginthreadex:NEAR
EXTRN	__imp__GetExitCodeThread@8:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_ppDecTalkThread$ = 12
_bMalloc$ = 16
_ThreadFunction$ = 20
_IDThread$ = 20
_WaitObjArray$ = -8
_exit_code$ = 8
_StartDecTalkSystemThread PROC NEAR

; 2450 : 	UINT IDThread;
; 2451 : 	DWORD cNumObjects =2;
; 2452 : #if !defined __osf__ && !defined __linux__
; 2453 : 	HANDLE WaitObjArray[2];
; 2454 : 	ULONG exit_code ;
; 2455 : #endif
; 2456 : 	/*typedef int ( * _stdcall Stdstart_address ) (void *);*/
; 2457 : 	
; 2458 : #ifdef WIN32
; 2459 : 	*ppDecTalkThread = (HANDLE) _beginthreadex(NULL,
; 2460 : 								0,
; 2461 : 								ThreadFunction,             
; 2462 : 								(void *)phTTS,                                   
; 2463 : 								0,
; 2464 : 								&IDThread
; 2465 : 								);

  009c0	8b 4c 24 10	 mov	 ecx, DWORD PTR _ThreadFunction$[esp-4]
  009c4	83 ec 08	 sub	 esp, 8
  009c7	8d 44 24 18	 lea	 eax, DWORD PTR _IDThread$[esp+4]
  009cb	56		 push	 esi
  009cc	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  009d0	57		 push	 edi
  009d1	50		 push	 eax
  009d2	6a 00		 push	 0
  009d4	56		 push	 esi
  009d5	51		 push	 ecx
  009d6	6a 00		 push	 0
  009d8	6a 00		 push	 0
  009da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthreadex
  009e0	8b 7c 24 30	 mov	 edi, DWORD PTR _ppDecTalkThread$[esp+36]
  009e4	83 c4 18	 add	 esp, 24			; 00000018H

; 2466 : #endif
; 2467 : #if defined __osf__ || defined __linux__
; 2468 : 	*ppDecTalkThread = OP_CreateThread(0,
; 2469 : 					   ThreadFunction,             
; 2470 : 					   (void *)phTTS);
; 2471 : #endif
; 2472 : 	
; 2473 : 	if ( *ppDecTalkThread == NULL )

  009e7	85 c0		 test	 eax, eax
  009e9	89 07		 mov	 DWORD PTR [edi], eax
  009eb	75 14		 jne	 SHORT $L71795

; 2474 : 	{
; 2475 : 		DeleteTextToSpeechObjects( phTTS );

  009ed	56		 push	 esi
  009ee	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  009f3	83 c4 04	 add	 esp, 4

; 2476 : 		return( MMSYSERR_NOMEM );

  009f6	b8 07 00 00 00	 mov	 eax, 7
  009fb	5f		 pop	 edi
  009fc	5e		 pop	 esi

; 2503 : #endif
; 2504 : #if defined __osf__ || defined __linux__
; 2505 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 2506 : 		DeleteTextToSpeechObjects( phTTS );
; 2507 : 	
; 2508 : 	return (phTTS->uiThreadError);
; 2509 : #endif
; 2510 : }

  009fd	83 c4 08	 add	 esp, 8
  00a00	c3		 ret	 0
$L71795:

; 2477 : 	}
; 2478 : 	
; 2479 : 	if(bMalloc == FALSE)          /* No dynamic memory allocations within thread main function */

  00a01	8b 4c 24 1c	 mov	 ecx, DWORD PTR _bMalloc$[esp+12]
  00a05	85 c9		 test	 ecx, ecx
  00a07	75 08		 jne	 SHORT $L71796
  00a09	5f		 pop	 edi

; 2480 : 		return MMSYSERR_NOERROR;  /*No errors */

  00a0a	33 c0		 xor	 eax, eax
  00a0c	5e		 pop	 esi

; 2503 : #endif
; 2504 : #if defined __osf__ || defined __linux__
; 2505 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 2506 : 		DeleteTextToSpeechObjects( phTTS );
; 2507 : 	
; 2508 : 	return (phTTS->uiThreadError);
; 2509 : #endif
; 2510 : }

  00a0d	83 c4 08	 add	 esp, 8
  00a10	c3		 ret	 0
$L71796:

; 2481 : #if !defined __osf__ && !defined __linux__
; 2482 : 	WaitObjArray[0] = *ppDecTalkThread;
; 2483 : 	WaitObjArray[1] = phTTS->hMallocSuccessEvent;

  00a11	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00a14	89 44 24 08	 mov	 DWORD PTR _WaitObjArray$[esp+16], eax

; 2484 : 	
; 2485 : 	WaitForMultipleObjects(cNumObjects,WaitObjArray,FALSE,INFINITE); 

  00a18	6a ff		 push	 -1
  00a1a	8d 44 24 0c	 lea	 eax, DWORD PTR _WaitObjArray$[esp+20]
  00a1e	6a 00		 push	 0
  00a20	50		 push	 eax
  00a21	6a 02		 push	 2
  00a23	89 54 24 1c	 mov	 DWORD PTR _WaitObjArray$[esp+36], edx
  00a27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForMultipleObjects@16

; 2486 : 	
; 2487 : 	GetExitCodeThread(*ppDecTalkThread,&exit_code);

  00a2d	8b 17		 mov	 edx, DWORD PTR [edi]
  00a2f	8d 4c 24 14	 lea	 ecx, DWORD PTR _exit_code$[esp+12]
  00a33	51		 push	 ecx
  00a34	52		 push	 edx
  00a35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8

; 2488 : #endif /* __osf__ && __linux__ */
; 2489 : #if defined __osf__ || defined __linux__
; 2490 : 	OP_WaitForEvent( phTTS->hMallocSuccessEvent, OP_INFINITE );
; 2491 : #endif
; 2492 : 	
; 2493 : #if !defined __osf__ && !defined __linux__
; 2494 : 	if(exit_code == MMSYSERR_NOMEM ||
; 2495 : 		exit_code == MMSYSERR_INVALPARAM ||
; 2496 : 		exit_code == MMSYSERR_ERROR )

  00a3b	8b 44 24 14	 mov	 eax, DWORD PTR _exit_code$[esp+12]
  00a3f	83 f8 07	 cmp	 eax, 7
  00a42	74 12		 je	 SHORT $L71798
  00a44	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00a47	74 0d		 je	 SHORT $L71798
  00a49	83 f8 01	 cmp	 eax, 1
  00a4c	74 08		 je	 SHORT $L71798
  00a4e	5f		 pop	 edi

; 2500 : 	}
; 2501 : 	
; 2502 : 	return MMSYSERR_NOERROR;    /*No errors */

  00a4f	33 c0		 xor	 eax, eax
  00a51	5e		 pop	 esi

; 2503 : #endif
; 2504 : #if defined __osf__ || defined __linux__
; 2505 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 2506 : 		DeleteTextToSpeechObjects( phTTS );
; 2507 : 	
; 2508 : 	return (phTTS->uiThreadError);
; 2509 : #endif
; 2510 : }

  00a52	83 c4 08	 add	 esp, 8
  00a55	c3		 ret	 0
$L71798:

; 2497 : 	{
; 2498 : 		DeleteTextToSpeechObjects( phTTS );

  00a56	56		 push	 esi
  00a57	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects

; 2499 : 		return(exit_code);

  00a5c	8b 44 24 18	 mov	 eax, DWORD PTR _exit_code$[esp+16]
  00a60	83 c4 04	 add	 esp, 4
  00a63	5f		 pop	 edi
  00a64	5e		 pop	 esi

; 2503 : #endif
; 2504 : #if defined __osf__ || defined __linux__
; 2505 : 	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
; 2506 : 		DeleteTextToSpeechObjects( phTTS );
; 2507 : 	
; 2508 : 	return (phTTS->uiThreadError);
; 2509 : #endif
; 2510 : }

  00a65	83 c4 08	 add	 esp, 8
  00a68	c3		 ret	 0
_StartDecTalkSystemThread ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechShutdown
PUBLIC	_TextToSpeechCloseInMemory
EXTRN	__imp__IsBadWritePtr@8:NEAR
EXTRN	_ThreadLock:NEAR
EXTRN	_ThreadUnlock:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechShutdown PROC NEAR

; 2543 : {

  00a70	56		 push	 esi

; 2544 : 	/********************************************************************/
; 2545 : 	/*  Return error if invalid handle.                                 */
; 2546 : 	/********************************************************************/
; 2547 : 	
; 2548 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  00a71	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00a75	6a 04		 push	 4
  00a77	56		 push	 esi
  00a78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  00a7e	85 c0		 test	 eax, eax
  00a80	74 07		 je	 SHORT $L71802

; 2549 : 		return( MMSYSERR_INVALHANDLE );

  00a82	b8 05 00 00 00	 mov	 eax, 5
  00a87	5e		 pop	 esi

; 2601 : }

  00a88	c3		 ret	 0
$L71802:

; 2550 : 	
; 2551 : 	/********************************************************************/
; 2552 : 	/*  If the last item in the TextToSpeechStartup() function was      */
; 2553 : 	/*  initialized then reset the the Text-To-Speech system.           */
; 2554 : 	/********************************************************************/
; 2555 : 	
; 2556 : 	/* The if statement is not reqd as phTTSglobal is going to be oboselete for MI :MVP */
; 2557 : 	/*if ( phTTSglobal != NULL )*/
; 2558 : 	if(phTTS != NULL)

  00a89	85 f6		 test	 esi, esi
  00a8b	74 0b		 je	 SHORT $L71804

; 2559 : 		TextToSpeechReset( phTTS, TRUE );

  00a8d	6a 01		 push	 1
  00a8f	56		 push	 esi
  00a90	e8 00 00 00 00	 call	 _TextToSpeechReset
  00a95	83 c4 08	 add	 esp, 8
$L71804:

; 2560 : 	
; 2561 : #ifdef DTALK50
; 2562 : 	CPUnitAPI(phTTS->CPanelThread);       // Remove the Control Panel - KSB
; 2563 : #endif //DTALK50
; 2564 : 	
; 2565 : 	/********************************************************************/
; 2566 : 	/*  Delete any objects created by the TextToSpeechInMemory().       */
; 2567 : 	/*  function.                                                       */
; 2568 : 	/********************************************************************/
; 2569 : 	
; 2570 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  00a98	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  00a9f	75 09		 jne	 SHORT $L71805

; 2571 : 		TextToSpeechCloseInMemory( phTTS );

  00aa1	56		 push	 esi
  00aa2	e8 00 00 00 00	 call	 _TextToSpeechCloseInMemory
  00aa7	83 c4 04	 add	 esp, 4
$L71805:

; 2572 : 	
; 2573 : 	/********************************************************************/
; 2574 : 	/*  Delete all objects created in the TextToSpeechStartup()         */
; 2575 : 	/*  function.                                                       */
; 2576 : 	/********************************************************************/
; 2577 : 	// tek bats668 12may98 this must be decremented here to make sure 
; 2578 : 	// the dictionary gets unloaded.
; 2579 : 	// tek 27may98 bats 689:
; 2580 : 	// we need to lock around this to make sure we don't end up with a 
; 2581 : 	// startup and a shutdown colliding
; 2582 : #ifdef WIN32
; 2583 : 	ThreadLock(&tl_gnInstanceCounter,5); // tek 27may98 bats 689

  00aaa	6a 05		 push	 5
  00aac	68 00 00 00 00	 push	 OFFSET FLAT:_tl_gnInstanceCounter
  00ab1	e8 00 00 00 00	 call	 _ThreadLock

; 2584 : #endif
; 2585 : 	gnInstanceCounter--;     /* MVP: Decrement the instance counter */

  00ab6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gnInstanceCounter

; 2586 : 	
; 2587 : 	DeleteTextToSpeechObjects( phTTS );

  00abc	56		 push	 esi
  00abd	49		 dec	 ecx
  00abe	89 0d 00 00 00
	00		 mov	 DWORD PTR _gnInstanceCounter, ecx
  00ac4	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects

; 2588 : 	
; 2589 : #ifdef WIN32
; 2590 : 	ThreadUnlock(&tl_gnInstanceCounter); // tek 27may98 bats 689

  00ac9	68 00 00 00 00	 push	 OFFSET FLAT:_tl_gnInstanceCounter
  00ace	e8 00 00 00 00	 call	 _ThreadUnlock
  00ad3	83 c4 10	 add	 esp, 16			; 00000010H

; 2591 : #endif
; 2592 : 	
; 2593 : 	// release the license count..
; 2594 : #ifdef WIN32
; 2595 : #ifdef LICENSES
; 2596 : 	ReleaseLicenseRef();

  00ad6	e8 00 00 00 00	 call	 _ReleaseLicenseRef

; 2597 : #endif //LICENSES
; 2598 : #endif
; 2599 : 	
; 2600 : 	return( MMSYSERR_NOERROR );

  00adb	33 c0		 xor	 eax, eax
  00add	5e		 pop	 esi

; 2601 : }

  00ade	c3		 ret	 0
_TextToSpeechShutdown ENDP
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:NEAR
EXTRN	__imp__SetEvent@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	_write_pipe:NEAR
EXTRN	_exit_pipe:NEAR
EXTRN	_destroy_pipe:NEAR
EXTRN	_PA_DestroyPlayHandle:NEAR
EXTRN	__imp__SendMessageA@16:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	_FreePHInstanceData:NEAR
EXTRN	_unload_dictionary:NEAR
EXTRN	_FreeCMDThreadMemory:NEAR
EXTRN	__imp__UnregisterClassA@8:NEAR
EXTRN	_OP_DestroyMutex:NEAR
_DATA	SEGMENT
	ORG $+3
$SG71843 DB	'TextToSpeechWndClass', 00H
	ORG $+3
$SG71844 DB	'%s_%08X', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pCmd_t$ = -272
_dwDump$ = -268
_wDump$ = -280
_cDump$ = -284
_wndclass$ = -256
_DeleteTextToSpeechObjects PROC NEAR

; 2632 : {

  00ae0	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00ae6	53		 push	 ebx
  00ae7	55		 push	 ebp
  00ae8	56		 push	 esi

; 2633 : 	/* Added the following 2 varaibles for MI :MVP */
; 2634 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00ae9	8b b4 24 2c 01
	00 00		 mov	 esi, DWORD PTR _phTTS$[esp+292]

; 2635 : 	PVOID pCmd_t = phTTS->pCMDThreadData;
; 2636 : 	DWORD dwDump[3] = { 0x0b, 0x0b, 0x0b };  /*MVP not a static variable,is a const*/
; 2637 : 	WORD wDump[3] = { 0x0b, 0x0b, 0x0b };    /*MVP not a static variable,is a const*/
; 2638 : 	char cDump[3] = { 0x0b, 0x0b, 0x0b };    /*MVP not a static variable,is a const*/
; 2639 : #ifdef WIN32
; 2640 : 	HINSTANCE hInstance;	// 06may97 BATS320   
; 2641 : 	char wndclass[255];	// Window Class (KSB Aug-13-97)
; 2642 : #endif
; 2643 : #if defined __osf__ || defined __linux__
; 2644 : 	THREAD_STATUS_T ThreadStatus;
; 2645 : #endif
; 2646 : 	
; 2647 : 	/********************************************************************/
; 2648 : 	/*  Terminate all threads.                                          */
; 2649 : 	/********************************************************************/
; 2650 : 	
; 2651 : 	if ( pKsd_t->sync_pipe != NULL )

  00af0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CloseHandle@4
  00af6	57		 push	 edi
  00af7	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00afa	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00afd	89 44 24 1c	 mov	 DWORD PTR _pCmd_t$[esp+300], eax
  00b01	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00b06	89 44 24 20	 mov	 DWORD PTR _dwDump$[esp+300], eax
  00b0a	89 44 24 24	 mov	 DWORD PTR _dwDump$[esp+304], eax
  00b0e	89 44 24 28	 mov	 DWORD PTR _dwDump$[esp+308], eax
  00b12	66 89 44 24 14	 mov	 WORD PTR _wDump$[esp+300], ax
  00b17	66 89 44 24 16	 mov	 WORD PTR _wDump$[esp+302], ax
  00b1c	66 89 44 24 18	 mov	 WORD PTR _wDump$[esp+304], ax
  00b21	88 44 24 10	 mov	 BYTE PTR _cDump$[esp+300], al
  00b25	88 44 24 11	 mov	 BYTE PTR _cDump$[esp+301], al
  00b29	88 44 24 12	 mov	 BYTE PTR _cDump$[esp+302], al
  00b2d	8b 87 e0 00 00
	00		 mov	 eax, DWORD PTR [edi+224]
  00b33	33 ed		 xor	 ebp, ebp
  00b35	3b c5		 cmp	 eax, ebp
  00b37	0f 84 7f 01 00
	00		 je	 $L71833

; 2652 : 	{
; 2653 : 		/******************************************************************/
; 2654 : 		/*  Shut down the SYNC thread.                                    */
; 2655 : 		/******************************************************************/
; 2656 : 		
; 2657 : 		if ( phTTS->hThread_SYNC != NULL )

  00b3d	39 6e 34	 cmp	 DWORD PTR [esi+52], ebp
  00b40	74 31		 je	 SHORT $L71819

; 2658 : 		{
; 2659 : 												exit_pipe( pKsd_t->sync_pipe );

  00b42	50		 push	 eax
  00b43	e8 00 00 00 00	 call	 _exit_pipe

; 2660 : 												write_pipe( pKsd_t->sync_pipe, dwDump, 3 );

  00b48	8b 97 e0 00 00
	00		 mov	 edx, DWORD PTR [edi+224]
  00b4e	8d 4c 24 24	 lea	 ecx, DWORD PTR _dwDump$[esp+304]
  00b52	6a 03		 push	 3
  00b54	51		 push	 ecx
  00b55	52		 push	 edx
  00b56	e8 00 00 00 00	 call	 _write_pipe

; 2661 : #ifdef WIN32
; 2662 : 												WaitForSingleObject( phTTS->hThread_SYNC,
; 2663 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00b5b	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00b5e	83 c4 10	 add	 esp, 16			; 00000010H
  00b61	68 e8 03 00 00	 push	 1000			; 000003e8H
  00b66	50		 push	 eax
  00b67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 2664 : 												
; 2665 : 												CloseHandle( phTTS->hThread_SYNC );

  00b6d	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00b70	51		 push	 ecx
  00b71	ff d3		 call	 ebx
$L71819:

; 2666 : #endif
; 2667 : #if defined __osf__ || defined __linux__
; 2668 : 												OP_WaitForThreadTermination( phTTS->hThread_SYNC,
; 2669 : 													&ThreadStatus,
; 2670 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 2671 : #endif
; 2672 : 		}
; 2673 : 		
; 2674 : 		/******************************************************************/
; 2675 : 		/*  Shut down the VTM thread.                                     */
; 2676 : 		/******************************************************************/
; 2677 : 		
; 2678 : 		if ( phTTS->hThread_VTM != NULL )

  00b73	39 6e 30	 cmp	 DWORD PTR [esi+48], ebp
  00b76	74 4b		 je	 SHORT $L71821

; 2679 : 		{
; 2680 : 												exit_pipe( pKsd_t->vtm_pipe );

  00b78	8b 97 dc 00 00
	00		 mov	 edx, DWORD PTR [edi+220]
  00b7e	52		 push	 edx
  00b7f	e8 00 00 00 00	 call	 _exit_pipe

; 2681 : 												write_pipe( pKsd_t->vtm_pipe, wDump, 3 );

  00b84	8b 8f dc 00 00
	00		 mov	 ecx, DWORD PTR [edi+220]
  00b8a	8d 44 24 18	 lea	 eax, DWORD PTR _wDump$[esp+304]
  00b8e	6a 03		 push	 3
  00b90	50		 push	 eax
  00b91	51		 push	 ecx
  00b92	e8 00 00 00 00	 call	 _write_pipe

; 2682 : 												
; 2683 : 												/*MVP Free the allocated memory in LTS thread activity */
; 2684 : 												if(phTTS->pVTMThreadData)

  00b97	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00b9a	83 c4 10	 add	 esp, 16			; 00000010H
  00b9d	3b c5		 cmp	 eax, ebp
  00b9f	74 0d		 je	 SHORT $L71822

; 2685 : 												{
; 2686 : 													free(phTTS->pVTMThreadData);

  00ba1	50		 push	 eax
  00ba2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00ba8	83 c4 04	 add	 esp, 4

; 2687 : 													phTTS->pVTMThreadData = NULL;

  00bab	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
$L71822:

; 2688 : 												}
; 2689 : 												
; 2690 : #ifdef WIN32
; 2691 : 												WaitForSingleObject( phTTS->hThread_VTM,
; 2692 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00bae	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00bb1	68 e8 03 00 00	 push	 1000			; 000003e8H
  00bb6	52		 push	 edx
  00bb7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 2693 : 												
; 2694 : 												CloseHandle( phTTS->hThread_VTM );

  00bbd	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00bc0	50		 push	 eax
  00bc1	ff d3		 call	 ebx
$L71821:

; 2695 : #endif
; 2696 : #if defined __osf__ || defined __linux__
; 2697 : 												OP_WaitForThreadTermination( phTTS->hThread_VTM,
; 2698 : 													&ThreadStatus,
; 2699 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 2700 : #endif
; 2701 : 												
; 2702 : 		}
; 2703 : 		
; 2704 : 		/******************************************************************/
; 2705 : 		/*  Shut down the PH thread.                                      */
; 2706 : 		/******************************************************************/
; 2707 : 		
; 2708 : 		if ( phTTS->hThread_PH != NULL )

  00bc3	39 6e 2c	 cmp	 DWORD PTR [esi+44], ebp
  00bc6	74 4a		 je	 SHORT $L71825

; 2709 : 		{
; 2710 : 												exit_pipe( pKsd_t->ph_pipe );

  00bc8	8b 8f d4 00 00
	00		 mov	 ecx, DWORD PTR [edi+212]
  00bce	51		 push	 ecx
  00bcf	e8 00 00 00 00	 call	 _exit_pipe

; 2711 : 												write_pipe( pKsd_t->ph_pipe, wDump, 3 );

  00bd4	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00bda	8d 54 24 18	 lea	 edx, DWORD PTR _wDump$[esp+304]
  00bde	6a 03		 push	 3
  00be0	52		 push	 edx
  00be1	50		 push	 eax
  00be2	e8 00 00 00 00	 call	 _write_pipe

; 2712 : 												/*MVP Free the allocated memory in PH thread activity */
; 2713 : 												if(phTTS->pPHThreadData)

  00be7	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00bea	83 c4 10	 add	 esp, 16			; 00000010H
  00bed	3b c5		 cmp	 eax, ebp
  00bef	74 09		 je	 SHORT $L71826

; 2714 : 													FreePHInstanceData(phTTS->pPHThreadData); /* 04aug96 */

  00bf1	50		 push	 eax
  00bf2	e8 00 00 00 00	 call	 _FreePHInstanceData
  00bf7	83 c4 04	 add	 esp, 4
$L71826:

; 2715 : 												phTTS->pPHThreadData = NULL;
; 2716 : 												
; 2717 : #ifdef WIN32
; 2718 : 												WaitForSingleObject( phTTS->hThread_PH,
; 2719 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00bfa	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00bfd	68 e8 03 00 00	 push	 1000			; 000003e8H
  00c02	51		 push	 ecx
  00c03	89 6e 18	 mov	 DWORD PTR [esi+24], ebp
  00c06	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 2720 : 												
; 2721 : 												CloseHandle( phTTS->hThread_PH );

  00c0c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00c0f	52		 push	 edx
  00c10	ff d3		 call	 ebx
$L71825:

; 2722 : #endif
; 2723 : #if defined __osf__ || defined __linux__
; 2724 : 												OP_WaitForThreadTermination( phTTS->hThread_PH,
; 2725 : 													&ThreadStatus,
; 2726 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 2727 : #endif
; 2728 : 		}
; 2729 : 		
; 2730 : 		/******************************************************************/
; 2731 : 		/*  Shut down the LTS thread.                                     */
; 2732 : 		/******************************************************************/
; 2733 : 		
; 2734 : 		if ( phTTS->hThread_LTS != NULL )

  00c12	39 6e 28	 cmp	 DWORD PTR [esi+40], ebp
  00c15	74 4b		 je	 SHORT $L71829

; 2735 : 		{
; 2736 : 												exit_pipe( pKsd_t->lts_pipe );

  00c17	8b 87 d0 00 00
	00		 mov	 eax, DWORD PTR [edi+208]
  00c1d	50		 push	 eax
  00c1e	e8 00 00 00 00	 call	 _exit_pipe

; 2737 : 												write_pipe( pKsd_t->lts_pipe, wDump, 3 );

  00c23	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00c29	8d 4c 24 18	 lea	 ecx, DWORD PTR _wDump$[esp+304]
  00c2d	6a 03		 push	 3
  00c2f	51		 push	 ecx
  00c30	52		 push	 edx
  00c31	e8 00 00 00 00	 call	 _write_pipe

; 2738 : 												/*MVP Free the allocated memory in LTS thread activity */
; 2739 : 												if(phTTS->pLTSThreadData)

  00c36	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00c39	83 c4 10	 add	 esp, 16			; 00000010H
  00c3c	3b c5		 cmp	 eax, ebp
  00c3e	74 0a		 je	 SHORT $L71830

; 2740 : 													free(phTTS->pLTSThreadData);

  00c40	50		 push	 eax
  00c41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00c47	83 c4 04	 add	 esp, 4
$L71830:

; 2741 : 												phTTS->pLTSThreadData = NULL;
; 2742 : #ifdef WIN32
; 2743 : 												WaitForSingleObject( phTTS->hThread_LTS,
; 2744 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00c4a	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00c4d	68 e8 03 00 00	 push	 1000			; 000003e8H
  00c52	50		 push	 eax
  00c53	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
  00c56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 2745 : 												
; 2746 : 												CloseHandle( phTTS->hThread_LTS );

  00c5c	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00c5f	51		 push	 ecx
  00c60	ff d3		 call	 ebx
$L71829:

; 2747 : #endif
; 2748 : #if defined __osf__ || defined __linux__
; 2749 : 												OP_WaitForThreadTermination( phTTS->hThread_LTS,
; 2750 : 													&ThreadStatus,
; 2751 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 2752 : #endif
; 2753 : 		}
; 2754 : 
; 2755 : 		
; 2756 : 		/******************************************************************/
; 2757 : 		/*  Shut down the CMD thread.                                     */
; 2758 : 		/******************************************************************/
; 2759 : 		
; 2760 : 		if ( phTTS->hThread_CMD != NULL )

  00c62	39 6e 24	 cmp	 DWORD PTR [esi+36], ebp
  00c65	74 55		 je	 SHORT $L71833

; 2761 : 		{
; 2762 : 												exit_pipe( pKsd_t->cmd_pipe );

  00c67	8b 97 d8 00 00
	00		 mov	 edx, DWORD PTR [edi+216]
  00c6d	52		 push	 edx
  00c6e	e8 00 00 00 00	 call	 _exit_pipe

; 2763 : 												write_pipe( pKsd_t->cmd_pipe, cDump, 3 );

  00c73	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  00c79	8d 44 24 14	 lea	 eax, DWORD PTR _cDump$[esp+304]
  00c7d	6a 03		 push	 3
  00c7f	50		 push	 eax
  00c80	51		 push	 ecx
  00c81	e8 00 00 00 00	 call	 _write_pipe

; 2764 : 												/*MVP Free the allocated memory in CMD thread activity */
; 2765 : 												if(pCmd_t)

  00c86	8b 44 24 2c	 mov	 eax, DWORD PTR _pCmd_t$[esp+316]
  00c8a	83 c4 10	 add	 esp, 16			; 00000010H
  00c8d	3b c5		 cmp	 eax, ebp
  00c8f	74 09		 je	 SHORT $L71834

; 2766 : 													FreeCMDThreadMemory(pCmd_t);

  00c91	50		 push	 eax
  00c92	e8 00 00 00 00	 call	 _FreeCMDThreadMemory
  00c97	83 c4 04	 add	 esp, 4
$L71834:

; 2767 : 												phTTS->pCMDThreadData = pCmd_t = NULL;
; 2768 : 												
; 2769 : #ifdef WIN32
; 2770 : 												SetEvent( phTTS->hSyncEvent );

  00c9a	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00c9d	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00ca0	52		 push	 edx
  00ca1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 2771 : 												
; 2772 : 												WaitForSingleObject( phTTS->hThread_CMD,
; 2773 : 													TIMEOUT_INTERVAL_IN_MSEC );

  00ca7	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00caa	68 e8 03 00 00	 push	 1000			; 000003e8H
  00caf	50		 push	 eax
  00cb0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 2774 : 												
; 2775 : 												CloseHandle( phTTS->hThread_CMD );

  00cb6	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00cb9	51		 push	 ecx
  00cba	ff d3		 call	 ebx
$L71833:

; 2776 : #endif
; 2777 : #if defined __osf__ || defined __linux__
; 2778 : 												OP_SetEvent( phTTS->hSyncEvent );
; 2779 : 												
; 2780 : 												OP_WaitForThreadTermination( phTTS->hThread_CMD,
; 2781 : 													&ThreadStatus,
; 2782 : 													TIMEOUT_INTERVAL_IN_MSEC );
; 2783 : #endif
; 2784 : 		}
; 2785 :   }
; 2786 :   
; 2787 :   /********************************************************************/
; 2788 :   /*  Shutdown the Audio thread                                       */
; 2789 :   /********************************************************************/
; 2790 :   
; 2791 :   if ( phTTS->pAudioHandle != NULL )

  00cbc	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  00cc2	3b c5		 cmp	 eax, ebp
  00cc4	74 09		 je	 SHORT $L71837

; 2792 : 	  PA_DestroyPlayHandle( phTTS->pAudioHandle );

  00cc6	50		 push	 eax
  00cc7	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00ccc	83 c4 04	 add	 esp, 4
$L71837:

; 2793 :   
; 2794 :   /********************************************************************/
; 2795 :   /*  Terminate the Text-To-Speech thread.                            */
; 2796 :   /********************************************************************/
; 2797 :   
; 2798 :   // 06may97 tek BATS320
; 2799 :   // get the instance so that we can unregister the class
; 2800 :   // after the window is destroyed
; 2801 :   // tek 13nov97 we have no idea whether hWnd is valid, so use NULL.
; 2802 :   //hInstance = (HINSTANCE)GetWindowLong( phTTS->hWnd,
; 2803 :   //					GWL_HINSTANCE );
; 2804 : #ifdef WIN32
; 2805 :   hInstance = NULL;
; 2806 : #endif
; 2807 :   
; 2808 :   if ( phTTS->hThread_TXT != NULL )

  00ccf	39 6e 20	 cmp	 DWORD PTR [esi+32], ebp
  00cd2	74 4b		 je	 SHORT $L71840

; 2809 :   {
; 2810 : #if !defined __osf__ && !defined __linux__
; 2811 : 	  MMRESULT mmStatus=0;
; 2812 : 	  SendMessage( phTTS->hTextToSpeechWnd,
; 2813 : 		  ID_TTS_Destroy,
; 2814 : 		  0L,
; 2815 : 		  0L );

  00cd4	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00cd7	55		 push	 ebp
  00cd8	55		 push	 ebp
  00cd9	68 01 04 00 00	 push	 1025			; 00000401H
  00cde	52		 push	 edx
  00cdf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 2816 : 	  
; 2817 : 	  WaitForSingleObject( phTTS->hThread_TXT,
; 2818 : 		  TIMEOUT_INTERVAL_IN_MSEC );

  00ce5	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00ce8	68 e8 03 00 00	 push	 1000			; 000003e8H
  00ced	50		 push	 eax
  00cee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 2819 : 	  
; 2820 : 	  CloseHandle( phTTS->hThread_TXT );

  00cf4	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00cf7	51		 push	 ecx
  00cf8	ff d3		 call	 ebx

; 2821 : 	  sprintf(wndclass,"%s_%08X",TEXTTOSPEECHWNDCLASS,(unsigned long int) phTTS);

  00cfa	56		 push	 esi
  00cfb	68 00 00 00 00	 push	 OFFSET FLAT:$SG71843
  00d00	8d 54 24 34	 lea	 edx, DWORD PTR _wndclass$[esp+308]
  00d04	68 00 00 00 00	 push	 OFFSET FLAT:$SG71844
  00d09	52		 push	 edx
  00d0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00d10	83 c4 10	 add	 esp, 16			; 00000010H

; 2822 : 	  mmStatus = UnregisterClass(wndclass,hInstance);

  00d13	8d 44 24 2c	 lea	 eax, DWORD PTR _wndclass$[esp+300]
  00d17	55		 push	 ebp
  00d18	50		 push	 eax
  00d19	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
$L71840:

; 2823 : #endif
; 2824 : #if defined __osf__ || defined __linux__
; 2825 : 	  phTTS->uiTextThreadExit = TRUE;
; 2826 : 	  OP_SetEvent(phTTS->hTextInQueueEvent);
; 2827 : 	  OP_WaitForThreadTermination(phTTS->hThread_TXT, 
; 2828 : 		  &ThreadStatus, 
; 2829 : 		  OP_INFINITE);
; 2830 : 	  phTTS->hThread_TXT = NULL;
; 2831 : #endif	
; 2832 :   }
; 2833 :   
; 2834 :   /********************************************************************/
; 2835 :   /*  Free the handle to the "Not Emptying Vtm Pipe" event.           */
; 2836 :   /********************************************************************/
; 2837 :   
; 2838 :   if ( phTTS->hNotEmptyingVtmPipeEvent != NULL )

  00d1f	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00d22	3b c5		 cmp	 eax, ebp
  00d24	74 03		 je	 SHORT $L71846

; 2839 :   {
; 2840 : #ifdef WIN32
; 2841 : 	  CloseHandle( phTTS->hNotEmptyingVtmPipeEvent );

  00d26	50		 push	 eax
  00d27	ff d3		 call	 ebx
$L71846:

; 2842 : #endif
; 2843 : #if defined __osf__ || defined __linux__
; 2844 : 	  OP_DestroyEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 2845 : #endif
; 2846 :   }
; 2847 :   
; 2848 :   /********************************************************************/
; 2849 :   /*  Free the handle to the "Sync" event.                            */
; 2850 :   /********************************************************************/
; 2851 :   
; 2852 :   if ( phTTS->hSyncEvent != NULL )

  00d29	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00d2c	3b c5		 cmp	 eax, ebp
  00d2e	74 03		 je	 SHORT $L71848

; 2853 :   {
; 2854 : #ifdef WIN32
; 2855 : 	  CloseHandle( phTTS->hSyncEvent );

  00d30	50		 push	 eax
  00d31	ff d3		 call	 ebx
$L71848:

; 2856 : #endif
; 2857 : #if defined __osf__ || defined __linux__
; 2858 : 	  OP_DestroyEvent( phTTS->hSyncEvent );
; 2859 : #endif
; 2860 :   }
; 2861 :   
; 2862 : #if defined __osf__ || defined __linux__
; 2863 :   
; 2864 :   /********************************************************************/
; 2865 :   /*  Free the handle to the "TextInQueue" event.                     */
; 2866 :   /********************************************************************/
; 2867 :   
; 2868 :   if ( phTTS->hTextInQueueEvent != NULL )
; 2869 :   {
; 2870 : 	  OP_DestroyEvent( phTTS->hTextInQueueEvent );
; 2871 : 	  phTTS->hTextInQueueEvent = NULL;
; 2872 :   }
; 2873 : #endif
; 2874 :   
; 2875 :   /********************************************************************/
; 2876 :   /*  Free the handle to the "Successful Memory alloacation" event.   */
; 2877 :   /********************************************************************/
; 2878 :   
; 2879 :   if (phTTS->hMallocSuccessEvent != NULL)

  00d33	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00d36	3b c5		 cmp	 eax, ebp
  00d38	74 06		 je	 SHORT $L71850

; 2880 :   {
; 2881 : #ifdef WIN32
; 2882 : 	  CloseHandle(phTTS->hMallocSuccessEvent);

  00d3a	50		 push	 eax
  00d3b	ff d3		 call	 ebx

; 2883 : #endif
; 2884 : #if defined __osf__ || defined __linux__
; 2885 : 	  OP_DestroyEvent(phTTS->hMallocSuccessEvent);
; 2886 : #endif
; 2887 : 	  phTTS->hMallocSuccessEvent = NULL;

  00d3d	89 6e 1c	 mov	 DWORD PTR [esi+28], ebp
$L71850:

; 2888 : 	  
; 2889 :   }
; 2890 :   
; 2891 :   /********************************************************************/
; 2892 :   /*  Free the handle to the "TTS Callback Mutex .                    */
; 2893 :   /********************************************************************/
; 2894 :   
; 2895 : #ifdef WIN32
; 2896 :   if (phTTS->hmxCallback != NULL)

  00d40	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  00d46	3b c5		 cmp	 eax, ebp
  00d48	74 0f		 je	 SHORT $L71853

; 2897 :   {
; 2898 : 	  OP_DestroyMutex(phTTS->hmxCallback);    // tek 03aug96

  00d4a	50		 push	 eax
  00d4b	e8 00 00 00 00	 call	 _OP_DestroyMutex
  00d50	83 c4 04	 add	 esp, 4

; 2899 : 	  phTTS->hmxCallback = NULL;

  00d53	89 ae ac 00 00
	00		 mov	 DWORD PTR [esi+172], ebp
$L71853:

; 2900 :   }
; 2901 : #endif
; 2902 : #if defined __osf__ || defined __linux__
; 2903 :   if (phTTS->pcsCallback != NULL)
; 2904 :   {
; 2905 : 	  OP_DestroyMutex(phTTS->pcsCallback);
; 2906 : 	  phTTS->pcsCallback = NULL;
; 2907 :   }
; 2908 : #endif
; 2909 :   
; 2910 :   /********************************************************************/
; 2911 :   /*  Delete the log file critical section.                           */
; 2912 :   /********************************************************************/
; 2913 :   
; 2914 :   if ( phTTS->pcsLogFile != NULL )

  00d59	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  00d5f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeleteCriticalSection@4
  00d65	3b c5		 cmp	 eax, ebp
  00d67	74 13		 je	 SHORT $L71856

; 2915 :   {
; 2916 : #ifdef WIN32
; 2917 : 	  DeleteCriticalSection( phTTS->pcsLogFile );

  00d69	50		 push	 eax
  00d6a	ff d3		 call	 ebx

; 2918 : 	  
; 2919 : 	  free( phTTS->pcsLogFile );

  00d6c	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  00d72	51		 push	 ecx
  00d73	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00d79	83 c4 04	 add	 esp, 4
$L71856:

; 2920 : #endif
; 2921 : #if defined __osf__ || defined __linux__
; 2922 : 	  OP_DestroyMutex( phTTS->pcsLogFile );
; 2923 : #endif 
; 2924 : 	  
; 2925 :   }
; 2926 :   
; 2927 :   /********************************************************************/
; 2928 :   /*  Delete the queued character count critical section.             */
; 2929 :   /********************************************************************/
; 2930 :   
; 2931 :   if ( phTTS->pcsQueuedCharacterCount != NULL )

  00d7c	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00d82	3b c5		 cmp	 eax, ebp
  00d84	74 13		 je	 SHORT $L71858

; 2932 :   {
; 2933 : #ifdef WIN32
; 2934 : 	  DeleteCriticalSection( phTTS->pcsQueuedCharacterCount );

  00d86	50		 push	 eax
  00d87	ff d3		 call	 ebx

; 2935 : 	  
; 2936 : 	  free( phTTS->pcsQueuedCharacterCount );

  00d89	8b 96 c0 00 00
	00		 mov	 edx, DWORD PTR [esi+192]
  00d8f	52		 push	 edx
  00d90	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00d96	83 c4 04	 add	 esp, 4
$L71858:

; 2937 : #endif
; 2938 : #if defined __osf__ || defined __linux__
; 2939 : 	  OP_DestroyMutex( phTTS->pcsQueuedCharacterCount );
; 2940 : #endif
; 2941 :   }
; 2942 :   
; 2943 : #ifdef WIN32
; 2944 :   /* tek 6mar97 bats 278 */
; 2945 :   /********************************************************************/
; 2946 :   /*  Delete the index queue critical section.                        */
; 2947 :   /********************************************************************/
; 2948 :   
; 2949 :   if ( pKsd_t->pcsSpcPktSave != NULL )

  00d99	8b 87 80 01 00
	00		 mov	 eax, DWORD PTR [edi+384]
  00d9f	3b c5		 cmp	 eax, ebp
  00da1	74 19		 je	 SHORT $L71860

; 2950 :   {
; 2951 : 	  DeleteCriticalSection( pKsd_t->pcsSpcPktSave );

  00da3	50		 push	 eax
  00da4	ff d3		 call	 ebx

; 2952 : 	  
; 2953 : 	  free( pKsd_t->pcsSpcPktSave );

  00da6	8b 87 80 01 00
	00		 mov	 eax, DWORD PTR [edi+384]
  00dac	50		 push	 eax
  00dad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00db3	83 c4 04	 add	 esp, 4

; 2954 : 	  pKsd_t->pcsSpcPktSave = NULL;

  00db6	89 af 80 01 00
	00		 mov	 DWORD PTR [edi+384], ebp
$L71860:

; 2955 :   }
; 2956 : #endif
; 2957 :   
; 2958 :   
; 2959 :   /********************************************************************/
; 2960 :   /*  Delete the flush message number critical section.               */
; 2961 :   /********************************************************************/
; 2962 :   
; 2963 :   if ( phTTS->pcsFlushMsgNumber != NULL )

  00dbc	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  00dc2	3b c5		 cmp	 eax, ebp
  00dc4	74 13		 je	 SHORT $L71863

; 2964 :   {
; 2965 : #ifdef WIN32
; 2966 : 	  DeleteCriticalSection( phTTS->pcsFlushMsgNumber );

  00dc6	50		 push	 eax
  00dc7	ff d3		 call	 ebx

; 2967 : 	  
; 2968 : 	  free( phTTS->pcsFlushMsgNumber );

  00dc9	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  00dcf	51		 push	 ecx
  00dd0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00dd6	83 c4 04	 add	 esp, 4
$L71863:

; 2969 : #endif
; 2970 : #if defined __osf__ || defined __linux__
; 2971 : 	  OP_DestroyMutex( phTTS->pcsFlushMsgNumber );
; 2972 : #endif
; 2973 :   }
; 2974 :   
; 2975 : #if defined __osf__ || defined __linux__
; 2976 :   
; 2977 :   /********************************************************************/
; 2978 :   /*  Delete the Buffer Pipe mutex.                                   */
; 2979 :   /********************************************************************/
; 2980 :   
; 2981 :   if ( phTTS->pcsBufferPipe != NULL )
; 2982 :   {
; 2983 : 	  OP_DestroyMutex( phTTS->pcsBufferPipe );
; 2984 :   }
; 2985 :   
; 2986 :   /********************************************************************/
; 2987 :   /*  Delete the Text Msg mutex.                                      */
; 2988 :   /********************************************************************/
; 2989 :   
; 2990 :   if ( phTTS->pcsTextMsgList != NULL )
; 2991 :   {
; 2992 : 	  OP_DestroyMutex( phTTS->pcsTextMsgList );
; 2993 :   }
; 2994 : #endif
; 2995 :   
; 2996 :   /********************************************************************/
; 2997 :   /*  Delete the last queued text message number critical section.    */
; 2998 :   /********************************************************************/
; 2999 :   
; 3000 :   if ( phTTS->pcsLastQueuedTextMsgNumber != NULL )

  00dd9	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  00ddf	3b c5		 cmp	 eax, ebp
  00de1	74 13		 je	 SHORT $L71865

; 3001 :   {
; 3002 : #ifdef WIN32
; 3003 : 	  DeleteCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  00de3	50		 push	 eax
  00de4	ff d3		 call	 ebx

; 3004 : 	  
; 3005 : 	  free( phTTS->pcsLastQueuedTextMsgNumber );

  00de6	8b 96 b8 00 00
	00		 mov	 edx, DWORD PTR [esi+184]
  00dec	52		 push	 edx
  00ded	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00df3	83 c4 04	 add	 esp, 4
$L71865:

; 3006 : #endif
; 3007 : #if defined __osf__ || defined __linux__
; 3008 : 	  OP_DestroyMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3009 : #endif
; 3010 :   }
; 3011 :   
; 3012 :   /********************************************************************/
; 3013 :   /*  Delete the queued sample count critical section.                */
; 3014 :   /********************************************************************/
; 3015 :   
; 3016 :   if ( phTTS->pcsQueuedSampleCount != NULL )

  00df6	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  00dfc	3b c5		 cmp	 eax, ebp
  00dfe	74 13		 je	 SHORT $L71867

; 3017 :   {
; 3018 : #ifdef WIN32
; 3019 : 	  DeleteCriticalSection( phTTS->pcsQueuedSampleCount );

  00e00	50		 push	 eax
  00e01	ff d3		 call	 ebx

; 3020 : 	  
; 3021 : 	  free( phTTS->pcsQueuedSampleCount );

  00e03	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  00e09	50		 push	 eax
  00e0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00e10	83 c4 04	 add	 esp, 4
$L71867:

; 3022 :   }
; 3023 :   
; 3024 :   // tek 24oct97 bats 497 delete and deallocate this critical section object
; 3025 :   if ( pKsd_t->pcsVtmPipeRead != NULL )

  00e13	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  00e19	3b c5		 cmp	 eax, ebp
  00e1b	74 1d		 je	 SHORT $L73197

; 3026 :   {
; 3027 : 	  DeleteCriticalSection( pKsd_t->pcsVtmPipeRead );

  00e1d	50		 push	 eax
  00e1e	ff d3		 call	 ebx

; 3028 : 	  
; 3029 : 	  free( pKsd_t->pcsVtmPipeRead );

  00e20	8b 8f f4 00 00
	00		 mov	 ecx, DWORD PTR [edi+244]
  00e26	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  00e2c	51		 push	 ecx
  00e2d	ff d3		 call	 ebx
  00e2f	83 c4 04	 add	 esp, 4

; 3030 : 	  pKsd_t->pcsVtmPipeRead = NULL;

  00e32	89 af f4 00 00
	00		 mov	 DWORD PTR [edi+244], ebp
  00e38	eb 06		 jmp	 SHORT $L71869
$L73197:
  00e3a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
$L71869:

; 3031 :   }
; 3032 :   // tek 24oct97 end of bats 497
; 3033 : #endif
; 3034 : #if defined __osf__ || defined __linux__
; 3035 :   OP_DestroyMutex( phTTS->pcsQueuedSampleCount );
; 3036 :   }
; 3037 : #endif
; 3038 :   
; 3039 :   /********************************************************************/
; 3040 :   /*  Free the dictionary memory.                                     */
; 3041 :   /********************************************************************/
; 3042 :   /*MVP : Unload dictionary when no other instance of DECtalk speech  */
; 3043 :   /*      object is running                                           */
; 3044 :   
; 3045 :   if(!gnInstanceCounter)        

  00e40	39 2d 00 00 00
	00		 cmp	 DWORD PTR _gnInstanceCounter, ebp
  00e46	75 2b		 jne	 SHORT $L71872

; 3046 :   {
; 3047 : 	  /* GL 11/05/1997  for BATS#510 */
; 3048 : 	  if ( pKsd_t->fdic_entries[pKsd_t->lang_curr] != 0 )

  00e48	8b 87 f8 00 00
	00		 mov	 eax, DWORD PTR [edi+248]
  00e4e	8b 54 87 1c	 mov	 edx, DWORD PTR [edi+eax*4+28]
  00e52	8d 4c 87 1c	 lea	 ecx, DWORD PTR [edi+eax*4+28]
  00e56	3b d5		 cmp	 edx, ebp
  00e58	74 19		 je	 SHORT $L71872

; 3049 : 	  {
; 3050 : 		  unload_dictionary((void **)&(pKsd_t->fdic[pKsd_t->lang_curr]),
; 3051 : 			  (unsigned int *)&(pKsd_t->fdic_entries[pKsd_t->lang_curr]));

  00e5a	8d 14 87	 lea	 edx, DWORD PTR [edi+eax*4]
  00e5d	51		 push	 ecx
  00e5e	52		 push	 edx
  00e5f	e8 00 00 00 00	 call	 _unload_dictionary
  00e64	83 c4 08	 add	 esp, 8

; 3052 : 		  gpufdic = NULL;

  00e67	89 2d 00 00 00
	00		 mov	 DWORD PTR _gpufdic, ebp

; 3053 : 		  gufdic_entries = 0;

  00e6d	89 2d 00 00 00
	00		 mov	 DWORD PTR _gufdic_entries, ebp
$L71872:

; 3054 : 	  }
; 3055 :   }
; 3056 :   
; 3057 :   /********************************************************************/
; 3058 :   /*  Free the user dictionary memory.                                */
; 3059 :   /********************************************************************/
; 3060 :   
; 3061 :   /* GL 11/05/1997  for BATS#510 */
; 3062 :   if ( pKsd_t->udic_entries[pKsd_t->lang_curr] != 0 )

  00e73	8b 87 f8 00 00
	00		 mov	 eax, DWORD PTR [edi+248]
  00e79	8b 54 87 54	 mov	 edx, DWORD PTR [edi+eax*4+84]
  00e7d	8d 4c 87 54	 lea	 ecx, DWORD PTR [edi+eax*4+84]
  00e81	3b d5		 cmp	 edx, ebp
  00e83	74 0e		 je	 SHORT $L71876

; 3063 :   {
; 3064 : 	  unload_dictionary((void **)&pKsd_t->udic[pKsd_t->lang_curr],
; 3065 : 		  (unsigned int *)&pKsd_t->udic_entries[pKsd_t->lang_curr] );

  00e85	8d 44 87 38	 lea	 eax, DWORD PTR [edi+eax*4+56]
  00e89	51		 push	 ecx
  00e8a	50		 push	 eax
  00e8b	e8 00 00 00 00	 call	 _unload_dictionary
  00e90	83 c4 08	 add	 esp, 8
$L71876:

; 3066 :   }
; 3067 :   
; 3068 :   /********************************************************************/
; 3069 :   /*  Destroy all the pipes.                                          */
; 3070 :   /********************************************************************/
; 3071 :   /* tek 30aug96 be kind; NULL the pointers when done.. */
; 3072 :   if ( pKsd_t->sync_pipe != NULL )

  00e93	8b 87 e0 00 00
	00		 mov	 eax, DWORD PTR [edi+224]
  00e99	3b c5		 cmp	 eax, ebp
  00e9b	74 0f		 je	 SHORT $L71880

; 3073 :   {
; 3074 : 	  destroy_pipe( pKsd_t->sync_pipe );

  00e9d	50		 push	 eax
  00e9e	e8 00 00 00 00	 call	 _destroy_pipe
  00ea3	83 c4 04	 add	 esp, 4

; 3075 : 	  pKsd_t->sync_pipe = NULL;

  00ea6	89 af e0 00 00
	00		 mov	 DWORD PTR [edi+224], ebp
$L71880:

; 3076 :   }
; 3077 :   
; 3078 :   if ( pKsd_t->vtm_pipe != NULL )

  00eac	8b 87 dc 00 00
	00		 mov	 eax, DWORD PTR [edi+220]
  00eb2	3b c5		 cmp	 eax, ebp
  00eb4	74 0f		 je	 SHORT $L71883

; 3079 :   {
; 3080 : 	  destroy_pipe( pKsd_t->vtm_pipe );

  00eb6	50		 push	 eax
  00eb7	e8 00 00 00 00	 call	 _destroy_pipe
  00ebc	83 c4 04	 add	 esp, 4

; 3081 : 	  pKsd_t->vtm_pipe = NULL;

  00ebf	89 af dc 00 00
	00		 mov	 DWORD PTR [edi+220], ebp
$L71883:

; 3082 :   }
; 3083 :   
; 3084 :   if ( pKsd_t->ph_pipe != NULL )

  00ec5	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00ecb	3b c5		 cmp	 eax, ebp
  00ecd	74 0f		 je	 SHORT $L71886

; 3085 :   {
; 3086 : 	  destroy_pipe( pKsd_t->ph_pipe );

  00ecf	50		 push	 eax
  00ed0	e8 00 00 00 00	 call	 _destroy_pipe
  00ed5	83 c4 04	 add	 esp, 4

; 3087 : 	  pKsd_t->ph_pipe = NULL;

  00ed8	89 af d4 00 00
	00		 mov	 DWORD PTR [edi+212], ebp
$L71886:

; 3088 :   }
; 3089 :   
; 3090 :   if ( pKsd_t->lts_pipe != NULL )

  00ede	8b 87 d0 00 00
	00		 mov	 eax, DWORD PTR [edi+208]
  00ee4	3b c5		 cmp	 eax, ebp
  00ee6	74 0f		 je	 SHORT $L71889

; 3091 :   {
; 3092 : 	  destroy_pipe( pKsd_t->lts_pipe );

  00ee8	50		 push	 eax
  00ee9	e8 00 00 00 00	 call	 _destroy_pipe
  00eee	83 c4 04	 add	 esp, 4

; 3093 : 	  pKsd_t->lts_pipe = NULL;

  00ef1	89 af d0 00 00
	00		 mov	 DWORD PTR [edi+208], ebp
$L71889:

; 3094 :   }
; 3095 :   
; 3096 :   if ( pKsd_t->cmd_pipe != NULL )

  00ef7	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  00efd	3b c5		 cmp	 eax, ebp
  00eff	74 0f		 je	 SHORT $L71892

; 3097 :   {
; 3098 : 	  destroy_pipe( pKsd_t->cmd_pipe );

  00f01	50		 push	 eax
  00f02	e8 00 00 00 00	 call	 _destroy_pipe
  00f07	83 c4 04	 add	 esp, 4

; 3099 : 	  pKsd_t->cmd_pipe = NULL;

  00f0a	89 af d8 00 00
	00		 mov	 DWORD PTR [edi+216], ebp
$L71892:

; 3100 :   }
; 3101 :   
; 3102 :   /********************************************************************/
; 3103 :   /* Free the "loaded_languages" element of Kernel_share_data structure*/
; 3104 :   /* This element have been allocated in Kernel sub-system in usa_init*/
; 3105 :   /* function. MVP MI                                                 */
; 3106 :   /********************************************************************/
; 3107 :   if(pKsd_t->loaded_languages != NULL)  

  00f10	8b 87 54 04 00
	00		 mov	 eax, DWORD PTR [edi+1108]
  00f16	3b c5		 cmp	 eax, ebp
  00f18	74 0c		 je	 SHORT $L71895

; 3108 :   {
; 3109 : 	  free(pKsd_t->loaded_languages);

  00f1a	50		 push	 eax
  00f1b	ff d3		 call	 ebx
  00f1d	83 c4 04	 add	 esp, 4

; 3110 : 	  pKsd_t->loaded_languages = NULL;

  00f20	89 af 54 04 00
	00		 mov	 DWORD PTR [edi+1108], ebp
$L71895:

; 3111 :   }
; 3112 :   
; 3113 :   /********************************************************************/
; 3114 :   /* Free the kernel_share_data element in TTS structure for MI :MVP  */
; 3115 :   /********************************************************************/
; 3116 :   if(phTTS->pKernelShareData != NULL)

  00f26	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00f29	3b c5		 cmp	 eax, ebp
  00f2b	74 09		 je	 SHORT $L71898

; 3117 :   {
; 3118 : 	  free(phTTS->pKernelShareData);

  00f2d	50		 push	 eax
  00f2e	ff d3		 call	 ebx
  00f30	83 c4 04	 add	 esp, 4

; 3119 : 	  phTTS->pKernelShareData = NULL;

  00f33	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
$L71898:

; 3120 :   }
; 3121 :   
; 3122 :   /********************************************************************/
; 3123 :   /*  Free the TTS handle structure.                                  */
; 3124 :   /********************************************************************/
; 3125 :   
; 3126 :   free( phTTS );

  00f36	56		 push	 esi
  00f37	ff d3		 call	 ebx
  00f39	83 c4 04	 add	 esp, 4
  00f3c	5f		 pop	 edi
  00f3d	5e		 pop	 esi
  00f3e	5d		 pop	 ebp
  00f3f	5b		 pop	 ebx

; 3127 :   phTTS=NULL;
; 3128 :   
; 3129 :   return;
; 3130 : }

  00f40	81 c4 1c 01 00
	00		 add	 esp, 284		; 0000011cH
  00f46	c3		 ret	 0
_DeleteTextToSpeechObjects ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSpeak
PUBLIC	_TextToSpeechSpeakEx
_TEXT	SEGMENT
_phTTS$ = 8
_pszTextString$ = 12
_dwFlags$ = 16
_TextToSpeechSpeak PROC NEAR

; 3193 : {

  00f50	56		 push	 esi

; 3194 : 
; 3195 : #ifdef UNDER_CE	//01jan99 mfg convert unicode string to char string for Windows CE
; 3196 : char string[16384];
; 3197 : 
; 3198 : WideStringtoAsciiString(string, pszTextString, 16384);
; 3199 : #endif
; 3200 : 
; 3201 : 	/********************************************************************/
; 3202 : 	/*  Return error if invalid handle.                                 */
; 3203 : 	/********************************************************************/
; 3204 : #ifdef WIN32
; 3205 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  00f51	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00f55	6a 04		 push	 4
  00f57	56		 push	 esi
  00f58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  00f5e	85 c0		 test	 eax, eax
  00f60	74 07		 je	 SHORT $L71908

; 3206 : 		return( MMSYSERR_INVALHANDLE );

  00f62	b8 05 00 00 00	 mov	 eax, 5
  00f67	5e		 pop	 esi

; 3222 : 		// will break existing apps.. sigh..
; 3223 : 	}
; 3224 : #endif
; 3225 : #if defined __osf__ || defined __linux__
; 3226 : 	char proc_name[]="TextToSpeechSpeak";
; 3227 : 	int uiTextLength = 0;
; 3228 : 	unsigned char * pText;
; 3229 : 	LPTEXT_MSG_T pTextMsg;
; 3230 : 	LPTEXT_MSG_T pNextTextMsg;
; 3231 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 3232 : 	const char cForce2 = (char)(SYNC);
; 3233 : 	
; 3234 : #ifdef TTSDBG
; 3235 : 	printf("%s\n",proc_name);
; 3236 : #endif
; 3237 : 	
; 3238 : 	/********************************************************************/
; 3239 : 	/*  Return error if NULL handle.                                    */
; 3240 : 	/********************************************************************/
; 3241 : 	if (phTTS == NULL)
; 3242 : 		return( MMSYSERR_INVALHANDLE );
; 3243 : 	
; 3244 : 	/********************************************************************/
; 3245 : 	/*  Allocate the memory locked Text Message structure.              */
; 3246 : 	/********************************************************************/
; 3247 : 	
; 3248 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 3249 : 	
; 3250 : 	if ( pTextMsg == NULL )
; 3251 : 		return( MMSYSERR_NOMEM );
; 3252 : 	
; 3253 : 	pTextMsg->pLink = NULL;
; 3254 : 	
; 3255 : 	/********************************************************************/
; 3256 : 	/*  Adjust string length for force character.                       */
; 3257 : 	/********************************************************************/
; 3258 : 	
; 3259 : 	uiTextLength = strlen(pszTextString);
; 3260 : 	
; 3261 : 	if( dwFlags & TTS_FORCE )
; 3262 : 	{
; 3263 : 		uiTextLength++;
; 3264 : 	}
; 3265 : 	
; 3266 : 	/********************************************************************/
; 3267 : 	/*  If the text length is zero then exit with success.              */
; 3268 : 	/********************************************************************/
; 3269 : 	
; 3270 : 	if ( uiTextLength == 0 )
; 3271 : 	{
; 3272 : 		free( pTextMsg );
; 3273 : 		return MMSYSERR_NOERROR;
; 3274 : 	}
; 3275 : 	
; 3276 : 	/********************************************************************/
; 3277 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 3278 : 	/*  location in case the force character is appended to the text    */
; 3279 : 	/*  string.                                                         */
; 3280 : 	/********************************************************************/
; 3281 : 	
; 3282 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 3283 : 	
; 3284 : 	if ( pText == NULL )
; 3285 : 	{ 
; 3286 : 		free( pTextMsg );
; 3287 : 		return( MMSYSERR_NOMEM );
; 3288 : 	} 
; 3289 : 	
; 3290 : 	/********************************************************************/
; 3291 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 3292 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 3293 : 	/*  should not be used after the call to the function.              */
; 3294 : 	/********************************************************************/
; 3295 : 	
; 3296 : 	strcpy( pText, pszTextString );
; 3297 : 	
; 3298 : 	/********************************************************************/
; 3299 : 	/*  Conditionally append the force character to the text.           */
; 3300 : 	/********************************************************************/
; 3301 : 	
; 3302 : 	if( dwFlags & TTS_FORCE )
; 3303 : 	{
; 3304 : 		pText[uiTextLength-1] = cForce;
; 3305 : 	}
; 3306 : 	
; 3307 : 	pTextMsg->pText = pText;
; 3308 : 	pTextMsg->uiLength = uiTextLength;
; 3309 : 	
; 3310 :     // tek 01sep98
; 3311 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 3312 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 3313 : 	phTTS->uiCurrentMsgNumber++;
; 3314 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 3315 : 	
; 3316 : 	/********************************************************************/
; 3317 : 	/*  Increment the queued character count.                           */
; 3318 : 	/********************************************************************/
; 3319 : 	
; 3320 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 3321 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 3322 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 3323 : 	
; 3324 : 	/*
; 3325 : 	* keep track of what we've queued so that we can 
; 3326 : 	* sync correctly
; 3327 : 	* (tek 11aug98)
; 3328 : 	*/
; 3329 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3330 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 3331 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3332 : 
; 3333 : 	/********************************************************************/
; 3334 : 	/*  Add the text message to the text-message linked list.           */
; 3335 : 	/********************************************************************/
; 3336 : 	
; 3337 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 3338 : 	
; 3339 : 	/********************************************************************/
; 3340 : 	/*  Put the Text Message at the end of the linked list.             */
; 3341 : 	/********************************************************************/
; 3342 : 	
; 3343 : 	if ( phTTS->pTextMsgList == NULL )
; 3344 : 	{
; 3345 : 		phTTS->pTextMsgList = pTextMsg;
; 3346 : 	}
; 3347 : 	else
; 3348 : 	{
; 3349 : 		pNextTextMsg = phTTS->pTextMsgList;
; 3350 : 		
; 3351 : 		while ( pNextTextMsg->pLink != NULL )
; 3352 : 		{
; 3353 : 			pNextTextMsg = pNextTextMsg->pLink;
; 3354 : 		}
; 3355 : 		
; 3356 : 		pNextTextMsg->pLink = pTextMsg;
; 3357 : 	}
; 3358 : 	
; 3359 : 	/********************************************************************/
; 3360 : 	/*  Set the Text In Queue event.                                    */
; 3361 : 	/********************************************************************/
; 3362 : 	
; 3363 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 3364 : 	
; 3365 : 	/********************************************************************/
; 3366 : 	/*  Unlock the text-message linked list.                            */
; 3367 : 	/********************************************************************/
; 3368 : 	
; 3369 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 3370 : 	
; 3371 : 	return( MMSYSERR_NOERROR );
; 3372 : #endif
; 3373 : 	
; 3374 : }

  00f68	c3		 ret	 0
$L71908:

; 3207 : 	
; 3208 : 	if (!phTTS->bInReset)

  00f69	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  00f6f	85 c0		 test	 eax, eax
  00f71	75 17		 jne	 SHORT $L71909

; 3209 : 	{
; 3210 : 		return (TextToSpeechSpeakEx( phTTS,
; 3211 : #ifdef UNDER_CE
; 3212 : 				string,
; 3213 : #else
; 3214 : 				pszTextString,
; 3215 : #endif
; 3216 : 				dwFlags,
; 3217 : 				TRUE));

  00f73	8b 44 24 10	 mov	 eax, DWORD PTR _dwFlags$[esp]
  00f77	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pszTextString$[esp]
  00f7b	6a 01		 push	 1
  00f7d	50		 push	 eax
  00f7e	51		 push	 ecx
  00f7f	56		 push	 esi
  00f80	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx
  00f85	83 c4 10	 add	 esp, 16			; 00000010H
  00f88	5e		 pop	 esi

; 3222 : 		// will break existing apps.. sigh..
; 3223 : 	}
; 3224 : #endif
; 3225 : #if defined __osf__ || defined __linux__
; 3226 : 	char proc_name[]="TextToSpeechSpeak";
; 3227 : 	int uiTextLength = 0;
; 3228 : 	unsigned char * pText;
; 3229 : 	LPTEXT_MSG_T pTextMsg;
; 3230 : 	LPTEXT_MSG_T pNextTextMsg;
; 3231 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 3232 : 	const char cForce2 = (char)(SYNC);
; 3233 : 	
; 3234 : #ifdef TTSDBG
; 3235 : 	printf("%s\n",proc_name);
; 3236 : #endif
; 3237 : 	
; 3238 : 	/********************************************************************/
; 3239 : 	/*  Return error if NULL handle.                                    */
; 3240 : 	/********************************************************************/
; 3241 : 	if (phTTS == NULL)
; 3242 : 		return( MMSYSERR_INVALHANDLE );
; 3243 : 	
; 3244 : 	/********************************************************************/
; 3245 : 	/*  Allocate the memory locked Text Message structure.              */
; 3246 : 	/********************************************************************/
; 3247 : 	
; 3248 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 3249 : 	
; 3250 : 	if ( pTextMsg == NULL )
; 3251 : 		return( MMSYSERR_NOMEM );
; 3252 : 	
; 3253 : 	pTextMsg->pLink = NULL;
; 3254 : 	
; 3255 : 	/********************************************************************/
; 3256 : 	/*  Adjust string length for force character.                       */
; 3257 : 	/********************************************************************/
; 3258 : 	
; 3259 : 	uiTextLength = strlen(pszTextString);
; 3260 : 	
; 3261 : 	if( dwFlags & TTS_FORCE )
; 3262 : 	{
; 3263 : 		uiTextLength++;
; 3264 : 	}
; 3265 : 	
; 3266 : 	/********************************************************************/
; 3267 : 	/*  If the text length is zero then exit with success.              */
; 3268 : 	/********************************************************************/
; 3269 : 	
; 3270 : 	if ( uiTextLength == 0 )
; 3271 : 	{
; 3272 : 		free( pTextMsg );
; 3273 : 		return MMSYSERR_NOERROR;
; 3274 : 	}
; 3275 : 	
; 3276 : 	/********************************************************************/
; 3277 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 3278 : 	/*  location in case the force character is appended to the text    */
; 3279 : 	/*  string.                                                         */
; 3280 : 	/********************************************************************/
; 3281 : 	
; 3282 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 3283 : 	
; 3284 : 	if ( pText == NULL )
; 3285 : 	{ 
; 3286 : 		free( pTextMsg );
; 3287 : 		return( MMSYSERR_NOMEM );
; 3288 : 	} 
; 3289 : 	
; 3290 : 	/********************************************************************/
; 3291 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 3292 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 3293 : 	/*  should not be used after the call to the function.              */
; 3294 : 	/********************************************************************/
; 3295 : 	
; 3296 : 	strcpy( pText, pszTextString );
; 3297 : 	
; 3298 : 	/********************************************************************/
; 3299 : 	/*  Conditionally append the force character to the text.           */
; 3300 : 	/********************************************************************/
; 3301 : 	
; 3302 : 	if( dwFlags & TTS_FORCE )
; 3303 : 	{
; 3304 : 		pText[uiTextLength-1] = cForce;
; 3305 : 	}
; 3306 : 	
; 3307 : 	pTextMsg->pText = pText;
; 3308 : 	pTextMsg->uiLength = uiTextLength;
; 3309 : 	
; 3310 :     // tek 01sep98
; 3311 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 3312 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 3313 : 	phTTS->uiCurrentMsgNumber++;
; 3314 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 3315 : 	
; 3316 : 	/********************************************************************/
; 3317 : 	/*  Increment the queued character count.                           */
; 3318 : 	/********************************************************************/
; 3319 : 	
; 3320 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 3321 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 3322 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 3323 : 	
; 3324 : 	/*
; 3325 : 	* keep track of what we've queued so that we can 
; 3326 : 	* sync correctly
; 3327 : 	* (tek 11aug98)
; 3328 : 	*/
; 3329 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3330 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 3331 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3332 : 
; 3333 : 	/********************************************************************/
; 3334 : 	/*  Add the text message to the text-message linked list.           */
; 3335 : 	/********************************************************************/
; 3336 : 	
; 3337 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 3338 : 	
; 3339 : 	/********************************************************************/
; 3340 : 	/*  Put the Text Message at the end of the linked list.             */
; 3341 : 	/********************************************************************/
; 3342 : 	
; 3343 : 	if ( phTTS->pTextMsgList == NULL )
; 3344 : 	{
; 3345 : 		phTTS->pTextMsgList = pTextMsg;
; 3346 : 	}
; 3347 : 	else
; 3348 : 	{
; 3349 : 		pNextTextMsg = phTTS->pTextMsgList;
; 3350 : 		
; 3351 : 		while ( pNextTextMsg->pLink != NULL )
; 3352 : 		{
; 3353 : 			pNextTextMsg = pNextTextMsg->pLink;
; 3354 : 		}
; 3355 : 		
; 3356 : 		pNextTextMsg->pLink = pTextMsg;
; 3357 : 	}
; 3358 : 	
; 3359 : 	/********************************************************************/
; 3360 : 	/*  Set the Text In Queue event.                                    */
; 3361 : 	/********************************************************************/
; 3362 : 	
; 3363 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 3364 : 	
; 3365 : 	/********************************************************************/
; 3366 : 	/*  Unlock the text-message linked list.                            */
; 3367 : 	/********************************************************************/
; 3368 : 	
; 3369 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 3370 : 	
; 3371 : 	return( MMSYSERR_NOERROR );
; 3372 : #endif
; 3373 : 	
; 3374 : }

  00f89	c3		 ret	 0
$L71909:

; 3218 : 	}
; 3219 : 	else
; 3220 : 	{
; 3221 : 		return (MMSYSERR_NOERROR); // _HANDLEBUSY would be better, but

  00f8a	33 c0		 xor	 eax, eax
  00f8c	5e		 pop	 esi

; 3222 : 		// will break existing apps.. sigh..
; 3223 : 	}
; 3224 : #endif
; 3225 : #if defined __osf__ || defined __linux__
; 3226 : 	char proc_name[]="TextToSpeechSpeak";
; 3227 : 	int uiTextLength = 0;
; 3228 : 	unsigned char * pText;
; 3229 : 	LPTEXT_MSG_T pTextMsg;
; 3230 : 	LPTEXT_MSG_T pNextTextMsg;
; 3231 : 	static char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 3232 : 	const char cForce2 = (char)(SYNC);
; 3233 : 	
; 3234 : #ifdef TTSDBG
; 3235 : 	printf("%s\n",proc_name);
; 3236 : #endif
; 3237 : 	
; 3238 : 	/********************************************************************/
; 3239 : 	/*  Return error if NULL handle.                                    */
; 3240 : 	/********************************************************************/
; 3241 : 	if (phTTS == NULL)
; 3242 : 		return( MMSYSERR_INVALHANDLE );
; 3243 : 	
; 3244 : 	/********************************************************************/
; 3245 : 	/*  Allocate the memory locked Text Message structure.              */
; 3246 : 	/********************************************************************/
; 3247 : 	
; 3248 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));
; 3249 : 	
; 3250 : 	if ( pTextMsg == NULL )
; 3251 : 		return( MMSYSERR_NOMEM );
; 3252 : 	
; 3253 : 	pTextMsg->pLink = NULL;
; 3254 : 	
; 3255 : 	/********************************************************************/
; 3256 : 	/*  Adjust string length for force character.                       */
; 3257 : 	/********************************************************************/
; 3258 : 	
; 3259 : 	uiTextLength = strlen(pszTextString);
; 3260 : 	
; 3261 : 	if( dwFlags & TTS_FORCE )
; 3262 : 	{
; 3263 : 		uiTextLength++;
; 3264 : 	}
; 3265 : 	
; 3266 : 	/********************************************************************/
; 3267 : 	/*  If the text length is zero then exit with success.              */
; 3268 : 	/********************************************************************/
; 3269 : 	
; 3270 : 	if ( uiTextLength == 0 )
; 3271 : 	{
; 3272 : 		free( pTextMsg );
; 3273 : 		return MMSYSERR_NOERROR;
; 3274 : 	}
; 3275 : 	
; 3276 : 	/********************************************************************/
; 3277 : 	/*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
; 3278 : 	/*  location in case the force character is appended to the text    */
; 3279 : 	/*  string.                                                         */
; 3280 : 	/********************************************************************/
; 3281 : 	
; 3282 : 	pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );
; 3283 : 	
; 3284 : 	if ( pText == NULL )
; 3285 : 	{ 
; 3286 : 		free( pTextMsg );
; 3287 : 		return( MMSYSERR_NOMEM );
; 3288 : 	} 
; 3289 : 	
; 3290 : 	/********************************************************************/
; 3291 : 	/*  The memory pointed to by pTextMsg and text is                   */
; 3292 : 	/*  deallocated in the Text-To-Speech text thread and it            */
; 3293 : 	/*  should not be used after the call to the function.              */
; 3294 : 	/********************************************************************/
; 3295 : 	
; 3296 : 	strcpy( pText, pszTextString );
; 3297 : 	
; 3298 : 	/********************************************************************/
; 3299 : 	/*  Conditionally append the force character to the text.           */
; 3300 : 	/********************************************************************/
; 3301 : 	
; 3302 : 	if( dwFlags & TTS_FORCE )
; 3303 : 	{
; 3304 : 		pText[uiTextLength-1] = cForce;
; 3305 : 	}
; 3306 : 	
; 3307 : 	pTextMsg->pText = pText;
; 3308 : 	pTextMsg->uiLength = uiTextLength;
; 3309 : 	
; 3310 :     // tek 01sep98
; 3311 : 	OP_LockMutex( phTTS->pcsFlushMsgNumber );
; 3312 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
; 3313 : 	phTTS->uiCurrentMsgNumber++;
; 3314 : 	OP_UnlockMutex( phTTS->pcsFlushMsgNumber );
; 3315 : 	
; 3316 : 	/********************************************************************/
; 3317 : 	/*  Increment the queued character count.                           */
; 3318 : 	/********************************************************************/
; 3319 : 	
; 3320 : 	OP_LockMutex( phTTS->pcsQueuedCharacterCount );
; 3321 : 	phTTS->uiQueuedCharacterCount += uiTextLength;
; 3322 : 	OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
; 3323 : 	
; 3324 : 	/*
; 3325 : 	* keep track of what we've queued so that we can 
; 3326 : 	* sync correctly
; 3327 : 	* (tek 11aug98)
; 3328 : 	*/
; 3329 : 	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3330 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 3331 : 	OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
; 3332 : 
; 3333 : 	/********************************************************************/
; 3334 : 	/*  Add the text message to the text-message linked list.           */
; 3335 : 	/********************************************************************/
; 3336 : 	
; 3337 : 	OP_LockMutex( phTTS->pcsTextMsgList );
; 3338 : 	
; 3339 : 	/********************************************************************/
; 3340 : 	/*  Put the Text Message at the end of the linked list.             */
; 3341 : 	/********************************************************************/
; 3342 : 	
; 3343 : 	if ( phTTS->pTextMsgList == NULL )
; 3344 : 	{
; 3345 : 		phTTS->pTextMsgList = pTextMsg;
; 3346 : 	}
; 3347 : 	else
; 3348 : 	{
; 3349 : 		pNextTextMsg = phTTS->pTextMsgList;
; 3350 : 		
; 3351 : 		while ( pNextTextMsg->pLink != NULL )
; 3352 : 		{
; 3353 : 			pNextTextMsg = pNextTextMsg->pLink;
; 3354 : 		}
; 3355 : 		
; 3356 : 		pNextTextMsg->pLink = pTextMsg;
; 3357 : 	}
; 3358 : 	
; 3359 : 	/********************************************************************/
; 3360 : 	/*  Set the Text In Queue event.                                    */
; 3361 : 	/********************************************************************/
; 3362 : 	
; 3363 : 	OP_SetEvent( phTTS->hTextInQueueEvent );
; 3364 : 	
; 3365 : 	/********************************************************************/
; 3366 : 	/*  Unlock the text-message linked list.                            */
; 3367 : 	/********************************************************************/
; 3368 : 	
; 3369 : 	OP_UnlockMutex( phTTS->pcsTextMsgList );
; 3370 : 	
; 3371 : 	return( MMSYSERR_NOERROR );
; 3372 : #endif
; 3373 : 	
; 3374 : }

  00f8d	c3		 ret	 0
_TextToSpeechSpeak ENDP
_TEXT	ENDS
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pszTextString$ = 12
_dwFlags$ = 16
_TextToSpeechSpeakEx PROC NEAR

; 3381 : {

  00f90	53		 push	 ebx
  00f91	55		 push	 ebp
  00f92	56		 push	 esi

; 3382 : 	UINT i;
; 3383 : 	UINT uiLength;
; 3384 : 	unsigned char * pTextBuffer;
; 3385 : 	TEXT_MSG_T * pTextMsg;
; 3386 : 	const char cForce = (char)((PFASCII<<PSFONT)+0xb);
; 3387 : 	const char cForce2 = (char)(SYNC);
; 3388 : 	
; 3389 : 	
; 3390 : 	
; 3391 : 	
; 3392 : 	/********************************************************************/
; 3393 : 	/*  Return error if invalid handle.                                 */
; 3394 : 	/********************************************************************/
; 3395 : 	
; 3396 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  00f93	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  00f97	57		 push	 edi
  00f98	6a 04		 push	 4
  00f9a	56		 push	 esi
  00f9b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  00fa1	85 c0		 test	 eax, eax
  00fa3	74 0a		 je	 SHORT $L71928
  00fa5	5f		 pop	 edi
  00fa6	5e		 pop	 esi
  00fa7	5d		 pop	 ebp

; 3397 : 		return( MMSYSERR_INVALHANDLE );

  00fa8	b8 05 00 00 00	 mov	 eax, 5
  00fad	5b		 pop	 ebx

; 3552 : }

  00fae	c3		 ret	 0
$L71928:

; 3398 : 	
; 3399 : #ifdef TYPING_MODE
; 3400 : 	// tek 06nov97 (during BATS508)
; 3401 : 	// we have to clear out the typing mode flag here, because if
; 3402 : 	// we don't we can end up with a message queued but still do
; 3403 : 	// a typing-mode fast reset (which will leave this sneak
; 3404 : 	// message inside the synthesizer)
; 3405 : 	phTTS->bInTypingMode = FALSE;
; 3406 : #endif TYPING_MODE
; 3407 : 	
; 3408 : 	/********************************************************************/
; 3409 : 	/*  Allocate the Text Message structure.                            */
; 3410 : 	/********************************************************************/
; 3411 : 	
; 3412 : 	pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));

  00faf	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__malloc
  00fb5	6a 0c		 push	 12			; 0000000cH
  00fb7	c7 86 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+212], 0
  00fc1	ff d5		 call	 ebp
  00fc3	8b d8		 mov	 ebx, eax
  00fc5	83 c4 04	 add	 esp, 4

; 3413 : 	
; 3414 : 	if ( pTextMsg == NULL )

  00fc8	85 db		 test	 ebx, ebx
  00fca	75 0a		 jne	 SHORT $L71932
  00fcc	5f		 pop	 edi
  00fcd	5e		 pop	 esi
  00fce	5d		 pop	 ebp

; 3415 : 		return( MMSYSERR_NOMEM );

  00fcf	b8 07 00 00 00	 mov	 eax, 7
  00fd4	5b		 pop	 ebx

; 3552 : }

  00fd5	c3		 ret	 0
$L71932:

; 3416 : 	
; 3417 : 	/********************************************************************/
; 3418 : 	/*  Get the character string length.                                */
; 3419 : 	/********************************************************************/
; 3420 : 	
; 3421 : 	uiLength = strlen( pszTextString );

  00fd6	8b 7c 24 18	 mov	 edi, DWORD PTR _pszTextString$[esp+12]
  00fda	83 c9 ff	 or	 ecx, -1
  00fdd	33 c0		 xor	 eax, eax
  00fdf	f2 ae		 repne scasb
  00fe1	f7 d1		 not	 ecx
  00fe3	49		 dec	 ecx
  00fe4	8b f9		 mov	 edi, ecx

; 3422 : 	
; 3423 : 	/********************************************************************/
; 3424 : 	/*  Allocate the pipe text buffer. Allocate 1 extra location in     */
; 3425 : 	/*  case the force character is appended to the text string.        */
; 3426 : 	/* now allocate 2 extra for the two forcing chars.. tex 16aug96     */
; 3427 : 	/********************************************************************/
; 3428 : 	
; 3429 : 	pTextBuffer = (unsigned char *)malloc(( uiLength + 2 ) * sizeof(char));

  00fe6	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00fe9	50		 push	 eax
  00fea	ff d5		 call	 ebp
  00fec	8b e8		 mov	 ebp, eax
  00fee	83 c4 04	 add	 esp, 4

; 3430 : 	
; 3431 : 	if ( pTextBuffer == NULL )

  00ff1	85 ed		 test	 ebp, ebp
  00ff3	75 14		 jne	 SHORT $L71936

; 3432 : 	{
; 3433 : 		free( pTextMsg );

  00ff5	53		 push	 ebx
  00ff6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00ffc	83 c4 04	 add	 esp, 4

; 3434 : 		return( MMSYSERR_NOMEM );

  00fff	b8 07 00 00 00	 mov	 eax, 7
  01004	5f		 pop	 edi
  01005	5e		 pop	 esi
  01006	5d		 pop	 ebp
  01007	5b		 pop	 ebx

; 3552 : }

  01008	c3		 ret	 0
$L71936:

; 3435 : 	}
; 3436 : 	
; 3437 : 	/********************************************************************/
; 3438 : 	/*  The memory pointed to by pTextMsg and pTextBuffer is            */
; 3439 : 	/*  deallocated in the Text To Speech thread window procedure and   */
; 3440 : 	/*  should not be used after the call to the SendMessage()          */
; 3441 : 	/*  function.                                                       */
; 3442 : 	/********************************************************************/
; 3443 : 	
; 3444 : 	for ( i = 0; i < uiLength; i++ )

  01009	85 ff		 test	 edi, edi
  0100b	76 1d		 jbe	 SHORT $L71939
  0100d	8b 4c 24 18	 mov	 ecx, DWORD PTR _pszTextString$[esp+12]
  01011	8b c5		 mov	 eax, ebp
  01013	2b cd		 sub	 ecx, ebp
  01015	89 7c 24 18	 mov	 DWORD PTR 12+[esp+12], edi
$L71937:

; 3445 : 		pTextBuffer[i] = pszTextString[i];

  01019	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0101c	88 10		 mov	 BYTE PTR [eax], dl
  0101e	8b 54 24 18	 mov	 edx, DWORD PTR 12+[esp+12]
  01022	40		 inc	 eax
  01023	4a		 dec	 edx
  01024	89 54 24 18	 mov	 DWORD PTR 12+[esp+12], edx
  01028	75 ef		 jne	 SHORT $L71937
$L71939:

; 3446 : 	
; 3447 : 	/********************************************************************/
; 3448 : 	/*  Conditionally append the force character to the text.           */
; 3449 : 	/********************************************************************/
; 3450 : 	
; 3451 : 	if ( dwFlags & TTS_FORCE )

  0102a	f6 44 24 1c 01	 test	 BYTE PTR _dwFlags$[esp+12], 1
  0102f	74 0a		 je	 SHORT $L71940

; 3452 : 	{
; 3453 : 		pTextBuffer[uiLength] = cForce;

  01031	c6 04 2f 0b	 mov	 BYTE PTR [edi+ebp], 11	; 0000000bH

; 3454 : 		uiLength++;

  01035	47		 inc	 edi

; 3455 : 		pTextBuffer[uiLength] = cForce2;

  01036	c6 04 2f 0a	 mov	 BYTE PTR [edi+ebp], 10	; 0000000aH

; 3456 : 		uiLength++;

  0103a	47		 inc	 edi
$L71940:

; 3457 : 	}
; 3458 : 	// tek 05nov97 bats472 we have to do all message numbering and 
; 3459 : 	// queueing under a critical section, so that we are absolutely
; 3460 : 	// sure that the numbers will be monotonically increasing; if 
; 3461 : 	// they aren't. WaitForTextQueueingToComplete will end up 
; 3462 : 	// waiting forever.
; 3463 : 
; 3464 : 	EnterCriticalSection( phTTS->pcsQueuedCharacterCount );

  0103b	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  01041	50		 push	 eax
  01042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 3465 : 
; 3466 : 	/********************************************************************/
; 3467 : 	/*  Set up the Text Message structure.                              */
; 3468 : 	/*  The message number is used in the Text-To-Speech thread to      */
; 3469 : 	/*  to throw away window messages which are received after          */
; 3470 : 	/*  TextToSpeechReset() is called.                                  */
; 3471 : 	/********************************************************************/
; 3472 : 	
; 3473 : 	pTextMsg->pText = pTextBuffer;

  01048	89 6b 08	 mov	 DWORD PTR [ebx+8], ebp

; 3474 : 	pTextMsg->uiLength = uiLength;

  0104b	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 3475 : 	
; 3476 : 	EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  0104e	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  01054	51		 push	 ecx
  01055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 3477 : 
; 3478 : 	pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;

  0105b	8b 56 44	 mov	 edx, DWORD PTR [esi+68]

; 3479 : 	phTTS->uiCurrentMsgNumber++;
; 3480 : 
; 3481 : 	LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  0105e	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__LeaveCriticalSection@4
  01064	89 13		 mov	 DWORD PTR [ebx], edx
  01066	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  01069	40		 inc	 eax
  0106a	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0106d	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  01073	50		 push	 eax
  01074	ff d5		 call	 ebp

; 3482 : 
; 3483 : 	// tek 16jun97 bats 385 moves the store/increment inside the CS
; 3484 : 	
; 3485 : 	/********************************************************************/
; 3486 : 	/*  Save this message number in the Text-To-Speech handle for       */
; 3487 : 	/*  the TextToSpeechSync() function.                                */
; 3488 : 	/********************************************************************/
; 3489 : 	
; 3490 : 	phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;
; 3491 : 	
; 3492 : 	/********************************************************************/
; 3493 : 	/*  Accumulate the queued character count.                          */
; 3494 : 	/********************************************************************/
; 3495 : 	
; 3496 : 	//tek bats472: move this up to before the point where we 
; 3497 : 	// take a number
; 3498 : 	//EnterCriticalSection( phTTS->pcsQueuedCharacterCount );
; 3499 : 	phTTS->uiQueuedCharacterCount += uiLength;

  01076	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  01079	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0107b	03 d7		 add	 edx, edi

; 3500 : 	// tek bats472: move this to after the PostMessage.
; 3501 : 	//LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );
; 3502 : #ifdef API_DEBUG
; 3503 : 	{
; 3504 : 		char szTemp[256]="";
; 3505 : 		char szTemp2[128]="";
; 3506 : 		int	i=0;
; 3507 : 		for (i=0;i<127 && i<pTextMsg->uiLength ;i++)
; 3508 : 		{
; 3509 : 			if (!isprint(pTextBuffer[i]))
; 3510 : 			{
; 3511 : 				szTemp2[i]='.';
; 3512 : 			}
; 3513 : 			else
; 3514 : 			{
; 3515 : 				szTemp2[i]=pTextBuffer[i];
; 3516 : 			}
; 3517 : 		}
; 3518 : 		szTemp2[i]='\0';
; 3519 : 		sprintf(szTemp,"  .. TTSMessage %u posting. [%s]\n",
; 3520 : 			pTextMsg->uiMsgNumber,
; 3521 : 			szTemp2);
; 3522 : 		OutputDebugString(szTemp);
; 3523 : 	}
; 3524 : #endif //API_DEBUG
; 3525 : 	/********************************************************************/
; 3526 : 	/*  Send the structure pointed to by pTextMsg to the text thread.   */
; 3527 : 	/********************************************************************/
; 3528 : 	
; 3529 : 	PostMessage( phTTS->hTextToSpeechWnd,
; 3530 : 		ID_TTS_Queue_Text,
; 3531 : 		0L,
; 3532 : 		(LPARAM)pTextMsg );

  0107d	53		 push	 ebx
  0107e	89 56 40	 mov	 DWORD PTR [esi+64], edx
  01081	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01084	6a 00		 push	 0
  01086	68 00 04 00 00	 push	 1024			; 00000400H
  0108b	52		 push	 edx
  0108c	89 4e 48	 mov	 DWORD PTR [esi+72], ecx
  0108f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 3533 : 	// tek bats472: OK to do this now.
; 3534 : 	LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );

  01095	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  0109b	50		 push	 eax
  0109c	ff d5		 call	 ebp
  0109e	5f		 pop	 edi
  0109f	5e		 pop	 esi
  010a0	5d		 pop	 ebp

; 3535 : 	/********************************************************************/
; 3536 : 	/*  Re-enable error messages in the audio thread. The audio thread  */
; 3537 : 	/*  disables the audio error handler after sending a message. This  */
; 3538 : 	/*  is done to ensure that the application only receives at most    */
; 3539 : 	/*  only one error message per call to the TextToSpeechSpeak()      */
; 3540 : 	/*  function. Otherwise a message would be sent each time the audio */
; 3541 : 	/*  thread was unable to open the audio device.                     */
; 3542 : 	/********************************************************************/
; 3543 : 	
; 3544 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
; 3545 : 	{
; 3546 : #ifndef OLEDECTALK
; 3547 : 		//  EnableAudioErrorMessage( phTTS->pAudioHandle );
; 3548 : #endif //OLEDECTALK
; 3549 : 	}
; 3550 : 	
; 3551 : 	return( MMSYSERR_NOERROR );

  010a1	33 c0		 xor	 eax, eax
  010a3	5b		 pop	 ebx

; 3552 : }

  010a4	c3		 ret	 0
_TextToSpeechSpeakEx ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechPause
EXTRN	_PA_Pause:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechPause PROC NEAR

; 3587 : {

  010b0	56		 push	 esi

; 3588 : 	MMRESULT mmStatus;
; 3589 : 	
; 3590 : 	/********************************************************************/
; 3591 : 	/*  Return error if invalid handle.                                 */
; 3592 : 	/********************************************************************/
; 3593 : 	
; 3594 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  010b1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  010b5	6a 04		 push	 4
  010b7	56		 push	 esi
  010b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  010be	85 c0		 test	 eax, eax
  010c0	74 07		 je	 SHORT $L71947

; 3595 : 	{
; 3596 : 		mmStatus = MMSYSERR_INVALHANDLE;

  010c2	b8 05 00 00 00	 mov	 eax, 5
  010c7	5e		 pop	 esi

; 3602 : #endif //OLEDECTALK
; 3603 : 	}
; 3604 : 	return( mmStatus );
; 3605 : }

  010c8	c3		 ret	 0
$L71947:

; 3597 : 	}
; 3598 : 	else
; 3599 : 	{
; 3600 : #ifndef OLEDECTALK
; 3601 : 		mmStatus = PA_Pause( phTTS->pAudioHandle );

  010c9	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  010cf	50		 push	 eax
  010d0	e8 00 00 00 00	 call	 _PA_Pause
  010d5	83 c4 04	 add	 esp, 4
  010d8	5e		 pop	 esi

; 3602 : #endif //OLEDECTALK
; 3603 : 	}
; 3604 : 	return( mmStatus );
; 3605 : }

  010d9	c3		 ret	 0
_TextToSpeechPause ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechResume
EXTRN	_PA_Resume:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechResume PROC NEAR

; 3639 : {

  010e0	56		 push	 esi

; 3640 : 	MMRESULT mmStatus;
; 3641 : 	
; 3642 : 	/********************************************************************/
; 3643 : 	/*  Return error if invalid handle.                                 */
; 3644 : 	/********************************************************************/
; 3645 : 	
; 3646 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  010e1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  010e5	6a 04		 push	 4
  010e7	56		 push	 esi
  010e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  010ee	85 c0		 test	 eax, eax
  010f0	74 07		 je	 SHORT $L71953

; 3647 : 	{
; 3648 : 		mmStatus = MMSYSERR_INVALHANDLE;

  010f2	b8 05 00 00 00	 mov	 eax, 5
  010f7	5e		 pop	 esi

; 3654 : #endif //OLEDECTALK
; 3655 : 	}
; 3656 : 	return( mmStatus );
; 3657 : }

  010f8	c3		 ret	 0
$L71953:

; 3649 : 	}
; 3650 : 	else
; 3651 : 	{
; 3652 : #ifndef OLEDECTALK
; 3653 : 		mmStatus = PA_Resume( phTTS->pAudioHandle );

  010f9	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  010ff	50		 push	 eax
  01100	e8 00 00 00 00	 call	 _PA_Resume
  01105	83 c4 04	 add	 esp, 4
  01108	5e		 pop	 esi

; 3654 : #endif //OLEDECTALK
; 3655 : 	}
; 3656 : 	return( mmStatus );
; 3657 : }

  01109	c3		 ret	 0
_TextToSpeechResume ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenWaveOutFile
PUBLIC	_TextToSpeechSync
EXTRN	__imp__fwrite:NEAR
EXTRN	_SetSampleRate:NEAR
_DATA	SEGMENT
$SG71981 DB	'wb', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pszFileName$ = 12
_dwFormat$ = 16
_TextToSpeechOpenWaveOutFile PROC NEAR

; 3717 : {

  01110	53		 push	 ebx
  01111	55		 push	 ebp
  01112	56		 push	 esi
  01113	57		 push	 edi

; 3718 :   MMRESULT mmStatus;
; 3719 :   WAVE_FILE_HDR_T * pWaveFileHdr;
; 3720 : #ifdef UNDER_CE
; 3721 :   DWORD dwRW;
; 3722 : #endif
; 3723 : 
; 3724 : 	/********************************************************************/
; 3725 : 	/*  Return error if invalid handle.                                 */
; 3726 : 	/********************************************************************/
; 3727 : 	
; 3728 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01114	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  01118	6a 04		 push	 4
  0111a	57		 push	 edi
  0111b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01121	85 c0		 test	 eax, eax
  01123	74 0a		 je	 SHORT $L71964
  01125	5f		 pop	 edi
  01126	5e		 pop	 esi
  01127	5d		 pop	 ebp

; 3729 : 		return( MMSYSERR_INVALHANDLE );

  01128	b8 05 00 00 00	 mov	 eax, 5
  0112d	5b		 pop	 ebx

; 3870 : }

  0112e	c3		 ret	 0
$L71964:

; 3730 : 	
; 3731 : 	/********************************************************************/
; 3732 : 	/*  If a file is already open, then don't try to open another one.  */
; 3733 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 3734 : 	/*  an error.                                                       */
; 3735 : 	/********************************************************************/
; 3736 : 	
; 3737 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 3738 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  0112f	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  01135	33 ed		 xor	 ebp, ebp
  01137	3b c5		 cmp	 eax, ebp
  01139	74 0f		 je	 SHORT $L71965
  0113b	83 f8 04	 cmp	 eax, 4
  0113e	74 0a		 je	 SHORT $L71965
  01140	5f		 pop	 edi
  01141	5e		 pop	 esi
  01142	5d		 pop	 ebp

; 3739 : 		return( MMSYSERR_ALLOCATED );

  01143	b8 04 00 00 00	 mov	 eax, 4
  01148	5b		 pop	 ebx

; 3870 : }

  01149	c3		 ret	 0
$L71965:

; 3740 : 	
; 3741 : 	/********************************************************************/
; 3742 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 3743 : 	/*  function have completed.                                        */
; 3744 : 	/********************************************************************/
; 3745 : 	
; 3746 : 	mmStatus = TextToSpeechSync( phTTS );

  0114a	57		 push	 edi
  0114b	e8 00 00 00 00	 call	 _TextToSpeechSync
  01150	83 c4 04	 add	 esp, 4

; 3747 : 	
; 3748 : 	if ( mmStatus )

  01153	3b c5		 cmp	 eax, ebp

; 3749 : 		return( mmStatus );

  01155	0f 85 57 01 00
	00		 jne	 $L71961

; 3750 : 	
; 3751 : 	/********************************************************************/
; 3752 : 	/*  Create the header for the output file                           */
; 3753 : 	/********************************************************************/
; 3754 : 	
; 3755 : 	pWaveFileHdr = (WAVE_FILE_HDR_T *) malloc( sizeof(WAVE_FILE_HDR_T));

  0115b	6a 2c		 push	 44			; 0000002cH
  0115d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  01163	8b f0		 mov	 esi, eax
  01165	83 c4 04	 add	 esp, 4

; 3756 : 	
; 3757 : 	if ( pWaveFileHdr == NULL )

  01168	3b f5		 cmp	 esi, ebp
  0116a	75 0a		 jne	 SHORT $L71970
  0116c	5f		 pop	 edi
  0116d	5e		 pop	 esi
  0116e	5d		 pop	 ebp

; 3758 : 		return( MMSYSERR_NOMEM );

  0116f	b8 07 00 00 00	 mov	 eax, 7
  01174	5b		 pop	 ebx

; 3870 : }

  01175	c3		 ret	 0
$L71970:

; 3759 : 	
; 3760 : 	/* MVP: Initialize the Wave_File_header's common elements for all waveformats.*/
; 3761 : 	/*{ "RIFF", 0, "WAVEfmt ", 16, 1, 1, 11025, 11025, 1, 8, "data", 0 };*/
; 3762 : 	pWaveFileHdr->psRiff[0] = 'R';
; 3763 : 	pWaveFileHdr->psRiff[1] = 'I';
; 3764 : 	pWaveFileHdr->psRiff[2] = 'F';

  01176	b0 46		 mov	 al, 70			; 00000046H

; 3765 : 	pWaveFileHdr->psRiff[3] = 'F';
; 3766 : 	pWaveFileHdr->dwRiffChunkSize = 0;

  01178	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  0117b	88 46 02	 mov	 BYTE PTR [esi+2], al
  0117e	88 46 03	 mov	 BYTE PTR [esi+3], al

; 3767 : 	pWaveFileHdr->psWaveFmt[0] = 'W';
; 3768 : 	pWaveFileHdr->psWaveFmt[1] = 'A';
; 3769 : 	pWaveFileHdr->psWaveFmt[2] = 'V';
; 3770 : 	pWaveFileHdr->psWaveFmt[3] = 'E';
; 3771 : 	pWaveFileHdr->psWaveFmt[4] = 'f';
; 3772 : 	pWaveFileHdr->psWaveFmt[5] = 'm';
; 3773 : 	pWaveFileHdr->psWaveFmt[6] = 't';
; 3774 : 	pWaveFileHdr->psWaveFmt[7] = ' ';
; 3775 : 	pWaveFileHdr->dwWaveChunkSize = 16;
; 3776 : 	pWaveFileHdr->wNumberOfChannels = 1;
; 3777 : 	pWaveFileHdr->psData[0] = 'd';
; 3778 : 	pWaveFileHdr->psData[1] = 'a';

  01181	b0 61		 mov	 al, 97			; 00000061H

; 3779 : 	pWaveFileHdr->psData[2] = 't';
; 3780 : 	pWaveFileHdr->psData[3] = 'a';
; 3781 : 	pWaveFileHdr->dwDataChunkSize = 0;

  01183	89 6e 28	 mov	 DWORD PTR [esi+40], ebp

; 3782 : 	
; 3783 : 	/********************************************************************/
; 3784 : 	/*  If the dwFormat value is invalid then return an error.          */
; 3785 : 	/********************************************************************/
; 3786 : 	
; 3787 : 	switch( dwFormat )
; 3788 : 	{

  01186	8b 6c 24 1c	 mov	 ebp, DWORD PTR _dwFormat$[esp+12]
  0118a	88 46 25	 mov	 BYTE PTR [esi+37], al
  0118d	88 46 27	 mov	 BYTE PTR [esi+39], al
  01190	8b c5		 mov	 eax, ebp
  01192	b1 74		 mov	 cl, 116			; 00000074H
  01194	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  01199	bb 01 00 00 00	 mov	 ebx, 1
  0119e	48		 dec	 eax
  0119f	c6 06 52	 mov	 BYTE PTR [esi], 82	; 00000052H
  011a2	c6 46 01 49	 mov	 BYTE PTR [esi+1], 73	; 00000049H
  011a6	c6 46 08 57	 mov	 BYTE PTR [esi+8], 87	; 00000057H
  011aa	c6 46 09 41	 mov	 BYTE PTR [esi+9], 65	; 00000041H
  011ae	c6 46 0a 56	 mov	 BYTE PTR [esi+10], 86	; 00000056H
  011b2	c6 46 0b 45	 mov	 BYTE PTR [esi+11], 69	; 00000045H
  011b6	c6 46 0c 66	 mov	 BYTE PTR [esi+12], 102	; 00000066H
  011ba	c6 46 0d 6d	 mov	 BYTE PTR [esi+13], 109	; 0000006dH
  011be	88 4e 0e	 mov	 BYTE PTR [esi+14], cl
  011c1	c6 46 0f 20	 mov	 BYTE PTR [esi+15], 32	; 00000020H
  011c5	89 56 10	 mov	 DWORD PTR [esi+16], edx
  011c8	66 89 5e 16	 mov	 WORD PTR [esi+22], bx
  011cc	c6 46 24 64	 mov	 BYTE PTR [esi+36], 100	; 00000064H
  011d0	88 4e 26	 mov	 BYTE PTR [esi+38], cl
  011d3	74 4a		 je	 SHORT $L71976
  011d5	83 e8 03	 sub	 eax, 3
  011d8	74 26		 je	 SHORT $L71975
  011da	83 e8 03	 sub	 eax, 3
  011dd	74 14		 je	 SHORT $L71977

; 3824 : 		
; 3825 : 	default:
; 3826 : 		
; 3827 : 		free( pWaveFileHdr );

  011df	56		 push	 esi
  011e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  011e6	83 c4 04	 add	 esp, 4

; 3828 : 		return( MMSYSERR_INVALPARAM );

  011e9	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  011ee	5f		 pop	 edi
  011ef	5e		 pop	 esi
  011f0	5d		 pop	 ebp
  011f1	5b		 pop	 ebx

; 3870 : }

  011f2	c3		 ret	 0
$L71977:

; 3810 : 		
; 3811 : 		break;
; 3812 : 		
; 3813 : 	case WAVE_FORMAT_08M08:
; 3814 : 		
; 3815 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_MULAW;

  011f3	66 c7 46 14 07
	00		 mov	 WORD PTR [esi+20], 7

; 3816 : 		pWaveFileHdr->dwSamplesPerSecond = MULAW_SAMPLE_RATE;

  011f9	b8 40 1f 00 00	 mov	 eax, 8000		; 00001f40H

; 3817 : 		pWaveFileHdr->dwAvgBytesPerSecond = MULAW_SAMPLE_RATE;
; 3818 : 		pWaveFileHdr->wNumberBlockAlign = 1;
; 3819 : 		pWaveFileHdr->wBitsPerSample = 8;
; 3820 : 		
; 3821 : 		SetSampleRate( phTTS, MULAW_SAMPLE_RATE );
; 3822 : 		
; 3823 : 		break;

  011fe	eb 28		 jmp	 SHORT $L73205
$L71975:

; 3789 : 	case WAVE_FORMAT_1M16:
; 3790 : 		
; 3791 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_PCM;
; 3792 : 		pWaveFileHdr->dwSamplesPerSecond = PC_SAMPLE_RATE;

  01200	b8 11 2b 00 00	 mov	 eax, 11025		; 00002b11H
  01205	66 89 5e 14	 mov	 WORD PTR [esi+20], bx
  01209	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 3793 : 		pWaveFileHdr->dwAvgBytesPerSecond = PC_SAMPLE_RATE + PC_SAMPLE_RATE;

  0120c	c7 46 1c 22 56
	00 00		 mov	 DWORD PTR [esi+28], 22050 ; 00005622H

; 3794 : 		pWaveFileHdr->wNumberBlockAlign = 2;

  01213	66 c7 46 20 02
	00		 mov	 WORD PTR [esi+32], 2

; 3795 : 		pWaveFileHdr->wBitsPerSample = 16;

  01219	66 89 56 22	 mov	 WORD PTR [esi+34], dx

; 3796 : 		
; 3797 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 3798 : 		
; 3799 : 		break;

  0121d	eb 19		 jmp	 SHORT $L73206
$L71976:

; 3800 : 		
; 3801 : 	case WAVE_FORMAT_1M08:
; 3802 : 		
; 3803 : 		pWaveFileHdr->wFormatTag = WAVE_FORMAT_PCM;

  0121f	66 89 5e 14	 mov	 WORD PTR [esi+20], bx

; 3804 : 		pWaveFileHdr->dwSamplesPerSecond = PC_SAMPLE_RATE;

  01223	b8 11 2b 00 00	 mov	 eax, 11025		; 00002b11H
$L73205:
  01228	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 3805 : 		pWaveFileHdr->dwAvgBytesPerSecond = PC_SAMPLE_RATE;

  0122b	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 3806 : 		pWaveFileHdr->wNumberBlockAlign = 1;

  0122e	66 89 5e 20	 mov	 WORD PTR [esi+32], bx

; 3807 : 		pWaveFileHdr->wBitsPerSample = 8;

  01232	66 c7 46 22 08
	00		 mov	 WORD PTR [esi+34], 8
$L73206:

; 3808 : 		
; 3809 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );

  01238	50		 push	 eax
  01239	57		 push	 edi
  0123a	e8 00 00 00 00	 call	 _SetSampleRate

; 3829 : 	}
; 3830 : 	
; 3831 : 	phTTS->dwFormat = dwFormat;
; 3832 : 	
; 3833 : 	/********************************************************************/
; 3834 : 	/*  Open the wave output file.                                      */
; 3835 : 	/********************************************************************/
; 3836 : 	
; 3837 : #ifdef UNDER_CE //mfgce
; 3838 :   if((phTTS->pWaveFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL))==NULL)
; 3839 : #else
; 3840 :   if (( phTTS->pWaveFile = fopen(pszFileName, "wb" )) == NULL )

  0123f	8b 44 24 20	 mov	 eax, DWORD PTR _pszFileName$[esp+20]
  01243	83 c4 08	 add	 esp, 8
  01246	89 af 80 00 00
	00		 mov	 DWORD PTR [edi+128], ebp
  0124c	68 00 00 00 00	 push	 OFFSET FLAT:$SG71981
  01251	50		 push	 eax
  01252	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  01258	83 c4 08	 add	 esp, 8
  0125b	89 87 94 00 00
	00		 mov	 DWORD PTR [edi+148], eax
  01261	85 c0		 test	 eax, eax
  01263	75 11		 jne	 SHORT $L71980

; 3841 : #endif
; 3842 : 	{
; 3843 : 		free( pWaveFileHdr );

  01265	56		 push	 esi
  01266	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0126c	83 c4 04	 add	 esp, 4

; 3844 : 		return( MMSYSERR_ERROR );

  0126f	8b c3		 mov	 eax, ebx
  01271	5f		 pop	 edi
  01272	5e		 pop	 esi
  01273	5d		 pop	 ebp
  01274	5b		 pop	 ebx

; 3870 : }

  01275	c3		 ret	 0
$L71980:

; 3845 : 	}
; 3846 : 	
; 3847 : 	/********************************************************************/
; 3848 : 	/*  Write the header to the output file.                            */
; 3849 : 	/********************************************************************/
; 3850 : 	
; 3851 : #ifdef UNDER_CE
; 3852 :   if(WriteFile( phTTS->pWaveFile,pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ), &dwRW, NULL)==0)
; 3853 : #else
; 3854 :   if( 1 != fwrite( (char *)pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ),1,phTTS->pWaveFile ))

  01276	50		 push	 eax
  01277	53		 push	 ebx
  01278	6a 2c		 push	 44			; 0000002cH
  0127a	56		 push	 esi
  0127b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  01281	83 c4 10	 add	 esp, 16			; 00000010H
  01284	3b c3		 cmp	 eax, ebx
  01286	74 11		 je	 SHORT $L71984

; 3855 : #endif
; 3856 : 	{
; 3857 : 		free( pWaveFileHdr );

  01288	56		 push	 esi
  01289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0128f	83 c4 04	 add	 esp, 4

; 3858 : 		return( MMSYSERR_ERROR );

  01292	8b c3		 mov	 eax, ebx
  01294	5f		 pop	 edi
  01295	5e		 pop	 esi
  01296	5d		 pop	 ebp
  01297	5b		 pop	 ebx

; 3870 : }

  01298	c3		 ret	 0
$L71984:

; 3859 : 	}
; 3860 : 	
; 3861 : 	/********************************************************************/
; 3862 : 	/*  Initialize the file sample count.                               */
; 3863 : 	/********************************************************************/
; 3864 : 	
; 3865 : 	phTTS->dwFileSampleCount = 0;

  01299	c7 47 78 00 00
	00 00		 mov	 DWORD PTR [edi+120], 0

; 3866 : 	phTTS->pWaveFileHdr = pWaveFileHdr;

  012a0	89 b7 9c 00 00
	00		 mov	 DWORD PTR [edi+156], esi

; 3867 : 	phTTS->dwOutputState = STATE_OUTPUT_WAVE_FILE;

  012a6	c7 87 84 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+132], 2

; 3868 : 	
; 3869 : 	return( MMSYSERR_NOERROR );

  012b0	33 c0		 xor	 eax, eax
$L71961:
  012b2	5f		 pop	 edi
  012b3	5e		 pop	 esi
  012b4	5d		 pop	 ebp
  012b5	5b		 pop	 ebx

; 3870 : }

  012b6	c3		 ret	 0
_TextToSpeechOpenWaveOutFile ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechCloseWaveOutFile
EXTRN	__imp__fseek:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechCloseWaveOutFile PROC NEAR

; 3910 : {

  012c0	53		 push	 ebx
  012c1	55		 push	 ebp
  012c2	56		 push	 esi

; 3911 : 	DWORD dwLengthInBytes;
; 3912 : #ifdef UNDER_CE
; 3913 : 	HANDLE * pWaveFile;
; 3914 : 	DWORD dwRW;
; 3915 : #else
; 3916 : 	FILE * pWaveFile;
; 3917 : #endif
; 3918 : 	WAVE_FILE_HDR_T * pWaveFileHdr;
; 3919 : 	MMRESULT mmStatus;
; 3920 : 	
; 3921 : 	/********************************************************************/
; 3922 : 	/*  Return error if invalid handle.                                 */
; 3923 : 	/********************************************************************/
; 3924 : 	
; 3925 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  012c3	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  012c7	57		 push	 edi
  012c8	6a 04		 push	 4
  012ca	56		 push	 esi
  012cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  012d1	85 c0		 test	 eax, eax
  012d3	74 0a		 je	 SHORT $L71992
  012d5	5f		 pop	 edi
  012d6	5e		 pop	 esi
  012d7	5d		 pop	 ebp

; 3926 : 		return( MMSYSERR_INVALHANDLE );

  012d8	b8 05 00 00 00	 mov	 eax, 5
  012dd	5b		 pop	 ebx

; 4052 : }

  012de	c3		 ret	 0
$L71992:

; 3927 : 	
; 3928 : 	/********************************************************************/
; 3929 : 	/*  If a file is not open, then exit.                               */
; 3930 : 	/********************************************************************/
; 3931 : 	
; 3932 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_WAVE_FILE )

  012df	83 be 84 00 00
	00 02		 cmp	 DWORD PTR [esi+132], 2
  012e6	74 0a		 je	 SHORT $L71993
  012e8	5f		 pop	 edi
  012e9	5e		 pop	 esi
  012ea	5d		 pop	 ebp

; 3933 : 		return( MMSYSERR_ERROR );

  012eb	b8 01 00 00 00	 mov	 eax, 1
  012f0	5b		 pop	 ebx

; 4052 : }

  012f1	c3		 ret	 0
$L71993:

; 3934 : 	
; 3935 : 	/********************************************************************/
; 3936 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 3937 : 	/*  function have completed.                                        */
; 3938 : 	/********************************************************************/
; 3939 : 	
; 3940 : 	mmStatus = TextToSpeechSync( phTTS );

  012f2	56		 push	 esi
  012f3	e8 00 00 00 00	 call	 _TextToSpeechSync
  012f8	8b d8		 mov	 ebx, eax

; 3941 : 	
; 3942 : 	if ( mmStatus )
; 3943 : 		mmStatus = MMSYSERR_ERROR;
; 3944 : 	else
; 3945 : 		mmStatus = MMSYSERR_NOERROR;
; 3946 : 	
; 3947 : 	/********************************************************************/
; 3948 : 	/*  Set the sample rate to the default value in case the sample     */
; 3949 : 	/*  was changed.                                                    */
; 3950 : 	/********************************************************************/
; 3951 : 	
; 3952 : 	SetSampleRate( phTTS, PC_SAMPLE_RATE );

  012fa	68 11 2b 00 00	 push	 11025			; 00002b11H
  012ff	f7 db		 neg	 ebx
  01301	1b db		 sbb	 ebx, ebx
  01303	56		 push	 esi
  01304	f7 db		 neg	 ebx
  01306	e8 00 00 00 00	 call	 _SetSampleRate

; 3953 : 	
; 3954 : 	/********************************************************************/
; 3955 : 	/*  Update the wave header riff chunk and data chunk lengths.       */
; 3956 : 	/********************************************************************/
; 3957 : 	
; 3958 : 	switch( phTTS->dwFormat )
; 3959 : 	{

  0130b	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  01311	83 c4 0c	 add	 esp, 12			; 0000000cH
  01314	48		 dec	 eax
  01315	74 1b		 je	 SHORT $L72002
  01317	83 e8 03	 sub	 eax, 3
  0131a	74 0f		 je	 SHORT $L72000
  0131c	83 e8 03	 sub	 eax, 3
  0131f	74 11		 je	 SHORT $L72002
  01321	5f		 pop	 edi
  01322	5e		 pop	 esi
  01323	5d		 pop	 ebp

; 3969 : 		break;
; 3970 : 		
; 3971 : 	default:
; 3972 : 		
; 3973 : 		/******************************************************************/
; 3974 : 		/*  It should be impossible to get here so this error message is  */
; 3975 : 		/*  not documented.                                               */
; 3976 : 		/******************************************************************/
; 3977 : 		
; 3978 : 		return( MMSYSERR_INVALPARAM );

  01324	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01329	5b		 pop	 ebx

; 4052 : }

  0132a	c3		 ret	 0
$L72000:

; 3960 : 	case WAVE_FORMAT_1M16:
; 3961 : 		
; 3962 : 		dwLengthInBytes = (DWORD)phTTS->dwFileSampleCount << 1;

  0132b	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0132e	d1 e0		 shl	 eax, 1

; 3963 : 		break;

  01330	eb 03		 jmp	 SHORT $L71997
$L72002:

; 3964 : 		
; 3965 : 	case WAVE_FORMAT_1M08:
; 3966 : 	case WAVE_FORMAT_08M08:
; 3967 : 		
; 3968 : 		dwLengthInBytes = (DWORD)phTTS->dwFileSampleCount;

  01332	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
$L71997:

; 3979 : 	}
; 3980 : 	
; 3981 : 	pWaveFileHdr = (WAVE_FILE_HDR_T *)phTTS->pWaveFileHdr;

  01335	8b be 9c 00 00
	00		 mov	 edi, DWORD PTR [esi+156]

; 3982 : 	
; 3983 : 	pWaveFileHdr->dwDataChunkSize = dwLengthInBytes;
; 3984 : 	
; 3985 : 	pWaveFileHdr->dwRiffChunkSize =
; 3986 : 		pWaveFileHdr->dwDataChunkSize + RIFF_HEADER_OFFSET;
; 3987 : 	
; 3988 : 	/********************************************************************/
; 3989 : 	/*  Seek to the top of the file to write the updated wave header.   */
; 3990 : 	/********************************************************************/
; 3991 : 	
; 3992 : #ifdef UNDER_CE
; 3993 :    pWaveFile = (HANDLE *)phTTS->pWaveFile;
; 3994 : #else
; 3995 :    pWaveFile = (FILE *)phTTS->pWaveFile;
; 3996 : #endif
; 3997 : 
; 3998 : #ifdef UNDER_CE //mfgce fix return value
; 3999 :   SetFilePointer(pWaveFile ,0L ,NULL ,FILE_BEGIN);
; 4000 : #else
; 4001 :   if ( fseek( pWaveFile, 0L, SEEK_SET ))

  0133b	6a 00		 push	 0
  0133d	6a 00		 push	 0
  0133f	89 47 28	 mov	 DWORD PTR [edi+40], eax
  01342	83 c0 24	 add	 eax, 36			; 00000024H
  01345	89 47 04	 mov	 DWORD PTR [edi+4], eax
  01348	8b ae 94 00 00
	00		 mov	 ebp, DWORD PTR [esi+148]
  0134e	55		 push	 ebp
  0134f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  01355	83 c4 0c	 add	 esp, 12			; 0000000cH
  01358	85 c0		 test	 eax, eax
  0135a	74 14		 je	 SHORT $L72007

; 4002 :   {
; 4003 : 	free( pWaveFileHdr );

  0135c	57		 push	 edi
  0135d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  01363	83 c4 04	 add	 esp, 4

; 4004 : 	return( MMSYSERR_ERROR );

  01366	b8 01 00 00 00	 mov	 eax, 1
  0136b	5f		 pop	 edi
  0136c	5e		 pop	 esi
  0136d	5d		 pop	 ebp
  0136e	5b		 pop	 ebx

; 4052 : }

  0136f	c3		 ret	 0
$L72007:

; 4005 :   }
; 4006 : #endif
; 4007 : 	
; 4008 : 	/********************************************************************/
; 4009 : 	/*  Write the header to the output file.                            */
; 4010 : 	/********************************************************************/
; 4011 : 	
; 4012 : #ifdef UNDER_CE
; 4013 :   if(WriteFile( phTTS->pWaveFile,pWaveFileHdr,sizeof( WAVE_FILE_HDR_T ), &dwRW, NULL)==0)
; 4014 : #else
; 4015 :   if ( 1 != fwrite( (char *)pWaveFileHdr,sizeof(WAVE_FILE_HDR_T ),1,phTTS->pWaveFile ))

  01370	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  01376	50		 push	 eax
  01377	6a 01		 push	 1
  01379	6a 2c		 push	 44			; 0000002cH
  0137b	57		 push	 edi
  0137c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  01382	83 c4 10	 add	 esp, 16			; 00000010H
  01385	83 f8 01	 cmp	 eax, 1

; 4016 : #endif
; 4017 : 	{
; 4018 : 		free( pWaveFileHdr );

  01388	57		 push	 edi
  01389	74 13		 je	 SHORT $L72010
  0138b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  01391	83 c4 04	 add	 esp, 4

; 4019 : 		return( MMSYSERR_ERROR );

  01394	b8 01 00 00 00	 mov	 eax, 1
  01399	5f		 pop	 edi
  0139a	5e		 pop	 esi
  0139b	5d		 pop	 ebp
  0139c	5b		 pop	 ebx

; 4052 : }

  0139d	c3		 ret	 0
$L72010:

; 4020 : 	}
; 4021 : 	
; 4022 : 	/********************************************************************/
; 4023 : 	/*  Free the wave file header.                                      */
; 4024 : 	/********************************************************************/
; 4025 : 	
; 4026 : 	free( pWaveFileHdr );

  0139e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 4027 : 	
; 4028 : 	/********************************************************************/
; 4029 : 	/*  Set the system output state to audio if it is enabled.          */
; 4030 : 	/********************************************************************/
; 4031 : 	
; 4032 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  013a4	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  013a7	83 c4 04	 add	 esp, 4
  013aa	a9 00 00 00 80	 test	 eax, -2147483648	; 80000000H
  013af	75 17		 jne	 SHORT $L72011

; 4033 : 	{
; 4034 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 4035 : 		TextToSpeechReset(phTTS,FALSE); // tek 29jan99 bats 849: this resets the counters..

  013b1	6a 00		 push	 0
  013b3	56		 push	 esi
  013b4	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  013be	e8 00 00 00 00	 call	 _TextToSpeechReset
  013c3	83 c4 08	 add	 esp, 8

; 4036 : 	}
; 4037 : 	else

  013c6	eb 0a		 jmp	 SHORT $L72012
$L72011:

; 4038 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;

  013c8	c7 86 84 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+132], 4
$L72012:

; 4039 : 	
; 4040 : 	/********************************************************************/
; 4041 : 	/*  Close the wave file.                                            */
; 4042 : 	/********************************************************************/
; 4043 : 	
; 4044 : #if UNDER_CE
; 4045 : 	if ( CloseHandle( pWaveFile ) == 0)
; 4046 : #else
; 4047 : 	if ( fclose( pWaveFile ))

  013d2	55		 push	 ebp
  013d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  013d9	83 c4 04	 add	 esp, 4
  013dc	85 c0		 test	 eax, eax

; 4048 : #endif
; 4049 : 		return( MMSYSERR_ERROR );

  013de	b8 01 00 00 00	 mov	 eax, 1
  013e3	75 02		 jne	 SHORT $L71987

; 4050 : 	
; 4051 : 	return( mmStatus );

  013e5	8b c3		 mov	 eax, ebx
$L71987:
  013e7	5f		 pop	 edi
  013e8	5e		 pop	 esi
  013e9	5d		 pop	 ebp
  013ea	5b		 pop	 ebx

; 4052 : }

  013eb	c3		 ret	 0
_TextToSpeechCloseWaveOutFile ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetStatus
EXTRN	_PA_Status:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_dwIdentifierArray$ = 12
_dwStatusArray$ = 16
_dwNumberOfStatusValues$ = 20
_dwIdentifier$ = 8
_dwAudioStatus$ = -4
_TextToSpeechGetStatus PROC NEAR

; 4128 : {

  013f0	51		 push	 ecx
  013f1	53		 push	 ebx

; 4129 : 	UINT i;
; 4130 : #ifndef OLEDECTALK
; 4131 : 	DWORD dwIdentifier[1];
; 4132 : #endif //OLEDECTALK
; 4133 : 	DWORD dwAudioStatus[1];
; 4134 : 	MMRESULT mmStatus =0;
; 4135 : 	MMRESULT mmStatusReturn;
; 4136 : 	
; 4137 : 	/********************************************************************/
; 4138 : 	/*  Return error if invalid handle.                                 */
; 4139 : 	/********************************************************************/
; 4140 : 	
; 4141 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  013f2	8b 5c 24 0c	 mov	 ebx, DWORD PTR _phTTS$[esp+4]
  013f6	6a 04		 push	 4
  013f8	53		 push	 ebx
  013f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  013ff	85 c0		 test	 eax, eax
  01401	74 08		 je	 SHORT $L72028

; 4142 : 		return( MMSYSERR_INVALHANDLE );

  01403	b8 05 00 00 00	 mov	 eax, 5
  01408	5b		 pop	 ebx

; 4235 : }

  01409	59		 pop	 ecx
  0140a	c3		 ret	 0
$L72028:

; 4143 : 	
; 4144 : 	/********************************************************************/
; 4145 : 	/*  Range test the number of status values requested.               */
; 4146 : 	/********************************************************************/
; 4147 : 	
; 4148 : 	if (( dwNumberOfStatusValues == 0 )
; 4149 : 		|| ( dwNumberOfStatusValues > MAXIMUM_STATUS_VALUES ))

  0140b	8b 44 24 18	 mov	 eax, DWORD PTR _dwNumberOfStatusValues$[esp+4]
  0140f	85 c0		 test	 eax, eax
  01411	0f 84 26 01 00
	00		 je	 $L72030
  01417	83 f8 03	 cmp	 eax, 3
  0141a	0f 87 1d 01 00
	00		 ja	 $L72030
  01420	57		 push	 edi

; 4151 : 	
; 4152 : 	mmStatusReturn = MMSYSERR_NOERROR;

  01421	33 ff		 xor	 edi, edi

; 4153 : 	
; 4154 : 	/********************************************************************/
; 4155 : 	/*  Loop and fill in array dwStatusArray[].                             */
; 4156 : 	/********************************************************************/
; 4157 : 	
; 4158 : 	for ( i = 0; i < dwNumberOfStatusValues; i++ )

  01423	85 c0		 test	 eax, eax
  01425	0f 86 0c 01 00
	00		 jbe	 $L72033
  0142b	55		 push	 ebp

; 4226 : 			
; 4227 : 		default:
; 4228 : 			
; 4229 : 			dwStatusArray[i] = 0xFFFFFFFF;

  0142c	8b 6c 24 18	 mov	 ebp, DWORD PTR _dwIdentifierArray$[esp+12]
  01430	56		 push	 esi
  01431	8b 74 24 20	 mov	 esi, DWORD PTR _dwStatusArray$[esp+16]
  01435	2b ee		 sub	 ebp, esi
  01437	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
$L72031:
  0143b	8b 04 2e	 mov	 eax, DWORD PTR [esi+ebp]
  0143e	83 e8 00	 sub	 eax, 0
  01441	0f 84 bd 00 00
	00		 je	 $L72038

; 4159 : 	{
; 4160 : 		switch( dwIdentifierArray[i] )
; 4161 : 		{

  01447	48		 dec	 eax
  01448	74 68		 je	 SHORT $L72039
  0144a	48		 dec	 eax
  0144b	74 10		 je	 SHORT $L72044

; 4226 : 			
; 4227 : 		default:
; 4228 : 			
; 4229 : 			dwStatusArray[i] = 0xFFFFFFFF;

  0144d	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4230 : 			mmStatusReturn = MMSYSERR_INVALPARAM;

  01453	bf 0b 00 00 00	 mov	 edi, 11			; 0000000bH

; 4231 : 			break;

  01458	e9 c6 00 00 00	 jmp	 $L72032
$L72044:

; 4197 : 			
; 4198 : 		case WAVE_OUT_DEVICE_ID:
; 4199 : 			
; 4200 : 			if ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE )

  0145d	f7 43 74 00 00
	00 80		 test	 DWORD PTR [ebx+116], -2147483648 ; 80000000H
  01464	74 10		 je	 SHORT $L72045

; 4201 : 			{
; 4202 : 				dwStatusArray[i] = 0xFFFFFFFF;

  01466	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4203 : 				mmStatusReturn = MMSYSERR_ERROR;

  0146c	bf 01 00 00 00	 mov	 edi, 1

; 4204 : 			}
; 4205 : 			else

  01471	e9 ad 00 00 00	 jmp	 $L72032
$L72045:

; 4206 : 			{
; 4207 : #ifndef OLEDECTALK
; 4208 : 				dwIdentifier[0] = PA_DEVICE_ID;
; 4209 : 				
; 4210 : 				mmStatus = PA_Status( phTTS->pAudioHandle,
; 4211 : 					dwIdentifier,
; 4212 : 					dwAudioStatus,
; 4213 : 					1 );

  01476	8b 93 d0 00 00
	00		 mov	 edx, DWORD PTR [ebx+208]
  0147c	8d 44 24 10	 lea	 eax, DWORD PTR _dwAudioStatus$[esp+20]
  01480	6a 01		 push	 1
  01482	8d 4c 24 1c	 lea	 ecx, DWORD PTR _dwIdentifier$[esp+20]
  01486	50		 push	 eax
  01487	51		 push	 ecx
  01488	52		 push	 edx
  01489	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR _dwIdentifier$[esp+32], 3
  01491	e8 00 00 00 00	 call	 _PA_Status
  01496	83 c4 10	 add	 esp, 16			; 00000010H

; 4214 : #endif //OLEDECTALK
; 4215 : 				if ( mmStatus )

  01499	85 c0		 test	 eax, eax
  0149b	74 0d		 je	 SHORT $L72047

; 4216 : 				{
; 4217 : 					dwStatusArray[i] = 0xFFFFFFFF;

  0149d	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4218 : 					mmStatusReturn = MMSYSERR_ERROR;

  014a3	bf 01 00 00 00	 mov	 edi, 1

; 4219 : 				}
; 4220 : 				else

  014a8	eb 79		 jmp	 SHORT $L72032
$L72047:

; 4221 : 				{
; 4222 : 					dwStatusArray[i] = dwAudioStatus[0];

  014aa	8b 44 24 10	 mov	 eax, DWORD PTR _dwAudioStatus$[esp+20]
  014ae	89 06		 mov	 DWORD PTR [esi], eax

; 4223 : 				}
; 4224 : 			}
; 4225 : 			break;

  014b0	eb 71		 jmp	 SHORT $L72032
$L72039:

; 4167 : 			break;
; 4168 : 			
; 4169 : 		case STATUS_SPEAKING:
; 4170 : 			
; 4171 : 			if ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE )

  014b2	f7 43 74 00 00
	00 80		 test	 DWORD PTR [ebx+116], -2147483648 ; 80000000H
  014b9	74 0d		 je	 SHORT $L72040

; 4172 : 			{
; 4173 : 				dwStatusArray[i] = 0xFFFFFFFF;

  014bb	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4174 : 				mmStatusReturn = MMSYSERR_ERROR;

  014c1	bf 01 00 00 00	 mov	 edi, 1

; 4175 : 			}
; 4176 : 			else

  014c6	eb 5b		 jmp	 SHORT $L72032
$L72040:

; 4177 : 			{
; 4178 : #ifndef OLEDECTALK
; 4179 : 				dwIdentifier[0] = PA_DEVICE_PLAYING;
; 4180 : 				
; 4181 : 				mmStatus = PA_Status( phTTS->pAudioHandle,
; 4182 : 					dwIdentifier,
; 4183 : 					dwAudioStatus,
; 4184 : 					1 );

  014c8	8b 83 d0 00 00
	00		 mov	 eax, DWORD PTR [ebx+208]
  014ce	8d 4c 24 10	 lea	 ecx, DWORD PTR _dwAudioStatus$[esp+20]
  014d2	6a 01		 push	 1
  014d4	8d 54 24 1c	 lea	 edx, DWORD PTR _dwIdentifier$[esp+20]
  014d8	51		 push	 ecx
  014d9	52		 push	 edx
  014da	50		 push	 eax
  014db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _dwIdentifier$[esp+32], 0
  014e3	e8 00 00 00 00	 call	 _PA_Status
  014e8	83 c4 10	 add	 esp, 16			; 00000010H

; 4185 : #endif //OLEDECTALK
; 4186 : 				if ( mmStatus )

  014eb	85 c0		 test	 eax, eax
  014ed	74 0d		 je	 SHORT $L72042

; 4187 : 				{
; 4188 : 					dwStatusArray[i] = 0xFFFFFFFF;

  014ef	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 4189 : 					mmStatusReturn = MMSYSERR_ERROR;

  014f5	bf 01 00 00 00	 mov	 edi, 1

; 4190 : 				}
; 4191 : 				else

  014fa	eb 27		 jmp	 SHORT $L72032
$L72042:

; 4192 : 				{
; 4193 : 					dwStatusArray[i] = dwAudioStatus[0];

  014fc	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwAudioStatus$[esp+20]
  01500	89 0e		 mov	 DWORD PTR [esi], ecx

; 4194 : 				}
; 4195 : 			}
; 4196 : 			break;

  01502	eb 1f		 jmp	 SHORT $L72032
$L72038:

; 4162 : 		case INPUT_CHARACTER_COUNT:
; 4163 : 			
; 4164 : 			EnterCriticalSection( phTTS->pcsQueuedCharacterCount );

  01504	8b 93 c0 00 00
	00		 mov	 edx, DWORD PTR [ebx+192]
  0150a	52		 push	 edx
  0150b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 4165 : 			dwStatusArray[i] = phTTS->uiQueuedCharacterCount;

  01511	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  01514	89 06		 mov	 DWORD PTR [esi], eax

; 4166 : 			LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );

  01516	8b 8b c0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+192]
  0151c	51		 push	 ecx
  0151d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72032:
  01523	8b 44 24 24	 mov	 eax, DWORD PTR 20+[esp+16]
  01527	83 c6 04	 add	 esi, 4
  0152a	48		 dec	 eax
  0152b	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
  0152f	0f 85 06 ff ff
	ff		 jne	 $L72031
  01535	5e		 pop	 esi
  01536	5d		 pop	 ebp
$L72033:

; 4232 : 		}
; 4233 : 	}
; 4234 : 	return( mmStatusReturn );

  01537	8b c7		 mov	 eax, edi
  01539	5f		 pop	 edi
  0153a	5b		 pop	 ebx

; 4235 : }

  0153b	59		 pop	 ecx
  0153c	c3		 ret	 0
$L72030:

; 4150 : 		return( MMSYSERR_INVALPARAM );

  0153d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01542	5b		 pop	 ebx

; 4235 : }

  01543	59		 pop	 ecx
  01544	c3		 ret	 0
_TextToSpeechGetStatus ENDP
_TEXT	ENDS
PUBLIC	_SendBuffer
PUBLIC	_ReturnRemainingBuffers
PUBLIC	_DrainPipes
PUBLIC	_TextToSpeechAddBuffer
PUBLIC	_TextToSpeechCloseLogFile
EXTRN	_EmptyVtmPipe:NEAR
EXTRN	__imp__ResetEvent@4:NEAR
EXTRN	_pipe_count:NEAR
EXTRN	_PA_Reset:NEAR
EXTRN	_cmd_init:NEAR
EXTRN	_ls_util_lts_init:NEAR
EXTRN	_phinit:NEAR
EXTRN	_InitializeVTM:NEAR
EXTRN	_free_index:NEAR
EXTRN	_OP_GetThreadPriority:NEAR
EXTRN	__imp__GetCurrentThread@0:NEAR
_BSS	SEGMENT
	ALIGN	4

$SG72083 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_bReset$ = 12
_mmStatus$ = 8
_bWasTyping$ = 8
_szCforce3$ = -12
_tptPriority$ = -8
_dtpSync$72071 = -4
_LastVoice$72103 = 12
_TextToSpeechReset PROC NEAR

; 4287 : {

  01550	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01553	53		 push	 ebx
  01554	55		 push	 ebp
  01555	56		 push	 esi

; 4288 :   MMRESULT mmStatus;
; 4289 :   /* Added a varaible to get handle of instance specific Kernel_share_data for MI:MVP */
; 4290 :   PKSD_T pKsd_t;
; 4291 :   LPTTS_BUFFER_T pTTS_Buffer;
; 4292 :   
; 4293 : #ifdef API_DEBUG
; 4294 :   char szTemp[256]="";
; 4295 : #endif //API_DEBUG
; 4296 :   
; 4297 : #ifdef WIN32	
; 4298 : #ifdef TYPING_MODE	// 09jun97 tek
; 4299 :   BOOL	bWasTyping=FALSE;
; 4300 :   
; 4301 :   char szCforce3[] = {  
; 4302 :     (char)((PFASCII<<PSFONT)+0xb),

  01556	b0 0b		 mov	 al, 11			; 0000000bH

; 4303 :     /*	(char)(SYNC),					
; 4304 : 	(char)((PFASCII<<PSFONT)+0xb),
; 4305 : 	(char)(SYNC),					
; 4306 :     */
; 4307 :     (char)((PFASCII<<PSFONT)+0xb),
; 4308 :     (char)(SYNC),
; 4309 :     '\0'
; 4310 :   };

  01558	33 db		 xor	 ebx, ebx
  0155a	57		 push	 edi
  0155b	88 44 24 10	 mov	 BYTE PTR _szCforce3$[esp+28], al
  0155f	88 44 24 11	 mov	 BYTE PTR _szCforce3$[esp+29], al
  01563	c6 44 24 12 0a	 mov	 BYTE PTR _szCforce3$[esp+30], 10 ; 0000000aH
  01568	88 5c 24 13	 mov	 BYTE PTR _szCforce3$[esp+31], bl

; 4311 : #endif //TYPING_MODE
; 4312 :   HANDLE hThisThread=NULL;
; 4313 :   THREAD_PRIORITY_T tptPriority=0;

  0156c	89 5c 24 14	 mov	 DWORD PTR _tptPriority$[esp+28], ebx

; 4314 :   hThisThread = GetCurrentThread();

  01570	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  01576	8b e8		 mov	 ebp, eax

; 4315 :   if (hThisThread)

  01578	3b eb		 cmp	 ebp, ebx
  0157a	74 15		 je	 SHORT $L72066

; 4316 :     {
; 4317 : #ifndef UNDER_CE
; 4318 :       tptPriority = OP_GetThreadPriority(hThisThread);

  0157c	55		 push	 ebp
  0157d	e8 00 00 00 00	 call	 _OP_GetThreadPriority

; 4319 :       OP_SetThreadPriority(hThisThread,OP_PRIORITY_HIGHEST);

  01582	6a 02		 push	 2
  01584	55		 push	 ebp
  01585	89 44 24 20	 mov	 DWORD PTR _tptPriority$[esp+40], eax
  01589	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  0158e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72066:

; 4320 : #endif
; 4321 :     }
; 4322 :   
; 4323 :   
; 4324 : #ifdef API_DEBUG
; 4325 :   // tek 10aug97 (during bats423)
; 4326 :        // fix this for typing/nontyping
; 4327 : #ifdef TYPING_MODE  // tek 10aug97 (during bats423)
; 4328 : 			       // fix this for typing/nontyping
; 4329 : 						       sprintf(szTemp,"TTSreset() at %ld (%d). \n",timeGetTime(),phTTS->bInTypingMode);
; 4330 : #else //TYPING_MODE
; 4331 :   sprintf(szTemp,"TTSreset() at %ld. \n",timeGetTime());
; 4332 : #endif //TYPING_MODE
; 4333 :   OutputDebugString(szTemp);
; 4334 : #endif //API_DEBUG
; 4335 :   
; 4336 :   /********************************************************************/
; 4337 :   /*  Return error if invalid handle.                                 */
; 4338 :   /********************************************************************/
; 4339 :   
; 4340 :   if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01591	8b 74 24 20	 mov	 esi, DWORD PTR _phTTS$[esp+24]
  01595	6a 04		 push	 4
  01597	56		 push	 esi
  01598	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0159e	85 c0		 test	 eax, eax
  015a0	74 1f		 je	 SHORT $L72067

; 4341 :     {
; 4342 : #ifndef UNDER_CE
; 4343 :       if ( hThisThread)	 // tek 09jun97

  015a2	3b eb		 cmp	 ebp, ebx
  015a4	74 0e		 je	 SHORT $L72068

; 4344 : 	  {
; 4345 : 	OP_SetThreadPriority(hThisThread,tptPriority);

  015a6	8b 44 24 14	 mov	 eax, DWORD PTR _tptPriority$[esp+28]
  015aa	50		 push	 eax
  015ab	55		 push	 ebp
  015ac	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  015b1	83 c4 08	 add	 esp, 8
$L72068:
  015b4	5f		 pop	 edi
  015b5	5e		 pop	 esi
  015b6	5d		 pop	 ebp

; 4346 :       }
; 4347 : #endif
; 4348 :       return( MMSYSERR_INVALHANDLE );

  015b7	b8 05 00 00 00	 mov	 eax, 5
  015bc	5b		 pop	 ebx

; 4997 : 	  return( MMSYSERR_ERROR );
; 4998 :   
; 4999 :   return( MMSYSERR_NOERROR );
; 5000 : }

  015bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  015c0	c3		 ret	 0
$L72067:

; 4349 :     }
; 4350 : 
; 4351 :   /* 16jun97 tek bats385
; 4352 :      merged 28jul97 tek
; 4353 :      lock up the synthesizer against new speech.. 
; 4354 :      */
; 4355 : #endif /* WIN32 */
; 4356 :   
; 4357 :   /********************************************************************/
; 4358 :   /*   Set the InReset flag                                           */
; 4359 :   /********************************************************************/
; 4360 :   
; 4361 :   phTTS->bInReset = TRUE;
; 4362 :   
; 4363 : #if defined __osf__ || defined __linux__
; 4364 :   /********************************************************************/
; 4365 :   /*  Return error if invalid handle.                                 */
; 4366 :   /********************************************************************/
; 4367 :   
; 4368 :   if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
; 4369 :     { 
; 4370 :       phTTS->bInReset = FALSE;
; 4371 :       return( MMSYSERR_INVALHANDLE );
; 4372 :     }
; 4373 : #endif /* osf */
; 4374 :   
; 4375 :   /********************************************************************/
; 4376 :   /*  Set the halting flag. This will cause the CMD, LTS, PH, VTM,    */
; 4377 :   /*  and SYNC threads to all discard input data and flush the pipes. */
; 4378 :   /********************************************************************/
; 4379 :   /* Get the current instance kernel_share_data : MVP */
; 4380 :   pKsd_t = phTTS->pKernelShareData;

  015c1	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  015c4	b8 01 00 00 00	 mov	 eax, 1
  015c9	89 86 dc 00 00
	00		 mov	 DWORD PTR [esi+220], eax

; 4381 :   
; 4382 :   pKsd_t->halting = TRUE;

  015cf	89 87 74 01 00
	00		 mov	 DWORD PTR [edi+372], eax

; 4383 :   
; 4384 :   /* ETT fixme?: why is this only win32? */
; 4385 : #ifdef WIN32
; 4386 : #ifdef API_DEBUG
; 4387 :   OutputDebugString("TTSreset: ->halting is set. \n");
; 4388 : #endif //API_DEBUG
; 4389 :   /********************************************************************/
; 4390 :   /*  Stop the Text To Speech thread if it is queueing text.          */
; 4391 :   /*  The Text-To-Speech thread will queue no text if the message     */
; 4392 :   /*  number is less than phTTS->uiFlushMsgNumber.                    */
; 4393 :   /* this needs to happen before we do too much.. tek 17jun97		  */
; 4394 :   /********************************************************************/
; 4395 :   EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  015d5	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  015db	51		 push	 ecx
  015dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 4396 :   phTTS->uiFlushMsgNumber = phTTS->uiCurrentMsgNumber;
; 4397 :   LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  015e2	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  015e8	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  015eb	50		 push	 eax
  015ec	89 56 50	 mov	 DWORD PTR [esi+80], edx
  015ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 4398 :   
; 4399 :   phTTS->uiCurrentMsgNumber++;

  015f5	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]

; 4400 :   
; 4401 : #ifdef TYPING_MODE
; 4402 :   bWasTyping = phTTS->bInTypingMode;
; 4403 :   /* tek 15may97
; 4404 :      we set the PH thread's prority up here so that the first burst of
; 4405 :      sound that we need to get out in typing mode is quickly available; 
; 4406 :      after the VTM has processes two speech frames, vtmiont will drop the 
; 4407 :      PH thread back to normal priority so that any user processes can 
; 4408 :      continue running.
; 4409 :      if you change this, make sure the code in vtmiont still makes sense.
; 4410 :      */	
; 4411 :   if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)

  015f8	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  015fe	41		 inc	 ecx
  015ff	3b c3		 cmp	 eax, ebx
  01601	89 4e 44	 mov	 DWORD PTR [esi+68], ecx
  01604	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  0160a	89 4c 24 20	 mov	 DWORD PTR _bWasTyping$[esp+24], ecx
  0160e	75 19		 jne	 SHORT $L72069

; 4412 :     {
; 4413 :       /* tek 19nov97 this needs to be "highest" rather than "above normal";
; 4414 : 	 also, we need to do this for both VTM and PH, and VTM will 
; 4415 : 	 readjust it later for us. (this is all to deal with responsiveness
; 4416 : 	 in the presence of greedy tasks..)
; 4417 : 	 */
; 4418 : #ifndef UNDER_CE
; 4419 :       OP_SetThreadPriority((phTTS->hThread_VTM),OP_PRIORITY_HIGHEST);

  01610	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  01613	6a 02		 push	 2
  01615	52		 push	 edx
  01616	e8 00 00 00 00	 call	 _OP_SetThreadPriority

; 4420 :       OP_SetThreadPriority((phTTS->hThread_PH),OP_PRIORITY_HIGHEST);

  0161b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0161e	6a 02		 push	 2
  01620	50		 push	 eax
  01621	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  01626	83 c4 10	 add	 esp, 16			; 00000010H
$L72069:

; 4421 : #endif
; 4422 :     }
; 4423 :   
; 4424 : #endif //TYPING_MODE
; 4425 : #endif /* WIN32 */
; 4426 :   
; 4427 :   pKsd_t->cmd_flush=CMD_flush_toss;
; 4428 :   
; 4429 :   /* tek 04sep96   drain the lts and ph pipes, just like on the 
; 4430 :      hardware platforms..
; 4431 :      */  
; 4432 :   DrainPipes(phTTS);

  01629	56		 push	 esi
  0162a	c7 87 6c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+364], 1
  01634	e8 00 00 00 00	 call	 _DrainPipes

; 4433 :   
; 4434 : #ifdef WIN32
; 4435 :   EmptyVtmPipe(pKsd_t); /* tek 15may  */

  01639	57		 push	 edi
  0163a	e8 00 00 00 00	 call	 _EmptyVtmPipe

; 4436 :   
; 4437 : #ifdef TYPING_MODE /*09jun97 tek */
; 4438 :   if (bWasTyping)

  0163f	8b 44 24 28	 mov	 eax, DWORD PTR _bWasTyping$[esp+32]
  01643	83 c4 08	 add	 esp, 8
  01646	3b c3		 cmp	 eax, ebx
  01648	74 2b		 je	 SHORT $L72070

; 4439 :     {
; 4440 :       /* start the pipes clearing out */
; 4441 :       DT_PIPE_T dtpSync = SYNC;
; 4442 :       write_pipe(pKsd_t->ph_pipe,&dtpSync,1);

  0164a	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  01650	8d 4c 24 18	 lea	 ecx, DWORD PTR _dtpSync$72071[esp+28]
  01654	6a 01		 push	 1
  01656	51		 push	 ecx
  01657	52		 push	 edx
  01658	c7 44 24 24 0a
	1f 00 00	 mov	 DWORD PTR _dtpSync$72071[esp+40], 7946 ; 00001f0aH
  01660	e8 00 00 00 00	 call	 _write_pipe

; 4443 :       /* this WFEP is important for the case where the VTM still has
; 4444 : 	 work to do from above; we need to make sure that the VTM
; 4445 : 	 IO routines get to empty before we clear the halting flag.
; 4446 : 	 */	 
; 4447 :       mmStatus = WaitForEmptyPipes( phTTS,
; 4448 : 				    MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 4449 : 				    TRUE );

  01665	6a 01		 push	 1
  01667	68 10 27 00 00	 push	 10000			; 00002710H
  0166c	56		 push	 esi
  0166d	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  01672	83 c4 18	 add	 esp, 24			; 00000018H
$L72070:

; 4450 :     }
; 4451 : #endif /* TYPING_MODE */
; 4452 : #endif /* WIN32 */
; 4453 :   
; 4454 :   /********************************************************************/
; 4455 :   /*  Perform an audio reset to immediately stop audio from playing   */
; 4456 :   /*  and to make sure the VTM thread is not blocked.                 */
; 4457 :   /********************************************************************/
; 4458 :   
; 4459 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01675	39 9e 84 00 00
	00		 cmp	 DWORD PTR [esi+132], ebx
  0167b	75 0f		 jne	 SHORT $L72072

; 4460 :     {
; 4461 :       PA_Reset( phTTS->pAudioHandle );

  0167d	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  01683	50		 push	 eax
  01684	e8 00 00 00 00	 call	 _PA_Reset
  01689	83 c4 04	 add	 esp, 4
$L72072:

; 4462 :     }
; 4463 :   
; 4464 :   // 09jun97tek 
; 4465 :        // at this point, we should be able to drop back to our old priority
; 4466 :        
; 4467 : #ifdef WIN32
; 4468 : #ifndef UNDER_CE
; 4469 : 	if (hThisThread)

  0168c	3b eb		 cmp	 ebp, ebx
  0168e	74 0e		 je	 SHORT $L72073

; 4470 : 		OP_SetThreadPriority(hThisThread,tptPriority);

  01690	8b 4c 24 14	 mov	 ecx, DWORD PTR _tptPriority$[esp+28]
  01694	51		 push	 ecx
  01695	55		 push	 ebp
  01696	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  0169b	83 c4 08	 add	 esp, 8
$L72073:

; 4471 : #endif
; 4472 : #endif
; 4473 : 	
; 4474 : 	// tek 19aug96 the same anti-block issue for the memory case..
; 4475 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  0169e	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  016a5	75 5c		 jne	 SHORT $L73214

; 4476 : 	{     
; 4477 : 		// tek 29aug96 always send back the user's buffers.Do it
; 4478 : 		// now and git them out of the way.
; 4479 : 		ReturnRemainingBuffers(phTTS);

  016a7	56		 push	 esi
  016a8	e8 00 00 00 00	 call	 _ReturnRemainingBuffers

; 4480 : 		// we could have gotten stuck behind a buffer dump that happened
; 4481 : 		// "just after" the message to the calling loop that got us here;
; 4482 : 		// so, we have to queue up a dummy buffer to make sure we 
; 4483 : 		// survive the get_pipe call..
; 4484 : 		if((pKsd_t->buffer_pipe != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 1) )

  016ad	8b 87 e4 00 00
	00		 mov	 eax, DWORD PTR [edi+228]
  016b3	83 c4 04	 add	 esp, 4
  016b6	3b c3		 cmp	 eax, ebx
  016b8	74 18		 je	 SHORT $L72076
  016ba	50		 push	 eax
  016bb	e8 00 00 00 00	 call	 _pipe_count
  016c0	83 c4 04	 add	 esp, 4
  016c3	83 f8 01	 cmp	 eax, 1
  016c6	73 0a		 jae	 SHORT $L72076

; 4485 : 			TextToSpeechAddBuffer(phTTS, NULL); //GetBuffer knows how to handle nulls

  016c8	53		 push	 ebx
  016c9	56		 push	 esi
  016ca	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  016cf	83 c4 08	 add	 esp, 8
$L72076:

; 4486 : 
; 4487 : 		EnterCriticalSection(phTTS->pcsMemoryBuffer);

  016d2	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  016d8	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__EnterCriticalSection@4
  016de	52		 push	 edx
  016df	ff d5		 call	 ebp

; 4488 : 
; 4489 : 		// if we have an active output buffer, clear it.
; 4490 : 		if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  016e1	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  016e7	3b c3		 cmp	 eax, ebx
  016e9	74 09		 je	 SHORT $L72080

; 4491 : 		{
; 4492 : 			
; 4493 : 			pTTS_Buffer->dwBufferLength = 0;

  016eb	89 58 18	 mov	 DWORD PTR [eax+24], ebx

; 4494 : 			pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  016ee	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 4495 : 			pTTS_Buffer->dwNumberOfIndexMarks = 0;

  016f1	89 58 20	 mov	 DWORD PTR [eax+32], ebx
$L72080:

; 4496 : 			
; 4497 : 			
; 4498 : 		} // was not a null buffer
; 4499 : 
; 4500 : 		LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  016f4	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  016fa	50		 push	 eax
  016fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  01701	eb 06		 jmp	 SHORT $L72074
$L73214:
  01703	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__EnterCriticalSection@4
$L72074:

; 4501 : 		
; 4502 : 	}
; 4503 : 	
; 4504 : #ifdef TYPING_MODE // tek 09jun97
; 4505 : 	if (bWasTyping)

  01709	39 5c 24 20	 cmp	 DWORD PTR _bWasTyping$[esp+24], ebx
  0170d	75 3f		 jne	 SHORT $L72082

; 4506 : 	{
; 4507 : 		
; 4508 : 	}
; 4509 : 	else
; 4510 : 	{
; 4511 : #endif //TYPING_MODE
; 4512 : 		/********************************************************************/
; 4513 : 		/*  Stop the Text To Speech thread if it is queueing text.          */
; 4514 : 		/*  The Text-To-Speech thread will queue no text if the message     */
; 4515 : 		/*  number is less than phTTS->uiFlushMsgNumber.                    */
; 4516 : 		/********************************************************************/
; 4517 : 
; 4518 : 		EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  0170f	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  01715	51		 push	 ecx
  01716	ff d5		 call	 ebp

; 4519 : 		phTTS->uiFlushMsgNumber = phTTS->uiCurrentMsgNumber;

  01718	8b 46 44	 mov	 eax, DWORD PTR [esi+68]

; 4520 : 		phTTS->uiCurrentMsgNumber++;
; 4521 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  0171b	8b 96 bc 00 00
	00		 mov	 edx, DWORD PTR [esi+188]
  01721	89 46 50	 mov	 DWORD PTR [esi+80], eax
  01724	40		 inc	 eax
  01725	52		 push	 edx
  01726	89 46 44	 mov	 DWORD PTR [esi+68], eax
  01729	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 4522 : 
; 4523 : 		// merged 28jul97 tek
; 4524 : 		// tek 16jun97 bats 385 moves the increment inside the CS
; 4525 : 		
; 4526 : 		// tek 19aug96 we now need to force speech, so that everybody
; 4527 : 		// along the way gets cleared out. We do it here, so that the
; 4528 : 		// above setting of FlushMsgNumber will allow this force to
; 4529 : 		// go through.
; 4530 : #ifdef WIN32
; 4531 : 		TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );

  0172f	53		 push	 ebx
  01730	6a 01		 push	 1
  01732	68 00 00 00 00	 push	 OFFSET FLAT:$SG72083
  01737	56		 push	 esi
  01738	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 4532 : #endif
; 4533 : #if defined __osf__ || defined __linux__
; 4534 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4535 : #endif
; 4536 : 		/********************************************************************/
; 4537 : 		/*  Wait for the Text thread to complete all text queueing.         */
; 4538 : 		/********************************************************************/
; 4539 : 		WaitForTextQueuingToComplete( phTTS, TRUE );

  0173d	6a 01		 push	 1
  0173f	56		 push	 esi
  01740	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete
  01745	83 c4 18	 add	 esp, 24			; 00000018H

; 4540 : 		
; 4541 : 		
; 4542 : 		/********************************************************************/
; 4543 : 		/*  Clear the halting flag.                                         */
; 4544 : 		/********************************************************************/
; 4545 : 		
; 4546 : 		pKsd_t->halting = FALSE;

  01748	89 9f 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebx
$L72082:

; 4547 : #ifdef TYPING_MODE
; 4548 : 	}
; 4549 : #endif //TYPING_MODE
; 4550 : 	
; 4551 : 	/********************************************************************/
; 4552 : 	/*  If the output state is memory then return all buffers to the    */
; 4553 : 	/*  application.  WIH 3/28/95 Changed order for proper reset.       */
; 4554 : 	/********************************************************************/
; 4555 : 	
; 4556 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  0174e	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  01755	0f 85 f4 00 00
	00		 jne	 $L72084

; 4557 : 	{
; 4558 : 		/******************************************************************/
; 4559 : 		/*  If there is nothing to reset then return.                     */
; 4560 : 		/******************************************************************/
; 4561 : 		
; 4562 : 		if (( pipe_count( pKsd_t->cmd_pipe ) == 0 )
; 4563 : 			&& ( pipe_count( pKsd_t->lts_pipe ) == 0 )
; 4564 : 			&& ( pipe_count( pKsd_t->ph_pipe ) == 0 )
; 4565 : 			&& ( pipe_count( pKsd_t->vtm_pipe ) == 0 )
; 4566 : 			&& ( pipe_count( pKsd_t->buffer_pipe) == 0))

  0175b	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  01761	50		 push	 eax
  01762	e8 00 00 00 00	 call	 _pipe_count
  01767	83 c4 04	 add	 esp, 4
  0176a	85 c0		 test	 eax, eax
  0176c	75 74		 jne	 SHORT $L72087
  0176e	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  01774	51		 push	 ecx
  01775	e8 00 00 00 00	 call	 _pipe_count
  0177a	83 c4 04	 add	 esp, 4
  0177d	85 c0		 test	 eax, eax
  0177f	75 61		 jne	 SHORT $L72087
  01781	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  01787	52		 push	 edx
  01788	e8 00 00 00 00	 call	 _pipe_count
  0178d	83 c4 04	 add	 esp, 4
  01790	85 c0		 test	 eax, eax
  01792	75 4e		 jne	 SHORT $L72087
  01794	8b 87 dc 00 00
	00		 mov	 eax, DWORD PTR [edi+220]
  0179a	50		 push	 eax
  0179b	e8 00 00 00 00	 call	 _pipe_count
  017a0	83 c4 04	 add	 esp, 4
  017a3	85 c0		 test	 eax, eax
  017a5	75 3b		 jne	 SHORT $L72087
  017a7	8b 8f e4 00 00
	00		 mov	 ecx, DWORD PTR [edi+228]
  017ad	51		 push	 ecx
  017ae	e8 00 00 00 00	 call	 _pipe_count
  017b3	83 c4 04	 add	 esp, 4
  017b6	85 c0		 test	 eax, eax
  017b8	75 28		 jne	 SHORT $L72087

; 4567 : 		{
; 4568 : 			// tek 22aug96 by now, the cmd parser should be well oiled. Let it go*/
; 4569 : 			pKsd_t->cmd_flush = FALSE;

  017ba	89 9f 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebx

; 4570 : #ifdef API_DEBUG
; 4571 : 			OutputDebugString("TTSReset() exiting1.\n");
; 4572 : #endif //API_DEBUG
; 4573 : 			
; 4574 : 			// 16jun97 tek bats385
; 4575 : 			// merged 28jul97 tek
; 4576 : 			phTTS->bInReset = FALSE;
; 4577 : 			
; 4578 : 			if (pipe_count( phTTS->pKernelShareData->buffer_pipe ))

  017c0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  017c3	89 9e dc 00 00
	00		 mov	 DWORD PTR [esi+220], ebx
  017c9	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  017cf	50		 push	 eax
  017d0	e8 00 00 00 00	 call	 _pipe_count
  017d5	83 c4 04	 add	 esp, 4
  017d8	33 c0		 xor	 eax, eax
  017da	5f		 pop	 edi
  017db	5e		 pop	 esi
  017dc	5d		 pop	 ebp
  017dd	5b		 pop	 ebx

; 4997 : 	  return( MMSYSERR_ERROR );
; 4998 :   
; 4999 :   return( MMSYSERR_NOERROR );
; 5000 : }

  017de	83 c4 0c	 add	 esp, 12			; 0000000cH
  017e1	c3		 ret	 0
$L72087:

; 4579 : 			{
; 4580 : #ifdef API_DEBUG
; 4581 : 				OutputDebugString("Reset return: still have buffers.\n");
; 4582 : #endif //API_DEBUG
; 4583 : 				return(MMSYSERR_NOERROR);
; 4584 : 			}
; 4585 : 			else
; 4586 : 				return( MMSYSERR_NOERROR );
; 4587 : 		}
; 4588 : 		
; 4589 : 		/******************************************************************/
; 4590 : 		/*  If the previous reset has not completed then just flush the   */
; 4591 : 		/*  pipes and exit.                                               */
; 4592 : 		/******************************************************************/
; 4593 : 		if ( phTTS->bMemoryReset )

  017e2	39 9e 8c 00 00
	00		 cmp	 DWORD PTR [esi+140], ebx
  017e8	74 5b		 je	 SHORT $L72090

; 4594 : 		{
; 4595 : 			// reset the sync event so that we can use it to see when 
; 4596 : 			// this stuff gets through
; 4597 : #ifdef WIN32
; 4598 : 			ResetEvent(phTTS->hSyncEvent);

  017ea	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  017ed	51		 push	 ecx
  017ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 4599 : #ifdef	TYPING_MODE // tek 17jun97
; 4600 : 			TextToSpeechSpeakEx( phTTS, szCforce3,TTS_FORCE,FALSE);

  017f4	53		 push	 ebx
  017f5	8d 54 24 14	 lea	 edx, DWORD PTR _szCforce3$[esp+32]
  017f9	6a 01		 push	 1
  017fb	52		 push	 edx
  017fc	56		 push	 esi
  017fd	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 4601 : #else
; 4602 : 			
; 4603 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 4604 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 4605 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 4606 : 			TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 4607 : 			
; 4608 : #endif //TYPING_MODE
; 4609 : #endif
; 4610 : #if defined __osf__ || defined __linux__
; 4611 : 			OP_ResetEvent(phTTS->hSyncEvent);
; 4612 : 			
; 4613 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4614 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4615 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4616 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4617 : #endif
; 4618 : /****************************************************************/
; 4619 : /*  Wait until the VTM thread is about to send a buffer.        */
; 4620 : /****************************************************************/
; 4621 : /* tek 19aug96 this is probably a bad way to do it; it is 
; 4622 : better to wait for the sync even that we get from those
; 4623 : forces going through..
; 4624 : */
; 4625 : #ifdef API_DEBUG
; 4626 : sprintf(szTemp,"TTSReset wait for sync at %ld \n",timeGetTime());
; 4627 : OutputDebugString(szTemp);
; 4628 : #endif //API_DEBUG
; 4629 : #ifdef WIN32
; 4630 : 			WaitForSingleObject(phTTS->hSyncEvent,INFINITE);

  01802	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  01805	83 c4 10	 add	 esp, 16			; 00000010H
  01808	6a ff		 push	 -1
  0180a	50		 push	 eax
  0180b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 4631 : #endif
; 4632 : #if defined __osf__ || defined __linux__
; 4633 : 			OP_WaitForEvent(phTTS->hSyncEvent, OP_INFINITE);
; 4634 : #endif
; 4635 : 			//                while ( ! phTTS->bSendingBuffer )
; 4636 : 			//        {
; 4637 : 			//      Sleep( SEND_BUFFER_WAIT_TIME );
; 4638 : 			//        }
; 4639 : #ifdef API_DEBUG
; 4640 : 			sprintf(szTemp,"TTSReset sync'd at %ld\n",timeGetTime());
; 4641 : 			OutputDebugString(szTemp);
; 4642 : #endif //API_DEBUG
; 4643 : 			/****************************************************************/
; 4644 : 			/*  Empty all of the Text-To-Speech pipes.                      */
; 4645 : 			/****************************************************************/
; 4646 : 			
; 4647 : 			pKsd_t->halting = TRUE;
; 4648 : 			mmStatus = WaitForEmptyPipes( phTTS,
; 4649 : 				MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 4650 : 				TRUE );

  01811	6a 01		 push	 1
  01813	68 10 27 00 00	 push	 10000			; 00002710H
  01818	56		 push	 esi
  01819	c7 87 74 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+372], 1
  01823	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  01828	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4651 : 			pKsd_t->halting = FALSE;

  0182b	89 9f 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebx

; 4652 : 			// tek 29aug96 I'm not clear about the state of cmd_flush
; 4653 : 			// at this point. I don't know if I can clear it, because
; 4654 : 			// I *think* we're nested. But, I'll do it anyway.
; 4655 : 			pKsd_t->cmd_flush = FALSE;

  01831	89 9f 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebx

; 4656 : #ifdef API_DEBUG
; 4657 : 			if (pipe_count( pKsd_t->buffer_pipe ))
; 4658 : 			{
; 4659 : 				OutputDebugString("Reset return: still have buffers. \n");
; 4660 : 			}
; 4661 : 			OutputDebugString("TTSReset() exiting 2.\n");
; 4662 : #endif //API_DEBUG
; 4663 : 			
; 4664 : 			// 16jun97 tek bats385
; 4665 : 			// merged 28jul97 tek
; 4666 : 			phTTS->bInReset = FALSE;

  01837	89 9e dc 00 00
	00		 mov	 DWORD PTR [esi+220], ebx
  0183d	5f		 pop	 edi
  0183e	5e		 pop	 esi
  0183f	5d		 pop	 ebp
  01840	5b		 pop	 ebx

; 4997 : 	  return( MMSYSERR_ERROR );
; 4998 :   
; 4999 :   return( MMSYSERR_NOERROR );
; 5000 : }

  01841	83 c4 0c	 add	 esp, 12			; 0000000cH
  01844	c3		 ret	 0
$L72090:

; 4667 : 			
; 4668 : #ifdef WIN32
; 4669 : 			if (mmStatus)
; 4670 : 				return( mmStatus );
; 4671 : 			else
; 4672 : #endif
; 4673 : 				return(mmStatus);
; 4674 : 		}
; 4675 : 		
; 4676 : 		phTTS->bMemoryReset = TRUE;

  01845	c7 86 8c 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+140], 1
$L72084:

; 4677 :   }
; 4678 :   
; 4679 :   /********************************************************************/
; 4680 :   /*  At this point there may still be a clause stuck in ph. Force    */
; 4681 :   /*  the clause out.                                                 */
; 4682 :   /********************************************************************/
; 4683 :   
; 4684 :   /********************************************************************/
; 4685 :   /*  Set the halting flag. This will cause the CMD, LTS, PH, VTM,    */
; 4686 :   /*  and SYNC threads to all discard input data and flush the pipes. */
; 4687 :   /********************************************************************/
; 4688 : #ifdef TYPING_MODE
; 4689 :   if (!bWasTyping)

  0184f	39 5c 24 20	 cmp	 DWORD PTR _bWasTyping$[esp+24], ebx
  01853	75 23		 jne	 SHORT $L72091

; 4690 :   {
; 4691 : #endif //TYPING_MODE
; 4692 : 	  //tek 22aug96
; 4693 : 	  pKsd_t->halting = TRUE;
; 4694 : 	  
; 4695 : 	  
; 4696 : 
; 4697 : #ifdef	TYPING_MODE // tek 17jun97
; 4698 : 	  TextToSpeechSpeakEx( phTTS, szCforce3,TTS_FORCE,FALSE); // bats 385

  01855	53		 push	 ebx
  01856	8d 4c 24 14	 lea	 ecx, DWORD PTR _szCforce3$[esp+32]
  0185a	6a 01		 push	 1
  0185c	51		 push	 ecx
  0185d	56		 push	 esi
  0185e	c7 87 74 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+372], 1
  01868	e8 00 00 00 00	 call	 _TextToSpeechSpeakEx

; 4699 : #else
; 4700 : #ifdef WIN32
; 4701 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 4702 : #ifndef OLEDECTALK
; 4703 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 4704 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 4705 : 	  TextToSpeechSpeakEx( phTTS, "", TTS_FORCE, FALSE );
; 4706 : #endif
; 4707 : #endif
; 4708 : #if defined __osf__ || defined __linux__
; 4709 : 	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4710 : 	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4711 : 	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4712 : 	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 4713 : #endif
; 4714 : #endif //TYPING_MODE
; 4715 : 	  
; 4716 : 	  /********************************************************************/
; 4717 : 	  /*  Wait for the Text thread to complete all text queueing.         */
; 4718 : 	  /********************************************************************/
; 4719 : 	  // tek 22aug96
; 4720 : 	  WaitForTextQueuingToComplete( phTTS, TRUE );

  0186d	6a 01		 push	 1
  0186f	56		 push	 esi
  01870	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete
  01875	83 c4 18	 add	 esp, 24			; 00000018H
$L72091:

; 4721 : #ifdef TYPING_MODE
; 4722 :   }
; 4723 : #endif //TYPING_MODE
; 4724 :   // tek 22aug96 by now, the cmd parser should be well oiled. Let it go*/
; 4725 :   pKsd_t->cmd_flush = FALSE;

  01878	89 9f 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebx

; 4726 :   
; 4727 :   /********************************************************************/
; 4728 :   /*  Perform an second audio reset to immediately stop audio from    */
; 4729 :   /*  playing and to make sure the VTM thread is not blocked.         */
; 4730 :   /********************************************************************/
; 4731 :   
; 4732 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  0187e	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01884	3b c3		 cmp	 eax, ebx
  01886	75 0f		 jne	 SHORT $L72092

; 4733 :   {
; 4734 : 	  PA_Reset( phTTS->pAudioHandle );

  01888	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  0188e	52		 push	 edx
  0188f	e8 00 00 00 00	 call	 _PA_Reset
  01894	83 c4 04	 add	 esp, 4
$L72092:

; 4735 :   }
; 4736 :   
; 4737 :   // tek 19aug96 anti-block for the memory case.. 
; 4738 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  01897	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  0189e	75 4a		 jne	 SHORT $L72093

; 4739 :   {
; 4740 : 	  if (pipe_count( phTTS->pKernelShareData->buffer_pipe ) < 1)

  018a0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  018a3	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  018a9	51		 push	 ecx
  018aa	e8 00 00 00 00	 call	 _pipe_count
  018af	83 c4 04	 add	 esp, 4
  018b2	83 f8 01	 cmp	 eax, 1
  018b5	73 0a		 jae	 SHORT $L72094

; 4741 : 		  TextToSpeechAddBuffer(phTTS, NULL); //deadlock avoidance

  018b7	53		 push	 ebx
  018b8	56		 push	 esi
  018b9	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  018be	83 c4 08	 add	 esp, 8
$L72094:

; 4742 : 
; 4743 : 	  EnterCriticalSection(phTTS->pcsMemoryBuffer);

  018c1	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  018c7	52		 push	 edx
  018c8	ff d5		 call	 ebp

; 4744 : 
; 4745 : 	  // if we have an active output buffer, clear it.
; 4746 : 	  if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  018ca	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  018d0	3b c3		 cmp	 eax, ebx
  018d2	74 09		 je	 SHORT $L72098

; 4747 : 	  {
; 4748 : 		  
; 4749 : 		  pTTS_Buffer->dwBufferLength = 0;

  018d4	89 58 18	 mov	 DWORD PTR [eax+24], ebx

; 4750 : 		  pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  018d7	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 4751 : 		  pTTS_Buffer->dwNumberOfIndexMarks = 0;

  018da	89 58 20	 mov	 DWORD PTR [eax+32], ebx
$L72098:

; 4752 : 		  
; 4753 : 		  
; 4754 : 	  } // was not a null buffer
; 4755 : 
; 4756 : 	  LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  018dd	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  018e3	50		 push	 eax
  018e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72093:

; 4757 :   }
; 4758 :   
; 4759 :   /********************************************************************/
; 4760 :   /*  Maximize the queued sample count to release the                 */
; 4761 :   /*  WaitForAudioSampleToPlay() function (in file sync.c).           */
; 4762 :   /********************************************************************/
; 4763 : #ifdef TYPING_MODE
; 4764 :   if (!bWasTyping)

  018ea	39 5c 24 20	 cmp	 DWORD PTR _bWasTyping$[esp+24], ebx
  018ee	75 2d		 jne	 SHORT $L72100

; 4765 :   {
; 4766 : #endif //TYPING_MODE
; 4767 : 
; 4768 : 	  EnterCriticalSection( phTTS->pcsQueuedSampleCount );

  018f0	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  018f6	51		 push	 ecx
  018f7	ff d5		 call	 ebp

; 4769 : 	  phTTS->dwQueuedSampleCount = 4294967295;
; 4770 : 	  LeaveCriticalSection( phTTS->pcsQueuedSampleCount );

  018f9	8b 96 b4 00 00
	00		 mov	 edx, DWORD PTR [esi+180]
  018ff	c7 46 7c ff ff
	ff ff		 mov	 DWORD PTR [esi+124], -1
  01906	52		 push	 edx
  01907	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 4771 : 	  
; 4772 : #ifdef TYPING_MODE
; 4773 :   }
; 4774 : #endif //TYPING_MODE
; 4775 :   /********************************************************************/
; 4776 :   /*  Empty all of the Text-To-Speech pipes.                          */
; 4777 :   /********************************************************************/
; 4778 : #ifdef TYPING_MODE
; 4779 :   if (!bWasTyping)
; 4780 : #endif //TYPING_MODE
; 4781 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 4782 : 	  MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 4783 : 	  TRUE );

  0190d	6a 01		 push	 1
  0190f	68 10 27 00 00	 push	 10000			; 00002710H
  01914	56		 push	 esi
  01915	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  0191a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72100:

; 4784 :   
; 4785 :   /********************************************************************/
; 4786 :   /*  Initialize the VTM, PH, LTS, and CMD threads.                   */
; 4787 :   /********************************************************************/
; 4788 : #ifdef API_DEBUG
; 4789 : sprintf(szTemp,"TTSReset init threads at %ld\n",timeGetTime());
; 4790 :   OutputDebugString(szTemp);  
; 4791 : #endif //API_DEBUG
; 4792 :   if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  0191d	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  01924	74 09		 je	 SHORT $L72101

; 4793 :   {
; 4794 : 	  InitializeVTM(phTTS);

  01926	56		 push	 esi
  01927	e8 00 00 00 00	 call	 _InitializeVTM
  0192c	83 c4 04	 add	 esp, 4
$L72101:

; 4795 :   };
; 4796 :   
; 4797 :   
; 4798 :   phinit( phTTS, bReset );

  0192f	8b 6c 24 24	 mov	 ebp, DWORD PTR _bReset$[esp+24]
  01933	55		 push	 ebp
  01934	56		 push	 esi
  01935	e8 00 00 00 00	 call	 _phinit

; 4799 : #ifdef TYPING_MODE
; 4800 :   if (!bWasTyping)

  0193a	8b 44 24 28	 mov	 eax, DWORD PTR _bWasTyping$[esp+32]
  0193e	83 c4 08	 add	 esp, 8
  01941	3b c3		 cmp	 eax, ebx
  01943	75 13		 jne	 SHORT $L72102

; 4801 :   {
; 4802 : #endif //TYPING_MODE
; 4803 : 	  
; 4804 : 	  ls_util_lts_init(phTTS->pLTSThreadData);

  01945	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01948	50		 push	 eax
  01949	e8 00 00 00 00	 call	 _ls_util_lts_init

; 4805 : 	  
; 4806 : 	  
; 4807 : 	  cmd_init( phTTS,bReset );

  0194e	55		 push	 ebp
  0194f	56		 push	 esi
  01950	e8 00 00 00 00	 call	 _cmd_init
  01955	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72102:

; 4808 : 	  
; 4809 : #ifdef TYPING_MODE
; 4810 :   }
; 4811 : #endif //TYPING_MODE
; 4812 :   
; 4813 :   pKsd_t->halting = FALSE;
; 4814 :   // tek 22aug96 we still need to do a LAST_VOICE to make sure the VTM */
; 4815 :   // is in a nice state..
; 4816 :   {
; 4817 : #if defined __osf__ || defined __linux__
; 4818 : 	  unsigned short LastVoice=LAST_VOICE;
; 4819 : 	  write_pipe( pKsd_t->lts_pipe, &LastVoice, 1 );
; 4820 : #endif
; 4821 : 
; 4822 : #ifdef WIN32
; 4823 : 	  unsigned short LastVoice[2],phone;
; 4824 : 	  LastVoice[0]=LAST_VOICE;
; 4825 : 	  LastVoice[1]=SYNC;
; 4826 : #ifdef TYPING_MODE
; 4827 : 	  //	if (bWasTyping)
; 4828 : 	  //	{
; 4829 : 	  write_pipe( pKsd_t->ph_pipe, &LastVoice, 2 );

  01958	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  0195e	8d 4c 24 24	 lea	 ecx, DWORD PTR _LastVoice$72103[esp+24]
  01962	6a 02		 push	 2
  01964	51		 push	 ecx
  01965	52		 push	 edx
  01966	89 9f 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebx
  0196c	66 c7 44 24 30
	03 1f		 mov	 WORD PTR _LastVoice$72103[esp+36], 7939 ; 00001f03H
  01973	66 c7 44 24 32
	0a 1f		 mov	 WORD PTR _LastVoice$72103[esp+38], 7946 ; 00001f0aH
  0197a	e8 00 00 00 00	 call	 _write_pipe

; 4830 : 	  //	}
; 4831 : 	  //	else
; 4832 : #else //TYPING_MODE
; 4833 : 	  write_pipe( pKsd_t->lts_pipe, &LastVoice, 2 );
; 4834 : 	  /* GL 01/08/98  BATS#547  force a extra space after SYNC, VT/HT to fix the
; 4835 : 	  dropping punctuation problem. */
; 4836 : 	  phone = (PFASCII<<PSFONT) + ' ';
; 4837 : 	  write_pipe( pKsd_t->lts_pipe, &phone, 1 );
; 4838 : #endif //TYPING_MODE
; 4839 : #endif
; 4840 :   }
; 4841 :   
; 4842 :   /********************************************************************/
; 4843 :   /*  Perform a third audio reset to make sure the audio queue is     */
; 4844 :   /*  empty after the pipes were emptied.                             */
; 4845 :   /********************************************************************/
; 4846 :   
; 4847 :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  0197f	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01985	83 c4 0c	 add	 esp, 12			; 0000000cH
  01988	3b c3		 cmp	 eax, ebx
  0198a	75 0f		 jne	 SHORT $L72105

; 4848 :   {
; 4849 : 	  PA_Reset( phTTS->pAudioHandle );

  0198c	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  01992	50		 push	 eax
  01993	e8 00 00 00 00	 call	 _PA_Reset
  01998	83 c4 04	 add	 esp, 4
$L72105:

; 4850 :   }
; 4851 :   // tek 19aug96 anti-block for the memory case.. 
; 4852 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  0199b	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  019a2	75 4e		 jne	 SHORT $L72106

; 4853 :   {     
; 4854 : 	  if (pipe_count( phTTS->pKernelShareData->buffer_pipe ) < 2)

  019a4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  019a7	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  019ad	52		 push	 edx
  019ae	e8 00 00 00 00	 call	 _pipe_count
  019b3	83 c4 04	 add	 esp, 4
  019b6	83 f8 02	 cmp	 eax, 2
  019b9	73 0a		 jae	 SHORT $L72107

; 4855 : 		  TextToSpeechAddBuffer(phTTS, NULL); // deadlock avoidance

  019bb	53		 push	 ebx
  019bc	56		 push	 esi
  019bd	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  019c2	83 c4 08	 add	 esp, 8
$L72107:

; 4856 : 
; 4857 : 	  EnterCriticalSection(phTTS->pcsMemoryBuffer);

  019c5	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  019cb	50		 push	 eax
  019cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 4858 : 
; 4859 : 	  // if we have an active output buffer, clear it.
; 4860 : 	  if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)

  019d2	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  019d8	3b c3		 cmp	 eax, ebx
  019da	74 09		 je	 SHORT $L72111

; 4861 : 	  {
; 4862 : 		  
; 4863 : 		  pTTS_Buffer->dwBufferLength = 0;

  019dc	89 58 18	 mov	 DWORD PTR [eax+24], ebx

; 4864 : 		  pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  019df	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 4865 : 		  pTTS_Buffer->dwNumberOfIndexMarks = 0;

  019e2	89 58 20	 mov	 DWORD PTR [eax+32], ebx
$L72111:

; 4866 : 		  
; 4867 : 		  
; 4868 : 	  } // was not a null buffer
; 4869 : 
; 4870 : 	  LeaveCriticalSection(phTTS->pcsMemoryBuffer);

  019e5	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  019eb	51		 push	 ecx
  019ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72106:

; 4871 : 
; 4872 :   }
; 4873 : #ifdef TYPING_MODE
; 4874 :   if (bWasTyping)

  019f2	8b 44 24 20	 mov	 eax, DWORD PTR _bWasTyping$[esp+24]

; 4875 :   {
; 4876 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 4877 : 		  15,
; 4878 : 		  TRUE );

  019f6	6a 01		 push	 1
  019f8	3b c3		 cmp	 eax, ebx
  019fa	74 04		 je	 SHORT $L72112
  019fc	6a 0f		 push	 15			; 0000000fH

; 4879 :   }
; 4880 :   else

  019fe	eb 05		 jmp	 SHORT $L73216
$L72112:

; 4881 : #endif //TYPING_MODE
; 4882 : 	  /********************************************************************/
; 4883 : 	  /*  Empty all of the Text-To-Speech pipes.                          */
; 4884 : 	  /********************************************************************/
; 4885 : 	  //tek 22aug96
; 4886 : 	  mmStatus = WaitForEmptyPipes( phTTS,
; 4887 : 	  MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
; 4888 : 	  TRUE );

  01a00	68 10 27 00 00	 push	 10000			; 00002710H
$L73216:
  01a05	56		 push	 esi
  01a06	e8 00 00 00 00	 call	 _WaitForEmptyPipes

; 4889 :   
; 4890 :   
; 4891 :   /********************************************************************/
; 4892 :   /*  Zero the queued sample count (used for index marks and sync).   */
; 4893 :   /********************************************************************/
; 4894 :   
; 4895 :   EnterCriticalSection( phTTS->pcsQueuedSampleCount );

  01a0b	8b 96 b4 00 00
	00		 mov	 edx, DWORD PTR [esi+180]
  01a11	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a14	89 44 24 20	 mov	 DWORD PTR _mmStatus$[esp+24], eax
  01a18	52		 push	 edx
  01a19	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 4896 :   phTTS->dwQueuedSampleCount = 0;
; 4897 :   LeaveCriticalSection( phTTS->pcsQueuedSampleCount );

  01a1f	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  01a25	89 5e 7c	 mov	 DWORD PTR [esi+124], ebx
  01a28	50		 push	 eax
  01a29	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 4898 :   
; 4899 :   /********************************************************************/
; 4900 :   /*  Conditionally reset the state of the Text-To-Speech system.     */
; 4901 :   /********************************************************************/
; 4902 :   
; 4903 :   
; 4904 :   if ( bReset )

  01a2f	3b eb		 cmp	 ebp, ebx
  01a31	74 62		 je	 SHORT $L72114

; 4905 :   {
; 4906 : 	  switch( phTTS->dwOutputState )
; 4907 : 	  {

  01a33	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01a39	48		 dec	 eax
  01a3a	74 16		 je	 SHORT $L72119
  01a3c	48		 dec	 eax
  01a3d	74 0b		 je	 SHORT $L72120
  01a3f	48		 dec	 eax
  01a40	75 19		 jne	 SHORT $L72116

; 4917 : 		  
; 4918 : 	  case STATE_OUTPUT_LOG_FILE:
; 4919 : 		  
; 4920 : 		  TextToSpeechCloseLogFile( phTTS );

  01a42	56		 push	 esi
  01a43	e8 00 00 00 00	 call	 _TextToSpeechCloseLogFile

; 4921 : 		  break;

  01a48	eb 0e		 jmp	 SHORT $L73217
$L72120:

; 4911 : 		  break;
; 4912 : 		  
; 4913 : 	  case STATE_OUTPUT_WAVE_FILE:
; 4914 : 		  
; 4915 : 		  TextToSpeechCloseWaveOutFile( phTTS );

  01a4a	56		 push	 esi
  01a4b	e8 00 00 00 00	 call	 _TextToSpeechCloseWaveOutFile

; 4916 : 		  break;

  01a50	eb 06		 jmp	 SHORT $L73217
$L72119:

; 4908 : 	  case STATE_OUTPUT_MEMORY:
; 4909 : 		  
; 4910 : 		  TextToSpeechCloseInMemory( phTTS );

  01a52	56		 push	 esi
  01a53	e8 00 00 00 00	 call	 _TextToSpeechCloseInMemory
$L73217:
  01a58	83 c4 04	 add	 esp, 4
$L72116:

; 4922 : 		  
; 4923 : 	  default:
; 4924 : 		  break;
; 4925 : 	  }
; 4926 : 	  
; 4927 : 	  /******************************************************************/
; 4928 : 	  /*  Initialize the Text-To-Speech system state variables.         */
; 4929 : 	  /******************************************************************/
; 4930 : 	  
; 4931 : 	  pKsd_t->cmd_flush = FALSE;

  01a5b	89 9f 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebx

; 4932 : 	  pKsd_t->spc_flush = FALSE;

  01a61	89 9f a4 01 00
	00		 mov	 DWORD PTR [edi+420], ebx

; 4933 : 	  pKsd_t->logflag  = 0;

  01a67	89 9f 04 02 00
	00		 mov	 DWORD PTR [edi+516], ebx

; 4934 : 	  /* GL 11/15/1996 set defaulted Spanish to Latin */
; 4935 : #ifdef SPANISH_LA
; 4936 : 	  pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
; 4937 : #else
; 4938 : 	  pKsd_t->modeflag = MODE_CITATION;

  01a6d	c7 87 00 02 00
	00 00 01 00 00	 mov	 DWORD PTR [edi+512], 256 ; 00000100H

; 4939 : #endif //SPANISH_LA
; 4940 : 	  pKsd_t->sayflag = SAY_CLAUSE;

  01a77	89 9f 08 02 00
	00		 mov	 DWORD PTR [edi+520], ebx

; 4941 : 	  pKsd_t->pronflag = 0;

  01a7d	89 9f 0c 02 00
	00		 mov	 DWORD PTR [edi+524], ebx

; 4942 : 	  pKsd_t->wbreak = FALSE;

  01a83	89 9f 14 02 00
	00		 mov	 DWORD PTR [edi+532], ebx

; 4943 : 	  pKsd_t->text_flush = FALSE;

  01a89	89 9f 70 01 00
	00		 mov	 DWORD PTR [edi+368], ebx

; 4944 : 	  pKsd_t->async_change = FALSE;

  01a8f	89 9f 38 02 00
	00		 mov	 DWORD PTR [edi+568], ebx
$L72114:

; 4945 :   }
; 4946 :   
; 4947 :   /********************************************************************/
; 4948 :   /*  Free all allocated index mark memory.                           */
; 4949 :   /********************************************************************/
; 4950 :   
; 4951 :   
; 4952 :   free_index(pKsd_t);

  01a95	57		 push	 edi
  01a96	e8 00 00 00 00	 call	 _free_index

; 4953 :   
; 4954 :   /********************************************************************/
; 4955 :   /*  Enable error messages.                                          */
; 4956 :   /********************************************************************/
; 4957 :   
; 4958 :   phTTS->bEnableErrorMessage = TRUE;
; 4959 :   
; 4960 :   
; 4961 :   if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  01a9b	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01aa1	bd 01 00 00 00	 mov	 ebp, 1
  01aa6	83 c4 04	 add	 esp, 4
  01aa9	3b c5		 cmp	 eax, ebp
  01aab	89 ae 88 00 00
	00		 mov	 DWORD PTR [esi+136], ebp
  01ab1	75 09		 jne	 SHORT $L72123

; 4962 :   {
; 4963 : 	  ReturnRemainingBuffers(phTTS);   //tek 03sep96 make sure..

  01ab3	56		 push	 esi
  01ab4	e8 00 00 00 00	 call	 _ReturnRemainingBuffers
  01ab9	83 c4 04	 add	 esp, 4
$L72123:

; 4964 : 	  // tek somehow in here, Q2Mem could have snagged a buffer and
; 4965 : 	  // if so, we have to get rid of it..
; 4966 :   }
; 4967 :   
; 4968 :   if ((pKsd_t->buffer_pipe != NULL) && pipe_count(pKsd_t->buffer_pipe ) )

  01abc	8b bf e4 00 00
	00		 mov	 edi, DWORD PTR [edi+228]
  01ac2	3b fb		 cmp	 edi, ebx
  01ac4	74 16		 je	 SHORT $L72125
  01ac6	57		 push	 edi
  01ac7	e8 00 00 00 00	 call	 _pipe_count
  01acc	83 c4 04	 add	 esp, 4
  01acf	85 c0		 test	 eax, eax
  01ad1	74 09		 je	 SHORT $L72125

; 4969 :   {
; 4970 : #ifdef API_DEBUG
; 4971 : 	  OutputDebugString("Reset return: still have buffers. \n");
; 4972 : #endif //API_DEBUG
; 4973 : 	  ReturnRemainingBuffers(phTTS);

  01ad3	56		 push	 esi
  01ad4	e8 00 00 00 00	 call	 _ReturnRemainingBuffers
  01ad9	83 c4 04	 add	 esp, 4
$L72125:

; 4974 :   }
; 4975 :   
; 4976 :   if (phTTS->pTTS_Buffer != NULL)

  01adc	39 9e a0 00 00
	00		 cmp	 DWORD PTR [esi+160], ebx
  01ae2	74 09		 je	 SHORT $L72127

; 4977 : 	  SendBuffer(phTTS); // tek 04sep96 get rid of current

  01ae4	56		 push	 esi
  01ae5	e8 00 00 00 00	 call	 _SendBuffer
  01aea	83 c4 04	 add	 esp, 4
$L72127:

; 4978 :   // tek 29aug96 if we got this far, we know that we
; 4979 :   // can clear out MemoryReset.. normally SendBuf() would, 
; 4980 :   // but we've moved teh one that actually returns the buffers 
; 4981 :   // back in time.. 
; 4982 :   // tek 03sep96 now SendBuffer doesn't ever clear MemoryReset..
; 4983 :   phTTS->bMemoryReset = FALSE;
; 4984 :   // 16jun97 tek bats385
; 4985 :   // merged 28jul97 tek
; 4986 :   phTTS->bInReset = FALSE;
; 4987 :   
; 4988 : #ifdef API_DEBUG
; 4989 :   sprintf(szTemp,"TTSReset() exiting 3 at %ld\n",timeGetTime());
; 4990 :   OutputDebugString(szTemp);
; 4991 : #endif //API_DEBUG
; 4992 : #ifdef TYPING_MODE
; 4993 :   if (phTTS->dwOutputState == STATE_OUTPUT_AUDIO)

  01aed	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01af3	89 9e 8c 00 00
	00		 mov	 DWORD PTR [esi+140], ebx
  01af9	3b c3		 cmp	 eax, ebx
  01afb	89 9e dc 00 00
	00		 mov	 DWORD PTR [esi+220], ebx
  01b01	75 06		 jne	 SHORT $L72128

; 4994 : 	  phTTS->bInTypingMode = TRUE;

  01b03	89 ae d4 00 00
	00		 mov	 DWORD PTR [esi+212], ebp
$L72128:

; 4995 : #endif //TYPING_MODE
; 4996 :   if  ( mmStatus )

  01b09	8b 4c 24 20	 mov	 ecx, DWORD PTR _mmStatus$[esp+24]
  01b0d	33 c0		 xor	 eax, eax
  01b0f	5f		 pop	 edi
  01b10	3b cb		 cmp	 ecx, ebx
  01b12	5e		 pop	 esi
  01b13	5d		 pop	 ebp
  01b14	0f 95 c0	 setne	 al
  01b17	5b		 pop	 ebx

; 4997 : 	  return( MMSYSERR_ERROR );
; 4998 :   
; 4999 :   return( MMSYSERR_NOERROR );
; 5000 : }

  01b18	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b1b	c3		 ret	 0
_TextToSpeechReset ENDP
_TEXT	ENDS
PUBLIC	_PumpModeMessage
EXTRN	__imp__Sleep@4:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_bReset$ = 12
_WaitForTextQueuingToComplete PROC NEAR

; 5038 : {

  01b20	53		 push	 ebx

; 5039 : 	int iLockupCount=0;
; 5040 : #ifdef API_DEBUG
; 5041 : 	char szTemp[256]="";
; 5042 : 	ULONG ulStartTime, ulEndTime;
; 5043 : 	ulStartTime=timeGetTime();
; 5044 : 	sprintf(szTemp, "WFTQTC() at %ld.\n", ulStartTime);
; 5045 : 	OutputDebugString(szTemp);
; 5046 : #endif //API_DEBUG
; 5047 : 	
; 5048 : 	/********************************************************************/
; 5049 : 	/*  Wait for the Text-To-Speech thread to complete text queueing.   */
; 5050 : 	/*  up to all messages numbered uiLastTextMessageNumber.            */
; 5051 : 	/********************************************************************/
; 5052 : 	
; 5053 : 	while ( TRUE )
; 5054 : 	{
; 5055 : 
; 5056 : 		EnterCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );
; 5057 : 
; 5058 : 		if ( phTTS->uiLastQueuedTextMsgNumber < phTTS->uiLastTextMsgNumber )

  01b21	8b 5c 24 0c	 mov	 ebx, DWORD PTR _bReset$[esp]
  01b25	55		 push	 ebp
  01b26	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__LeaveCriticalSection@4
  01b2c	56		 push	 esi
  01b2d	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  01b31	57		 push	 edi
  01b32	33 ff		 xor	 edi, edi
$L72137:
  01b34	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  01b3a	50		 push	 eax
  01b3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  01b41	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  01b44	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  01b47	3b c8		 cmp	 ecx, eax
  01b49	73 69		 jae	 SHORT $L72139

; 5059 : 		{
; 5060 : 
; 5061 : 			LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  01b4b	8b 96 b8 00 00
	00		 mov	 edx, DWORD PTR [esi+184]
  01b51	52		 push	 edx
  01b52	ff d5		 call	 ebp

; 5062 : 
; 5063 : 			/****************************************************************/
; 5064 : 			/*  Set the sync event in case the cmd thread is blocked in the */
; 5065 : 			/*  cmd_sync() function.                                        */
; 5066 : 			/****************************************************************/
; 5067 : 			
; 5068 : 			if ( bReset )

  01b54	85 db		 test	 ebx, ebx
  01b56	74 23		 je	 SHORT $L72141

; 5069 : 			{
; 5070 : #ifdef WIN32
; 5071 : 				SetEvent( phTTS->hSyncEvent );

  01b58	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  01b5b	50		 push	 eax
  01b5c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 5072 : #endif
; 5073 : #if defined __osf__ || defined __linux__
; 5074 : 				OP_SetEvent( phTTS->hSyncEvent );
; 5075 : #endif
; 5076 : 				
; 5077 : 				
; 5078 : 				/**************************************************************/
; 5079 : 				/*  Perform an audio reset to immediately stop audio from     */
; 5080 : 				/*  playing and to make sure the VTM thread is not blocked.   */
; 5081 : 				/**************************************************************/
; 5082 : 				
; 5083 : 				if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01b62	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01b68	85 c0		 test	 eax, eax
  01b6a	75 0f		 jne	 SHORT $L72141

; 5084 : 				{
; 5085 : 					PA_Reset( phTTS->pAudioHandle );

  01b6c	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  01b72	51		 push	 ecx
  01b73	e8 00 00 00 00	 call	 _PA_Reset
  01b78	83 c4 04	 add	 esp, 4
$L72141:

; 5086 : 				}
; 5087 : 			}
; 5088 : 			
; 5089 : 			/****************************************************************/
; 5090 : 			/*  Go to sleep while the text queue empties.                   */
; 5091 : 			/****************************************************************/
; 5092 : 			Sleep( TEXT_QUEUE_WAIT_TIME );

  01b7b	6a 05		 push	 5
  01b7d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 5093 : 			PumpModeMessage(phTTS->pAudioHandle);

  01b83	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  01b89	52		 push	 edx
  01b8a	e8 00 00 00 00	 call	 _PumpModeMessage

; 5094 : 			if (( phTTS->dwOutputState == STATE_OUTPUT_MEMORY ) && ( bReset ))

  01b8f	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01b95	83 c4 04	 add	 esp, 4
  01b98	83 f8 01	 cmp	 eax, 1
  01b9b	75 97		 jne	 SHORT $L72137
  01b9d	85 db		 test	 ebx, ebx
  01b9f	74 93		 je	 SHORT $L72137

; 5095 : 			{
; 5096 : 				iLockupCount++;

  01ba1	47		 inc	 edi

; 5097 : 				
; 5098 : 				if ( iLockupCount > TEXT_LOCKUP_COUNT )

  01ba2	83 ff 02	 cmp	 edi, 2
  01ba5	7e 8d		 jle	 SHORT $L72137

; 5099 : 				{
; 5100 : 					FixMemoryLockup( phTTS );

  01ba7	56		 push	 esi
  01ba8	e8 00 00 00 00	 call	 _FixMemoryLockup
  01bad	83 c4 04	 add	 esp, 4

; 5101 : 					
; 5102 : 					iLockupCount = 0;

  01bb0	33 ff		 xor	 edi, edi
  01bb2	eb 80		 jmp	 SHORT $L72137
$L72139:

; 5103 : 				}
; 5104 : 			}
; 5105 : 			
; 5106 : 		}
; 5107 : 		else
; 5108 : 		{
; 5109 : 
; 5110 : 			LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  01bb4	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  01bba	50		 push	 eax
  01bbb	ff d5		 call	 ebp
  01bbd	5f		 pop	 edi
  01bbe	5e		 pop	 esi
  01bbf	5d		 pop	 ebp
  01bc0	5b		 pop	 ebx

; 5111 : 
; 5112 : 			break;
; 5113 : 		}
; 5114 : 	}
; 5115 : #ifdef API_DEBUG
; 5116 : 	ulEndTime=timeGetTime();
; 5117 : 	sprintf(szTemp, "WFTQTC() exit %ld ms.\n", ulEndTime-ulStartTime);
; 5118 : 	OutputDebugString(szTemp);
; 5119 : #endif //API_DEBUG
; 5120 : 	
; 5121 : 	return;
; 5122 : }

  01bc1	c3		 ret	 0
_WaitForTextQueuingToComplete ENDP
_TEXT	ENDS
EXTRN	_PA_WaitForPlayToComplete:NEAR
EXTRN	_OP_Sleep:NEAR
_BSS	SEGMENT
	ALIGN	4

$SG72153 DB	01H DUP (?)
	ALIGN	4

$SG72154 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechSync PROC NEAR

; 5163 : {

  01bd0	56		 push	 esi

; 5164 : 	MMRESULT mmStatus = MMSYSERR_NOERROR;
; 5165 : 	
; 5166 : 	/********************************************************************/
; 5167 : 	/*  Return error if invalid handle.                                 */
; 5168 : 	/********************************************************************/
; 5169 : 	
; 5170 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01bd1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01bd5	6a 04		 push	 4
  01bd7	56		 push	 esi
  01bd8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01bde	85 c0		 test	 eax, eax
  01be0	74 07		 je	 SHORT $L72149

; 5171 : 		return( MMSYSERR_INVALHANDLE );

  01be2	b8 05 00 00 00	 mov	 eax, 5
  01be7	5e		 pop	 esi

; 5274 : }

  01be8	c3		 ret	 0
$L72149:

; 5172 : 	
; 5173 : 	/********************************************************************/
; 5174 : 	/*  Resume if the text to speech system has been paused or this     */
; 5175 : 	/*  function will block here forever.                               */
; 5176 : 	/********************************************************************/
; 5177 : #ifndef OLEDECTALK
; 5178 : #if defined __osf__ || defined __linux__
; 5179 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 5180 : #endif
; 5181 : #ifdef WIN32
; 5182 : 		if (
; 5183 : 			( ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
; 5184 : 			&&(!phTTS->bInReset)
; 5185 : 			)

  01be9	f7 46 74 00 00
	00 80		 test	 DWORD PTR [esi+116], -2147483648 ; 80000000H
  01bf0	75 19		 jne	 SHORT $L72150
  01bf2	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  01bf8	85 c0		 test	 eax, eax
  01bfa	75 6a		 jne	 SHORT $L72158

; 5186 : #endif
; 5187 : 			PA_Resume( phTTS->pAudioHandle );

  01bfc	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  01c02	50		 push	 eax
  01c03	e8 00 00 00 00	 call	 _PA_Resume
  01c08	83 c4 04	 add	 esp, 4
$L72150:

; 5188 : #endif //OLEDECTALK
; 5189 : 		/********************************************************************/
; 5190 : 		/*  Wait for the Text thread to complete all text queueing.         */
; 5191 : 		/********************************************************************/
; 5192 : #ifdef WIN32
; 5193 : 		if (!phTTS->bInReset) // tek bats 385 merged 28jul97

  01c0b	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  01c11	85 c0		 test	 eax, eax
  01c13	75 51		 jne	 SHORT $L72158

; 5194 : #endif
; 5195 : 		{
; 5196 : 			WaitForTextQueuingToComplete( phTTS, FALSE );

  01c15	6a 00		 push	 0
  01c17	56		 push	 esi
  01c18	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete

; 5197 : 		}
; 5198 : 		
; 5199 : 		/********************************************************************/
; 5200 : 		/*  Now that all the text is queued, make sure that it is purged.   */
; 5201 : 		/*  Four TTS_FORCE characters are used because of the way the       */
; 5202 : 		/*  WaitForEmptyPipes() function performs the wait.                 */
; 5203 : 		/********************************************************************/
; 5204 : 		
; 5205 : #ifdef WIN32
; 5206 : 		if (!phTTS->bInReset) // tek bats 385 merged 28jul97

  01c1d	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  01c23	83 c4 08	 add	 esp, 8
  01c26	85 c0		 test	 eax, eax
  01c28	75 3c		 jne	 SHORT $L72158

; 5207 : 		{
; 5208 : #ifdef UNDER_CE
; 5209 : 			TextToSpeechSpeak( phTTS, _T(""), TTS_FORCE );
; 5210 : 			TextToSpeechSpeak( phTTS, _T(""), TTS_FORCE );
; 5211 : #else
; 5212 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  01c2a	6a 01		 push	 1
  01c2c	68 00 00 00 00	 push	 OFFSET FLAT:$SG72153
  01c31	56		 push	 esi
  01c32	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 5213 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE ); /* tek 10jan97 don't need */
; 5214 : 			//TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5215 : 			TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  01c37	6a 01		 push	 1
  01c39	68 00 00 00 00	 push	 OFFSET FLAT:$SG72154
  01c3e	56		 push	 esi
  01c3f	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 5216 : #endif //UNDER_CE
; 5217 : 		}
; 5218 : #endif
; 5219 : #if defined __osf__ || defined __linux__
; 5220 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5221 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5222 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5223 : 		TextToSpeechSpeak( phTTS, "", TTS_FORCE );
; 5224 : #endif
; 5225 : 		
; 5226 : 		/********************************************************************/
; 5227 : 		/*  Now wait for all of the Text-To-Speech pipes to empty.          */
; 5228 : 		/********************************************************************/
; 5229 : 		/*  first, wait for the Text thread to complete all text queueing.  */
; 5230 : 		/*  (tek 10jan97)                                                   */
; 5231 : 		/********************************************************************/
; 5232 : #ifdef WIN32
; 5233 : 		if (!phTTS->bInReset)	// tek bats 385 merged 28jul97

  01c44	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  01c4a	83 c4 18	 add	 esp, 24			; 00000018H
  01c4d	85 c0		 test	 eax, eax
  01c4f	75 15		 jne	 SHORT $L72158

; 5234 : 			WaitForTextQueuingToComplete( phTTS, FALSE );

  01c51	6a 00		 push	 0
  01c53	56		 push	 esi
  01c54	e8 00 00 00 00	 call	 _WaitForTextQueuingToComplete

; 5235 : 		
; 5236 : 		// 28jul97 bats 385 merged
; 5237 : 		// this is where we think about exiting if we are in a reset;
; 5238 : 		// there is no need to do any of the subsequent waits, but we
; 5239 : 		// do want to hang here until the reset is done. 
; 5240 : 		if (phTTS->bInReset)

  01c59	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  01c5f	83 c4 08	 add	 esp, 8
  01c62	85 c0		 test	 eax, eax
  01c64	74 18		 je	 SHORT $L72156
$L72158:

; 5241 : 		{
; 5242 : 			while (phTTS->bInReset)
; 5243 : 			{
; 5244 : 				OP_Sleep(SYNC_RESET_CHECK_INTERVAL);

  01c66	6a 1e		 push	 30			; 0000001eH
  01c68	e8 00 00 00 00	 call	 _OP_Sleep
  01c6d	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  01c73	83 c4 04	 add	 esp, 4
  01c76	85 c0		 test	 eax, eax
  01c78	75 ec		 jne	 SHORT $L72158
$L72163:

; 5271 : 			}
; 5272 : 		}
; 5273 : 		return( MMSYSERR_NOERROR );

  01c7a	33 c0		 xor	 eax, eax
  01c7c	5e		 pop	 esi

; 5274 : }

  01c7d	c3		 ret	 0
$L72156:

; 5245 : 			}
; 5246 : 			return (MMSYSERR_NOERROR);
; 5247 : 		}
; 5248 : #endif
; 5249 : 		
; 5250 : 		mmStatus = WaitForEmptyPipes( phTTS,
; 5251 : 			MAXIMUM_SYNC_WAIT_TIME_IN_MSEC,
; 5252 : 			FALSE );

  01c7e	6a 00		 push	 0
  01c80	68 40 77 1b 00	 push	 1800000			; 001b7740H
  01c85	56		 push	 esi
  01c86	e8 00 00 00 00	 call	 _WaitForEmptyPipes
  01c8b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5253 : 		
; 5254 : 		if ( mmStatus )

  01c8e	85 c0		 test	 eax, eax
  01c90	74 07		 je	 SHORT $L72160

; 5255 : 			return( MMSYSERR_ERROR );

  01c92	b8 01 00 00 00	 mov	 eax, 1
  01c97	5e		 pop	 esi

; 5274 : }

  01c98	c3		 ret	 0
$L72160:

; 5256 : 		
; 5257 : 		/********************************************************************/
; 5258 : 		/*  Now that the pipes are all empty, wait for the audio to         */
; 5259 : 		/*  complete.                                                       */
; 5260 : 		/********************************************************************/
; 5261 : 		
; 5262 : 		if( ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  01c99	f7 46 74 00 00
	00 80		 test	 DWORD PTR [esi+116], -2147483648 ; 80000000H
  01ca0	75 d8		 jne	 SHORT $L72163

; 5263 : 		{
; 5264 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  01ca2	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01ca8	85 c0		 test	 eax, eax
  01caa	75 ce		 jne	 SHORT $L72163

; 5265 : 			{
; 5266 : #ifndef OLEDECTALK
; 5267 : 				mmStatus = PA_WaitForPlayToComplete( phTTS->pAudioHandle );

  01cac	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  01cb2	51		 push	 ecx
  01cb3	e8 00 00 00 00	 call	 _PA_WaitForPlayToComplete
  01cb8	83 c4 04	 add	 esp, 4

; 5268 : #endif //OLEDECTALK
; 5269 : 				if ( mmStatus )

  01cbb	85 c0		 test	 eax, eax
  01cbd	74 bb		 je	 SHORT $L72163

; 5270 : 					return( MMSYSERR_ERROR );

  01cbf	b8 01 00 00 00	 mov	 eax, 1
  01cc4	5e		 pop	 esi

; 5274 : }

  01cc5	c3		 ret	 0
_TextToSpeechSync ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetRate
_TEXT	SEGMENT
_phTTS$ = 8
_pdwRate$ = 12
_TextToSpeechGetRate PROC NEAR

; 5312 : {

  01cd0	56		 push	 esi

; 5313 : 	/********************************************************************/
; 5314 : 	/*  Return error if invalid handle.                                 */
; 5315 : 	/********************************************************************/
; 5316 : 	
; 5317 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01cd1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01cd5	6a 04		 push	 4
  01cd7	56		 push	 esi
  01cd8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01cde	85 c0		 test	 eax, eax
  01ce0	74 07		 je	 SHORT $L72169

; 5318 : 		return( MMSYSERR_INVALHANDLE );

  01ce2	b8 05 00 00 00	 mov	 eax, 5
  01ce7	5e		 pop	 esi

; 5331 : }

  01ce8	c3		 ret	 0
$L72169:

; 5319 : 	
; 5320 : 	*pdwRate = (DWORD) phTTS->pKernelShareData->sprate ;

  01ce9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01cec	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pdwRate$[esp]
  01cf0	0f bf 80 22 02
	00 00		 movsx	 eax, WORD PTR [eax+546]

; 5321 : 	
; 5322 : 	/********************************************************************/
; 5323 : 	/*  The following range test should never fail, so the error return */
; 5324 : 	/*  is undocumented.                                                */
; 5325 : 	/********************************************************************/
; 5326 : 	
; 5327 : 	if (( *pdwRate < MIN_SPEAKING_RATE ) || ( *pdwRate > MAX_SPEAKING_RATE ))

  01cf7	83 f8 32	 cmp	 eax, 50			; 00000032H
  01cfa	89 01		 mov	 DWORD PTR [ecx], eax
  01cfc	72 0b		 jb	 SHORT $L72172
  01cfe	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  01d03	77 04		 ja	 SHORT $L72172

; 5329 : 	
; 5330 : 	return( MMSYSERR_NOERROR );

  01d05	33 c0		 xor	 eax, eax
  01d07	5e		 pop	 esi

; 5331 : }

  01d08	c3		 ret	 0
$L72172:

; 5328 : 		return( MMSYSERR_ERROR );

  01d09	b8 01 00 00 00	 mov	 eax, 1
  01d0e	5e		 pop	 esi

; 5331 : }

  01d0f	c3		 ret	 0
_TextToSpeechGetRate ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetRate
_TEXT	SEGMENT
_phTTS$ = 8
_dwRate$ = 12
_TextToSpeechSetRate PROC NEAR

; 5369 : {

  01d10	56		 push	 esi

; 5370 : 	/********************************************************************/
; 5371 : 	/*  Return error if invalid handle.                                 */
; 5372 : 	/********************************************************************/
; 5373 : 	
; 5374 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01d11	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01d15	6a 04		 push	 4
  01d17	56		 push	 esi
  01d18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01d1e	85 c0		 test	 eax, eax
  01d20	74 07		 je	 SHORT $L72178

; 5375 : 		return( MMSYSERR_INVALHANDLE );

  01d22	b8 05 00 00 00	 mov	 eax, 5
  01d27	5e		 pop	 esi

; 5387 : }

  01d28	c3		 ret	 0
$L72178:

; 5376 : 	
; 5377 : 	/********************************************************************/
; 5378 : 	/*  Range test the speaking rate.                                   */
; 5379 : 	/********************************************************************/
; 5380 : 	
; 5381 : 	if (( dwRate < MIN_SPEAKING_RATE ) || ( dwRate > MAX_SPEAKING_RATE ))

  01d29	8b 44 24 0c	 mov	 eax, DWORD PTR _dwRate$[esp]
  01d2d	83 f8 32	 cmp	 eax, 50			; 00000032H
  01d30	72 15		 jb	 SHORT $L72180
  01d32	3d 58 02 00 00	 cmp	 eax, 600		; 00000258H
  01d37	77 0e		 ja	 SHORT $L72180

; 5383 : 	
; 5384 : 	phTTS->pKernelShareData->sprate = (short)dwRate;

  01d39	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01d3c	5e		 pop	 esi
  01d3d	66 89 81 22 02
	00 00		 mov	 WORD PTR [ecx+546], ax

; 5385 : 	
; 5386 : 	return( MMSYSERR_NOERROR );

  01d44	33 c0		 xor	 eax, eax

; 5387 : }

  01d46	c3		 ret	 0
$L72180:

; 5382 : 		return( MMSYSERR_INVALPARAM );

  01d47	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01d4c	5e		 pop	 esi

; 5387 : }

  01d4d	c3		 ret	 0
_TextToSpeechSetRate ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetSpeaker
_TEXT	SEGMENT
_phTTS$ = 8
_pSpeaker$ = 12
_TextToSpeechGetSpeaker PROC NEAR

; 5424 : {

  01d50	56		 push	 esi

; 5425 : 	/********************************************************************/
; 5426 : 	/*  Return error if invalid handle.                                 */
; 5427 : 	/********************************************************************/
; 5428 : 	
; 5429 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01d51	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01d55	6a 04		 push	 4
  01d57	56		 push	 esi
  01d58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01d5e	85 c0		 test	 eax, eax
  01d60	74 07		 je	 SHORT $L72187

; 5430 : 		return( MMSYSERR_INVALHANDLE );

  01d62	b8 05 00 00 00	 mov	 eax, 5
  01d67	5e		 pop	 esi

; 5442 : 		return( MMSYSERR_ERROR );
; 5443 : 	
; 5444 : 	return( MMSYSERR_NOERROR );
; 5445 : }

  01d68	c3		 ret	 0
$L72187:

; 5431 : 	/* Also initialized new element in KSD for MI : MVP */
; 5432 : 	/* MGS 11/20/1998 BATS #571 Fixed TextToSpeechGetSpeaker */
; 5433 : 	//*pSpeaker = (SPEAKER_T)(phTTS->pKernelShareData->uiCurrentSpeaker);
; 5434 : 	*pSpeaker = (SPEAKER_T)(phTTS->pKernelShareData->last_voice);

  01d69	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01d6c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pSpeaker$[esp]

; 5435 : 	
; 5436 : 	/********************************************************************/
; 5437 : 	/*  The following range test should never fail, so the error return */
; 5438 : 	/*  is undocumented.                                                */
; 5439 : 	/********************************************************************/
; 5440 : 	
; 5441 : 	if ( *pSpeaker > WENDY + 1 )

  01d70	ba 09 00 00 00	 mov	 edx, 9
  01d75	5e		 pop	 esi
  01d76	0f bf 80 20 02
	00 00		 movsx	 eax, WORD PTR [eax+544]
  01d7d	3b d0		 cmp	 edx, eax
  01d7f	89 01		 mov	 DWORD PTR [ecx], eax
  01d81	1b c0		 sbb	 eax, eax
  01d83	f7 d8		 neg	 eax

; 5442 : 		return( MMSYSERR_ERROR );
; 5443 : 	
; 5444 : 	return( MMSYSERR_NOERROR );
; 5445 : }

  01d85	c3		 ret	 0
_TextToSpeechGetSpeaker ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetSpeaker
_TEXT	SEGMENT
_phTTS$ = 8
_Speaker$ = 12
_TextToSpeechSetSpeaker PROC NEAR

; 5483 : {

  01d90	56		 push	 esi

; 5484 : 	/********************************************************************/
; 5485 : 	/*  Return error if invalid handle.                                 */
; 5486 : 	/********************************************************************/
; 5487 : 	
; 5488 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01d91	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01d95	6a 04		 push	 4
  01d97	56		 push	 esi
  01d98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01d9e	85 c0		 test	 eax, eax
  01da0	74 07		 je	 SHORT $L72195

; 5489 : 		return( MMSYSERR_INVALHANDLE );

  01da2	b8 05 00 00 00	 mov	 eax, 5
  01da7	5e		 pop	 esi

; 5505 : }

  01da8	c3		 ret	 0
$L72195:

; 5490 : 	
; 5491 : 	/********************************************************************/
; 5492 : 	/*  Range test the speaker voice.                                   */
; 5493 : 	/********************************************************************/
; 5494 : 	
; 5495 : 	if (( Speaker < PAUL ) || ( Speaker > WENDY ))

  01da9	8b 44 24 0c	 mov	 eax, DWORD PTR _Speaker$[esp]
  01dad	83 f8 08	 cmp	 eax, 8
  01db0	77 0e		 ja	 SHORT $L72197

; 5497 : 	
; 5498 : 	/********************************************************************/
; 5499 : 	/*  Set voice change flag for phmain.c in the PH thread.            */
; 5500 : 	/********************************************************************/
; 5501 : 	
; 5502 : 	SetSpeaker( phTTS , Speaker );

  01db2	50		 push	 eax
  01db3	56		 push	 esi
  01db4	e8 00 00 00 00	 call	 _SetSpeaker
  01db9	83 c4 08	 add	 esp, 8

; 5503 : 	
; 5504 : 	return( MMSYSERR_NOERROR );

  01dbc	33 c0		 xor	 eax, eax
  01dbe	5e		 pop	 esi

; 5505 : }

  01dbf	c3		 ret	 0
$L72197:

; 5496 : 		return( MMSYSERR_INVALPARAM );

  01dc0	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01dc5	5e		 pop	 esi

; 5505 : }

  01dc6	c3		 ret	 0
_TextToSpeechSetSpeaker ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetLanguage
_TEXT	SEGMENT
_phTTS$ = 8
_pLanguage$ = 12
_TextToSpeechGetLanguage PROC NEAR

; 5543 : 	/********************************************************************/
; 5544 : 	/*  Return error if invalid handle.                                 */
; 5545 : 	/********************************************************************/
; 5546 : 	
; 5547 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01dd0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01dd4	6a 04		 push	 4
  01dd6	50		 push	 eax
  01dd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01ddd	85 c0		 test	 eax, eax
  01ddf	74 06		 je	 SHORT $L72203

; 5548 : 		return( MMSYSERR_INVALHANDLE );

  01de1	b8 05 00 00 00	 mov	 eax, 5

; 5553 : }

  01de6	c3		 ret	 0
$L72203:

; 5549 : 	
; 5550 : 	*pLanguage = TTS_AMERICAN_ENGLISH;

  01de7	8b 4c 24 08	 mov	 ecx, DWORD PTR _pLanguage$[esp-4]

; 5551 : 	
; 5552 : 	return( MMSYSERR_NOERROR );

  01deb	33 c0		 xor	 eax, eax
  01ded	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 5553 : }

  01df3	c3		 ret	 0
_TextToSpeechGetLanguage ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetLanguage
_TEXT	SEGMENT
_phTTS$ = 8
_Language$ = 12
_TextToSpeechSetLanguage PROC NEAR

; 5593 : 	/********************************************************************/
; 5594 : 	/*  Return error if invalid handle.                                 */
; 5595 : 	/********************************************************************/
; 5596 : 	
; 5597 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01e00	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01e04	6a 04		 push	 4
  01e06	50		 push	 eax
  01e07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01e0d	85 c0		 test	 eax, eax
  01e0f	74 06		 je	 SHORT $L72209

; 5598 : 		return( MMSYSERR_INVALHANDLE );

  01e11	b8 05 00 00 00	 mov	 eax, 5

; 5601 : 		return( MMSYSERR_INVALPARAM );
; 5602 : 	
; 5603 : 	return( MMSYSERR_NOERROR );
; 5604 : }

  01e16	c3		 ret	 0
$L72209:

; 5599 : 	
; 5600 : 	if ( Language != TTS_AMERICAN_ENGLISH )

  01e17	8b 44 24 08	 mov	 eax, DWORD PTR _Language$[esp-4]
  01e1b	48		 dec	 eax
  01e1c	f7 d8		 neg	 eax
  01e1e	1b c0		 sbb	 eax, eax
  01e20	83 e0 0b	 and	 eax, 11			; 0000000bH

; 5601 : 		return( MMSYSERR_INVALPARAM );
; 5602 : 	
; 5603 : 	return( MMSYSERR_NOERROR );
; 5604 : }

  01e23	c3		 ret	 0
_TextToSpeechSetLanguage ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetCaps
_TEXT	SEGMENT
_pTTScaps$ = 8
_TextToSpeechGetCaps PROC NEAR

; 5644 : 	if ( pTTScaps == NULL )

  01e30	8b 44 24 04	 mov	 eax, DWORD PTR _pTTScaps$[esp-4]
  01e34	85 c0		 test	 eax, eax
  01e36	75 06		 jne	 SHORT $L72216

; 5645 : 		return( MMSYSERR_ERROR );

  01e38	b8 01 00 00 00	 mov	 eax, 1

; 5661 : }

  01e3d	c3		 ret	 0
$L72216:

; 5646 : 	
; 5647 : 	LanguageParamsArray[0].dwLanguage = TTS_AMERICAN_ENGLISH;

  01e3e	b9 01 00 00 00	 mov	 ecx, 1
  01e43	89 0d 00 00 00
	00		 mov	 DWORD PTR _LanguageParamsArray, ecx

; 5648 : 	LanguageParamsArray[0].dwLanguageAttributes = PROPER_NAME_PRONUNCIATION;

  01e49	89 0d 04 00 00
	00		 mov	 DWORD PTR _LanguageParamsArray+4, ecx

; 5649 : 	
; 5650 : 	pTTScaps->dwNumberOfLanguages = 1;

  01e4f	89 08		 mov	 DWORD PTR [eax], ecx

; 5651 : 	pTTScaps->lpLanguageParamsArray = LanguageParamsArray;

  01e51	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:_LanguageParamsArray

; 5652 : 	pTTScaps->dwSampleRate = 11025;

  01e58	c7 40 08 11 2b
	00 00		 mov	 DWORD PTR [eax+8], 11025 ; 00002b11H

; 5653 : 	pTTScaps->dwMinimumSpeakingRate = MIN_SPEAKING_RATE;

  01e5f	c7 40 0c 32 00
	00 00		 mov	 DWORD PTR [eax+12], 50	; 00000032H

; 5654 : 	pTTScaps->dwMaximumSpeakingRate = MAX_SPEAKING_RATE;

  01e66	c7 40 10 58 02
	00 00		 mov	 DWORD PTR [eax+16], 600	; 00000258H

; 5655 : 	pTTScaps->dwNumberOfPredefinedSpeakers = WENDY + 1;

  01e6d	c7 40 14 09 00
	00 00		 mov	 DWORD PTR [eax+20], 9

; 5656 : 	pTTScaps->dwCharacterSet = TTS_ASCII;

  01e74	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 5657 : 	/* GL 11/19/1998  BATS#827 use correct version number set in coop.h */
; 5658 : 	pTTScaps->Version = DTALK_MAJ_VERSION*100 + DTALK_MIN_VERSION;

  01e7b	c7 40 1c cc 01
	00 00		 mov	 DWORD PTR [eax+28], 460	; 000001ccH

; 5659 : 	
; 5660 : 	return( MMSYSERR_NOERROR );

  01e82	33 c0		 xor	 eax, eax

; 5661 : }

  01e84	c3		 ret	 0
_TextToSpeechGetCaps ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechLoadUserDictionary
EXTRN	_load_dictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_szFileName$ = 12
_TextToSpeechLoadUserDictionary PROC NEAR

; 5704 : {

  01e90	56		 push	 esi
  01e91	57		 push	 edi

; 5705 : 	// Added a local varaible to get the handle of current kernel_share_data handle :MVP
; 5706 : 	PKSD_T pKsd_t;
; 5707 : 	
; 5708 : 	// Initialize with the pointer stored in phTTS :MVP */
; 5709 : 	pKsd_t = phTTS->pKernelShareData ;

  01e92	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]

; 5710 : 	
; 5711 : 	
; 5712 : 	/********************************************************************/
; 5713 : 	/*  Return error if invalid handle.                                 */
; 5714 : 	/********************************************************************/
; 5715 : 	
; 5716 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01e96	6a 04		 push	 4
  01e98	57		 push	 edi
  01e99	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  01e9c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01ea2	85 c0		 test	 eax, eax
  01ea4	74 08		 je	 SHORT $L72223
  01ea6	5f		 pop	 edi

; 5717 : 		return( MMSYSERR_INVALHANDLE );

  01ea7	b8 05 00 00 00	 mov	 eax, 5
  01eac	5e		 pop	 esi

; 5751 : #endif
; 5752 : }

  01ead	c3		 ret	 0
$L72223:

; 5718 : 	
; 5719 : 	/********************************************************************/
; 5720 : 	/*  Return error if a user dictionary is already loaded.            */
; 5721 : 	/********************************************************************/
; 5722 : 	/* Changed KS to pKsd_t :MVP */
; 5723 : 	/* GL 11/05/1997  for BATS#510 */
; 5724 : 	if ( pKsd_t->udic_entries[pKsd_t->lang_curr] != 0 )

  01eae	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  01eb4	8b 54 86 54	 mov	 edx, DWORD PTR [esi+eax*4+84]
  01eb8	8d 4c 86 54	 lea	 ecx, DWORD PTR [esi+eax*4+84]
  01ebc	85 d2		 test	 edx, edx
  01ebe	74 08		 je	 SHORT $L72224
  01ec0	5f		 pop	 edi

; 5725 : 		return( MMSYSERR_ERROR );

  01ec1	b8 01 00 00 00	 mov	 eax, 1
  01ec6	5e		 pop	 esi

; 5751 : #endif
; 5752 : }

  01ec7	c3		 ret	 0
$L72224:

; 5726 : 	
; 5727 : 	/********************************************************************/
; 5728 : 	/*  Load the user dictionary.                                       */
; 5729 : 	/********************************************************************/
; 5730 : 	
; 5731 : 	// this is very broken; should be phTTS not phTTS->hWnd!?!
; 5732 : 	/* GL 11/05/1997  for BATS#510 */
; 5733 : 	// ETT: fixme? why is the linux one different?????!
; 5734 : 
; 5735 : #if defined __osf__ || defined __linux__
; 5736 : 	return( load_dictionary((void **)&(pKsd_t->udic[pKsd_t->lang_curr]),
; 5737 : 				(unsigned int *)&(pKsd_t->udic_entries[pKsd_t->lang_curr]),
; 5738 : 				szFileName, 1));
; 5739 : #endif
; 5740 : #ifdef WIN32
; 5741 : 	return( load_dictionary( phTTS,
; 5742 : //#endif
; 5743 : //#if defined __osf__
; 5744 : //	return( load_dictionary( phTTS->hWnd,
; 5745 : //#endif
; 5746 : 		(void **)&(pKsd_t->udic[pKsd_t->lang_curr]),
; 5747 : 		(unsigned int *)&(pKsd_t->udic_entries[pKsd_t->lang_curr]),
; 5748 : 		szFileName,
; 5749 : 		TRUE,
; 5750 : 		FALSE ));

  01ec8	8b 54 24 10	 mov	 edx, DWORD PTR _szFileName$[esp+4]
  01ecc	6a 00		 push	 0
  01ece	6a 01		 push	 1
  01ed0	52		 push	 edx
  01ed1	8d 44 86 38	 lea	 eax, DWORD PTR [esi+eax*4+56]
  01ed5	51		 push	 ecx
  01ed6	50		 push	 eax
  01ed7	57		 push	 edi
  01ed8	e8 00 00 00 00	 call	 _load_dictionary
  01edd	83 c4 18	 add	 esp, 24			; 00000018H
  01ee0	5f		 pop	 edi
  01ee1	5e		 pop	 esi

; 5751 : #endif
; 5752 : }

  01ee2	c3		 ret	 0
_TextToSpeechLoadUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechUnloadUserDictionary
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechUnloadUserDictionary PROC NEAR

; 5785 : {

  01ef0	56		 push	 esi

; 5786 : 	/********************************************************************/
; 5787 : 	/*  Return error if invalid handle.                                 */
; 5788 : 	/********************************************************************/
; 5789 : 	
; 5790 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01ef1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01ef5	6a 04		 push	 4
  01ef7	56		 push	 esi
  01ef8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01efe	85 c0		 test	 eax, eax
  01f00	74 07		 je	 SHORT $L72230

; 5791 : 		return( MMSYSERR_INVALHANDLE );

  01f02	b8 05 00 00 00	 mov	 eax, 5
  01f07	5e		 pop	 esi

; 5798 : #ifdef WIN32
; 5799 : 	UNREFERENCED_PARAMETER( phTTS );
; 5800 : #endif
; 5801 : }

  01f08	c3		 ret	 0
$L72230:

; 5792 : 	
; 5793 : 	/* GL 11/05/1997  for BATS#510 */
; 5794 : 	unload_dictionary((void **)&(phTTS->pKernelShareData->udic[phTTS->pKernelShareData->lang_curr]),
; 5795 : 		(unsigned int *)&(phTTS->pKernelShareData->udic_entries[phTTS->pKernelShareData->lang_curr]));

  01f09	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01f0c	8b 88 f8 00 00
	00		 mov	 ecx, DWORD PTR [eax+248]
  01f12	8d 54 88 54	 lea	 edx, DWORD PTR [eax+ecx*4+84]
  01f16	8d 44 88 38	 lea	 eax, DWORD PTR [eax+ecx*4+56]
  01f1a	52		 push	 edx
  01f1b	50		 push	 eax
  01f1c	e8 00 00 00 00	 call	 _unload_dictionary
  01f21	83 c4 08	 add	 esp, 8

; 5796 : 	
; 5797 : 	return( MMSYSERR_NOERROR );

  01f24	33 c0		 xor	 eax, eax
  01f26	5e		 pop	 esi

; 5798 : #ifdef WIN32
; 5799 : 	UNREFERENCED_PARAMETER( phTTS );
; 5800 : #endif
; 5801 : }

  01f27	c3		 ret	 0
_TextToSpeechUnloadUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenInMemory
_DATA	SEGMENT
	ORG $+1
$SG72258 DB	'DECtalkBufferMessage', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_dwFormat$ = 12
_TextToSpeechOpenInMemory PROC NEAR

; 5850 : {

  01f30	56		 push	 esi

; 5851 : 	P_PIPE buffer_pipe = NULL_PIPE;
; 5852 : #ifdef WIN32
; 5853 : 	// tek bats385
; 5854 : 	// we need the "buffer delay pipe" to make sure that we 
; 5855 : 	// don't get stuck forever returning buffers if the
; 5856 : 	// user buffer callback routine immediately returns buffers
; 5857 : 	// during a reset.
; 5858 : 	P_PIPE buffer_delay_pipe = NULL_PIPE;
; 5859 : #endif
; 5860 : 	MMRESULT mmStatus;
; 5861 : 	
; 5862 : 	/********************************************************************/
; 5863 : 	/*  Return error if invalid handle.                                 */
; 5864 : 	/********************************************************************/
; 5865 : 	
; 5866 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  01f31	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  01f35	57		 push	 edi
  01f36	6a 04		 push	 4
  01f38	56		 push	 esi
  01f39	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  01f3f	85 c0		 test	 eax, eax
  01f41	74 08		 je	 SHORT $L72243
  01f43	5f		 pop	 edi

; 5867 : 		return( MMSYSERR_INVALHANDLE );

  01f44	b8 05 00 00 00	 mov	 eax, 5
  01f49	5e		 pop	 esi

; 5990 : }

  01f4a	c3		 ret	 0
$L72243:

; 5868 : 	
; 5869 : 	/********************************************************************/
; 5870 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 5871 : 	/*  an error.                                                       */
; 5872 : 	/********************************************************************/
; 5873 : 	
; 5874 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 5875 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  01f4b	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01f51	85 c0		 test	 eax, eax
  01f53	74 0d		 je	 SHORT $L72244
  01f55	83 f8 04	 cmp	 eax, 4
  01f58	74 08		 je	 SHORT $L72244
  01f5a	5f		 pop	 edi

; 5876 : 		return( MMSYSERR_ERROR );

  01f5b	b8 01 00 00 00	 mov	 eax, 1
  01f60	5e		 pop	 esi

; 5990 : }

  01f61	c3		 ret	 0
$L72244:

; 5877 : 	
; 5878 : 	/********************************************************************/
; 5879 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 5880 : 	/*  function have completed.                                        */
; 5881 : 	/********************************************************************/
; 5882 : 	
; 5883 : 	mmStatus = TextToSpeechSync( phTTS );

  01f62	56		 push	 esi
  01f63	e8 00 00 00 00	 call	 _TextToSpeechSync
  01f68	83 c4 04	 add	 esp, 4

; 5884 : 	
; 5885 : 	if ( mmStatus )

  01f6b	85 c0		 test	 eax, eax

; 5886 : 		return( mmStatus );

  01f6d	0f 85 db 00 00
	00		 jne	 $L72237

; 5887 : 	
; 5888 : 	/********************************************************************/
; 5889 : 	/*  If the dwFormat value is invalid then return an error.          */
; 5890 : 	/********************************************************************/
; 5891 : 	
; 5892 : 	switch( dwFormat )
; 5893 : 	{

  01f73	8b 7c 24 10	 mov	 edi, DWORD PTR _dwFormat$[esp+4]
  01f77	8b c7		 mov	 eax, edi
  01f79	48		 dec	 eax
  01f7a	74 19		 je	 SHORT $L72250
  01f7c	83 e8 03	 sub	 eax, 3
  01f7f	74 14		 je	 SHORT $L72250
  01f81	83 e8 03	 sub	 eax, 3
  01f84	74 08		 je	 SHORT $L72252
  01f86	5f		 pop	 edi

; 5911 : 		
; 5912 : 	default:
; 5913 : 		
; 5914 : 		return( MMSYSERR_INVALPARAM );

  01f87	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  01f8c	5e		 pop	 esi

; 5990 : }

  01f8d	c3		 ret	 0
$L72252:

; 5903 : 		
; 5904 : 		break;
; 5905 : 		
; 5906 : 	case WAVE_FORMAT_08M08:
; 5907 : 		
; 5908 : 		SetSampleRate( phTTS, MULAW_SAMPLE_RATE );

  01f8e	68 40 1f 00 00	 push	 8000			; 00001f40H

; 5909 : 		
; 5910 : 		break;

  01f93	eb 05		 jmp	 SHORT $L73237
$L72250:

; 5894 : 	case WAVE_FORMAT_1M16:
; 5895 : 		
; 5896 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );
; 5897 : 		
; 5898 : 		break;
; 5899 : 		
; 5900 : 	case WAVE_FORMAT_1M08:
; 5901 : 		
; 5902 : 		SetSampleRate( phTTS, PC_SAMPLE_RATE );

  01f95	68 11 2b 00 00	 push	 11025			; 00002b11H
$L73237:
  01f9a	56		 push	 esi
  01f9b	e8 00 00 00 00	 call	 _SetSampleRate
  01fa0	83 c4 08	 add	 esp, 8

; 5915 : 	}
; 5916 : 	
; 5917 : 	phTTS->dwFormat = dwFormat;

  01fa3	89 be 80 00 00
	00		 mov	 DWORD PTR [esi+128], edi

; 5918 : 	
; 5919 : 	/********************************************************************/
; 5920 : 	/*  Create a pipe to send the buffer addresses to the VTM thread.   */
; 5921 : 	/********************************************************************/
; 5922 : 	
; 5923 : 	buffer_pipe = create_pipe( VOID_PTR_PIPE, BUFFER_PIPE_LENGTH );

  01fa9	68 00 01 00 00	 push	 256			; 00000100H
  01fae	6a 06		 push	 6
  01fb0	e8 00 00 00 00	 call	 _create_pipe
  01fb5	83 c4 08	 add	 esp, 8

; 5924 : 	
; 5925 : 	if ( buffer_pipe == NULL )

  01fb8	85 c0		 test	 eax, eax
  01fba	75 08		 jne	 SHORT $L72255
  01fbc	5f		 pop	 edi

; 5926 : 	{
; 5927 : 		return( MMSYSERR_NOMEM );

  01fbd	b8 07 00 00 00	 mov	 eax, 7
  01fc2	5e		 pop	 esi

; 5990 : }

  01fc3	c3		 ret	 0
$L72255:

; 5928 : 	}
; 5929 : 	
; 5930 : 	phTTS->pKernelShareData->buffer_pipe = buffer_pipe;

  01fc4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 5931 : 	
; 5932 : #ifdef WIN32
; 5933 : 	// 16jun97 tek bats 385 (buffer delay)
; 5934 : 	
; 5935 : 	/********************************************************************/
; 5936 : 	/*  Create a pipe to send the buffer addresses to the VTM thread.   */
; 5937 : 	/********************************************************************/
; 5938 : 	
; 5939 : 	buffer_delay_pipe = create_pipe( VOID_PTR_PIPE, BUFFER_PIPE_LENGTH );

  01fc7	68 00 01 00 00	 push	 256			; 00000100H
  01fcc	6a 06		 push	 6
  01fce	89 81 e4 00 00
	00		 mov	 DWORD PTR [ecx+228], eax
  01fd4	e8 00 00 00 00	 call	 _create_pipe
  01fd9	83 c4 08	 add	 esp, 8

; 5940 : 	
; 5941 : 	if ( buffer_delay_pipe == NULL )

  01fdc	85 c0		 test	 eax, eax
  01fde	75 08		 jne	 SHORT $L72257
  01fe0	5f		 pop	 edi

; 5942 : 	{
; 5943 : 		return( MMSYSERR_NOMEM );

  01fe1	b8 07 00 00 00	 mov	 eax, 7
  01fe6	5e		 pop	 esi

; 5990 : }

  01fe7	c3		 ret	 0
$L72257:

; 5944 : 	}
; 5945 : 	
; 5946 : 	phTTS->pKernelShareData->buffer_delay_pipe = buffer_delay_pipe;

  01fe8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 5947 : 	
; 5948 : 	/********************************************************************/
; 5949 : 	/*  Get the DECtalk error message.                                  */
; 5950 : 	/********************************************************************/
; 5951 : 	
; 5952 : 	phTTS->uiID_Buffer_Message =
; 5953 : 		RegisterWindowMessage("DECtalkBufferMessage");

  01feb	68 00 00 00 00	 push	 OFFSET FLAT:$SG72258
  01ff0	89 82 e8 00 00
	00		 mov	 DWORD PTR [edx+232], eax
  01ff6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4

; 5954 : 	
; 5955 : 	if ( phTTS->uiID_Buffer_Message == 0 )

  01ffc	85 c0		 test	 eax, eax
  01ffe	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  02001	75 08		 jne	 SHORT $L72259
  02003	5f		 pop	 edi

; 5956 : 		return( MMSYSERR_ERROR );

  02004	b8 01 00 00 00	 mov	 eax, 1
  02009	5e		 pop	 esi

; 5990 : }

  0200a	c3		 ret	 0
$L72259:

; 5957 : 	
; 5958 : #endif
; 5959 : 	/********************************************************************/
; 5960 : 	/*  Create the memory buffer critical section.                      */
; 5961 : 	/********************************************************************/
; 5962 : 	
; 5963 : #ifdef WIN32
; 5964 : 	phTTS->pcsMemoryBuffer =
; 5965 : 		( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  0200b	6a 18		 push	 24			; 00000018H
  0200d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  02013	83 c4 04	 add	 esp, 4
  02016	89 86 b0 00 00
	00		 mov	 DWORD PTR [esi+176], eax

; 5966 : #endif
; 5967 : #if defined __osf__ || defined __linux__
; 5968 : 	phTTS->pcsMemoryBuffer = OP_CreateMutex();
; 5969 : #endif
; 5970 : 	
; 5971 : 	if ( phTTS->pcsMemoryBuffer == NULL )

  0201c	85 c0		 test	 eax, eax
  0201e	75 11		 jne	 SHORT $L72263

; 5972 : 	{
; 5973 : 		DeleteTextToSpeechObjects( phTTS );

  02020	56		 push	 esi
  02021	e8 00 00 00 00	 call	 _DeleteTextToSpeechObjects
  02026	83 c4 04	 add	 esp, 4

; 5974 : 		return( MMSYSERR_NOMEM );

  02029	b8 07 00 00 00	 mov	 eax, 7
  0202e	5f		 pop	 edi
  0202f	5e		 pop	 esi

; 5990 : }

  02030	c3		 ret	 0
$L72263:

; 5975 : 	}
; 5976 : 	
; 5977 : #ifdef WIN32
; 5978 : 	InitializeCriticalSection( phTTS->pcsMemoryBuffer );

  02031	50		 push	 eax
  02032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 5979 : #endif
; 5980 : 	
; 5981 : 	/********************************************************************/
; 5982 : 	/*  Initialize the handle objects for memory output.                */
; 5983 : 	/********************************************************************/
; 5984 : 	
; 5985 : 	phTTS->pTTS_Buffer = NULL;

  02038	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0

; 5986 : 	
; 5987 : 	phTTS->dwOutputState = STATE_OUTPUT_MEMORY;

  02042	c7 86 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+132], 1

; 5988 : 	
; 5989 : 	return( MMSYSERR_NOERROR );

  0204c	33 c0		 xor	 eax, eax
$L72237:
  0204e	5f		 pop	 edi
  0204f	5e		 pop	 esi

; 5990 : }

  02050	c3		 ret	 0
_TextToSpeechOpenInMemory ENDP
_phTTS$ = 8
_TextToSpeechCloseInMemory PROC NEAR

; 6026 : {

  02060	56		 push	 esi

; 6027 : 	/********************************************************************/
; 6028 : 	/*  Return error if invalid handle.                                 */
; 6029 : 	/********************************************************************/
; 6030 : 	
; 6031 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02061	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02065	6a 04		 push	 4
  02067	56		 push	 esi
  02068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0206e	85 c0		 test	 eax, eax
  02070	74 07		 je	 SHORT $L72268

; 6032 : 		return( MMSYSERR_INVALHANDLE );

  02072	b8 05 00 00 00	 mov	 eax, 5
  02077	5e		 pop	 esi

; 6097 : }

  02078	c3		 ret	 0
$L72268:

; 6033 : 	
; 6034 : 	/********************************************************************/
; 6035 : 	/*  If not in MEMORY output state then return an error.             */
; 6036 : 	/********************************************************************/
; 6037 : 	
; 6038 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  02079	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  0207f	b8 01 00 00 00	 mov	 eax, 1
  02084	3b c8		 cmp	 ecx, eax

; 6039 : 		return( MMSYSERR_ERROR );

  02086	75 7e		 jne	 SHORT $L72267
  02088	57		 push	 edi

; 6040 : 	
; 6041 : #ifdef WIN32
; 6042 : 	// merged 28jul97 tek
; 6043 : 	// 16jun97 tek bats 385 sync will hang forever if we don't clear
; 6044 : 	// bInReset..
; 6045 : 	phTTS->bInReset = FALSE;

  02089	33 ff		 xor	 edi, edi

; 6046 : #endif
; 6047 : 	
; 6048 : 	/********************************************************************/
; 6049 : 	/*  Halt the system and flush all data.                             */
; 6050 : 	/********************************************************************/
; 6051 : 	
; 6052 : 	TextToSpeechSync( phTTS );

  0208b	56		 push	 esi
  0208c	89 be dc 00 00
	00		 mov	 DWORD PTR [esi+220], edi
  02092	e8 00 00 00 00	 call	 _TextToSpeechSync

; 6053 : 	
; 6054 : 	/********************************************************************/
; 6055 : 	/*  Delete the memory buffer critical section.                      */
; 6056 : 	/********************************************************************/
; 6057 : 	
; 6058 : 	if ( phTTS->pcsMemoryBuffer != NULL )

  02097	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0209d	83 c4 04	 add	 esp, 4
  020a0	3b c7		 cmp	 eax, edi
  020a2	74 17		 je	 SHORT $L72271

; 6059 : 	{
; 6060 : #ifdef WIN32
; 6061 : 		DeleteCriticalSection( phTTS->pcsMemoryBuffer );

  020a4	50		 push	 eax
  020a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 6062 : 		
; 6063 : 		free( phTTS->pcsMemoryBuffer );

  020ab	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  020b1	50		 push	 eax
  020b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  020b8	83 c4 04	 add	 esp, 4
$L72271:

; 6064 : #endif
; 6065 : #if defined __osf__ || defined __linux__
; 6066 : 		OP_DestroyMutex( phTTS->pcsMemoryBuffer );
; 6067 : #endif
; 6068 : 	}
; 6069 : 	
; 6070 : 	/********************************************************************/
; 6071 : 	/*  Delete the memory buffer pipe.                                  */
; 6072 : 	/********************************************************************/
; 6073 : 	
; 6074 : 	destroy_pipe( phTTS->pKernelShareData->buffer_pipe );

  020bb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  020be	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  020c4	52		 push	 edx
  020c5	e8 00 00 00 00	 call	 _destroy_pipe

; 6075 : 	// tek 30aug96 null the pointer.
; 6076 : 	phTTS->pKernelShareData->buffer_pipe = NULL;

  020ca	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  020cd	89 b8 e4 00 00
	00		 mov	 DWORD PTR [eax+228], edi

; 6077 : 	
; 6078 : #ifdef WIN32
; 6079 : 	// merged 28jul97 tek
; 6080 : 	// 16jun97 tek bats 385 (buffer delay)
; 6081 : 	destroy_pipe( phTTS->pKernelShareData->buffer_delay_pipe );

  020d3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  020d6	8b 91 e8 00 00
	00		 mov	 edx, DWORD PTR [ecx+232]
  020dc	52		 push	 edx
  020dd	e8 00 00 00 00	 call	 _destroy_pipe

; 6082 : 	phTTS->pKernelShareData->buffer_delay_pipe = NULL;

  020e2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  020e5	83 c4 08	 add	 esp, 8
  020e8	89 b8 e8 00 00
	00		 mov	 DWORD PTR [eax+232], edi

; 6083 : #endif
; 6084 : 	
; 6085 : 	/********************************************************************/
; 6086 : 	/*  Set the system output state to audio if it is enabled.          */
; 6087 : 	/********************************************************************/
; 6088 : 	
; 6089 : 	phTTS->pTTS_Buffer = NULL;
; 6090 : 	
; 6091 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  020ee	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  020f1	c1 e9 1d	 shr	 ecx, 29			; 0000001dH
  020f4	83 e1 04	 and	 ecx, 4
  020f7	89 be a0 00 00
	00		 mov	 DWORD PTR [esi+160], edi
  020fd	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx

; 6092 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 6093 : 	else
; 6094 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 6095 : 	
; 6096 : 	return( MMSYSERR_NOERROR );

  02103	33 c0		 xor	 eax, eax
  02105	5f		 pop	 edi
$L72267:
  02106	5e		 pop	 esi

; 6097 : }

  02107	c3		 ret	 0
_TextToSpeechCloseInMemory ENDP
_TEXT	ENDS
EXTRN	_LockPipe:NEAR
EXTRN	_UnlockPipe:NEAR
_BSS	SEGMENT
	ALIGN	4

$SG72285 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pTTS_Buffer$ = 12
_pPipeArray$ = 8
_TextToSpeechAddBuffer PROC NEAR

; 6134 : {

  02110	56		 push	 esi

; 6135 : 	LPTTS_BUFFER_T pPipeArray[1];
; 6136 : 	unsigned int uiI;
; 6137 : 	char szTemp[256]="";
; 6138 : 	
; 6139 : #ifdef API_DEBUG
; 6140 : 	OutputDebugString("TTSAddBuffer().\n");
; 6141 : 	
; 6142 : 	if (pTTS_Buffer == NULL)
; 6143 : 	{
; 6144 : 		OutputDebugString("  ..adding null buffer.\n");
; 6145 : 	}
; 6146 : 	else
; 6147 : 	{
; 6148 : 		OutputDebugString("  ..adding user buffer.\n");
; 6149 : 	}
; 6150 : #endif //API_DEBUG
; 6151 : 	
; 6152 : 	/********************************************************************/
; 6153 : 	/*  Return error if invalid handle.                                 */
; 6154 : 	/********************************************************************/
; 6155 : 	
; 6156 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02111	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02115	6a 04		 push	 4
  02117	56		 push	 esi
  02118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0211e	85 c0		 test	 eax, eax
  02120	74 07		 je	 SHORT $L72286

; 6157 : 		return( MMSYSERR_INVALHANDLE );

  02122	b8 05 00 00 00	 mov	 eax, 5
  02127	5e		 pop	 esi

; 6193 : }

  02128	c3		 ret	 0
$L72286:

; 6158 : 	
; 6159 : 	/********************************************************************/
; 6160 : 	/*  If not in MEMORY output state then return an error.             */
; 6161 : 	/********************************************************************/
; 6162 : 	
; 6163 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  02129	83 be 84 00 00
	00 01		 cmp	 DWORD PTR [esi+132], 1
  02130	74 07		 je	 SHORT $L72287

; 6164 : 		return( MMSYSERR_ERROR );

  02132	b8 01 00 00 00	 mov	 eax, 1
  02137	5e		 pop	 esi

; 6193 : }

  02138	c3		 ret	 0
$L72287:

; 6165 : 	
; 6166 : 	/********************************************************************/
; 6167 : 	/*  Send the wave header to the VTM thread.                         */
; 6168 : 	/********************************************************************/
; 6169 : 	
; 6170 : 	pPipeArray[0] = pTTS_Buffer;

  02139	8b 44 24 0c	 mov	 eax, DWORD PTR _pTTS_Buffer$[esp]

; 6171 : 	
; 6172 : 	// tek 03sep96 add some debugging info here..
; 6173 : #ifdef WIN32
; 6174 : 	LockPipe( phTTS->pKernelShareData->buffer_pipe );

  0213d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02140	89 44 24 08	 mov	 DWORD PTR _pPipeArray$[esp], eax
  02144	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  0214a	52		 push	 edx
  0214b	e8 00 00 00 00	 call	 _LockPipe

; 6175 : #endif
; 6176 : #if defined __osf__ || defined __linux__
; 6177 : 	OP_LockMutex( phTTS->pcsBufferPipe);
; 6178 : #endif
; 6179 : 	write_pipe( phTTS->pKernelShareData->buffer_pipe, pPipeArray, 1 );

  02150	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02153	8d 44 24 0c	 lea	 eax, DWORD PTR _pPipeArray$[esp+4]
  02157	6a 01		 push	 1
  02159	50		 push	 eax
  0215a	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  02160	52		 push	 edx
  02161	e8 00 00 00 00	 call	 _write_pipe

; 6180 : 	uiI = pipe_count( phTTS->pKernelShareData->buffer_pipe );

  02166	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02169	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  0216f	51		 push	 ecx
  02170	e8 00 00 00 00	 call	 _pipe_count

; 6181 : #ifdef WIN32
; 6182 : #ifdef API_DEBUG
; 6183 : 	sprintf(szTemp,"Added buffer %08lx, count now %d\n",
; 6184 : 		pPipeArray[0], uiI);
; 6185 : 	OutputDebugString(szTemp);
; 6186 : #endif //API_DEBUG
; 6187 : 	UnlockPipe( phTTS->pKernelShareData->buffer_pipe );

  02175	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02178	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  0217e	50		 push	 eax
  0217f	e8 00 00 00 00	 call	 _UnlockPipe
  02184	83 c4 18	 add	 esp, 24			; 00000018H

; 6188 : #endif
; 6189 : #if defined __osf__ || defined __linux__
; 6190 : 	OP_UnlockMutex( phTTS->pcsBufferPipe );
; 6191 : #endif
; 6192 : 	return( MMSYSERR_NOERROR );

  02187	33 c0		 xor	 eax, eax
  02189	5e		 pop	 esi

; 6193 : }

  0218a	c3		 ret	 0
_TextToSpeechAddBuffer ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReturnBuffer
_TEXT	SEGMENT
_phTTS$ = 8
_ppTTS_Buffer$ = 12
_TextToSpeechReturnBuffer PROC NEAR

; 6232 : {

  02190	56		 push	 esi

; 6233 : 	/********************************************************************/
; 6234 : 	/*  Return error if invalid handle.                                 */
; 6235 : 	/********************************************************************/
; 6236 : #ifdef API_DEBUG
; 6237 : 	OutputDebugString("TTSReturnBuffer() ?? \n");
; 6238 : #endif //API_DEBUG
; 6239 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02191	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02195	6a 04		 push	 4
  02197	56		 push	 esi
  02198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0219e	85 c0		 test	 eax, eax
  021a0	74 07		 je	 SHORT $L72293

; 6240 : 		return( MMSYSERR_INVALHANDLE );

  021a2	b8 05 00 00 00	 mov	 eax, 5
  021a7	5e		 pop	 esi

; 6266 : }

  021a8	c3		 ret	 0
$L72293:

; 6241 : 	
; 6242 : 	/********************************************************************/
; 6243 : 	/*  If not in MEMORY output state then return an error.             */
; 6244 : 	/********************************************************************/
; 6245 : 	
; 6246 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )

  021a9	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  021af	b8 01 00 00 00	 mov	 eax, 1
  021b4	3b c8		 cmp	 ecx, eax

; 6247 : 		return( MMSYSERR_ERROR );

  021b6	75 32		 jne	 SHORT $L72292

; 6248 : 	
; 6249 : 	/********************************************************************/
; 6250 : 	/*  Return the last buffer to the application.                      */
; 6251 : 	/*  Block if the buffer is busy.                                    */
; 6252 : 	/********************************************************************/
; 6253 : 
; 6254 : 	EnterCriticalSection( phTTS->pcsMemoryBuffer );

  021b8	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  021be	50		 push	 eax
  021bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 6255 : 
; 6256 : 	*ppTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  021c5	8b 54 24 0c	 mov	 edx, DWORD PTR _ppTTS_Buffer$[esp]
  021c9	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  021cf	89 0a		 mov	 DWORD PTR [edx], ecx

; 6257 : 	phTTS->pTTS_Buffer = NULL;
; 6258 : 	
; 6259 : 	/********************************************************************/
; 6260 : 	/*  Release the buffer.                                             */
; 6261 : 	/********************************************************************/
; 6262 : 
; 6263 : 	LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  021d1	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  021d7	50		 push	 eax
  021d8	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0
  021e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6264 : 
; 6265 : 	return( MMSYSERR_NOERROR );

  021e8	33 c0		 xor	 eax, eax
$L72292:
  021ea	5e		 pop	 esi

; 6266 : }

  021eb	c3		 ret	 0
_TextToSpeechReturnBuffer ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechOpenLogFile
_DATA	SEGMENT
	ORG $+3
$SG72312 DB	'w', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pszFileName$ = 12
_dwFlags$ = 16
_TextToSpeechOpenLogFile PROC NEAR

; 6328 : {

  021f0	53		 push	 ebx
  021f1	56		 push	 esi

; 6329 : 	MMRESULT mmStatus;
; 6330 : 	
; 6331 : 	/********************************************************************/
; 6332 : 	/*  Return error if invalid handle.                                 */
; 6333 : 	/********************************************************************/
; 6334 : 	
; 6335 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  021f2	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  021f6	57		 push	 edi
  021f7	6a 04		 push	 4
  021f9	56		 push	 esi
  021fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  02200	85 c0		 test	 eax, eax
  02202	74 09		 je	 SHORT $L72305
  02204	5f		 pop	 edi
  02205	5e		 pop	 esi

; 6336 : 		return( MMSYSERR_INVALHANDLE );

  02206	b8 05 00 00 00	 mov	 eax, 5
  0220b	5b		 pop	 ebx

; 6420 : }

  0220c	c3		 ret	 0
$L72305:

; 6337 : 	
; 6338 : 	/********************************************************************/
; 6339 : 	/*  If a file is already open, then don't try to open another one.  */
; 6340 : 	/********************************************************************/
; 6341 : 	
; 6342 : 
; 6343 : 	EnterCriticalSection( phTTS->pcsLogFile );

  0220d	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  02213	50		 push	 eax
  02214	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 6344 : 
; 6345 : 	if ( phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE )

  0221a	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  02220	83 f8 03	 cmp	 eax, 3
  02223	75 16		 jne	 SHORT $L72306

; 6346 : 	{
; 6347 : 
; 6348 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  02225	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  0222b	51		 push	 ecx
  0222c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02232	5f		 pop	 edi
  02233	5e		 pop	 esi

; 6349 : 
; 6350 : 		return( MMSYSERR_ALLOCATED );

  02234	b8 04 00 00 00	 mov	 eax, 4
  02239	5b		 pop	 ebx

; 6420 : }

  0223a	c3		 ret	 0
$L72306:

; 6351 : 	}
; 6352 : 	
; 6353 : 	/********************************************************************/
; 6354 : 	/*  If not in NULL output state or AUDIO Output state then return   */
; 6355 : 	/*  an error.                                                       */
; 6356 : 	/********************************************************************/
; 6357 : 	
; 6358 : 	if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 6359 : 		&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  0223b	85 c0		 test	 eax, eax
  0223d	74 1b		 je	 SHORT $L72307
  0223f	83 f8 04	 cmp	 eax, 4
  02242	74 16		 je	 SHORT $L72307

; 6360 : 	{
; 6361 : 
; 6362 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  02244	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  0224a	52		 push	 edx
  0224b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02251	5f		 pop	 edi
  02252	5e		 pop	 esi

; 6363 : 
; 6364 : 		return( MMSYSERR_ERROR );

  02253	b8 01 00 00 00	 mov	 eax, 1
  02258	5b		 pop	 ebx

; 6420 : }

  02259	c3		 ret	 0
$L72307:

; 6365 : 	}
; 6366 : 	
; 6367 : 	/********************************************************************/
; 6368 : 	/*  Make sure the arguments are valid.                              */
; 6369 : 	/********************************************************************/
; 6370 : 	
; 6371 : 	if ( dwFlags & ~( LOG_TEXT | LOG_PHONEMES | LOG_SYLLABLES ))

  0225a	8b 5c 24 18	 mov	 ebx, DWORD PTR _dwFlags$[esp+8]
  0225e	f7 c3 ec ff ff
	ff		 test	 ebx, -20		; ffffffecH
  02264	74 16		 je	 SHORT $L72308

; 6372 : 	{
; 6373 : 
; 6374 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  02266	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  0226c	50		 push	 eax
  0226d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  02273	5f		 pop	 edi
  02274	5e		 pop	 esi

; 6375 : 
; 6376 : 		return( MMSYSERR_INVALPARAM );

  02275	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0227a	5b		 pop	 ebx

; 6420 : }

  0227b	c3		 ret	 0
$L72308:

; 6377 : 	}
; 6378 : 	
; 6379 : 	/********************************************************************/
; 6380 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 6381 : 	/*  function have completed.                                        */
; 6382 : 	/********************************************************************/
; 6383 : 	
; 6384 : 	mmStatus = TextToSpeechSync( phTTS );

  0227c	56		 push	 esi
  0227d	e8 00 00 00 00	 call	 _TextToSpeechSync
  02282	8b f8		 mov	 edi, eax
  02284	83 c4 04	 add	 esp, 4

; 6385 : 	
; 6386 : 	if ( mmStatus )

  02287	85 ff		 test	 edi, edi
  02289	74 13		 je	 SHORT $L72309

; 6387 : 	{
; 6388 : 
; 6389 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  0228b	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  02291	51		 push	 ecx
  02292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6390 : 
; 6391 : 		return( mmStatus );

  02298	8b c7		 mov	 eax, edi
  0229a	5f		 pop	 edi
  0229b	5e		 pop	 esi
  0229c	5b		 pop	 ebx

; 6420 : }

  0229d	c3		 ret	 0
$L72309:

; 6392 : 	}
; 6393 : 	
; 6394 : 	/********************************************************************/
; 6395 : 	/*  Open the log file.                                              */
; 6396 : 	/********************************************************************/
; 6397 : 	
; 6398 : #ifdef UNDER_CE
; 6399 : 	if (( phTTS->pLogFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)) == NULL )
; 6400 : #else
; 6401 : 	if (( phTTS->pLogFile = fopen( pszFileName, "w" )) == NULL )

  0229e	8b 54 24 14	 mov	 edx, DWORD PTR _pszFileName$[esp+8]
  022a2	68 00 00 00 00	 push	 OFFSET FLAT:$SG72312
  022a7	52		 push	 edx
  022a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  022ae	83 c4 08	 add	 esp, 8
  022b1	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  022b7	85 c0		 test	 eax, eax
  022b9	75 16		 jne	 SHORT $L72311

; 6402 : #endif
; 6403 : 	{
; 6404 : 
; 6405 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  022bb	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  022c1	50		 push	 eax
  022c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  022c8	5f		 pop	 edi
  022c9	5e		 pop	 esi

; 6406 : 
; 6407 : 		return( MMSYSERR_ERROR );

  022ca	b8 01 00 00 00	 mov	 eax, 1
  022cf	5b		 pop	 ebx

; 6420 : }

  022d0	c3		 ret	 0
$L72311:

; 6408 : 	}
; 6409 : 	
; 6410 : 	/********************************************************************/
; 6411 : 	/*  Set the log file control variables.                             */
; 6412 : 	/********************************************************************/
; 6413 : 	
; 6414 : 	phTTS->pKernelShareData->logflag = dwFlags;

  022d1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  022d4	89 99 04 02 00
	00		 mov	 DWORD PTR [ecx+516], ebx

; 6415 : 	phTTS->dwOutputState = STATE_OUTPUT_LOG_FILE;
; 6416 : 	
; 6417 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  022da	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  022e0	52		 push	 edx
  022e1	c7 86 84 00 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+132], 3
  022eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  022f1	5f		 pop	 edi
  022f2	5e		 pop	 esi

; 6418 : 
; 6419 : 	return( MMSYSERR_NOERROR );

  022f3	33 c0		 xor	 eax, eax
  022f5	5b		 pop	 ebx

; 6420 : }

  022f6	c3		 ret	 0
_TextToSpeechOpenLogFile ENDP
_phTTS$ = 8
_TextToSpeechCloseLogFile PROC NEAR

; 6456 : {

  02300	56		 push	 esi

; 6457 : 	MMRESULT mmStatus;
; 6458 : 	
; 6459 : 	/********************************************************************/
; 6460 : 	/*  Return error if invalid handle.                                 */
; 6461 : 	/********************************************************************/
; 6462 : 	
; 6463 : 	if ( IsBadWritePtr( phTTS, sizeof(phTTS)))

  02301	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02305	57		 push	 edi
  02306	6a 04		 push	 4
  02308	56		 push	 esi
  02309	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  0230f	85 c0		 test	 eax, eax
  02311	74 08		 je	 SHORT $L72317
  02313	5f		 pop	 edi

; 6464 : 		return( MMSYSERR_INVALHANDLE );

  02314	b8 05 00 00 00	 mov	 eax, 5
  02319	5e		 pop	 esi

; 6543 : }

  0231a	c3		 ret	 0
$L72317:

; 6465 : 
; 6466 : 	/********************************************************************/
; 6467 : 	/*  Wait until all previous calls to the TextToSpeechSpeak()        */
; 6468 : 	/*  function have completed.                                        */
; 6469 : 	/********************************************************************/
; 6470 : 	// tek 29jan99 bats 849: this must be done before the logflag is cleared.
; 6471 : 	mmStatus = TextToSpeechSync( phTTS );

  0231b	56		 push	 esi
  0231c	e8 00 00 00 00	 call	 _TextToSpeechSync
  02321	8b f8		 mov	 edi, eax

; 6472 : 	
; 6473 : 	if ( mmStatus )
; 6474 : 		mmStatus = MMSYSERR_ERROR;
; 6475 : 	else
; 6476 : 		mmStatus = MMSYSERR_NOERROR;
; 6477 : 		
; 6478 : #ifdef WIN32
; 6479 : 	/********************************************************************/
; 6480 : 	/*  Disable writing to the log file.                                */
; 6481 : 	/********************************************************************/
; 6482 : 	
; 6483 : 	phTTS->pKernelShareData->logflag = 0;       /* BATS#120 FIX TK & JL */

  02323	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02326	83 c4 04	 add	 esp, 4
  02329	f7 df		 neg	 edi
  0232b	c7 80 04 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+516], 0

; 6484 : #endif
; 6485 : 	
; 6486 : 	/********************************************************************/
; 6487 : 	/*  If a file is not open, then exit.                               */
; 6488 : 	/********************************************************************/
; 6489 : 	
; 6490 : 
; 6491 : 	EnterCriticalSection( phTTS->pcsLogFile );

  02335	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  0233b	1b ff		 sbb	 edi, edi
  0233d	51		 push	 ecx
  0233e	f7 df		 neg	 edi
  02340	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 6492 : 
; 6493 : 	if ( phTTS->dwOutputState != STATE_OUTPUT_LOG_FILE )

  02346	83 be 84 00 00
	00 03		 cmp	 DWORD PTR [esi+132], 3
  0234d	74 15		 je	 SHORT $L72320

; 6494 : 	{
; 6495 : 
; 6496 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  0234f	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  02355	52		 push	 edx
  02356	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0235c	5f		 pop	 edi

; 6497 : 
; 6498 : 		return( MMSYSERR_ERROR );

  0235d	b8 01 00 00 00	 mov	 eax, 1
  02362	5e		 pop	 esi

; 6543 : }

  02363	c3		 ret	 0
$L72320:

; 6499 : 	}
; 6500 : 	
; 6501 : 
; 6502 : #ifdef WIN32
; 6503 : 	/********************************************************************/
; 6504 : 	/*  Make sure data has been written to the file.                    */
; 6505 : 	/********************************************************************/
; 6506 : 	
; 6507 : 	_flushall;
; 6508 : #endif
; 6509 : #if defined __osf__ || defined __linux__
; 6510 : 	/********************************************************************/
; 6511 : 	/*  Disable writing to the log file.                                */
; 6512 : 	/********************************************************************/
; 6513 : 	
; 6514 : 	phTTS->pKernelShareData->logflag = 0;
; 6515 : #endif
; 6516 : 	
; 6517 : 	/********************************************************************/
; 6518 : 	/*  Set the system output state to audio if it is enabled.          */
; 6519 : 	/********************************************************************/
; 6520 : 	
; 6521 : 	if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  02364	f7 46 74 00 00
	00 80		 test	 DWORD PTR [esi+116], -2147483648 ; 80000000H
  0236b	75 17		 jne	 SHORT $L72321

; 6522 : 	{
; 6523 : 		phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 6524 : 		TextToSpeechReset(phTTS,FALSE); // tek 28jan99 bats 849: this resets the counters..

  0236d	6a 00		 push	 0
  0236f	56		 push	 esi
  02370	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  0237a	e8 00 00 00 00	 call	 _TextToSpeechReset
  0237f	83 c4 08	 add	 esp, 8

; 6525 : 	}
; 6526 : 	else

  02382	eb 0a		 jmp	 SHORT $L72322
$L72321:

; 6527 : 		phTTS->dwOutputState = STATE_OUTPUT_NULL;

  02384	c7 86 84 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+132], 4
$L72322:

; 6528 : 	
; 6529 : 	/********************************************************************/
; 6530 : 	/*  Close the log file.                                             */
; 6531 : 	/********************************************************************/
; 6532 : 	
; 6533 : #ifdef UNDER_CE
; 6534 : 	if ( CloseHandle( phTTS->pLogFile)==0)
; 6535 : #else
; 6536 : 	if ( fclose( phTTS->pLogFile ))

  0238e	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  02394	50		 push	 eax
  02395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0239b	83 c4 04	 add	 esp, 4
  0239e	85 c0		 test	 eax, eax
  023a0	74 05		 je	 SHORT $L72323

; 6537 : #endif
; 6538 : 		mmStatus = MMSYSERR_ERROR;

  023a2	bf 01 00 00 00	 mov	 edi, 1
$L72323:

; 6539 : 	
; 6540 : 		LeaveCriticalSection( phTTS->pcsLogFile );

  023a7	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  023ad	51		 push	 ecx
  023ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6541 : 	
; 6542 : 	return( mmStatus );

  023b4	8b c7		 mov	 eax, edi
  023b6	5f		 pop	 edi
  023b7	5e		 pop	 esi

; 6543 : }

  023b8	c3		 ret	 0
_TextToSpeechCloseLogFile ENDP
_TEXT	ENDS
PUBLIC	_QueueToMemory
_TEXT	SEGMENT
_phTTS$ = 8
_pSamples$ = 12
_dwNumberOfSamples$ = 16
_QueueToMemory PROC NEAR

; 6584 : 	unsigned int i;                        /*MVP : Not a static */
; 6585 : 	DWORD dwBytesLeft;             /*MVP : Not a static */
; 6586 : 	DWORD dwWordsLeft;             /*MVP : Not a static */
; 6587 : 	unsigned char * pBuffer;       /*MVP : Not a static */
; 6588 : 	short * pShort;                /*tek/bh 29jul96 */
; 6589 : 	LPTTS_BUFFER_T pTTS_Buffer;/*MVP : Not a static */
; 6590 : 	
; 6591 : 	/********************************************************************/
; 6592 : 	/*  Loop until all samples have been moved into buffers.            */
; 6593 : 	/********************************************************************/
; 6594 : 	
; 6595 : 	while( dwNumberOfSamples )

  023c0	8b 44 24 0c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp-4]
  023c4	53		 push	 ebx
  023c5	55		 push	 ebp
  023c6	56		 push	 esi
  023c7	85 c0		 test	 eax, eax
  023c9	57		 push	 edi
  023ca	0f 84 4a 02 00
	00		 je	 $L72339

; 6617 : 		}
; 6618 : 		
; 6619 : 		/******************************************************************/
; 6620 : 		/*  Move as many samples as possible into the buffer.             */
; 6621 : 		/*  Get the current buffer pointer and the number of bytes left   */
; 6622 : 		/*  in the buffer.                                                */
; 6623 : 		/******************************************************************/
; 6624 : 		
; 6625 : 		pTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  023d0	8b 7c 24 18	 mov	 edi, DWORD PTR _pSamples$[esp+12]
$L72338:

; 6596 : 	{
; 6597 : 		/******************************************************************/
; 6598 : 		/*  Block if the TextToSpeechReturnBuffer() function is returning */
; 6599 : 		/*  the current buffer.                                           */
; 6600 : 		/******************************************************************/
; 6601 : 
; 6602 : 		EnterCriticalSection( phTTS->pcsMemoryBuffer );

  023d4	8b 74 24 14	 mov	 esi, DWORD PTR _phTTS$[esp+12]
  023d8	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  023de	50		 push	 eax
  023df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 6603 : 		
; 6604 : 		/******************************************************************/
; 6605 : 		/*  If a new Text-To-Speech buffer is needed then get one from    */
; 6606 : 		/*  the application. Block if one is not available.               */
; 6607 : 		/******************************************************************/
; 6608 : 		
; 6609 : 		if ( (phTTS->pTTS_Buffer == NULL )
; 6610 : 			&& !(phTTS->bMemoryReset) 
; 6611 : 			&& !(phTTS->pKernelShareData->halting) )

  023e5	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  023eb	85 c0		 test	 eax, eax
  023ed	75 26		 jne	 SHORT $L72341
  023ef	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  023f5	85 c0		 test	 eax, eax
  023f7	75 1c		 jne	 SHORT $L72341
  023f9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  023fc	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  02402	85 c0		 test	 eax, eax
  02404	75 0f		 jne	 SHORT $L72341

; 6612 : 		{
; 6613 : #ifdef API_DEBUG
; 6614 : 			OutputDebugString("Q2M getting buffer.\n");
; 6615 : #endif //API_DEBUG
; 6616 : 			phTTS->pTTS_Buffer = GetBuffer( phTTS );

  02406	56		 push	 esi
  02407	e8 00 00 00 00	 call	 _GetBuffer
  0240c	83 c4 04	 add	 esp, 4
  0240f	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
$L72341:

; 6617 : 		}
; 6618 : 		
; 6619 : 		/******************************************************************/
; 6620 : 		/*  Move as many samples as possible into the buffer.             */
; 6621 : 		/*  Get the current buffer pointer and the number of bytes left   */
; 6622 : 		/*  in the buffer.                                                */
; 6623 : 		/******************************************************************/
; 6624 : 		
; 6625 : 		pTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

  02415	8b ae a0 00 00
	00		 mov	 ebp, DWORD PTR [esi+160]

; 6626 : 		
; 6627 : 		/******************************************************************/
; 6628 : 		/*  NULL buffers sent by reset to fix hang. WIH 3/27/95           */
; 6629 : 		/******************************************************************/
; 6630 : 		
; 6631 : 		/* tek 19aug96 Also, we should bail out here if we're doing a     */
; 6632 : 		/* reset.                                                         */
; 6633 : 		if ( (pTTS_Buffer == NULL))

  0241b	85 ed		 test	 ebp, ebp
  0241d	0f 84 b4 01 00
	00		 je	 $L73251

; 6637 : 	
; 6638 : #ifdef API_DEBUG
; 6639 : 			OutputDebugString("Q2M null bailout.\n");
; 6640 : #endif //API_DEBUG
; 6641 : 			return;
; 6642 : 		}
; 6643 : 		
; 6644 : 		if (phTTS->bMemoryReset)

  02423	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  02429	85 c0		 test	 eax, eax
  0242b	0f 85 b8 01 00
	00		 jne	 $L73252

; 6648 : 
; 6649 : 			SendBuffer(phTTS); //tek 03sep96
; 6650 : #ifdef API_DEBUG
; 6651 : 			OutputDebugString("Q2M reset bailout.\n");
; 6652 : #endif //API_DEBUG
; 6653 : 			return;
; 6654 : 		}       
; 6655 : 		
; 6656 : 		if  (phTTS->pKernelShareData->halting)

  02431	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02434	8b 82 74 01 00
	00		 mov	 eax, DWORD PTR [edx+372]
  0243a	85 c0		 test	 eax, eax
  0243c	0f 85 c2 01 00
	00		 jne	 $L73253

; 6662 : #ifdef API_DEBUG
; 6663 : 			OutputDebugString("Q2M halt bailout.\n");
; 6664 : #endif //API_DEBUG
; 6665 : 			return;
; 6666 : 		}
; 6667 : 		
; 6668 : 		pBuffer = (unsigned char *) pTTS_Buffer->lpData + pTTS_Buffer->dwBufferLength;

  02442	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  02445	8b 75 00	 mov	 esi, DWORD PTR [ebp]

; 6669 : 		
; 6670 : 		dwBytesLeft =
; 6671 : 			pTTS_Buffer->dwMaximumBufferLength - pTTS_Buffer->dwBufferLength;

  02448	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]
  0244b	03 f0		 add	 esi, eax
  0244d	2b d8		 sub	 ebx, eax

; 6672 : 		
; 6673 : 		/******************************************************************/
; 6674 : 		/*  Put the samples into the buffer in the proper format.         */
; 6675 : 		/******************************************************************/
; 6676 : 		
; 6677 : 		switch( phTTS->dwFormat )
; 6678 : 		{

  0244f	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  02453	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [eax+128]
  02459	48		 dec	 eax
  0245a	0f 84 cd 00 00
	00		 je	 $L72362
  02460	83 e8 03	 sub	 eax, 3
  02463	74 74		 je	 SHORT $L72352
  02465	83 e8 03	 sub	 eax, 3
  02468	0f 85 12 01 00
	00		 jne	 $L72368

; 6728 : 			}
; 6729 : 			
; 6730 : 			break;
; 6731 : 			
; 6732 : 			/******************************************************************/
; 6733 : 			/*  Output 8 bit mu-law samples.                                  */
; 6734 : 			/******************************************************************/
; 6735 : 			
; 6736 : 		case WAVE_FORMAT_08M08:
; 6737 : 			
; 6738 : 			if ( dwNumberOfSamples >= dwBytesLeft )

  0246e	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
  02472	3b c3		 cmp	 eax, ebx
  02474	72 3c		 jb	 SHORT $L72374

; 6739 : 			{
; 6740 : 				for ( i = 0; i < dwBytesLeft; i++ )

  02476	85 db		 test	 ebx, ebx
  02478	76 25		 jbe	 SHORT $L72377
  0247a	89 5c 24 18	 mov	 DWORD PTR 12+[esp+12], ebx
$L72375:

; 6741 : 					*pBuffer++ = LinearToMuLaw( *pSamples++ );

  0247e	66 8b 07	 mov	 ax, WORD PTR [edi]
  02481	83 c7 02	 add	 edi, 2
  02484	50		 push	 eax
  02485	e8 00 00 00 00	 call	 _LinearToMuLaw
  0248a	88 06		 mov	 BYTE PTR [esi], al
  0248c	8b 44 24 1c	 mov	 eax, DWORD PTR 12+[esp+16]
  02490	83 c4 04	 add	 esp, 4
  02493	46		 inc	 esi
  02494	48		 dec	 eax
  02495	89 44 24 18	 mov	 DWORD PTR 12+[esp+12], eax
  02499	75 e3		 jne	 SHORT $L72375

; 6739 : 			{
; 6740 : 				for ( i = 0; i < dwBytesLeft; i++ )

  0249b	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
$L72377:

; 6742 : 				
; 6743 : 				pTTS_Buffer->dwBufferLength += dwBytesLeft;

  0249f	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  024a2	03 d3		 add	 edx, ebx

; 6744 : 				dwNumberOfSamples = dwNumberOfSamples - dwBytesLeft;

  024a4	2b c3		 sub	 eax, ebx
  024a6	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  024a9	89 44 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], eax

; 6745 : 			}
; 6746 : 			else

  024ad	e9 ce 00 00 00	 jmp	 $L72368
$L72374:

; 6747 : 			{
; 6748 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  024b2	85 c0		 test	 eax, eax
  024b4	76 1b		 jbe	 SHORT $L72381
  024b6	8b d8		 mov	 ebx, eax
$L72379:

; 6749 : 					*pBuffer++ = LinearToMuLaw( *pSamples++ );

  024b8	66 8b 07	 mov	 ax, WORD PTR [edi]
  024bb	83 c7 02	 add	 edi, 2
  024be	50		 push	 eax
  024bf	e8 00 00 00 00	 call	 _LinearToMuLaw
  024c4	83 c4 04	 add	 esp, 4
  024c7	88 06		 mov	 BYTE PTR [esi], al
  024c9	46		 inc	 esi
  024ca	4b		 dec	 ebx
  024cb	75 eb		 jne	 SHORT $L72379

; 6747 : 			{
; 6748 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  024cd	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
$L72381:

; 6750 : 				
; 6751 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples;

  024d1	01 45 18	 add	 DWORD PTR [ebp+24], eax

; 6752 : 				dwNumberOfSamples = 0;
; 6753 : 			}
; 6754 : 			
; 6755 : 			break;

  024d4	e9 9f 00 00 00	 jmp	 $L73261
$L72352:

; 6679 : 			/******************************************************************/
; 6680 : 			/*  Output 16 bit samples.                                        */
; 6681 : 			/******************************************************************/
; 6682 : 			
; 6683 : 		case WAVE_FORMAT_1M16:
; 6684 : 			
; 6685 : 			dwWordsLeft = dwBytesLeft >> 1;
; 6686 : 			pShort = (short *)pBuffer;      
; 6687 : 			
; 6688 : 			if ( dwNumberOfSamples >= dwWordsLeft )

  024d9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwNumberOfSamples$[esp+12]
  024dd	d1 eb		 shr	 ebx, 1
  024df	3b cb		 cmp	 ecx, ebx
  024e1	72 28		 jb	 SHORT $L72354

; 6689 : 			{
; 6690 : 				for ( i = 0; i < dwWordsLeft; i++ )

  024e3	85 db		 test	 ebx, ebx
  024e5	76 11		 jbe	 SHORT $L72357
  024e7	8b c3		 mov	 eax, ebx
$L72355:

; 6691 : 					*pShort++ = *pSamples++;

  024e9	66 8b 17	 mov	 dx, WORD PTR [edi]
  024ec	83 c7 02	 add	 edi, 2
  024ef	66 89 16	 mov	 WORD PTR [esi], dx
  024f2	83 c6 02	 add	 esi, 2
  024f5	48		 dec	 eax
  024f6	75 f1		 jne	 SHORT $L72355
$L72357:

; 6692 : 				
; 6693 : 				pTTS_Buffer->dwBufferLength += dwWordsLeft << 1;

  024f8	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  024fb	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  024fe	03 d0		 add	 edx, eax

; 6694 : 				dwNumberOfSamples = dwNumberOfSamples - dwWordsLeft;

  02500	2b cb		 sub	 ecx, ebx
  02502	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  02505	89 4c 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], ecx

; 6695 : 			}
; 6696 : 			else

  02509	eb 75		 jmp	 SHORT $L72368
$L72354:

; 6697 : 			{
; 6698 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  0250b	85 c9		 test	 ecx, ecx
  0250d	76 11		 jbe	 SHORT $L72361
  0250f	8b c1		 mov	 eax, ecx
$L72359:

; 6699 : 					*pShort++ = *pSamples++;

  02511	66 8b 17	 mov	 dx, WORD PTR [edi]
  02514	83 c7 02	 add	 edi, 2
  02517	66 89 16	 mov	 WORD PTR [esi], dx
  0251a	83 c6 02	 add	 esi, 2
  0251d	48		 dec	 eax
  0251e	75 f1		 jne	 SHORT $L72359
$L72361:

; 6700 : 				
; 6701 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples << 1;

  02520	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  02523	8b 4d 18	 mov	 ecx, DWORD PTR [ebp+24]
  02526	03 c8		 add	 ecx, eax
  02528	89 4d 18	 mov	 DWORD PTR [ebp+24], ecx

; 6702 : 				dwNumberOfSamples = 0;
; 6703 : 			}
; 6704 : 			
; 6705 : 			break;

  0252b	eb 4b		 jmp	 SHORT $L73261
$L72362:

; 6706 : 			
; 6707 : 			/******************************************************************/
; 6708 : 			/*  Output 8 bit samples.                                         */
; 6709 : 			/******************************************************************/
; 6710 : 			
; 6711 : 		case WAVE_FORMAT_1M08:
; 6712 : 			
; 6713 : 			if ( dwNumberOfSamples >= dwBytesLeft )

  0252d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwNumberOfSamples$[esp+12]
  02531	3b cb		 cmp	 ecx, ebx
  02533	72 28		 jb	 SHORT $L72363

; 6714 : 			{
; 6715 : 				for ( i = 0; i < dwBytesLeft; i++ )

  02535	85 db		 test	 ebx, ebx
  02537	76 14		 jbe	 SHORT $L72366
  02539	8b c3		 mov	 eax, ebx
$L72364:

; 6716 : 					*pBuffer++ = ((unsigned char)((*pSamples++) >> 8)) ^ 0x80;

  0253b	66 8b 17	 mov	 dx, WORD PTR [edi]
  0253e	83 c7 02	 add	 edi, 2
  02541	c1 fa 08	 sar	 edx, 8
  02544	80 f2 80	 xor	 dl, 128			; 00000080H
  02547	88 16		 mov	 BYTE PTR [esi], dl
  02549	46		 inc	 esi
  0254a	48		 dec	 eax
  0254b	75 ee		 jne	 SHORT $L72364
$L72366:

; 6717 : 				
; 6718 : 				pTTS_Buffer->dwBufferLength += dwBytesLeft;

  0254d	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  02550	03 d3		 add	 edx, ebx

; 6719 : 				dwNumberOfSamples = dwNumberOfSamples - dwBytesLeft;

  02552	2b cb		 sub	 ecx, ebx
  02554	89 55 18	 mov	 DWORD PTR [ebp+24], edx
  02557	89 4c 24 1c	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], ecx

; 6720 : 			}
; 6721 : 			else

  0255b	eb 23		 jmp	 SHORT $L72368
$L72363:

; 6722 : 			{
; 6723 : 				for ( i = 0; i < dwNumberOfSamples; i++ )

  0255d	85 c9		 test	 ecx, ecx
  0255f	76 14		 jbe	 SHORT $L72371
  02561	8b c1		 mov	 eax, ecx
$L72369:

; 6724 : 					*pBuffer++ = ((unsigned char)((*pSamples++) >> 8)) ^ 0x80;

  02563	66 8b 17	 mov	 dx, WORD PTR [edi]
  02566	83 c7 02	 add	 edi, 2
  02569	c1 fa 08	 sar	 edx, 8
  0256c	80 f2 80	 xor	 dl, 128			; 00000080H
  0256f	88 16		 mov	 BYTE PTR [esi], dl
  02571	46		 inc	 esi
  02572	48		 dec	 eax
  02573	75 ee		 jne	 SHORT $L72369
$L72371:

; 6725 : 				
; 6726 : 				pTTS_Buffer->dwBufferLength += dwNumberOfSamples;

  02575	01 4d 18	 add	 DWORD PTR [ebp+24], ecx
$L73261:

; 6727 : 				dwNumberOfSamples = 0;

  02578	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _dwNumberOfSamples$[esp+12], 0
$L72368:

; 6756 : 			
; 6757 : 		default:
; 6758 : 			
; 6759 : 			break;
; 6760 : 		}
; 6761 : 		
; 6762 : 		/******************************************************************/
; 6763 : 		/*  The buffer is full. Return it to the application.             */
; 6764 : 		/******************************************************************/
; 6765 : 		
; 6766 : 		if ( pTTS_Buffer->dwBufferLength >= pTTS_Buffer->dwMaximumBufferLength )

  02580	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  02583	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  02586	3b c1		 cmp	 eax, ecx

; 6767 : 		{
; 6768 : 			/****************************************************************/
; 6769 : 			/*  Release the buffer.                                         */
; 6770 : 			/****************************************************************/
; 6771 : 	
; 6772 : 
; 6773 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02588	8b 4c 24 14	 mov	 ecx, DWORD PTR _phTTS$[esp+12]
  0258c	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  02592	52		 push	 edx
  02593	72 0d		 jb	 SHORT $L72383
  02595	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6774 : 		
; 6775 : 			SendBuffer( phTTS );

  0259b	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  0259f	50		 push	 eax

; 6776 : 		}
; 6777 : 		else

  025a0	eb 1c		 jmp	 SHORT $L73262
$L72383:

; 6778 : 		{
; 6779 : 
; 6780 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  025a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6781 : 			
; 6782 : 			/****************************************************************/
; 6783 : 			/*  tek 19aug96 if halting, release the buffer.                 */
; 6784 : 			/****************************************************************/
; 6785 : 			if (phTTS->pKernelShareData-> halting)

  025a8	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  025ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  025af	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  025b5	85 c0		 test	 eax, eax
  025b7	74 0d		 je	 SHORT $L72385

; 6786 : 				SendBuffer(phTTS);

  025b9	8b 54 24 14	 mov	 edx, DWORD PTR _phTTS$[esp+12]
  025bd	52		 push	 edx
$L73262:
  025be	e8 00 00 00 00	 call	 _SendBuffer
  025c3	83 c4 04	 add	 esp, 4
$L72385:
  025c6	8b 44 24 1c	 mov	 eax, DWORD PTR _dwNumberOfSamples$[esp+12]
  025ca	85 c0		 test	 eax, eax
  025cc	0f 85 02 fe ff
	ff		 jne	 $L72338
  025d2	5f		 pop	 edi
  025d3	5e		 pop	 esi
  025d4	5d		 pop	 ebp
  025d5	5b		 pop	 ebx

; 6787 : 			
; 6788 : 		}
; 6789 :   }
; 6790 :   
; 6791 :   return;
; 6792 : }

  025d6	c3		 ret	 0
$L73251:

; 6634 : 		{ // tek I think we have to do a leaveCS here.. 
; 6635 : 	
; 6636 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  025d7	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  025dd	50		 push	 eax
  025de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  025e4	5f		 pop	 edi
  025e5	5e		 pop	 esi
  025e6	5d		 pop	 ebp
  025e7	5b		 pop	 ebx

; 6787 : 			
; 6788 : 		}
; 6789 :   }
; 6790 :   
; 6791 :   return;
; 6792 : }

  025e8	c3		 ret	 0
$L73252:

; 6645 : 		{ // tek I think we have to do a leaveCS here.. 
; 6646 : 
; 6647 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  025e9	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  025ef	51		 push	 ecx

; 6657 : 		{ // tek I think we have to do a leaveCS here.. 
; 6658 : 
; 6659 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  025f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6660 : 
; 6661 : 			SendBuffer(phTTS); //tek 03sep96

  025f6	56		 push	 esi
  025f7	e8 00 00 00 00	 call	 _SendBuffer
  025fc	83 c4 04	 add	 esp, 4
  025ff	5f		 pop	 edi
  02600	5e		 pop	 esi
  02601	5d		 pop	 ebp
  02602	5b		 pop	 ebx

; 6787 : 			
; 6788 : 		}
; 6789 :   }
; 6790 :   
; 6791 :   return;
; 6792 : }

  02603	c3		 ret	 0
$L73253:

; 6657 : 		{ // tek I think we have to do a leaveCS here.. 
; 6658 : 
; 6659 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02604	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  0260a	52		 push	 edx
  0260b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 6660 : 
; 6661 : 			SendBuffer(phTTS); //tek 03sep96

  02611	56		 push	 esi
  02612	e8 00 00 00 00	 call	 _SendBuffer
  02617	83 c4 04	 add	 esp, 4
$L72339:
  0261a	5f		 pop	 edi
  0261b	5e		 pop	 esi
  0261c	5d		 pop	 ebp
  0261d	5b		 pop	 ebx

; 6787 : 			
; 6788 : 		}
; 6789 :   }
; 6790 :   
; 6791 :   return;
; 6792 : }

  0261e	c3		 ret	 0
_QueueToMemory ENDP
_TEXT	ENDS
EXTRN	_read_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pTTS_BufferArray$ = 8
_GetBuffer PROC NEAR

; 6821 : {

  02620	56		 push	 esi

; 6822 : 	LPTTS_BUFFER_T pTTS_BufferArray[1];  /*MVP : Not a static */
; 6823 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 6824 : 	
; 6825 : 	read_pipe( phTTS->pKernelShareData->buffer_pipe, &pTTS_BufferArray[0], 1 );

  02621	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02625	8d 44 24 08	 lea	 eax, DWORD PTR _pTTS_BufferArray$[esp]
  02629	6a 01		 push	 1
  0262b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0262e	50		 push	 eax
  0262f	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  02635	52		 push	 edx
  02636	e8 00 00 00 00	 call	 _read_pipe

; 6826 : 	
; 6827 : 	pTTS_Buffer = pTTS_BufferArray[0];

  0263b	8b 44 24 14	 mov	 eax, DWORD PTR _pTTS_BufferArray$[esp+12]

; 6828 : 	
; 6829 : 	if ( pTTS_Buffer != NULL )

  0263f	33 c9		 xor	 ecx, ecx
  02641	83 c4 0c	 add	 esp, 12			; 0000000cH
  02644	3b c1		 cmp	 eax, ecx
  02646	74 18		 je	 SHORT $L72393

; 6830 : 	{
; 6831 : 		pTTS_Buffer->dwBufferLength = 0;

  02648	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 6832 : 		pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  0264b	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 6833 : 		pTTS_Buffer->dwNumberOfIndexMarks = 0;

  0264e	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 6834 : 		
; 6835 : 		if ( phTTS->dwFormat == WAVE_FORMAT_1M16 )

  02651	8b 8e 80 00 00
	00		 mov	 ecx, DWORD PTR [esi+128]
  02657	83 f9 04	 cmp	 ecx, 4
  0265a	75 04		 jne	 SHORT $L72393

; 6836 : 			pTTS_Buffer->dwMaximumBufferLength &= 0xFFFFFFFE;

  0265c	83 60 0c fe	 and	 DWORD PTR [eax+12], -2	; fffffffeH
$L72393:
  02660	5e		 pop	 esi

; 6837 : 	}
; 6838 : 	return( pTTS_Buffer );
; 6839 : }

  02661	c3		 ret	 0
_GetBuffer ENDP
_TEXT	ENDS
PUBLIC	_Report_TTS_Status
_TEXT	SEGMENT
_phTTS$ = 8
_SendBuffer PROC NEAR

; 6867 : {

  02670	56		 push	 esi

; 6868 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 6869 : #ifdef API_DEBUG
; 6870 : 	OutputDebugString("SendBuffer().\n");
; 6871 : #endif //API_DEBUG
; 6872 : 	if ( (! phTTS->bMemoryReset)
; 6873 : 		&& (! phTTS->pKernelShareData->halting))

  02671	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02675	57		 push	 edi
  02676	33 ff		 xor	 edi, edi
  02678	39 be 8c 00 00
	00		 cmp	 DWORD PTR [esi+140], edi
  0267e	75 60		 jne	 SHORT $L72398
  02680	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02683	39 b8 74 01 00
	00		 cmp	 DWORD PTR [eax+372], edi
  02689	75 55		 jne	 SHORT $L72398

; 6874 : 	{
; 6875 : #ifdef API_DEBUG
; 6876 : 		OutputDebugString(" SB (!reset).\n");
; 6877 : #endif //API_DEBUG
; 6878 : 		if ( phTTS->pTTS_Buffer != NULL )

  0268b	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  02691	3b c7		 cmp	 eax, edi
  02693	0f 84 b3 00 00
	00		 je	 $L72408

; 6879 : 		{
; 6880 : 			pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;
; 6881 : 			
; 6882 : 			/****************************************************************/
; 6883 : 			/*  NULL buffers sent by reset to fix hang. WIH 3/27/95         */
; 6884 : 			/****************************************************************/
; 6885 : 			
; 6886 : 			if ( pTTS_Buffer != NULL )
; 6887 : 			{
; 6888 : 				
; 6889 : 				
; 6890 : 				/****************************************************************/
; 6891 : 				/*  It is possible to get here with nothing in the buffer if    */
; 6892 : 				/*  a force caused the buffer to be returned. Check the buffer  */
; 6893 : 				/*  to see if it has any sections full.                         */
; 6894 : 				/****************************************************************/
; 6895 : 				
; 6896 : 				if (( pTTS_Buffer->dwBufferLength > 0 )
; 6897 : 					|| ( pTTS_Buffer->dwNumberOfIndexMarks > 0 )
; 6898 : 					|| ( pTTS_Buffer->dwNumberOfPhonemeChanges > 0 ))

  02699	39 78 18	 cmp	 DWORD PTR [eax+24], edi
  0269c	77 0e		 ja	 SHORT $L72405
  0269e	39 78 20	 cmp	 DWORD PTR [eax+32], edi
  026a1	77 09		 ja	 SHORT $L72405
  026a3	39 78 1c	 cmp	 DWORD PTR [eax+28], edi
  026a6	0f 86 a0 00 00
	00		 jbe	 $L72408
$L72405:

; 6899 : 				{
; 6900 : 					phTTS->bSendingBuffer = TRUE;
; 6901 : 					/*
; 6902 : 					SendMessage( phTTS->hWnd,
; 6903 : 					phTTS->uiID_Buffer_Message,
; 6904 : 					0,
; 6905 : 					(LPARAM)phTTS->pTTS_Buffer );
; 6906 : 					*/
; 6907 : 					//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 6908 : #ifdef API_DEBUG
; 6909 : 					OutputDebugString("returning partial buffer.\n");
; 6910 : #endif //API_DEBUG
; 6911 : 					
; 6912 : 					Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)phTTS->pTTS_Buffer);

  026ac	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  026af	50		 push	 eax
  026b0	57		 push	 edi
  026b1	51		 push	 ecx
  026b2	56		 push	 esi
  026b3	c7 86 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+144], 1
  026bd	e8 00 00 00 00	 call	 _Report_TTS_Status

; 6913 : 					
; 6914 : 					phTTS->bSendingBuffer = FALSE;
; 6915 : 					
; 6916 : #ifdef WIN32
; 6917 : 					WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  026c2	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  026c5	83 c4 10	 add	 esp, 16			; 00000010H
  026c8	89 be 90 00 00
	00		 mov	 DWORD PTR [esi+144], edi
  026ce	6a ff		 push	 -1
  026d0	52		 push	 edx
  026d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 6918 : #endif
; 6919 : #if defined __osf__ || defined __linux__
; 6920 : 					OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 6921 : #endif
; 6922 : 					phTTS->pTTS_Buffer = NULL;

  026d7	89 be a0 00 00
	00		 mov	 DWORD PTR [esi+160], edi
  026dd	5f		 pop	 edi
  026de	5e		 pop	 esi

; 7003 : #endif
; 7004 : #if defined __osf__ || defined __linux__
; 7005 : 		OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 7006 : #endif
; 7007 : 	}
; 7008 : #ifdef API_DEBUG
; 7009 : 	OutputDebugString("SB done.\n");
; 7010 : #endif //API_DEBUG
; 7011 : 	return;
; 7012 : }

  026df	c3		 ret	 0
$L72398:

; 6923 : 				}
; 6924 : 			}
; 6925 : 		}
; 6926 : 	}
; 6927 : 	else
; 6928 : 	{
; 6929 : #ifdef API_DEBUG
; 6930 : 		OutputDebugString("SB (reset)\n");
; 6931 : 		if (phTTS->pKernelShareData->halting)
; 6932 : 			OutputDebugString("SB halting.. \n");
; 6933 : 		if (phTTS->bMemoryReset)
; 6934 : 			OutputDebugString("SB memreset.. \n");
; 6935 : #endif //API_DEBUG
; 6936 : 		
; 6937 : 		/******************************************************************/
; 6938 : 		/*  Send the current buffer back.                                 */
; 6939 : 		/******************************************************************/
; 6940 : 		
; 6941 : 		if ( phTTS->pTTS_Buffer != NULL )

  026e0	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  026e6	3b c7		 cmp	 eax, edi
  026e8	74 31		 je	 SHORT $L72413

; 6942 : 		{
; 6943 : #ifdef API_DEBUG
; 6944 : 			OutputDebugString("SB return current buf. \n");
; 6945 : #endif //API_DEBUG
; 6946 : 			pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;
; 6947 : 			
; 6948 : 			/****************************************************************/
; 6949 : 			/*  NULL buffers sent by reset to fix hang. WIH 3/27/95         */
; 6950 : 			/*  This is needed in spite of previous "if" statement because  */
; 6951 : 			/*  the app is multip-threaded.                                 */
; 6952 : 			/****************************************************************/
; 6953 : 			
; 6954 : 			if ( pTTS_Buffer != NULL )
; 6955 : 			{
; 6956 : 				phTTS->bSendingBuffer = TRUE;
; 6957 : 				/*
; 6958 : 				SendMessage( phTTS->hWnd,
; 6959 : 				phTTS->uiID_Buffer_Message,
; 6960 : 				0,
; 6961 : 				(LPARAM)pTTS_Buffer );
; 6962 : 				*/
; 6963 : 				//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 6964 : #ifdef API_DEBUG
; 6965 : 				OutputDebugString(" returning a buffer.. \n");
; 6966 : #endif //API_DEBUG
; 6967 : 				
; 6968 : 				Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)pTTS_Buffer);

  026ea	50		 push	 eax
  026eb	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  026ee	57		 push	 edi
  026ef	50		 push	 eax
  026f0	56		 push	 esi
  026f1	c7 86 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+144], 1
  026fb	e8 00 00 00 00	 call	 _Report_TTS_Status

; 6969 : 				phTTS->pTTS_Buffer = NULL;        //tek 03sep96
; 6970 : 				
; 6971 : 				phTTS->bSendingBuffer = FALSE;
; 6972 : 				
; 6973 : #ifdef WIN32
; 6974 : 				WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  02700	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  02703	83 c4 10	 add	 esp, 16			; 00000010H
  02706	89 be a0 00 00
	00		 mov	 DWORD PTR [esi+160], edi
  0270c	89 be 90 00 00
	00		 mov	 DWORD PTR [esi+144], edi
  02712	6a ff		 push	 -1
  02714	51		 push	 ecx
  02715	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$L72413:

; 6975 : #endif
; 6976 : #if defined __osf__ || defined __linux__
; 6977 : 				OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 6978 : #endif
; 6979 : 			}
; 6980 : 			
; 6981 : 		}
; 6982 : 		
; 6983 : 		// tek 03sep96 moved the return of remaining buffers out to 
; 6984 : 		// a separate routine.
; 6985 : 		ReturnRemainingBuffers(phTTS);

  0271b	56		 push	 esi
  0271c	e8 00 00 00 00	 call	 _ReturnRemainingBuffers

; 6986 : 		
; 6987 : 		// tek 29aug96 if we're in a flusg, put in another null buffer.. 
; 6988 : 		if (phTTS->pKernelShareData->halting )

  02721	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02724	83 c4 04	 add	 esp, 4
  02727	39 ba 74 01 00
	00		 cmp	 DWORD PTR [edx+372], edi
  0272d	74 0a		 je	 SHORT $L72416

; 6989 : 			TextToSpeechAddBuffer(phTTS, NULL); // a dummy buffer.

  0272f	57		 push	 edi
  02730	56		 push	 esi
  02731	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  02736	83 c4 08	 add	 esp, 8
$L72416:

; 6990 : 		/******************************************************************/
; 6991 : 		/*  Empty the VTM pipe in case there is still any data in it      */
; 6992 : 		/******************************************************************/
; 6993 : 		
; 6994 : 		InitializeVTM(phTTS);

  02739	56		 push	 esi
  0273a	e8 00 00 00 00	 call	 _InitializeVTM

; 6995 : 		
; 6996 : 		//phTTS->pTTS_Buffer = NULL;
; 6997 : 		//tek 03sep96 we can't clear this flag here, because  vtm writes
; 6998 : 		// that sneak in at the 'right' time could prematurely clear it.
; 6999 : 		//phTTS->bMemoryReset = FALSE;
; 7000 : 		
; 7001 : #ifdef WIN32
; 7002 : 		SetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  0273f	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  02742	83 c4 04	 add	 esp, 4
  02745	50		 push	 eax
  02746	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L72408:
  0274c	5f		 pop	 edi
  0274d	5e		 pop	 esi

; 7003 : #endif
; 7004 : #if defined __osf__ || defined __linux__
; 7005 : 		OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 7006 : #endif
; 7007 : 	}
; 7008 : #ifdef API_DEBUG
; 7009 : 	OutputDebugString("SB done.\n");
; 7010 : #endif //API_DEBUG
; 7011 : 	return;
; 7012 : }

  0274e	c3		 ret	 0
_SendBuffer ENDP
_phTTS$ = 8
_pPipeArray$ = 8
_ReturnRemainingBuffers PROC NEAR

; 7024 : {

  02750	56		 push	 esi

; 7025 : 	LPTTS_BUFFER_T pPipeArray[1];        /*MVP : Not a static */
; 7026 : 	LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
; 7027 : #ifdef WIN32
; 7028 : 	UINT	uiPipeCount=0;				// 16jun97 tek bats 385 merged 28jul97
; 7029 : 	
; 7030 : #ifdef API_DEBUG
; 7031 : 	OutputDebugString("ReturnRemainingBuffers()\n");
; 7032 : #endif //API_DEBUG
; 7033 : #endif
; 7034 : 	
; 7035 :     /******************************************************************/
; 7036 : 	/*  Send all the remaining buffers back.                          */
; 7037 : 	/******************************************************************/
; 7038 : 	
; 7039 : 	// tek 03sep96 we need to lock the pipe to make sure nothing arrives
; 7040 :     // while we're dumping.. 
; 7041 : #ifdef WIN32
; 7042 : 	// 16jun97 tek bats 385: (merged 28jul97)
; 7043 : 	// the user callback may be coded to just return buffers, and that 
; 7044 : 	// would result in an infinite loop if we just tried to drain the pipe.
; 7045 : 	// Soooo.. we empty the pipe into an cache, and then return the buffers
; 7046 : 	// from the cache; this means the user callback is filling a different
; 7047 : 	// pipe and thus we won't loop forever.
; 7048 :     LockPipe(phTTS->pKernelShareData->buffer_pipe);

  02751	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02755	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02758	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  0275e	51		 push	 ecx
  0275f	e8 00 00 00 00	 call	 _LockPipe

; 7049 : #endif
; 7050 : #if defined __osf__ || defined __linux__
; 7051 :     OP_LockMutex(phTTS->pcsBufferPipe);
; 7052 : #endif
; 7053 : 	
; 7054 : 	while (pipe_count( phTTS->pKernelShareData->buffer_pipe ) )

  02764	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02767	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  0276d	50		 push	 eax
  0276e	e8 00 00 00 00	 call	 _pipe_count
  02773	83 c4 08	 add	 esp, 8
  02776	85 c0		 test	 eax, eax
  02778	74 42		 je	 SHORT $L72426
$L72425:

; 7055 : 	{
; 7056 : 		read_pipe( phTTS->pKernelShareData->buffer_pipe, &pPipeArray, 1 );

  0277a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0277d	8d 4c 24 08	 lea	 ecx, DWORD PTR _pPipeArray$[esp]
  02781	6a 01		 push	 1
  02783	51		 push	 ecx
  02784	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  0278a	50		 push	 eax
  0278b	e8 00 00 00 00	 call	 _read_pipe

; 7057 : #ifdef WIN32
; 7058 : 		write_pipe(phTTS->pKernelShareData->buffer_delay_pipe, pPipeArray, 1 );

  02790	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  02793	8d 4c 24 14	 lea	 ecx, DWORD PTR _pPipeArray$[esp+12]
  02797	6a 01		 push	 1
  02799	51		 push	 ecx
  0279a	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  027a0	50		 push	 eax
  027a1	e8 00 00 00 00	 call	 _write_pipe
  027a6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  027a9	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  027af	52		 push	 edx
  027b0	e8 00 00 00 00	 call	 _pipe_count
  027b5	83 c4 1c	 add	 esp, 28			; 0000001cH
  027b8	85 c0		 test	 eax, eax
  027ba	75 be		 jne	 SHORT $L72425
$L72426:

; 7059 : 	}
; 7060 : 	UnlockPipe(phTTS->pKernelShareData->buffer_pipe);

  027bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  027bf	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  027c5	51		 push	 ecx
  027c6	e8 00 00 00 00	 call	 _UnlockPipe

; 7061 : 	
; 7062 : 	while (pipe_count( phTTS->pKernelShareData->buffer_delay_pipe ))

  027cb	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  027ce	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  027d4	50		 push	 eax
  027d5	e8 00 00 00 00	 call	 _pipe_count
  027da	83 c4 08	 add	 esp, 8
  027dd	85 c0		 test	 eax, eax
  027df	74 73		 je	 SHORT $L72429
  027e1	53		 push	 ebx
  027e2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WaitForSingleObject@8
  027e8	57		 push	 edi
  027e9	33 ff		 xor	 edi, edi
$L72428:

; 7063 : 	{
; 7064 : 		read_pipe( phTTS->pKernelShareData->buffer_delay_pipe, &pPipeArray, 1 );

  027eb	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  027ee	8d 4c 24 10	 lea	 ecx, DWORD PTR _pPipeArray$[esp+8]
  027f2	6a 01		 push	 1
  027f4	51		 push	 ecx
  027f5	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  027fb	50		 push	 eax
  027fc	e8 00 00 00 00	 call	 _read_pipe

; 7065 : 		
; 7066 : #endif
; 7067 : #if defined __osf__ || defined __linux__
; 7068 : 		OP_UnlockMutex(phTTS->pcsBufferPipe);
; 7069 : #endif
; 7070 : 		pTTS_Buffer = pPipeArray[0];

  02801	8b 44 24 1c	 mov	 eax, DWORD PTR _pPipeArray$[esp+20]
  02805	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7071 : 		
; 7072 : 		if ( pTTS_Buffer != NULL )

  02808	3b c7		 cmp	 eax, edi
  0280a	74 30		 je	 SHORT $L72431

; 7073 : 		{
; 7074 : 			pTTS_Buffer->dwBufferLength = 0;

  0280c	89 78 18	 mov	 DWORD PTR [eax+24], edi

; 7075 : 			pTTS_Buffer->dwNumberOfPhonemeChanges = 0;

  0280f	89 78 1c	 mov	 DWORD PTR [eax+28], edi

; 7076 : 			pTTS_Buffer->dwNumberOfIndexMarks = 0;

  02812	89 78 20	 mov	 DWORD PTR [eax+32], edi

; 7077 : 			
; 7078 : 			phTTS->bSendingBuffer = TRUE;
; 7079 : 			/*
; 7080 : 			SendMessage( phTTS->hWnd,
; 7081 : 			phTTS->uiID_Buffer_Message,
; 7082 : 			0,
; 7083 : 			(LPARAM)pTTS_Buffer );
; 7084 : 			*/
; 7085 : 			//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
; 7086 : #ifdef API_DEBUG
; 7087 : 			OutputDebugString(" returning a remaining buffer.. \n");
; 7088 : #endif //API_DEBUG
; 7089 : 			Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)pTTS_Buffer);

  02815	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  02818	50		 push	 eax
  02819	57		 push	 edi
  0281a	51		 push	 ecx
  0281b	56		 push	 esi
  0281c	c7 86 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+144], 1
  02826	e8 00 00 00 00	 call	 _Report_TTS_Status

; 7090 : 			
; 7091 : 			phTTS->bSendingBuffer = FALSE;
; 7092 : #ifdef WIN32
; 7093 : 			WaitForSingleObject( phTTS->hNotEmptyingVtmPipeEvent, INFINITE );

  0282b	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  0282e	83 c4 10	 add	 esp, 16			; 00000010H
  02831	89 be 90 00 00
	00		 mov	 DWORD PTR [esi+144], edi
  02837	6a ff		 push	 -1
  02839	52		 push	 edx
  0283a	ff d3		 call	 ebx
$L72431:
  0283c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0283f	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  02845	51		 push	 ecx
  02846	e8 00 00 00 00	 call	 _pipe_count
  0284b	83 c4 04	 add	 esp, 4
  0284e	85 c0		 test	 eax, eax
  02850	75 99		 jne	 SHORT $L72428
  02852	5f		 pop	 edi
  02853	5b		 pop	 ebx
$L72429:
  02854	5e		 pop	 esi

; 7094 : #endif
; 7095 : #if defined __osf__ || defined __linux__
; 7096 : 			OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
; 7097 : #endif
; 7098 : 		}
; 7099 : 		// relock the pipe to atomically get a count and a buffer.
; 7100 : 		// LockPipe(phTTS->pKernelShareData->buffer_pipe);
; 7101 : #if defined __osf__ || defined __linux__
; 7102 : 		OP_LockMutex(phTTS->pcsBufferPipe);
; 7103 : #endif
; 7104 : 	}
; 7105 : 	//  UnlockPipe(phTTS->pKernelShareData->buffer_pipe);
; 7106 : #if defined __osf__ || defined __linux__
; 7107 : 	OP_UnlockMutex(phTTS->pcsBufferPipe);
; 7108 : #endif
; 7109 : } // ReturnRemainingBuffers()

  02855	c3		 ret	 0
_ReturnRemainingBuffers ENDP
_TEXT	ENDS
PUBLIC	_PutIndexMarkInBuffer
_BSS	SEGMENT
	ALIGN	4

_?pIndexArray@?1??PutIndexMarkInBuffer@@9@9 DD 01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_dwIndexValue$ = 12
_dwSampleNumber$ = 16
_PutIndexMarkInBuffer PROC NEAR

; 7146 : {

  02860	56		 push	 esi

; 7147 : 	UINT uiIndex;                                                      /*MVP : Not a static */
; 7148 : 	/*static LPTTS_BUFFER_T pPipeArray[1];*/               /*MVP : Never Used   */
; 7149 : 	LPTTS_BUFFER_T pTTS_Buffer;                                    /*MVP : Not a static */
; 7150 : 	static LPTTS_INDEX_T pIndexArray;                              /*MVP : Not a static */
; 7151 : 	
; 7152 : #if defined __osf__ || defined __linux__
; 7153 : 	/********************************************************************/
; 7154 : 	/*   If current in the Reset code, no need to continue              */
; 7155 : 	/********************************************************************/
; 7156 : 	if ( phTTS->bInReset )
; 7157 : 		return;
; 7158 : #endif
; 7159 : 	
; 7160 : 	/********************************************************************/
; 7161 : 	/*  Block if the TextToSpeechReturnBuffer() function is returning   */
; 7162 : 	/*  the current buffer.                                             */
; 7163 : 	/********************************************************************/
; 7164 : 
; 7165 : 		EnterCriticalSection( phTTS->pcsMemoryBuffer );

  02861	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02865	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0286b	50		 push	 eax
  0286c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7166 : 	
; 7167 : 	/********************************************************************/
; 7168 : 	/*  If a new Text-To-Speech buffer is needed then get one from      */
; 7169 : 	/*  the application. Block if one is not available.                 */
; 7170 : 	/********************************************************************/
; 7171 : 	
; 7172 : 	if ( phTTS->pTTS_Buffer == NULL )

  02872	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  02878	85 c0		 test	 eax, eax
  0287a	75 0f		 jne	 SHORT $L72446

; 7173 : 	{
; 7174 : 		phTTS->pTTS_Buffer = GetBuffer( phTTS );

  0287c	56		 push	 esi
  0287d	e8 00 00 00 00	 call	 _GetBuffer
  02882	83 c4 04	 add	 esp, 4
  02885	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
$L72446:

; 7175 : 	}
; 7176 : 	
; 7177 : 	pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

  0288b	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]

; 7178 : 	
; 7179 : 	/********************************************************************/
; 7180 : 	/*  NULL buffers sent by reset to fix hang. WIH 3/27/95             */
; 7181 : 	/********************************************************************/
; 7182 : 	
; 7183 : 	if ( pTTS_Buffer == NULL )

  02891	85 c0		 test	 eax, eax

; 7184 : 	{
; 7185 : 
; 7186 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );
; 7187 : 
; 7188 : 		return;

  02893	74 6c		 je	 SHORT $L72451

; 7189 : 	}
; 7190 : 	
; 7191 : 	/********************************************************************/
; 7192 : 	/*  Put the index mark into the current buffer.                     */
; 7193 : 	/********************************************************************/
; 7194 : 	
; 7195 : 	pIndexArray = pTTS_Buffer->lpIndexArray;

  02895	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 7196 : 	
; 7197 : 	if ( pIndexArray != NULL )

  02898	85 d2		 test	 edx, edx
  0289a	89 15 00 00 00
	00		 mov	 DWORD PTR _?pIndexArray@?1??PutIndexMarkInBuffer@@9@9, edx
  028a0	74 5f		 je	 SHORT $L72451

; 7198 : 	{
; 7199 : 		uiIndex = pTTS_Buffer->dwNumberOfIndexMarks;

  028a2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  028a5	57		 push	 edi

; 7200 : 		
; 7201 : 		if ( pTTS_Buffer->dwMaximumNumberOfIndexMarks > 0 )

  028a6	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  028a9	85 ff		 test	 edi, edi
  028ab	76 22		 jbe	 SHORT $L72452

; 7202 : 		{
; 7203 : 			(pIndexArray+uiIndex)->dwIndexValue = dwIndexValue;

  028ad	8b 7c 24 10	 mov	 edi, DWORD PTR _dwIndexValue$[esp+4]
  028b1	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  028b4	c1 e1 02	 shl	 ecx, 2
  028b7	89 3c 11	 mov	 DWORD PTR [ecx+edx], edi

; 7204 : 			(pIndexArray+uiIndex)->dwIndexSampleNumber = dwSampleNumber;

  028ba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _?pIndexArray@?1??PutIndexMarkInBuffer@@9@9
  028c0	8b 54 24 14	 mov	 edx, DWORD PTR _dwSampleNumber$[esp+4]
  028c4	89 54 39 04	 mov	 DWORD PTR [ecx+edi+4], edx

; 7205 : 			pTTS_Buffer->dwNumberOfIndexMarks++;

  028c8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  028cb	41		 inc	 ecx
  028cc	89 48 20	 mov	 DWORD PTR [eax+32], ecx
$L72452:

; 7206 : 		}
; 7207 : 		
; 7208 : 		/******************************************************************/
; 7209 : 		/*  If the index mark array is full then return it to the         */
; 7210 : 		/*  application.                                                  */
; 7211 : 		/******************************************************************/
; 7212 : 		
; 7213 : 		if ( pTTS_Buffer->dwNumberOfIndexMarks
; 7214 : 			>= pTTS_Buffer->dwMaximumNumberOfIndexMarks )

  028cf	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  028d2	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  028d5	3b ca		 cmp	 ecx, edx
  028d7	5f		 pop	 edi
  028d8	72 18		 jb	 SHORT $L72453

; 7215 : 		{
; 7216 : 			/****************************************************************/
; 7217 : 			/*  Release the buffer.                                         */
; 7218 : 			/****************************************************************/
; 7219 : 			
; 7220 : 
; 7221 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  028da	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  028e0	52		 push	 edx
  028e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7222 : 			
; 7223 : 			SendBuffer( phTTS );

  028e7	56		 push	 esi
  028e8	e8 00 00 00 00	 call	 _SendBuffer
  028ed	83 c4 04	 add	 esp, 4
  028f0	5e		 pop	 esi

; 7243 : 
; 7244 : 	}
; 7245 : 	return;
; 7246 : }

  028f1	c3		 ret	 0
$L72453:

; 7224 : 		}
; 7225 : 		else
; 7226 : 		{
; 7227 : 			/****************************************************************/
; 7228 : 			/*  Release the buffer.                                         */
; 7229 : 			/****************************************************************/
; 7230 : 			
; 7231 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  028f2	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  028f8	50		 push	 eax

; 7232 : 
; 7233 : 		}
; 7234 : 	}
; 7235 : 	else
; 7236 : 	{
; 7237 : 		/******************************************************************/
; 7238 : 		/*  Release the buffer.                                           */
; 7239 : 		/******************************************************************/
; 7240 : 		
; 7241 : 
; 7242 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  028f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  028ff	5e		 pop	 esi

; 7243 : 
; 7244 : 	}
; 7245 : 	return;
; 7246 : }

  02900	c3		 ret	 0
$L72451:

; 7232 : 
; 7233 : 		}
; 7234 : 	}
; 7235 : 	else
; 7236 : 	{
; 7237 : 		/******************************************************************/
; 7238 : 		/*  Release the buffer.                                           */
; 7239 : 		/******************************************************************/
; 7240 : 		
; 7241 : 
; 7242 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02901	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  02907	51		 push	 ecx
  02908	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0290e	5e		 pop	 esi

; 7243 : 
; 7244 : 	}
; 7245 : 	return;
; 7246 : }

  0290f	c3		 ret	 0
_PutIndexMarkInBuffer ENDP
_TEXT	ENDS
PUBLIC	_PutPhonemeInBuffer
_TEXT	SEGMENT
_phTTS$ = 8
_dwPhoneme$ = 12
_dwPhonemeDuration$ = 16
_dwSampleNumber$ = 20
_PutPhonemeInBuffer PROC NEAR

; 7283 : {

  02910	56		 push	 esi

; 7284 : 	UINT uiIndex;                                                     /* MVP : Not a static */
; 7285 : 	/*static LPTTS_BUFFER_T pPipeArray[1];*/  /* MVP : Never Used   */
; 7286 : 	LPTTS_BUFFER_T pTTS_Buffer;                           /* MVP : Not a static */
; 7287 : 	LPTTS_PHONEME_T pPhonemeArray;                        /* MVP : Not a static */
; 7288 : 	
; 7289 : #ifdef WIN32
; 7290 : 	/********************************************************************/
; 7291 : 	/*   If current in the Reset code, no need to continue              */
; 7292 : 	/********************************************************************/
; 7293 : 	if ( phTTS->bInReset )

  02911	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  02915	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  0291b	85 c0		 test	 eax, eax
  0291d	0f 85 a1 00 00
	00		 jne	 $L72480

; 7294 : 		return;
; 7295 : #endif
; 7296 : 	
; 7297 : 	
; 7298 : 	/********************************************************************/
; 7299 : 	/*  Block if the TextToSpeechReturnBuffer() function is returning   */
; 7300 : 	/*  the current buffer.                                             */
; 7301 : 	/********************************************************************/
; 7302 : 
; 7303 : 	EnterCriticalSection( phTTS->pcsMemoryBuffer );

  02923	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  02929	50		 push	 eax
  0292a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7304 : 	
; 7305 : 	/********************************************************************/
; 7306 : 	/*  If a new Text-To-Speech buffer is needed then get one from      */
; 7307 : 	/*  the application. Block if one is not available.                 */
; 7308 : 	/********************************************************************/
; 7309 : 	
; 7310 : 	if ( phTTS->pTTS_Buffer == NULL )

  02930	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  02936	85 c0		 test	 eax, eax
  02938	75 0f		 jne	 SHORT $L72471

; 7311 : 	{
; 7312 : 		phTTS->pTTS_Buffer = GetBuffer( phTTS );

  0293a	56		 push	 esi
  0293b	e8 00 00 00 00	 call	 _GetBuffer
  02940	83 c4 04	 add	 esp, 4
  02943	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
$L72471:

; 7313 : 	}
; 7314 : 	
; 7315 : 	/********************************************************************/
; 7316 : 	/*  Put the index mark into the current buffer.                     */
; 7317 : 	/********************************************************************/
; 7318 : 	
; 7319 : 	pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

  02949	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]

; 7320 : 	
; 7321 : 	/********************************************************************/
; 7322 : 	/*  NULL buffers sent by reset to fix hang. WIH 3/27/95             */
; 7323 : 	/********************************************************************/
; 7324 : 	
; 7325 : 	if ( pTTS_Buffer == NULL )

  0294f	85 c0		 test	 eax, eax

; 7326 : 	{
; 7327 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );
; 7328 : 		return;

  02951	74 64		 je	 SHORT $L72476

; 7329 : 	}
; 7330 : 	
; 7331 : 	pPhonemeArray = pTTS_Buffer->lpPhonemeArray;

  02953	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 7332 : 	
; 7333 : 	if ( pPhonemeArray != NULL )

  02956	85 d2		 test	 edx, edx
  02958	74 5d		 je	 SHORT $L72476

; 7334 : 	{
; 7335 : 		uiIndex = pTTS_Buffer->dwNumberOfPhonemeChanges;

  0295a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0295d	57		 push	 edi

; 7336 : 		
; 7337 : 		if ( pTTS_Buffer->dwMaximumNumberOfPhonemeChanges > 0 )

  0295e	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  02961	85 ff		 test	 edi, edi
  02963	5f		 pop	 edi
  02964	76 20		 jbe	 SHORT $L72477

; 7338 : 		{
; 7339 : 			(pPhonemeArray+uiIndex)->dwPhoneme = dwPhoneme;

  02966	c1 e1 04	 shl	 ecx, 4
  02969	03 ca		 add	 ecx, edx
  0296b	8b 54 24 0c	 mov	 edx, DWORD PTR _dwPhoneme$[esp]
  0296f	89 11		 mov	 DWORD PTR [ecx], edx

; 7340 : 			(pPhonemeArray+uiIndex)->dwPhonemeSampleNumber = dwSampleNumber;

  02971	8b 54 24 14	 mov	 edx, DWORD PTR _dwSampleNumber$[esp]
  02975	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 7341 : 			(pPhonemeArray+uiIndex)->dwPhonemeDuration = dwPhonemeDuration;

  02978	8b 54 24 10	 mov	 edx, DWORD PTR _dwPhonemeDuration$[esp]
  0297c	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 7342 : 			pTTS_Buffer->dwNumberOfPhonemeChanges++;

  0297f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02982	41		 inc	 ecx
  02983	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L72477:

; 7343 : 		}
; 7344 : 		
; 7345 : 		/******************************************************************/
; 7346 : 		/*  If the phoneme array is full then return it to the            */
; 7347 : 		/*  application.                                                  */
; 7348 : 		/******************************************************************/
; 7349 : 		
; 7350 : 		if ( pTTS_Buffer->dwNumberOfPhonemeChanges
; 7351 : 			>= pTTS_Buffer->dwMaximumNumberOfPhonemeChanges )

  02986	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02989	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0298c	3b ca		 cmp	 ecx, edx
  0298e	72 18		 jb	 SHORT $L72478

; 7352 : 		{
; 7353 : 			/****************************************************************/
; 7354 : 			/*  Release the buffer.                                         */
; 7355 : 			/****************************************************************/
; 7356 : 
; 7357 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  02990	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  02996	52		 push	 edx
  02997	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7358 : 			SendBuffer( phTTS );

  0299d	56		 push	 esi
  0299e	e8 00 00 00 00	 call	 _SendBuffer
  029a3	83 c4 04	 add	 esp, 4
  029a6	5e		 pop	 esi

; 7375 : 	}
; 7376 : 	return;
; 7377 : }

  029a7	c3		 ret	 0
$L72478:

; 7359 : 		}
; 7360 : 		else
; 7361 : 		{
; 7362 : 			/****************************************************************/
; 7363 : 			/*  Release the buffer.                                         */
; 7364 : 			/****************************************************************/
; 7365 : 			LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  029a8	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  029ae	50		 push	 eax

; 7366 : 		}
; 7367 : 	}
; 7368 : 	else
; 7369 : 	{
; 7370 : 		/******************************************************************/
; 7371 : 		/*  Release the buffer.                                           */
; 7372 : 		/******************************************************************/
; 7373 : 
; 7374 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  029af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  029b5	5e		 pop	 esi

; 7375 : 	}
; 7376 : 	return;
; 7377 : }

  029b6	c3		 ret	 0
$L72476:

; 7366 : 		}
; 7367 : 	}
; 7368 : 	else
; 7369 : 	{
; 7370 : 		/******************************************************************/
; 7371 : 		/*  Release the buffer.                                           */
; 7372 : 		/******************************************************************/
; 7373 : 
; 7374 : 		LeaveCriticalSection( phTTS->pcsMemoryBuffer );

  029b7	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  029bd	51		 push	 ecx
  029be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72480:
  029c4	5e		 pop	 esi

; 7375 : 	}
; 7376 : 	return;
; 7377 : }

  029c5	c3		 ret	 0
_PutPhonemeInBuffer ENDP
_phTTS$ = 8
_Speaker$ = 12
_SetSpeaker PROC NEAR

; 7407 : 	/********************************************************************/
; 7408 : 	/*  Set voice change flag for phmain.c in the PH thread.            */
; 7409 : 	/********************************************************************/
; 7410 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  029d0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 7411 : 	
; 7412 : 	pKsd_t->async_voice = Speaker;

  029d4	8b 4c 24 08	 mov	 ecx, DWORD PTR _Speaker$[esp-4]
  029d8	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  029db	89 88 3c 02 00
	00		 mov	 DWORD PTR [eax+572], ecx

; 7413 : 	pKsd_t->last_voice = (short)Speaker;

  029e1	66 89 88 20 02
	00 00		 mov	 WORD PTR [eax+544], cx

; 7414 : 	pKsd_t->async_change |= ASYNC_voice;

  029e8	83 88 38 02 00
	00 01		 or	 DWORD PTR [eax+568], 1

; 7415 : 	
; 7416 : }

  029ef	c3		 ret	 0
_SetSpeaker ENDP
_TEXT	ENDS
EXTRN	__imp___endthreadex:NEAR
EXTRN	__imp__GetMessageA@16:NEAR
EXTRN	__imp__DispatchMessageA@4:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_msg$ = -28
_TextToSpeechThreadMain@4 PROC NEAR

; 7437 : {

  029f0	83 ec 1c	 sub	 esp, 28			; 0000001cH
  029f3	56		 push	 esi

; 7438 : 	MSG msg;
; 7439 : 	
; 7440 : 	/********************************************************************/
; 7441 : 	/*  Create the TextToSpeech window.                                 */
; 7442 : 	/********************************************************************/
; 7443 : 	
; 7444 : 	phTTS->hTextToSpeechWnd = InitTextToSpeechWindow( phTTS );

  029f4	8b 74 24 24	 mov	 esi, DWORD PTR _phTTS$[esp+28]
  029f8	56		 push	 esi
  029f9	e8 00 00 00 00	 call	 _InitTextToSpeechWindow
  029fe	83 c4 04	 add	 esp, 4
  02a01	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 7445 : 	
; 7446 : 	if(phTTS->hTextToSpeechWnd == NULL)

  02a04	85 c0		 test	 eax, eax
  02a06	75 0c		 jne	 SHORT $L72493

; 7447 : 		return(MMSYSERR_ERROR);

  02a08	b8 01 00 00 00	 mov	 eax, 1
  02a0d	5e		 pop	 esi

; 7458 : }

  02a0e	83 c4 1c	 add	 esp, 28			; 0000001cH
  02a11	c2 04 00	 ret	 4
$L72493:

; 7448 : 	SetEvent(phTTS->hMallocSuccessEvent);    /*Got a hTextToSpeechWnd now */

  02a14	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  02a17	57		 push	 edi
  02a18	50		 push	 eax
  02a19	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 7449 : 	
; 7450 : 	while( GetMessage( &msg,
; 7451 : 		phTTS->hTextToSpeechWnd,
; 7452 : 		0L,
; 7453 : 		ID_TTS_Destroy ))

  02a1f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02a22	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetMessageA@16
  02a28	68 01 04 00 00	 push	 1025			; 00000401H
  02a2d	6a 00		 push	 0
  02a2f	8d 54 24 10	 lea	 edx, DWORD PTR _msg$[esp+44]
  02a33	51		 push	 ecx
  02a34	52		 push	 edx
  02a35	ff d7		 call	 edi
  02a37	85 c0		 test	 eax, eax
  02a39	74 25		 je	 SHORT $L72496
  02a3b	53		 push	 ebx
  02a3c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DispatchMessageA@4
$L72495:

; 7454 : 		DispatchMessage( &msg );

  02a42	8d 44 24 0c	 lea	 eax, DWORD PTR _msg$[esp+40]
  02a46	50		 push	 eax
  02a47	ff d3		 call	 ebx
  02a49	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02a4c	68 01 04 00 00	 push	 1025			; 00000401H
  02a51	6a 00		 push	 0
  02a53	8d 54 24 14	 lea	 edx, DWORD PTR _msg$[esp+48]
  02a57	51		 push	 ecx
  02a58	52		 push	 edx
  02a59	ff d7		 call	 edi
  02a5b	85 c0		 test	 eax, eax
  02a5d	75 e3		 jne	 SHORT $L72495
  02a5f	5b		 pop	 ebx
$L72496:

; 7455 : 	
; 7456 : 	_endthreadex(msg.wParam);

  02a60	8b 44 24 10	 mov	 eax, DWORD PTR _msg$[esp+44]
  02a64	50		 push	 eax
  02a65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___endthreadex
  02a6b	83 c4 04	 add	 esp, 4

; 7457 : 	return( FALSE );

  02a6e	33 c0		 xor	 eax, eax
  02a70	5f		 pop	 edi
  02a71	5e		 pop	 esi

; 7458 : }

  02a72	83 c4 1c	 add	 esp, 28			; 0000001cH
  02a75	c2 04 00	 ret	 4
_TextToSpeechThreadMain@4 ENDP
_TEXT	ENDS
EXTRN	__imp__LoadIconA@8:NEAR
EXTRN	__imp__RegisterClassA@4:NEAR
EXTRN	__imp__SetWindowLongA@12:NEAR
EXTRN	__imp__CreateWindowExA@48:NEAR
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__LoadCursorA@8:NEAR
_DATA	SEGMENT
	ORG $+2
$SG72506 DB	'TextToSpeechWndClass', 00H
	ORG $+3
$SG72507 DB	'%s_%08X', 00H
$SG72521 DB	'TextToSpeech Output, v1.0', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_wc$ = -296
_wndclass$ = -256
_InitTextToSpeechWindow PROC NEAR

; 7627 : {

  02a80	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  02a86	56		 push	 esi
  02a87	57		 push	 edi

; 7628 : 	WNDCLASS wc;
; 7629 : 	HWND hWnd;
; 7630 : 	HINSTANCE hInstance;
; 7631 : 	char wndclass[255];
; 7632 : 	
; 7633 : 	/********************************************************************/
; 7634 : 	/*  Register a TextToSpeech Window Class.                           */
; 7635 : 	/*  Get the hInstance for the new Window.                           */
; 7636 : 	/********************************************************************/
; 7637 : 	
; 7638 : 	// tek 13nov97 why do we think the phTTS->hWnd is anything useful??
; 7639 : 	hInstance = NULL;
; 7640 : 	//hInstance = (HINSTANCE)GetWindowLong( phTTS->hWnd,
; 7641 : 	//					GWL_HINSTANCE );
; 7642 : 	
; 7643 : 	/********************************************************************/
; 7644 : 	/*  Register a TextToSpeech window class.                           */
; 7645 : 	/********************************************************************/
; 7646 : 	
; 7647 : 	sprintf(wndclass,"%s_%08X",TEXTTOSPEECHWNDCLASS,(unsigned long int) phTTS);

  02a88	8b bc 24 34 01
	00 00		 mov	 edi, DWORD PTR _phTTS$[esp+300]
  02a8f	8d 44 24 30	 lea	 eax, DWORD PTR _wndclass$[esp+304]
  02a93	57		 push	 edi
  02a94	68 00 00 00 00	 push	 OFFSET FLAT:$SG72506
  02a99	68 00 00 00 00	 push	 OFFSET FLAT:$SG72507
  02a9e	50		 push	 eax
  02a9f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  02aa5	83 c4 10	 add	 esp, 16			; 00000010H

; 7648 : 	wc.lpszClassName = wndclass;

  02aa8	8d 4c 24 30	 lea	 ecx, DWORD PTR _wndclass$[esp+304]
  02aac	89 4c 24 2c	 mov	 DWORD PTR _wc$[esp+340], ecx

; 7649 : 	wc.lpfnWndProc =   TextToSpeechWndProc;

  02ab0	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+308], OFFSET FLAT:_TextToSpeechWndProc@16

; 7650 : 	wc.hInstance =     hInstance;
; 7651 : #ifndef UNDER_CE
; 7652 : 	wc.hCursor =       LoadCursor( 0, IDC_ARROW );

  02ab8	68 00 7f 00 00	 push	 32512			; 00007f00H
  02abd	6a 00		 push	 0
  02abf	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+328], 0
  02ac7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8

; 7653 : 	wc.hIcon =         LoadIcon( 0, IDI_APPLICATION );

  02acd	68 00 7f 00 00	 push	 32512			; 00007f00H
  02ad2	6a 00		 push	 0
  02ad4	89 44 24 28	 mov	 DWORD PTR _wc$[esp+336], eax
  02ad8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8

; 7654 : #else
; 7655 : 	wc.hCursor =       NULL;
; 7656 : 	wc.hIcon =         NULL;
; 7657 : #endif
; 7658 : 	wc.hbrBackground = (HBRUSH)( COLOR_APPWORKSPACE+1 );
; 7659 : 	wc.lpszMenuName =  NULL;
; 7660 : #ifndef UNDER_CE
; 7661 : 	wc.style =         CS_OWNDC;
; 7662 : #else
; 7663 : 	wc.style =         NULL;
; 7664 : #endif
; 7665 : 	wc.cbClsExtra =    0;
; 7666 : 	wc.cbWndExtra =    8;         /* MVP :To store phTTS through SetWindowLong */
; 7667 : 	
; 7668 : 	RegisterClass( &wc );

  02ade	8d 54 24 08	 lea	 edx, DWORD PTR _wc$[esp+304]
  02ae2	89 44 24 1c	 mov	 DWORD PTR _wc$[esp+324], eax
  02ae6	52		 push	 edx
  02ae7	c7 44 24 28 0d
	00 00 00	 mov	 DWORD PTR _wc$[esp+336], 13 ; 0000000dH
  02aef	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+340], 0
  02af7	c7 44 24 0c 20
	00 00 00	 mov	 DWORD PTR _wc$[esp+308], 32 ; 00000020H
  02aff	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _wc$[esp+316], 0
  02b07	c7 44 24 18 08
	00 00 00	 mov	 DWORD PTR _wc$[esp+320], 8
  02b0f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4

; 7669 : 	
; 7670 : 	/********************************************************************/
; 7671 : 	/*  Create an Invisible TextToSpeech Window.                        */
; 7672 : 	/********************************************************************/
; 7673 : 	
; 7674 : #ifndef UNDER_CE
; 7675 : 	hWnd = CreateWindow( wndclass,
; 7676 : 		"TextToSpeech Output, v1.0",
; 7677 : 		WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW,
; 7678 : 		CW_USEDEFAULT,
; 7679 : 		CW_USEDEFAULT,
; 7680 : 		CW_USEDEFAULT,
; 7681 : 		CW_USEDEFAULT,
; 7682 : 		0,
; 7683 : 		0,
; 7684 : 		hInstance,
; 7685 : 		NULL);      /*MVP : was (LPVOID)phTTS ,This is changed to avoid

  02b15	6a 00		 push	 0
  02b17	6a 00		 push	 0
  02b19	6a 00		 push	 0
  02b1b	6a 00		 push	 0
  02b1d	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02b22	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02b27	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02b2c	68 00 00 00 80	 push	 -2147483648		; 80000000H
  02b31	68 00 00 cf 02	 push	 47120384		; 02cf0000H
  02b36	8d 44 24 54	 lea	 eax, DWORD PTR _wndclass$[esp+340]
  02b3a	68 00 00 00 00	 push	 OFFSET FLAT:$SG72521
  02b3f	50		 push	 eax
  02b40	6a 00		 push	 0
  02b42	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  02b48	8b f0		 mov	 esi, eax

; 7686 : 					static declaration of this handle in TextToSpeechWndProc
; 7687 : 					Now this handle will be available through call to
; 7688 : 	GetWindowLong */
; 7689 : #else
; 7690 : 	hWnd = CreateWindow( wndclass,
; 7691 : 		"TextToSpeech Output, v1.0",
; 7692 : 		WS_CLIPCHILDREN | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
; 7693 : 		CW_USEDEFAULT,
; 7694 : 		CW_USEDEFAULT,
; 7695 : 		CW_USEDEFAULT,
; 7696 : 		CW_USEDEFAULT,
; 7697 : 		0,
; 7698 : 		0,
; 7699 : 		hInstance,
; 7700 : 		NULL);      /*MVP : was (LPVOID)phTTS ,This is changed to avoid
; 7701 : 					static declaration of this handle in TextToSpeechWndProc
; 7702 : 					Now this handle will be available through call to
; 7703 : 	GetWindowLong */
; 7704 : #endif
; 7705 : 	
; 7706 : 	if( ! hWnd )

  02b4a	85 f6		 test	 esi, esi
  02b4c	75 09		 jne	 SHORT $L72522
  02b4e	5f		 pop	 edi
  02b4f	5e		 pop	 esi

; 7715 : }

  02b50	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  02b56	c3		 ret	 0
$L72522:

; 7707 : 		return( NULL );
; 7708 : 	
; 7709 : 	/*MVP : Store phTTS in Window extra memory for later use in Wndproc */
; 7710 : 	SetWindowLong(hWnd,GWL_USERDATA,(LONG)phTTS);

  02b57	57		 push	 edi
  02b58	6a eb		 push	 -21			; ffffffebH
  02b5a	56		 push	 esi
  02b5b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 7711 : 	
; 7712 : 	ShowWindow( hWnd, SW_HIDE );

  02b61	6a 00		 push	 0
  02b63	56		 push	 esi
  02b64	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 7713 : 	
; 7714 : 	return( hWnd );

  02b6a	8b c6		 mov	 eax, esi
  02b6c	5f		 pop	 edi
  02b6d	5e		 pop	 esi

; 7715 : }

  02b6e	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  02b74	c3		 ret	 0
_InitTextToSpeechWindow ENDP
_TEXT	ENDS
EXTRN	__imp__DefWindowProcA@16:NEAR
EXTRN	__imp__PostQuitMessage@4:NEAR
EXTRN	__imp__GetWindowLongA@8:NEAR
EXTRN	__imp__DestroyWindow@4:NEAR
_TEXT	SEGMENT
_hWnd$ = 8
_message$ = 12
_wParam$ = 16
_lParam$ = 20
_TextToSpeechWndProc@16 PROC NEAR

; 7733 : {

  02b80	56		 push	 esi
  02b81	57		 push	 edi

; 7734 : 	
; 7735 : LPTTS_HANDLE_T phTTS;                    /* MVP : Avoided static behaviour through
; 7736 : 										 using GetWindowLong to retrieve the handle 
; 7737 : 										 from window extra memory,which was set
; 7738 : when window was created */
; 7739 : 
; 7740 : phTTS = (LPTTS_HANDLE_T)GetWindowLong(hWnd,GWL_USERDATA);

  02b82	8b 7c 24 0c	 mov	 edi, DWORD PTR _hWnd$[esp+4]
  02b86	6a eb		 push	 -21			; ffffffebH
  02b88	57		 push	 edi
  02b89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8

; 7741 : 
; 7742 : switch( message )
; 7743 : {

  02b8f	8b 74 24 10	 mov	 esi, DWORD PTR _message$[esp+4]
  02b93	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  02b99	77 33		 ja	 SHORT $L73282
  02b9b	74 19		 je	 SHORT $L72541
  02b9d	8b c6		 mov	 eax, esi
  02b9f	48		 dec	 eax
  02ba0	74 0d		 je	 SHORT $L72540
  02ba2	48		 dec	 eax
  02ba3	75 38		 jne	 SHORT $L72537

; 7767 : 	
; 7768 : case ID_TTS_Destroy:
; 7769 : 	
; 7770 : 	DestroyWindow( hWnd );
; 7771 : 	
; 7772 : 	break;
; 7773 : 	
; 7774 : 	/********************************************************************/
; 7775 : 	/*  The WM_DESTROY message is used to destroy a window.             */
; 7776 : 	/********************************************************************/
; 7777 : 	
; 7778 : case WM_DESTROY:
; 7779 : 	
; 7780 : 	PostQuitMessage(0);

  02ba5	6a 00		 push	 0
  02ba7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 7781 : 	
; 7782 : 	break;

  02bad	eb 2e		 jmp	 SHORT $L72537
$L72540:
  02baf	5f		 pop	 edi

; 7744 : 	/********************************************************************/
; 7745 : 	/*  TextToSpeech intialization occurs here.                         */
; 7746 : 	/********************************************************************/
; 7747 : 	
; 7748 : case WM_CREATE:
; 7749 : 	
; 7750 : 	/******************************************************************/
; 7751 : 	/*  Initialize pointer to the TextToSpeech parameter structure.   */
; 7752 : 	/******************************************************************/
; 7753 : 	/*MVP : Commented out, Value is retreived Through GetWindowLong */
; 7754 : 	/*phTTS = (LPTTS_HANDLE_T)(((LPCREATESTRUCT)lParam)->lpCreateParams);*/
; 7755 : 	
; 7756 : 	return( FALSE );

  02bb0	33 c0		 xor	 eax, eax
  02bb2	5e		 pop	 esi

; 7788 : }

  02bb3	c2 10 00	 ret	 16			; 00000010H
$L72541:

; 7757 : 	
; 7758 : 	/********************************************************************/
; 7759 : 	/*  Process the TextToSpeech message.                               */
; 7760 : 	/********************************************************************/
; 7761 : 	
; 7762 : case ID_TTS_Queue_Text:
; 7763 : 	
; 7764 : 	Process_TTS_Message( phTTS, lParam );

  02bb6	8b 4c 24 18	 mov	 ecx, DWORD PTR _lParam$[esp+4]
  02bba	51		 push	 ecx
  02bbb	50		 push	 eax
  02bbc	e8 00 00 00 00	 call	 _Process_TTS_Message
  02bc1	83 c4 08	 add	 esp, 8

; 7765 : 	
; 7766 : 	return( TRUE );

  02bc4	b8 01 00 00 00	 mov	 eax, 1
  02bc9	5f		 pop	 edi
  02bca	5e		 pop	 esi

; 7788 : }

  02bcb	c2 10 00	 ret	 16			; 00000010H
$L73282:

; 7741 : 
; 7742 : switch( message )
; 7743 : {

  02bce	81 fe 01 04 00
	00		 cmp	 esi, 1025		; 00000401H

; 7783 : 	
; 7784 : default:
; 7785 : 	break;

  02bd4	75 07		 jne	 SHORT $L72537
  02bd6	57		 push	 edi
  02bd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$L72537:

; 7786 : }
; 7787 : return( DefWindowProc( hWnd, message, wParam, lParam ));

  02bdd	8b 54 24 18	 mov	 edx, DWORD PTR _lParam$[esp+4]
  02be1	8b 44 24 14	 mov	 eax, DWORD PTR _wParam$[esp+4]
  02be5	52		 push	 edx
  02be6	50		 push	 eax
  02be7	56		 push	 esi
  02be8	57		 push	 edi
  02be9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  02bef	5f		 pop	 edi
  02bf0	5e		 pop	 esi

; 7788 : }

  02bf1	c2 10 00	 ret	 16			; 00000010H
_TextToSpeechWndProc@16 ENDP
_phTTS$ = 8
_lParam$ = 12
_Process_TTS_Message PROC NEAR

; 7820 : {

  02c00	53		 push	 ebx
  02c01	55		 push	 ebp
  02c02	56		 push	 esi

; 7821 : 	UINT uiLength;
; 7822 : 	unsigned char * pText;
; 7823 : 	TEXT_MSG_T * pTextMsg;
; 7824 : 	
; 7825 : 	pTextMsg = (TEXT_MSG_T *)lParam;
; 7826 : 	//OutputDebugString("	Process_TTS_Message().\n");
; 7827 : #ifdef API_DEBUG //tek 12aug97
; 7828 : 	{
; 7829 : 		char szTemp[256]="";
; 7830 : 		sprintf(szTemp,"Process_TTS_Message #%u at %lu\n",
; 7831 : 			pTextMsg->uiMsgNumber,
; 7832 : 			timeGetTime());
; 7833 : 		OutputDebugString(szTemp);
; 7834 : 	}
; 7835 : #endif //API_DEBUG
; 7836 : 	
; 7837 : 	/********************************************************************/
; 7838 : 	/*  If the posted Text-To-Speech message number is less than the    */
; 7839 : 	/*  message number of the last flush message, then throw the        */
; 7840 : 	/*  Text-To-Speech message away.                                    */
; 7841 : 	/********************************************************************/
; 7842 : 	
; 7843 : 	EnterCriticalSection( phTTS->pcsFlushMsgNumber );

  02c03	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  02c07	57		 push	 edi
  02c08	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  02c0e	50		 push	 eax
  02c0f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7844 : 	
; 7845 : 	if ( pTextMsg->uiMsgNumber > phTTS->uiFlushMsgNumber )

  02c15	8b 5c 24 18	 mov	 ebx, DWORD PTR _lParam$[esp+12]
  02c19	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  02c1c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02c1e	3b c8		 cmp	 ecx, eax
  02c20	76 6f		 jbe	 SHORT $L72554

; 7846 : 	{
; 7847 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  02c22	8b 96 bc 00 00
	00		 mov	 edx, DWORD PTR [esi+188]
  02c28	52		 push	 edx
  02c29	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7848 : #ifdef API_DEBUG
; 7849 : 		OutputDebugString("  .. TTSMessage processing.\n");
; 7850 : #endif //API_DEBUG
; 7851 : 		uiLength = pTextMsg->uiLength;

  02c2f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 7852 : #ifdef TYPING_MODE // tek 17jun97
; 7853 : 		if (uiLength>0)

  02c32	85 ff		 test	 edi, edi
  02c34	76 0a		 jbe	 SHORT $L72555

; 7854 : 			phTTS->bInTypingMode = FALSE;

  02c36	c7 86 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+212], 0
$L72555:

; 7855 : #endif //TYPING_MODE
; 7856 : 		pText = pTextMsg->pText;

  02c40	8b 6b 08	 mov	 ebp, DWORD PTR [ebx+8]

; 7857 : 		
; 7858 : 		/******************************************************************/
; 7859 : 		/*  Queue the text unless a TextToSpeechReset() forces an abort   */
; 7860 : 		/*  by setting the KS.halting flag.                               */
; 7861 : 		/******************************************************************/
; 7862 : 		/* we have to check for halting inside the loop, else we will hang */
; 7863 : 		/* if we have a lot of text to speak. We should probably also block*/
; 7864 : 		/* here, rather than in write_pipe(), on the pipe full condition, */
; 7865 : 		/* but that's probably chrome.. it would let us respond to a flush*/
; 7866 : 		/* a little faster. (tek 08jan97) */
; 7867 : 		
; 7868 : 		while (( uiLength > MAX_TEXT_WRITE_LENGTH ) 
; 7869 : 			&& ( ! (phTTS->pKernelShareData->halting))   // tek 08jan97
; 7870 : 			//      && ( ! (phTTS->pKernelShareData->halting))
; 7871 : 			)

  02c43	83 ff 10	 cmp	 edi, 16			; 00000010H
  02c46	76 2a		 jbe	 SHORT $L72558
$L72557:
  02c48	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02c4b	8b 88 74 01 00
	00		 mov	 ecx, DWORD PTR [eax+372]
  02c51	85 c9		 test	 ecx, ecx
  02c53	75 1d		 jne	 SHORT $L72558

; 7872 : 		{
; 7873 : 			//OutputDebugString(" .. text to write_pipe \n");
; 7874 : 			write_pipe( phTTS->pKernelShareData->cmd_pipe, pText, MAX_TEXT_WRITE_LENGTH );

  02c55	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [eax+216]
  02c5b	6a 10		 push	 16			; 00000010H
  02c5d	55		 push	 ebp
  02c5e	50		 push	 eax
  02c5f	e8 00 00 00 00	 call	 _write_pipe

; 7875 : 			uiLength -= MAX_TEXT_WRITE_LENGTH;

  02c64	83 ef 10	 sub	 edi, 16			; 00000010H
  02c67	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7876 : 			pText += MAX_TEXT_WRITE_LENGTH;

  02c6a	83 c5 10	 add	 ebp, 16			; 00000010H
  02c6d	83 ff 10	 cmp	 edi, 16			; 00000010H
  02c70	77 d6		 ja	 SHORT $L72557
$L72558:

; 7877 : 		}
; 7878 : 		
; 7879 : 		if (( uiLength > 0 ) 
; 7880 : 			&& (uiLength <= MAX_TEXT_WRITE_LENGTH)	/* tek 08jan97 */
; 7881 : 			//      && ( ! phTTS->pKernelShareData->halting )
; 7882 : 			)

  02c72	85 ff		 test	 edi, edi
  02c74	76 28		 jbe	 SHORT $L72560
  02c76	83 ff 10	 cmp	 edi, 16			; 00000010H
  02c79	77 23		 ja	 SHORT $L72560

; 7883 : 		{
; 7884 : 			//OutputDebugString(" .. .. Text to write_pipe \n");
; 7885 : 			write_pipe( phTTS->pKernelShareData->cmd_pipe, pText, uiLength );

  02c7b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  02c7e	57		 push	 edi
  02c7f	55		 push	 ebp
  02c80	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [ecx+216]
  02c86	52		 push	 edx
  02c87	e8 00 00 00 00	 call	 _write_pipe
  02c8c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7886 : 		}
; 7887 : 	}
; 7888 : 	else

  02c8f	eb 0d		 jmp	 SHORT $L72560
$L72554:

; 7889 : 	{
; 7890 : #ifdef API_DEBUG
; 7891 : 		OutputDebugString(" .. tossing textmsg due to flush.\n");
; 7892 : #endif //API_DEBUG
; 7893 : 		LeaveCriticalSection( phTTS->pcsFlushMsgNumber );

  02c91	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  02c97	50		 push	 eax
  02c98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L72560:

; 7894 : 	}
; 7895 : 	
; 7896 : 	/********************************************************************/
; 7897 : 	/*  Subtract the characters queued from the queued character count. */
; 7898 : 	/********************************************************************/
; 7899 : 	
; 7900 : 	EnterCriticalSection( phTTS->pcsQueuedCharacterCount );

  02c9e	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  02ca4	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__EnterCriticalSection@4
  02caa	51		 push	 ecx
  02cab	ff d5		 call	 ebp

; 7901 : 	phTTS->uiQueuedCharacterCount -= pTextMsg->uiLength;

  02cad	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  02cb0	8b 7e 40	 mov	 edi, DWORD PTR [esi+64]

; 7902 : 	LeaveCriticalSection( phTTS->pcsQueuedCharacterCount );

  02cb3	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  02cb9	2b fa		 sub	 edi, edx
  02cbb	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  02cbe	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LeaveCriticalSection@4
  02cc4	50		 push	 eax
  02cc5	ff d7		 call	 edi

; 7903 : 	
; 7904 : 	/********************************************************************/
; 7905 : 	/*  Update the last queued message parameter for the                */
; 7906 : 	/*  TextToSpeechSync() function.                                    */
; 7907 : 	/********************************************************************/
; 7908 : 	
; 7909 : 	EnterCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  02cc7	8b 8e b8 00 00
	00		 mov	 ecx, DWORD PTR [esi+184]
  02ccd	51		 push	 ecx
  02cce	ff d5		 call	 ebp

; 7910 : 	phTTS->uiLastQueuedTextMsgNumber = pTextMsg->uiMsgNumber;
; 7911 : 	LeaveCriticalSection( phTTS->pcsLastQueuedTextMsgNumber );

  02cd0	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  02cd6	8b 13		 mov	 edx, DWORD PTR [ebx]
  02cd8	50		 push	 eax
  02cd9	89 56 4c	 mov	 DWORD PTR [esi+76], edx
  02cdc	ff d7		 call	 edi

; 7912 : 	
; 7913 : 	/********************************************************************/
; 7914 : 	/*  Free the text buffer and the text message structure.            */
; 7915 : 	/*  These were allocated in the TextToSpeechSpeak() function which  */
; 7916 : 	/*  runs in the applications thread !                               */
; 7917 : 	/********************************************************************/
; 7918 : 	
; 7919 : 	free( pTextMsg->pText );

  02cde	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  02ce1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  02ce7	51		 push	 ecx
  02ce8	ff d6		 call	 esi

; 7920 : 	free( pTextMsg );

  02cea	53		 push	 ebx
  02ceb	ff d6		 call	 esi
  02ced	83 c4 08	 add	 esp, 8
  02cf0	5f		 pop	 edi
  02cf1	5e		 pop	 esi
  02cf2	5d		 pop	 ebp
  02cf3	5b		 pop	 ebx

; 7921 : 	
; 7922 : 	return;
; 7923 : }

  02cf4	c3		 ret	 0
_Process_TTS_Message ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechErrorHandler
_TEXT	SEGMENT
_phTTS$ = 8
_uiErrorCode$ = 12
_mmStatus$ = 16
_TextToSpeechErrorHandler PROC NEAR

; 7960 : 	if ( phTTS->bEnableErrorMessage )

  02d00	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  02d04	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  02d0a	85 c9		 test	 ecx, ecx
  02d0c	74 21		 je	 SHORT $L72568

; 7961 : 	{
; 7962 : 		phTTS->bEnableErrorMessage = FALSE;
; 7963 : 		/*
; 7964 : 		SendMessage( phTTS->hWnd,
; 7965 : 		phTTS->uiID_Error_Message,
; 7966 : 		(WPARAM)uiErrorCode,
; 7967 : 		(LPARAM)mmStatus );
; 7968 : 		*/
; 7969 : 		//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code:
; 7970 : #ifdef API_DEBUG
; 7971 : 		OutputDebugString("returning error message. \n");
; 7972 : #endif //API_DEBUG
; 7973 : 		Report_TTS_Status(phTTS,phTTS->uiID_Error_Message,(WPARAM)uiErrorCode,(LPARAM)mmStatus);

  02d0e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _mmStatus$[esp-4]
  02d12	8b 54 24 08	 mov	 edx, DWORD PTR _uiErrorCode$[esp-4]
  02d16	51		 push	 ecx
  02d17	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  02d1a	52		 push	 edx
  02d1b	51		 push	 ecx
  02d1c	50		 push	 eax
  02d1d	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], 0
  02d27	e8 00 00 00 00	 call	 _Report_TTS_Status
  02d2c	83 c4 10	 add	 esp, 16			; 00000010H
$L72568:

; 7974 : 		
; 7975 : 	}
; 7976 : 	return;
; 7977 : }

  02d2f	c3		 ret	 0
_TextToSpeechErrorHandler ENDP
_TEXT	ENDS
PUBLIC	_WriteAudioToFile
_TEXT	SEGMENT
_phTTS$ = 8
_pBuffer$ = 12
_uiLength$ = 16
_WriteAudioToFile PROC NEAR

; 8045 : {

  02d30	53		 push	 ebx

; 8046 : 	UINT i;
; 8047 : 	unsigned char * pByteDest;
; 8048 : 	LPSAMPLE_T pSource;
; 8049 : 	size_t Size;
; 8050 : 	
; 8051 : 	/********************************************************************/
; 8052 : 	/*  Convert the 16 bit samples to the desired output format.        */
; 8053 : 	/********************************************************************/
; 8054 : 	
; 8055 : 	switch( phTTS->dwFormat )
; 8056 : 	{

  02d31	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  02d35	55		 push	 ebp
  02d36	8b 6c 24 14	 mov	 ebp, DWORD PTR _uiLength$[esp+4]
  02d3a	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [ebx+128]
  02d40	56		 push	 esi
  02d41	48		 dec	 eax
  02d42	74 48		 je	 SHORT $L72589
  02d44	83 e8 03	 sub	 eax, 3
  02d47	74 3c		 je	 SHORT $L72587
  02d49	83 e8 03	 sub	 eax, 3
  02d4c	74 09		 je	 SHORT $L72596
  02d4e	5e		 pop	 esi
  02d4f	5d		 pop	 ebp

; 8086 : 		
; 8087 : 	default:
; 8088 : 		
; 8089 : 		return( MMSYSERR_INVALHANDLE );

  02d50	b8 05 00 00 00	 mov	 eax, 5
  02d55	5b		 pop	 ebx

; 8105 : }

  02d56	c3		 ret	 0
$L72596:

; 8072 : 		
; 8073 : 		break;
; 8074 : 		
; 8075 : 	case WAVE_FORMAT_08M08:
; 8076 : 		
; 8077 : 		pSource = pBuffer;

  02d57	8b 74 24 14	 mov	 esi, DWORD PTR _pBuffer$[esp+8]
  02d5b	57		 push	 edi

; 8078 : 		pByteDest = (unsigned char *)pBuffer;
; 8079 : 		
; 8080 : 		for ( i = 0; i < uiLength; i++ )

  02d5c	85 ed		 test	 ebp, ebp
  02d5e	8b fe		 mov	 edi, esi
  02d60	76 1b		 jbe	 SHORT $L72600

; 8072 : 		
; 8073 : 		break;
; 8074 : 		
; 8075 : 	case WAVE_FORMAT_08M08:
; 8076 : 		
; 8077 : 		pSource = pBuffer;

  02d62	8b dd		 mov	 ebx, ebp
$L72598:

; 8081 : 			*pByteDest++ = LinearToMuLaw( *pSource++ );

  02d64	66 8b 06	 mov	 ax, WORD PTR [esi]
  02d67	83 c6 02	 add	 esi, 2
  02d6a	50		 push	 eax
  02d6b	e8 00 00 00 00	 call	 _LinearToMuLaw
  02d70	83 c4 04	 add	 esp, 4
  02d73	88 07		 mov	 BYTE PTR [edi], al
  02d75	47		 inc	 edi
  02d76	4b		 dec	 ebx
  02d77	75 eb		 jne	 SHORT $L72598

; 8078 : 		pByteDest = (unsigned char *)pBuffer;
; 8079 : 		
; 8080 : 		for ( i = 0; i < uiLength; i++ )

  02d79	8b 5c 24 14	 mov	 ebx, DWORD PTR _phTTS$[esp+12]
$L72600:

; 8082 : 		
; 8083 : 		Size = sizeof( unsigned char );

  02d7d	b8 01 00 00 00	 mov	 eax, 1
  02d82	5f		 pop	 edi

; 8084 : 		
; 8085 : 		break;

  02d83	eb 2a		 jmp	 SHORT $L72584
$L72587:

; 8057 : 	case WAVE_FORMAT_1M16:
; 8058 : 		
; 8059 : 		Size = sizeof( short );

  02d85	b8 02 00 00 00	 mov	 eax, 2

; 8060 : 		
; 8061 : 		break;

  02d8a	eb 23		 jmp	 SHORT $L72584
$L72589:

; 8062 : 		
; 8063 : 	case WAVE_FORMAT_1M08:
; 8064 : 		
; 8065 : 		pSource = pBuffer;

  02d8c	8b 44 24 14	 mov	 eax, DWORD PTR _pBuffer$[esp+8]

; 8066 : 		pByteDest = (unsigned char *)pBuffer;
; 8067 : 		
; 8068 : 		for ( i = 0; i < uiLength; i++ )

  02d90	85 ed		 test	 ebp, ebp
  02d92	8b c8		 mov	 ecx, eax
  02d94	76 14		 jbe	 SHORT $L72593

; 8062 : 		
; 8063 : 	case WAVE_FORMAT_1M08:
; 8064 : 		
; 8065 : 		pSource = pBuffer;

  02d96	8b f5		 mov	 esi, ebp
$L72591:

; 8069 : 			*pByteDest++ = ((unsigned char)((*pSource++) >> 8)) ^ 0x80;

  02d98	66 8b 11	 mov	 dx, WORD PTR [ecx]
  02d9b	83 c1 02	 add	 ecx, 2
  02d9e	c1 fa 08	 sar	 edx, 8
  02da1	80 f2 80	 xor	 dl, 128			; 00000080H
  02da4	88 10		 mov	 BYTE PTR [eax], dl
  02da6	40		 inc	 eax
  02da7	4e		 dec	 esi
  02da8	75 ee		 jne	 SHORT $L72591
$L72593:

; 8070 : 		
; 8071 : 		Size = sizeof( unsigned char );

  02daa	b8 01 00 00 00	 mov	 eax, 1
$L72584:

; 8090 : 	}
; 8091 : 	
; 8092 : 	/********************************************************************/
; 8093 : 	/*  Write the audio samples to the output file.                     */
; 8094 : 	/********************************************************************/
; 8095 : 	
; 8096 : 	if ( uiLength != fwrite( (char *)pBuffer,
; 8097 : 		Size,
; 8098 : 		(size_t)uiLength,
; 8099 : 		phTTS->pWaveFile ))

  02daf	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [ebx+148]
  02db5	8b 54 24 14	 mov	 edx, DWORD PTR _pBuffer$[esp+8]
  02db9	51		 push	 ecx
  02dba	55		 push	 ebp
  02dbb	50		 push	 eax
  02dbc	52		 push	 edx
  02dbd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  02dc3	83 c4 10	 add	 esp, 16			; 00000010H
  02dc6	3b e8		 cmp	 ebp, eax
  02dc8	74 09		 je	 SHORT $L72605
  02dca	5e		 pop	 esi
  02dcb	5d		 pop	 ebp

; 8100 : 		return( MMSYSERR_ERROR );

  02dcc	b8 01 00 00 00	 mov	 eax, 1
  02dd1	5b		 pop	 ebx

; 8105 : }

  02dd2	c3		 ret	 0
$L72605:

; 8101 : 	
; 8102 : 	phTTS->dwFileSampleCount += uiLength;

  02dd3	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  02dd6	5e		 pop	 esi
  02dd7	03 c5		 add	 eax, ebp
  02dd9	5d		 pop	 ebp
  02dda	89 43 78	 mov	 DWORD PTR [ebx+120], eax

; 8103 : 	
; 8104 : 	return( MMSYSERR_NOERROR );

  02ddd	33 c0		 xor	 eax, eax
  02ddf	5b		 pop	 ebx

; 8105 : }

  02de0	c3		 ret	 0
_WriteAudioToFile ENDP
_wSample$ = 8
_LinearToMuLaw PROC NEAR

; 8144 : 	static short wExponentLut[256] = { 0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
; 8145 : 		4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
; 8146 : 		5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
; 8147 : 		5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
; 8148 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 8149 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 8150 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 8151 : 		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
; 8152 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8153 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8154 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8155 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8156 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8157 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8158 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
; 8159 : 		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 };
; 8160 : 	short wSign;
; 8161 : 	short wExponent;
; 8162 : 	short wMantissa;
; 8163 : 	unsigned char cMuLawByte;
; 8164 : 	
; 8165 : 	/********************************************************************/
; 8166 : 	/*  Get the sample into sign-magnitude.                             */
; 8167 : 	/*  First save the sign.                                            */
; 8168 : 	/********************************************************************/
; 8169 : 	
; 8170 : 	wSign = ( wSample >> 8 ) & 0x80;

  02df0	8b 44 24 04	 mov	 eax, DWORD PTR _wSample$[esp-4]
  02df4	53		 push	 ebx
  02df5	8b d8		 mov	 ebx, eax
  02df7	c1 fb 08	 sar	 ebx, 8
  02dfa	81 e3 80 00 00
	00		 and	 ebx, 128		; 00000080H

; 8171 : 	
; 8172 : 	/********************************************************************/
; 8173 : 	/*  Get magnitude.                                                  */
; 8174 : 	/********************************************************************/
; 8175 : 	
; 8176 : 	if ( wSign != 0 )

  02e00	66 85 db	 test	 bx, bx
  02e03	74 02		 je	 SHORT $L72615

; 8177 : 		wSample = - wSample;

  02e05	f7 d8		 neg	 eax
$L72615:

; 8178 : 	
; 8179 : 	/********************************************************************/
; 8180 : 	/*  Clip the magnitude.                                             */
; 8181 : 	/********************************************************************/
; 8182 : 	
; 8183 : 	if ( wSample > MULAW_CLIP_LEVEL )

  02e07	66 3d 7b 7f	 cmp	 ax, 32635		; 00007f7bH
  02e0b	7e 05		 jle	 SHORT $L72616

; 8184 : 		wSample = MULAW_CLIP_LEVEL;

  02e0d	b8 7b 7f 00 00	 mov	 eax, 32635		; 00007f7bH
$L72616:

; 8185 : 	
; 8186 : 	/********************************************************************/
; 8187 : 	/*  Convert from 16 bit linear to mu-law.                           */
; 8188 : 	/********************************************************************/
; 8189 : 	
; 8190 : 	wSample = wSample + MULAW_BIAS;

  02e12	05 84 00 00 00	 add	 eax, 132		; 00000084H

; 8191 : 	wExponent = wExponentLut[ ( wSample >> 7 ) & 0xFF ];

  02e17	8b c8		 mov	 ecx, eax
  02e19	c1 f9 07	 sar	 ecx, 7
  02e1c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02e22	66 8b 14 4d 00
	00 00 00	 mov	 dx, WORD PTR _?wExponentLut@?1??LinearToMuLaw@@9@9[ecx*2]

; 8192 : 	wMantissa = ( wSample >> ( wExponent + 3 ) ) & 0x0F;

  02e2a	66 8b ca	 mov	 cx, dx
  02e2d	66 83 c1 03	 add	 cx, 3
  02e31	66 d3 f8	 sar	 ax, cl

; 8193 : 	cMuLawByte = ~ ( wSign | ( wExponent << 4 ) | wMantissa );

  02e34	c0 e2 04	 shl	 dl, 4
  02e37	24 0f		 and	 al, 15			; 0000000fH

; 8194 : 	
; 8195 : 	/********************************************************************/
; 8196 : 	/*  Optional CCITT trap                                             */
; 8197 : 	/********************************************************************/
; 8198 : 	
; 8199 : #ifdef ZEROTRAP
; 8200 : 	if ( cMuLawByte == 0 )
; 8201 : 		cMuLawByte = 0x02;
; 8202 : #endif //ZEROTRAP
; 8203 : 	
; 8204 : 	return( cMuLawByte );

  02e39	0a c2		 or	 al, dl
  02e3b	0a c3		 or	 al, bl
  02e3d	5b		 pop	 ebx
  02e3e	f6 d0		 not	 al

; 8205 : }

  02e40	c3		 ret	 0
_LinearToMuLaw ENDP
_TEXT	ENDS
PUBLIC	_WaitForLtsFlush
_TEXT	SEGMENT
_phTTS$ = 8
_dwWaitTimeInMsec$ = 12
_uiPhCount$ = -4
_uiLtsCount$ = -4
_dwTotalTimeInMsec$ = -8
_WaitForLtsFlush PROC NEAR

; 8249 : {

  02e50	83 ec 08	 sub	 esp, 8

; 8250 : 	BOOL bPipesNotEmpty;
; 8251 : 	UINT uiSyncCount;
; 8252 : 	UINT uiVtmCount;
; 8253 : 	UINT uiPhCount;
; 8254 : 	UINT uiLtsCount;
; 8255 : #ifdef WIN32
; 8256 : 	UINT	uiSleepTime;
; 8257 : #endif
; 8258 : 	DWORD dwTotalTimeInMsec;
; 8259 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 8260 : 	* and initialize from phTTS structure
; 8261 : 	*/
; 8262 : 	PKSD_T pKsd_t = NULL;
; 8263 : 	
; 8264 : 	pKsd_t = phTTS->pKernelShareData;

  02e53	8b 44 24 0c	 mov	 eax, DWORD PTR _phTTS$[esp+4]
  02e57	53		 push	 ebx
  02e58	55		 push	 ebp
  02e59	56		 push	 esi
  02e5a	57		 push	 edi

; 8265 : #ifdef TYPING_MODE
; 8266 : 	if (phTTS->bInTypingMode)

  02e5b	8b b8 d4 00 00
	00		 mov	 edi, DWORD PTR [eax+212]
  02e61	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 8267 : 		uiSleepTime=1; // just reschedule
; 8268 : 	else
; 8269 : #endif //TYPING_MODE
; 8270 : #ifdef WIN32
; 8271 : 		uiSleepTime=WAIT_PIPE_SLEEP_TIME;
; 8272 : #endif
; 8273 : 	/********************************************************************/
; 8274 : 	/*  Wait for all the pipes to empty.                                */
; 8275 : 	/*  If the pipes are not empty then sleep for 100 msec. and check   */
; 8276 : 	/*  them again.                                                     */
; 8277 : 	/********************************************************************/
; 8278 : 	
; 8279 : 	dwTotalTimeInMsec = 0;

  02e64	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+24], 0
  02e6c	f7 df		 neg	 edi
  02e6e	1b ff		 sbb	 edi, edi
  02e70	83 e7 fc	 and	 edi, -4			; fffffffcH
  02e73	83 c7 05	 add	 edi, 5
$L72634:

; 8280 : 	bPipesNotEmpty = TRUE;
; 8281 : 	
; 8282 : 	while ( bPipesNotEmpty )
; 8283 : 	{
; 8284 : 		bPipesNotEmpty = FALSE;
; 8285 : 		
; 8286 : 		uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  02e76	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  02e7c	50		 push	 eax
  02e7d	e8 00 00 00 00	 call	 _pipe_count

; 8287 : 		uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  02e82	8b 8e dc 00 00
	00		 mov	 ecx, DWORD PTR [esi+220]
  02e88	8b d8		 mov	 ebx, eax
  02e8a	51		 push	 ecx
  02e8b	e8 00 00 00 00	 call	 _pipe_count

; 8288 : 		uiPhCount = pipe_count( pKsd_t->ph_pipe );

  02e90	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  02e96	8b e8		 mov	 ebp, eax
  02e98	52		 push	 edx
  02e99	e8 00 00 00 00	 call	 _pipe_count
  02e9e	89 44 24 20	 mov	 DWORD PTR _uiPhCount$[esp+36], eax

; 8289 : 		uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  02ea2	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  02ea8	50		 push	 eax
  02ea9	e8 00 00 00 00	 call	 _pipe_count
  02eae	83 c4 10	 add	 esp, 16			; 00000010H

; 8290 : 		
; 8291 : 		if  (( uiSyncCount != 0 )
; 8292 : 			|| ( uiVtmCount != 0 )
; 8293 : 			|| ( uiPhCount != 0 )
; 8294 : 			|| ( uiLtsCount != 0 ))

  02eb1	85 db		 test	 ebx, ebx
  02eb3	75 5f		 jne	 SHORT $L72640
  02eb5	85 ed		 test	 ebp, ebp
  02eb7	75 5b		 jne	 SHORT $L72640
  02eb9	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiPhCount$[esp+24]
  02ebd	85 c9		 test	 ecx, ecx
  02ebf	75 53		 jne	 SHORT $L72640
  02ec1	85 c0		 test	 eax, eax

; 8295 : 			bPipesNotEmpty = TRUE;
; 8296 : 		
; 8297 : 		/******************************************************************/
; 8298 : 		/*  If bPipesNotEmpty is still FALSE here then the pipes are      */
; 8299 : 		/*  probably empty. It is possible that there is still data in    */
; 8300 : 		/*  the pipes, but that it moved out of a pipe we are about to    */
; 8301 : 		/*  check into a pipe we have we just checked. We now check the   */
; 8302 : 		/*  pipes in the reverse order.                                   */
; 8303 : 		/******************************************************************/
; 8304 : 		
; 8305 : 		if ( ! bPipesNotEmpty )

  02ec3	75 4f		 jne	 SHORT $L72640

; 8306 : 		{
; 8307 : 		/*
; 8308 : 		kernel_disable(pKsd_t);
; 8309 : 			*/
; 8310 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  02ec5	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  02ecb	51		 push	 ecx
  02ecc	e8 00 00 00 00	 call	 _pipe_count

; 8311 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  02ed1	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  02ed7	89 44 24 18	 mov	 DWORD PTR _uiLtsCount$[esp+28], eax
  02edb	52		 push	 edx
  02edc	e8 00 00 00 00	 call	 _pipe_count
  02ee1	8b e8		 mov	 ebp, eax

; 8312 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  02ee3	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  02ee9	50		 push	 eax
  02eea	e8 00 00 00 00	 call	 _pipe_count

; 8313 : 			uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  02eef	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  02ef5	8b d8		 mov	 ebx, eax
  02ef7	51		 push	 ecx
  02ef8	e8 00 00 00 00	 call	 _pipe_count
  02efd	83 c4 10	 add	 esp, 16			; 00000010H

; 8314 : 			/*
; 8315 : 			kernel_enable( pKsd_t, uiDummy );
; 8316 : 			*/
; 8317 : 			if  (( uiSyncCount != 0 )
; 8318 : 				|| ( uiVtmCount != 0 )
; 8319 : 				|| ( uiPhCount != 0 )
; 8320 : 				|| ( uiLtsCount != 0 ))

  02f00	85 c0		 test	 eax, eax
  02f02	75 10		 jne	 SHORT $L72640
  02f04	85 db		 test	 ebx, ebx
  02f06	75 0c		 jne	 SHORT $L72640
  02f08	85 ed		 test	 ebp, ebp
  02f0a	75 08		 jne	 SHORT $L72640
  02f0c	8b 44 24 14	 mov	 eax, DWORD PTR _uiLtsCount$[esp+24]
  02f10	85 c0		 test	 eax, eax
  02f12	74 3d		 je	 SHORT $L72635
$L72640:

; 8321 : 				bPipesNotEmpty = TRUE;
; 8322 : 			else
; 8323 : 				bPipesNotEmpty = FALSE;
; 8324 : 		}
; 8325 : 		
; 8326 : 		/******************************************************************/
; 8327 : 		/*  Go to sleep for WAIT_PIPE_SLEEP_TIME msec.                    */
; 8328 : 		/******************************************************************/
; 8329 : 		
; 8330 : 		if ( bPipesNotEmpty )
; 8331 : 		{
; 8332 : #ifdef WIN32
; 8333 : 			PumpModeMessage(phTTS->pAudioHandle);

  02f14	8b 54 24 1c	 mov	 edx, DWORD PTR _phTTS$[esp+20]
  02f18	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  02f1e	50		 push	 eax
  02f1f	e8 00 00 00 00	 call	 _PumpModeMessage
  02f24	83 c4 04	 add	 esp, 4

; 8334 : 			Sleep( uiSleepTime );

  02f27	57		 push	 edi
  02f28	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 8335 : 			dwTotalTimeInMsec += uiSleepTime;

  02f2e	8b 44 24 10	 mov	 eax, DWORD PTR _dwTotalTimeInMsec$[esp+24]

; 8336 : #endif
; 8337 : #if defined __osf__ || defined __linux__
; 8338 : 			OP_Sleep( WAIT_PIPE_SLEEP_TIME );
; 8339 : 			dwTotalTimeInMsec += WAIT_PIPE_SLEEP_TIME;
; 8340 : #endif
; 8341 : 			
; 8342 : 			if ( dwTotalTimeInMsec > dwWaitTimeInMsec )

  02f32	8b 4c 24 20	 mov	 ecx, DWORD PTR _dwWaitTimeInMsec$[esp+20]
  02f36	03 c7		 add	 eax, edi
  02f38	3b c1		 cmp	 eax, ecx
  02f3a	89 44 24 10	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+24], eax
  02f3e	0f 86 32 ff ff
	ff		 jbe	 $L72634
  02f44	5f		 pop	 edi
  02f45	5e		 pop	 esi
  02f46	5d		 pop	 ebp

; 8343 : 			{
; 8344 : 				return( MMSYSERR_ERROR );

  02f47	b8 01 00 00 00	 mov	 eax, 1
  02f4c	5b		 pop	 ebx

; 8349 : }

  02f4d	83 c4 08	 add	 esp, 8
  02f50	c3		 ret	 0
$L72635:
  02f51	5f		 pop	 edi
  02f52	5e		 pop	 esi
  02f53	5d		 pop	 ebp

; 8345 : 			}
; 8346 : 		}
; 8347 : 	}
; 8348 : 	return( MMSYSERR_NOERROR );

  02f54	33 c0		 xor	 eax, eax
  02f56	5b		 pop	 ebx

; 8349 : }

  02f57	83 c4 08	 add	 esp, 8
  02f5a	c3		 ret	 0
_WaitForLtsFlush ENDP
_phTTS$ = 8
_uiLockedUpCount$ = -24
_uiLtsCount$ = 8
_uiCmdCount$ = -4
_uiOldVtmCount$ = -20
_uiOldPhCount$ = -16
_uiOldLtsCount$ = -12
_uiOldCmdCount$ = -8
_FixMemoryLockup PROC NEAR

; 8382 : {

  02f60	83 ec 18	 sub	 esp, 24			; 00000018H
  02f63	53		 push	 ebx

; 8383 : 	BOOL bPipesNotChanging;
; 8384 : 	UINT uiLockedUpCount;
; 8385 : 	UINT uiVtmCount;
; 8386 : 	UINT uiPhCount;
; 8387 : 	UINT uiLtsCount;
; 8388 : 	UINT uiCmdCount;
; 8389 : 	UINT uiOldVtmCount;
; 8390 : 	UINT uiOldPhCount;
; 8391 : 	UINT uiOldLtsCount;
; 8392 : 	UINT uiOldCmdCount;
; 8393 : #ifdef API_DEBUG
; 8394 : 	char szTemp[256]="";
; 8395 : 	ULONG ulStartTime, ulEndTime;
; 8396 : #endif //API_DEBUG
; 8397 : 	
; 8398 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 8399 : 	* and initialize from phTTS structure
; 8400 : 	*/
; 8401 : 	PKSD_T pKsd_t = NULL;
; 8402 : 	
; 8403 : #ifdef API_DEBUG
; 8404 : 	ulStartTime=timeGetTime();
; 8405 : 	sprintf(szTemp,"FixMemoryLockup() at %ld",ulStartTime);
; 8406 : 	OutputDebugString(szTemp);
; 8407 : #endif //API_DEBUG
; 8408 : 	
; 8409 : 	pKsd_t = phTTS->pKernelShareData;

  02f64	8b 5c 24 20	 mov	 ebx, DWORD PTR _phTTS$[esp+24]
  02f68	55		 push	 ebp
  02f69	56		 push	 esi

; 8410 : 	
; 8411 : 	/********************************************************************/
; 8412 : 	/*  Wait for all the pipes to change.                               */
; 8413 : 	/*  If the pipes are not changing then go to sleep                  */
; 8414 : 	/********************************************************************/
; 8415 : #ifdef WIN32
; 8416 : 	SetEvent( phTTS->hSyncEvent );

  02f6a	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  02f6d	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  02f70	57		 push	 edi
  02f71	50		 push	 eax
  02f72	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 8417 : #endif
; 8418 : #if defined __osf__ || defined __linux__
; 8419 : 	OP_SetEvent( phTTS->hSyncEvent );
; 8420 : #endif
; 8421 : 	
; 8422 : 	uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  02f78	8b 8e dc 00 00
	00		 mov	 ecx, DWORD PTR [esi+220]
  02f7e	51		 push	 ecx
  02f7f	e8 00 00 00 00	 call	 _pipe_count

; 8423 : 	uiPhCount = pipe_count( pKsd_t->ph_pipe );

  02f84	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  02f8a	8b f8		 mov	 edi, eax
  02f8c	52		 push	 edx
  02f8d	e8 00 00 00 00	 call	 _pipe_count
  02f92	8b e8		 mov	 ebp, eax

; 8424 : 	uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  02f94	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  02f9a	50		 push	 eax
  02f9b	e8 00 00 00 00	 call	 _pipe_count

; 8425 : 	uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  02fa0	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]
  02fa6	89 44 24 38	 mov	 DWORD PTR _uiLtsCount$[esp+48], eax
  02faa	51		 push	 ecx
  02fab	e8 00 00 00 00	 call	 _pipe_count

; 8426 : 	
; 8427 : 	uiOldVtmCount = uiVtmCount;
; 8428 : 	uiOldPhCount = uiPhCount;
; 8429 : 	uiOldLtsCount = uiLtsCount;

  02fb0	8b 4c 24 3c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+52]
  02fb4	83 c4 10	 add	 esp, 16			; 00000010H

; 8430 : 	uiOldCmdCount = uiCmdCount;
; 8431 : 	
; 8432 : 	uiLockedUpCount = 0;
; 8433 : 	bPipesNotChanging = TRUE;
; 8434 : 	
; 8435 : 	if (
; 8436 : 		(uiVtmCount) || (uiPhCount) 
; 8437 : 		|| (uiLtsCount) || (uiCmdCount) 
; 8438 : 		)

  02fb7	85 ff		 test	 edi, edi
  02fb9	89 7c 24 14	 mov	 DWORD PTR _uiOldVtmCount$[esp+40], edi
  02fbd	89 6c 24 18	 mov	 DWORD PTR _uiOldPhCount$[esp+40], ebp
  02fc1	89 4c 24 1c	 mov	 DWORD PTR _uiOldLtsCount$[esp+40], ecx
  02fc5	89 44 24 20	 mov	 DWORD PTR _uiOldCmdCount$[esp+40], eax
  02fc9	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _uiLockedUpCount$[esp+40], 0
  02fd1	75 10		 jne	 SHORT $L72662
  02fd3	85 ed		 test	 ebp, ebp
  02fd5	75 0c		 jne	 SHORT $L72662
  02fd7	85 c9		 test	 ecx, ecx
  02fd9	75 08		 jne	 SHORT $L72662
  02fdb	85 c0		 test	 eax, eax
  02fdd	0f 84 0c 01 00
	00		 je	 $L72664
$L72662:

; 8439 : 	{ 
; 8440 : 		while ( bPipesNotChanging )
; 8441 : 		{
; 8442 : 
; 8443 : 			PumpModeMessage(phTTS->pAudioHandle);

  02fe3	8b 93 d0 00 00
	00		 mov	 edx, DWORD PTR [ebx+208]
  02fe9	52		 push	 edx
  02fea	e8 00 00 00 00	 call	 _PumpModeMessage
  02fef	83 c4 04	 add	 esp, 4

; 8444 : 			Sleep( MEMORY_LOCKUP_SLEEP_TIME );

  02ff2	6a 14		 push	 20			; 00000014H
  02ff4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 8445 : 			
; 8446 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  02ffa	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  03000	50		 push	 eax
  03001	e8 00 00 00 00	 call	 _pipe_count

; 8447 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  03006	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  0300c	8b f8		 mov	 edi, eax
  0300e	51		 push	 ecx
  0300f	e8 00 00 00 00	 call	 _pipe_count

; 8448 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03014	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  0301a	8b e8		 mov	 ebp, eax
  0301c	52		 push	 edx
  0301d	e8 00 00 00 00	 call	 _pipe_count
  03022	89 44 24 38	 mov	 DWORD PTR _uiLtsCount$[esp+48], eax

; 8449 : 			uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  03026	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  0302c	50		 push	 eax
  0302d	e8 00 00 00 00	 call	 _pipe_count
  03032	83 c4 10	 add	 esp, 16			; 00000010H
  03035	89 44 24 24	 mov	 DWORD PTR _uiCmdCount$[esp+40], eax

; 8450 : 			
; 8451 : 			/******************************************************************/
; 8452 : 			/*  Are any of the the pipes changing ?                           */
; 8453 : 			/******************************************************************/
; 8454 : 			
; 8455 : 			if (
; 8456 : 				(
; 8457 : 				(uiVtmCount) || (uiPhCount) 
; 8458 : 				|| (uiLtsCount) || (uiCmdCount) 
; 8459 : 				)
; 8460 : 				&&
; 8461 : 				(   ( uiVtmCount == uiOldVtmCount )
; 8462 : 				&& ( uiPhCount == uiOldPhCount )
; 8463 : 				&& ( uiLtsCount == uiOldLtsCount )
; 8464 : 				&& ( uiCmdCount == uiOldCmdCount )
; 8465 : 				)
; 8466 : 				)

  03039	85 ff		 test	 edi, edi
  0303b	75 14		 jne	 SHORT $L72665
  0303d	85 ed		 test	 ebp, ebp
  0303f	75 10		 jne	 SHORT $L72665
  03041	8b 4c 24 2c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+36]
  03045	85 c9		 test	 ecx, ecx
  03047	75 08		 jne	 SHORT $L72665
  03049	85 c0		 test	 eax, eax
  0304b	0f 84 9e 00 00
	00		 je	 $L72664
$L72665:
  03051	3b 7c 24 14	 cmp	 edi, DWORD PTR _uiOldVtmCount$[esp+40]
  03055	0f 85 94 00 00
	00		 jne	 $L72664
  0305b	3b 6c 24 18	 cmp	 ebp, DWORD PTR _uiOldPhCount$[esp+40]
  0305f	0f 85 8a 00 00
	00		 jne	 $L72664
  03065	8b 4c 24 2c	 mov	 ecx, DWORD PTR _uiLtsCount$[esp+36]
  03069	8b 54 24 1c	 mov	 edx, DWORD PTR _uiOldLtsCount$[esp+40]
  0306d	3b ca		 cmp	 ecx, edx
  0306f	75 7e		 jne	 SHORT $L72664
  03071	3b 44 24 20	 cmp	 eax, DWORD PTR _uiOldCmdCount$[esp+40]
  03075	75 78		 jne	 SHORT $L72664

; 8467 : 			{
; 8468 : 				bPipesNotChanging = TRUE;
; 8469 : 				// tek 29aug96make sure we didn't somehow end up with no place
; 8470 : 				// to go..
; 8471 : 				if((pKsd_t->buffer_pipe != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 2) )

  03077	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  0307d	85 c0		 test	 eax, eax
  0307f	74 19		 je	 SHORT $L72667
  03081	50		 push	 eax
  03082	e8 00 00 00 00	 call	 _pipe_count
  03087	83 c4 04	 add	 esp, 4
  0308a	83 f8 02	 cmp	 eax, 2
  0308d	73 0b		 jae	 SHORT $L72667

; 8472 : 					TextToSpeechAddBuffer(phTTS, NULL);

  0308f	6a 00		 push	 0
  03091	53		 push	 ebx
  03092	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  03097	83 c4 08	 add	 esp, 8
$L72667:

; 8473 : 				uiLockedUpCount++;

  0309a	8b 44 24 10	 mov	 eax, DWORD PTR _uiLockedUpCount$[esp+40]
  0309e	40		 inc	 eax

; 8474 : 				
; 8475 : 				if ( uiLockedUpCount > MEMORY_LOCKUP_COUNT )

  0309f	83 f8 02	 cmp	 eax, 2
  030a2	89 44 24 10	 mov	 DWORD PTR _uiLockedUpCount$[esp+40], eax
  030a6	76 2a		 jbe	 SHORT $L72669

; 8476 : 				{
; 8477 : 					/**************************************************************/
; 8478 : 					/*  Test to see if the vtm thread is blocked by a call to     */
; 8479 : 					/*  SendMessage().                                            */
; 8480 : 					/**************************************************************/
; 8481 : 					
; 8482 : #ifdef WIN32
; 8483 : 					ResetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  030a8	8b 53 3c	 mov	 edx, DWORD PTR [ebx+60]
  030ab	52		 push	 edx
  030ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 8484 : #endif
; 8485 : #if defined __osf__ || defined __linux__
; 8486 : 					OP_ResetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 8487 : #endif
; 8488 : 					
; 8489 : 					if ( phTTS->bSendingBuffer )

  030b2	8b 83 90 00 00
	00		 mov	 eax, DWORD PTR [ebx+144]
  030b8	85 c0		 test	 eax, eax
  030ba	74 0c		 je	 SHORT $L72670

; 8490 : 					{
; 8491 : 						EmptyVtmPipe(phTTS->pKernelShareData);

  030bc	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  030bf	50		 push	 eax
  030c0	e8 00 00 00 00	 call	 _EmptyVtmPipe
  030c5	83 c4 04	 add	 esp, 4
$L72670:

; 8492 : 					}
; 8493 : #ifdef WIN32
; 8494 : 					SetEvent( phTTS->hNotEmptyingVtmPipeEvent );

  030c8	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  030cb	51		 push	 ecx
  030cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L72669:

; 8495 : #endif
; 8496 : #if defined __osf__ || defined __linux__
; 8497 : 					OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
; 8498 : #endif
; 8499 : 				}
; 8500 : 				
; 8501 : 				uiOldVtmCount = uiVtmCount;
; 8502 : 				uiOldPhCount = uiPhCount;
; 8503 : 				uiOldLtsCount = uiLtsCount;

  030d2	8b 54 24 2c	 mov	 edx, DWORD PTR _uiLtsCount$[esp+36]

; 8504 : 				uiOldCmdCount = uiCmdCount;

  030d6	8b 44 24 24	 mov	 eax, DWORD PTR _uiCmdCount$[esp+40]
  030da	89 7c 24 14	 mov	 DWORD PTR _uiOldVtmCount$[esp+40], edi
  030de	89 6c 24 18	 mov	 DWORD PTR _uiOldPhCount$[esp+40], ebp
  030e2	89 54 24 1c	 mov	 DWORD PTR _uiOldLtsCount$[esp+40], edx
  030e6	89 44 24 20	 mov	 DWORD PTR _uiOldCmdCount$[esp+40], eax

; 8505 : 			}
; 8506 : 			else

  030ea	e9 f4 fe ff ff	 jmp	 $L72662
$L72664:
  030ef	5f		 pop	 edi
  030f0	5e		 pop	 esi
  030f1	5d		 pop	 ebp
  030f2	5b		 pop	 ebx

; 8507 : 			{
; 8508 : 				bPipesNotChanging = FALSE;
; 8509 : 			}
; 8510 : 		}
; 8511 : 	} // if pipes not empty
; 8512 : #ifdef API_DEBUG
; 8513 : 	ulEndTime=timeGetTime();
; 8514 : 	sprintf(szTemp,"FixMemoryLockup() exit %ld ms",ulEndTime-ulStartTime);
; 8515 : 	OutputDebugString(szTemp);
; 8516 : #endif //API_DEBUG
; 8517 : 	
; 8518 : 	return;
; 8519 : }

  030f3	83 c4 18	 add	 esp, 24			; 00000018H
  030f6	c3		 ret	 0
_FixMemoryLockup ENDP
_phTTS$ = 8
_dwWaitTimeInMsec$ = 12
_bReset$ = 16
_bPipesNotEmpty$ = -32
_uiLockedUpCount$ = -36
_uiVtmCount$ = -44
_uiPhCount$ = -40
_uiOldSyncCount$ = -20
_uiOldVtmCount$ = -16
_uiOldPhCount$ = -12
_uiOldLtsCount$ = -8
_uiOldCmdCount$ = -4
_uiSleepTime$ = -28
_dwTotalTimeInMsec$ = -24
_WaitForEmptyPipes PROC NEAR

; 8562 : {

  03100	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 8563 : 	BOOL bPipesNotEmpty;
; 8564 : 	UINT uiLockedUpCount;
; 8565 : 	UINT uiSyncCount;
; 8566 : 	UINT uiVtmCount;
; 8567 : 	UINT uiPhCount;
; 8568 : 	UINT uiLtsCount;
; 8569 : 	UINT uiCmdCount;
; 8570 : 	UINT uiOldSyncCount;
; 8571 : 	UINT uiOldVtmCount;
; 8572 : 	UINT uiOldPhCount;
; 8573 : 	UINT uiOldLtsCount;
; 8574 : 	UINT uiOldCmdCount;
; 8575 : 	UINT	uiSleepTime;
; 8576 : 	DWORD dwTotalTimeInMsec;
; 8577 : #ifdef API_DEBUG
; 8578 : 	char szTemp[256]="";
; 8579 : 	ULONG ulStartTime, ulEndTime;
; 8580 : #endif //API_DEBUG
; 8581 : 	/* Added a varaible to get current instance Kernel_Share_Data 
; 8582 : 	* and initialize from phTTS structure
; 8583 : 	*/
; 8584 : 	PKSD_T pKsd_t = NULL;
; 8585 : #ifdef API_DEBUG
; 8586 : 	ulStartTime=timeGetTime();
; 8587 : 	sprintf(szTemp,"WaitForEmptyPipes at %ld\n",ulStartTime);
; 8588 : 	OutputDebugString(szTemp);
; 8589 : #endif //API_DEBUG
; 8590 : 	
; 8591 : 	pKsd_t = phTTS->pKernelShareData;

  03103	8b 4c 24 30	 mov	 ecx, DWORD PTR _phTTS$[esp+40]
  03107	53		 push	 ebx
  03108	55		 push	 ebp
  03109	56		 push	 esi

; 8592 : #ifdef TYPING_MODE
; 8593 : 	if (phTTS->bInTypingMode)

  0310a	8b 81 d4 00 00
	00		 mov	 eax, DWORD PTR [ecx+212]
  03110	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  03113	f7 d8		 neg	 eax
  03115	1b c0		 sbb	 eax, eax

; 8594 : 		uiSleepTime=1;	// just reschedule
; 8595 : 	// Well, actually, we have to sleep
; 8596 : 	// a little.. otherwise PH and VTM won't get
; 8597 : 	// to run..
; 8598 : 	else
; 8599 : #endif //TYPING_MODE
; 8600 : 		uiSleepTime=WAIT_PIPE_SLEEP_TIME;
; 8601 : 	/********************************************************************/
; 8602 : 	/*  Wait for all the pipes to empty.                                */
; 8603 : 	/*  If the pipes are not empty then sleep for 100 msec. and check   */
; 8604 : 	/*  them again.                                                     */
; 8605 : 	/********************************************************************/
; 8606 : 	
; 8607 : 	dwTotalTimeInMsec = 0;

  03117	33 d2		 xor	 edx, edx
  03119	24 fc		 and	 al, -4			; fffffffcH
  0311b	57		 push	 edi
  0311c	83 c0 05	 add	 eax, 5
  0311f	89 54 24 24	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+60], edx
  03123	89 44 24 20	 mov	 DWORD PTR _uiSleepTime$[esp+60], eax

; 8608 : 	
; 8609 : 	uiOldSyncCount = 0xFFFFFFFF;

  03127	83 c8 ff	 or	 eax, -1
  0312a	89 44 24 28	 mov	 DWORD PTR _uiOldSyncCount$[esp+60], eax

; 8610 : 	uiOldVtmCount = 0xFFFFFFFF;

  0312e	89 44 24 2c	 mov	 DWORD PTR _uiOldVtmCount$[esp+60], eax

; 8611 : 	uiOldPhCount = 0xFFFFFFFF;

  03132	89 44 24 30	 mov	 DWORD PTR _uiOldPhCount$[esp+60], eax

; 8612 : 	uiOldLtsCount = 0xFFFFFFFF;

  03136	89 44 24 34	 mov	 DWORD PTR _uiOldLtsCount$[esp+60], eax

; 8613 : 	uiOldCmdCount = 0xFFFFFFFF;

  0313a	89 44 24 38	 mov	 DWORD PTR _uiOldCmdCount$[esp+60], eax

; 8614 : 	uiLockedUpCount = 0;

  0313e	89 54 24 18	 mov	 DWORD PTR _uiLockedUpCount$[esp+60], edx
  03142	eb 04		 jmp	 SHORT $L72698
$L73315:
  03144	8b 4c 24 40	 mov	 ecx, DWORD PTR _phTTS$[esp+56]
$L72698:

; 8615 : 	bPipesNotEmpty = TRUE;
; 8616 : 	
; 8617 : 	while ( bPipesNotEmpty )
; 8618 : 	{
; 8619 : 		bPipesNotEmpty = FALSE;
; 8620 : 		
; 8621 : 		if ( bReset )

  03148	8b 44 24 48	 mov	 eax, DWORD PTR _bReset$[esp+56]
  0314c	85 c0		 test	 eax, eax
  0314e	74 0a		 je	 SHORT $L72700

; 8622 : #ifdef WIN32
; 8623 : 			SetEvent( phTTS->hSyncEvent );

  03150	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  03153	50		 push	 eax
  03154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L72700:

; 8624 : #endif
; 8625 : #if defined __osf__ || defined __linux__
; 8626 : 		OP_SetEvent( phTTS->hSyncEvent );
; 8627 : #endif
; 8628 : 		
; 8629 : 		uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  0315a	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  03160	51		 push	 ecx
  03161	e8 00 00 00 00	 call	 _pipe_count

; 8630 : 		uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  03166	8b 96 dc 00 00
	00		 mov	 edx, DWORD PTR [esi+220]
  0316c	8b f8		 mov	 edi, eax
  0316e	52		 push	 edx
  0316f	e8 00 00 00 00	 call	 _pipe_count
  03174	89 44 24 18	 mov	 DWORD PTR _uiVtmCount$[esp+68], eax

; 8631 : 		uiPhCount = pipe_count( pKsd_t->ph_pipe );

  03178	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  0317e	50		 push	 eax
  0317f	e8 00 00 00 00	 call	 _pipe_count

; 8632 : 		uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  03184	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  0318a	89 44 24 20	 mov	 DWORD PTR _uiPhCount$[esp+72], eax
  0318e	51		 push	 ecx
  0318f	e8 00 00 00 00	 call	 _pipe_count

; 8633 : 		uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  03194	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  0319a	8b e8		 mov	 ebp, eax
  0319c	52		 push	 edx
  0319d	e8 00 00 00 00	 call	 _pipe_count
  031a2	83 c4 14	 add	 esp, 20			; 00000014H
  031a5	8b d8		 mov	 ebx, eax

; 8634 : 		
; 8635 : 		if  (( uiSyncCount != 0 )
; 8636 : 			|| ( uiVtmCount != 0 )
; 8637 : 			|| ( uiPhCount != 0 )
; 8638 : 			|| ( uiLtsCount != 0 )
; 8639 : 			|| ( uiCmdCount != 0 ))

  031a7	85 ff		 test	 edi, edi
  031a9	0f 85 87 00 00
	00		 jne	 $L72702
  031af	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+60]
  031b3	85 c0		 test	 eax, eax
  031b5	75 7f		 jne	 SHORT $L72702
  031b7	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+60]
  031bb	85 c0		 test	 eax, eax
  031bd	75 77		 jne	 SHORT $L72702
  031bf	85 ed		 test	 ebp, ebp
  031c1	75 73		 jne	 SHORT $L72702
  031c3	85 db		 test	 ebx, ebx

; 8640 : 			bPipesNotEmpty = TRUE;
; 8641 : 		
; 8642 : 		/******************************************************************/
; 8643 : 		/*  If bPipesNotEmpty is still FALSE here then the pipes are      */
; 8644 : 		/*  probably empty. It is possible that there is still data in    */
; 8645 : 		/*  the pipes, but that it moved out of a pipe we are about to    */
; 8646 : 		/*  check into a pipe we have we just checked. We now check the   */
; 8647 : 		/*  pipes in the reverse order.                                   */
; 8648 : 		/******************************************************************/
; 8649 : 		
; 8650 : 		if ( ! bPipesNotEmpty )

  031c5	75 6f		 jne	 SHORT $L72702

; 8651 : 		{
; 8652 : 		/*
; 8653 : 		kernel_disable(pKsd_t);
; 8654 : 			*/
; 8655 : 			uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  031c7	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  031cd	50		 push	 eax
  031ce	e8 00 00 00 00	 call	 _pipe_count

; 8656 : 			uiLtsCount = pipe_count( pKsd_t->lts_pipe );

  031d3	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  031d9	8b d8		 mov	 ebx, eax
  031db	51		 push	 ecx
  031dc	e8 00 00 00 00	 call	 _pipe_count

; 8657 : 			uiPhCount = pipe_count( pKsd_t->ph_pipe );

  031e1	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  031e7	8b e8		 mov	 ebp, eax
  031e9	52		 push	 edx
  031ea	e8 00 00 00 00	 call	 _pipe_count
  031ef	89 44 24 20	 mov	 DWORD PTR _uiPhCount$[esp+72], eax

; 8658 : 			uiVtmCount = pipe_count( pKsd_t->vtm_pipe );

  031f3	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  031f9	50		 push	 eax
  031fa	e8 00 00 00 00	 call	 _pipe_count

; 8659 : 			uiSyncCount = pipe_count( pKsd_t->sync_pipe );

  031ff	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  03205	89 44 24 20	 mov	 DWORD PTR _uiVtmCount$[esp+76], eax
  03209	51		 push	 ecx
  0320a	e8 00 00 00 00	 call	 _pipe_count
  0320f	8b f8		 mov	 edi, eax
  03211	83 c4 14	 add	 esp, 20			; 00000014H

; 8660 : 			/*
; 8661 : 			kernel_enable( pKsd_t, uiDummy );
; 8662 : 			*/
; 8663 : 			if  (( uiSyncCount != 0 )
; 8664 : 				|| ( uiVtmCount != 0 )
; 8665 : 				|| ( uiPhCount != 0 )
; 8666 : 				|| ( uiLtsCount != 0 )
; 8667 : 				|| ( uiCmdCount != 0 ))

  03214	85 ff		 test	 edi, edi
  03216	75 1e		 jne	 SHORT $L72702
  03218	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+60]
  0321c	85 c0		 test	 eax, eax
  0321e	75 16		 jne	 SHORT $L72702
  03220	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+60]
  03224	85 c0		 test	 eax, eax
  03226	75 0e		 jne	 SHORT $L72702
  03228	85 ed		 test	 ebp, ebp
  0322a	75 0a		 jne	 SHORT $L72702
  0322c	85 db		 test	 ebx, ebx
  0322e	75 06		 jne	 SHORT $L72702

; 8668 : 				bPipesNotEmpty = TRUE;
; 8669 : 			else
; 8670 : 				bPipesNotEmpty = FALSE;

  03230	89 5c 24 1c	 mov	 DWORD PTR _bPipesNotEmpty$[esp+60], ebx
  03234	eb 67		 jmp	 SHORT $L72711
$L72702:

; 8671 : 		}
; 8672 : 		
; 8673 : 		/******************************************************************/
; 8674 : 		/*  Go to sleep for WAIT_PIPE_SLEEP_TIME msec.                    */
; 8675 : 		/******************************************************************/
; 8676 : 		
; 8677 : 		if ( bPipesNotEmpty )
; 8678 : 		{
; 8679 : 			// tek 29aug96make sure we didn't somehow end up with no place
; 8680 : 			// to go.
; 8681 : 			if((pKsd_t->buffer_pipe  != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 1) )

  03236	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  0323c	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bPipesNotEmpty$[esp+60], 1
  03244	85 c0		 test	 eax, eax
  03246	74 1d		 je	 SHORT $L72709
  03248	50		 push	 eax
  03249	e8 00 00 00 00	 call	 _pipe_count
  0324e	83 c4 04	 add	 esp, 4
  03251	83 f8 01	 cmp	 eax, 1
  03254	73 0f		 jae	 SHORT $L72709

; 8682 : 				TextToSpeechAddBuffer(phTTS, NULL);

  03256	8b 54 24 40	 mov	 edx, DWORD PTR _phTTS$[esp+56]
  0325a	6a 00		 push	 0
  0325c	52		 push	 edx
  0325d	e8 00 00 00 00	 call	 _TextToSpeechAddBuffer
  03262	83 c4 08	 add	 esp, 8
$L72709:

; 8683 : 			
; 8684 : #ifdef API_DEBUG
; 8685 : 			sprintf(szTemp,"WaitForEmptyPipes: c:%d l:%d p:%d v:%d s:%d at %ld\n",
; 8686 : 				uiCmdCount,
; 8687 : 				uiLtsCount,
; 8688 : 				uiPhCount,
; 8689 : 				uiVtmCount,
; 8690 : 				uiSyncCount,
; 8691 : 				timeGetTime());
; 8692 : 			OutputDebugString(szTemp);
; 8693 : #endif //API_DEBUG
; 8694 : 			
; 8695 : #ifdef WIN32
; 8696 : 
; 8697 : 			PumpModeMessage(phTTS->pAudioHandle);

  03265	8b 44 24 40	 mov	 eax, DWORD PTR _phTTS$[esp+56]
  03269	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  0326f	51		 push	 ecx
  03270	e8 00 00 00 00	 call	 _PumpModeMessage

; 8698 : 			Sleep( uiSleepTime );

  03275	8b 54 24 24	 mov	 edx, DWORD PTR _uiSleepTime$[esp+64]
  03279	83 c4 04	 add	 esp, 4
  0327c	52		 push	 edx
  0327d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 8699 : 			
; 8700 : 			dwTotalTimeInMsec += (uiSleepTime);

  03283	8b 44 24 24	 mov	 eax, DWORD PTR _dwTotalTimeInMsec$[esp+60]
  03287	8b 54 24 20	 mov	 edx, DWORD PTR _uiSleepTime$[esp+60]

; 8701 : #endif
; 8702 : #if defined __osf__ || defined __linux__
; 8703 : 			OP_Sleep( WAIT_PIPE_SLEEP_TIME );
; 8704 : 			
; 8705 : 			dwTotalTimeInMsec += WAIT_PIPE_SLEEP_TIME;
; 8706 : #endif
; 8707 : 			
; 8708 : 			if ( dwTotalTimeInMsec > dwWaitTimeInMsec )

  0328b	8b 4c 24 44	 mov	 ecx, DWORD PTR _dwWaitTimeInMsec$[esp+56]
  0328f	03 c2		 add	 eax, edx
  03291	3b c1		 cmp	 eax, ecx
  03293	89 44 24 24	 mov	 DWORD PTR _dwTotalTimeInMsec$[esp+60], eax
  03297	0f 87 c7 00 00
	00		 ja	 $L73311
$L72711:

; 8709 : 			{
; 8710 : #ifdef API_DEBUG
; 8711 : 				OutputDebugString("  ..WFPE() timed out!\n");
; 8712 : #endif //API_DEBUG
; 8713 : 				return( MMSYSERR_ERROR );
; 8714 : 			}
; 8715 : 		}
; 8716 : 		
; 8717 : 		/******************************************************************/
; 8718 : 		/*  If this is a reset then check to see if nothing is happening. */
; 8719 : 		/*  If any of the threads block then the pipe state may not       */
; 8720 : 		/*  change.                                                       */
; 8721 : 		/******************************************************************/
; 8722 : 		
; 8723 : 		if  (( bReset )
; 8724 : 			&& ( uiSyncCount && (uiSyncCount == uiOldSyncCount) )
; 8725 : 			&& ( uiVtmCount && (uiVtmCount == uiOldVtmCount) )
; 8726 : 			&& ( uiPhCount && (uiPhCount == uiOldPhCount) )
; 8727 : 			&& ( uiLtsCount && (uiLtsCount == uiOldLtsCount) )
; 8728 : 			&& ( uiCmdCount && (uiCmdCount == uiOldCmdCount) ))

  0329d	8b 44 24 48	 mov	 eax, DWORD PTR _bReset$[esp+56]
  032a1	85 c0		 test	 eax, eax
  032a3	74 7a		 je	 SHORT $L72712
  032a5	85 ff		 test	 edi, edi
  032a7	74 76		 je	 SHORT $L72712
  032a9	3b 7c 24 28	 cmp	 edi, DWORD PTR _uiOldSyncCount$[esp+60]
  032ad	75 70		 jne	 SHORT $L72712
  032af	8b 44 24 10	 mov	 eax, DWORD PTR _uiVtmCount$[esp+60]
  032b3	85 c0		 test	 eax, eax
  032b5	74 68		 je	 SHORT $L72712
  032b7	3b 44 24 2c	 cmp	 eax, DWORD PTR _uiOldVtmCount$[esp+60]
  032bb	75 62		 jne	 SHORT $L72712
  032bd	8b 44 24 14	 mov	 eax, DWORD PTR _uiPhCount$[esp+60]
  032c1	85 c0		 test	 eax, eax
  032c3	74 5a		 je	 SHORT $L72712
  032c5	3b 44 24 30	 cmp	 eax, DWORD PTR _uiOldPhCount$[esp+60]
  032c9	75 54		 jne	 SHORT $L72712
  032cb	85 ed		 test	 ebp, ebp
  032cd	74 50		 je	 SHORT $L72712
  032cf	3b 6c 24 34	 cmp	 ebp, DWORD PTR _uiOldLtsCount$[esp+60]
  032d3	75 4a		 jne	 SHORT $L72712
  032d5	85 db		 test	 ebx, ebx
  032d7	74 46		 je	 SHORT $L72712
  032d9	3b 5c 24 38	 cmp	 ebx, DWORD PTR _uiOldCmdCount$[esp+60]
  032dd	75 40		 jne	 SHORT $L72712

; 8729 : 		{
; 8730 : 			/****************************************************************/
; 8731 : 			/*  Perform an audio reset to immediately stop audio from       */
; 8732 : 			/*  playing and to make sure the VTM thread is not blocked.     */
; 8733 : 			/****************************************************************/
; 8734 : 			
; 8735 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  032df	8b 44 24 40	 mov	 eax, DWORD PTR _phTTS$[esp+56]
  032e3	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  032e9	85 c9		 test	 ecx, ecx
  032eb	75 13		 jne	 SHORT $L72713

; 8736 : 			{
; 8737 : 				PA_Reset( phTTS->pAudioHandle );

  032ed	8b 80 d0 00 00
	00		 mov	 eax, DWORD PTR [eax+208]
  032f3	50		 push	 eax
  032f4	e8 00 00 00 00	 call	 _PA_Reset
  032f9	8b 44 24 44	 mov	 eax, DWORD PTR _phTTS$[esp+60]
  032fd	83 c4 04	 add	 esp, 4
$L72713:

; 8738 : 			}
; 8739 : 			
; 8740 : 			uiLockedUpCount++;

  03300	8b 54 24 18	 mov	 edx, DWORD PTR _uiLockedUpCount$[esp+60]

; 8741 : 			
; 8742 : 			/****************************************************************/
; 8743 : 			/*  Fix hang when using speech-to-memory. WIH 4/6/95            */
; 8744 : 			/****************************************************************/
; 8745 : 			
; 8746 : 			if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )

  03304	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0330a	42		 inc	 edx
  0330b	83 f9 01	 cmp	 ecx, 1
  0330e	89 54 24 18	 mov	 DWORD PTR _uiLockedUpCount$[esp+60], edx
  03312	75 13		 jne	 SHORT $L72715

; 8747 : 			{
; 8748 : 				FixMemoryLockup( phTTS );

  03314	50		 push	 eax
  03315	e8 00 00 00 00	 call	 _FixMemoryLockup
  0331a	83 c4 04	 add	 esp, 4

; 8749 : 			}
; 8750 : 		}
; 8751 : 		else

  0331d	eb 08		 jmp	 SHORT $L72715
$L72712:

; 8752 : 		{
; 8753 : 			uiLockedUpCount = 0;

  0331f	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _uiLockedUpCount$[esp+60], 0
$L72715:

; 8754 : 		}
; 8755 : 		
; 8756 : 		uiOldSyncCount = uiSyncCount;
; 8757 : 		uiOldVtmCount = uiVtmCount;
; 8758 : 		uiOldPhCount = uiPhCount;
; 8759 : 		uiOldLtsCount = uiLtsCount;
; 8760 : 		uiOldCmdCount = uiCmdCount;
; 8761 : 		
; 8762 : 		if ( uiLockedUpCount >= WAIT_PIPE_ABORT_COUNT )

  03327	8b 44 24 18	 mov	 eax, DWORD PTR _uiLockedUpCount$[esp+60]
  0332b	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiVtmCount$[esp+60]
  0332f	8b 54 24 14	 mov	 edx, DWORD PTR _uiPhCount$[esp+60]
  03333	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  03338	89 7c 24 28	 mov	 DWORD PTR _uiOldSyncCount$[esp+60], edi
  0333c	89 4c 24 2c	 mov	 DWORD PTR _uiOldVtmCount$[esp+60], ecx
  03340	89 54 24 30	 mov	 DWORD PTR _uiOldPhCount$[esp+60], edx
  03344	89 6c 24 34	 mov	 DWORD PTR _uiOldLtsCount$[esp+60], ebp
  03348	89 5c 24 38	 mov	 DWORD PTR _uiOldCmdCount$[esp+60], ebx
  0334c	73 16		 jae	 SHORT $L73311
  0334e	8b 44 24 1c	 mov	 eax, DWORD PTR _bPipesNotEmpty$[esp+60]
  03352	85 c0		 test	 eax, eax
  03354	0f 85 ea fd ff
	ff		 jne	 $L73315
  0335a	5f		 pop	 edi
  0335b	5e		 pop	 esi
  0335c	5d		 pop	 ebp

; 8768 : 		}
; 8769 :   }
; 8770 : #ifdef API_DEBUG
; 8771 :   ulEndTime=timeGetTime();
; 8772 :   sprintf(szTemp,"WaitForEmptyPipes exit at %ld (%ld) ms\n",
; 8773 : 	  ulEndTime, ulEndTime - ulStartTime);
; 8774 :   OutputDebugString(szTemp);
; 8775 : #endif //API_DEBUG
; 8776 :   
; 8777 :   return( MMSYSERR_NOERROR );

  0335d	33 c0		 xor	 eax, eax
  0335f	5b		 pop	 ebx

; 8778 : }

  03360	83 c4 2c	 add	 esp, 44			; 0000002cH
  03363	c3		 ret	 0
$L73311:
  03364	5f		 pop	 edi
  03365	5e		 pop	 esi
  03366	5d		 pop	 ebp

; 8763 : 		{
; 8764 : #ifdef API_DEBUG
; 8765 : 			OutputDebugString("  ..WFPE() lockup failure?\n");
; 8766 : #endif //API_DEBUG
; 8767 : 			return( MMSYSERR_ERROR );

  03367	b8 01 00 00 00	 mov	 eax, 1
  0336c	5b		 pop	 ebx

; 8778 : }

  0336d	83 c4 2c	 add	 esp, 44			; 0000002cH
  03370	c3		 ret	 0
_WaitForEmptyPipes ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG72727 DB	'DECtalkErrorMessage', 00H
_DATA	ENDS
_TEXT	SEGMENT
_aInstance$ = 12
_aMessage$ = 16
_aParam$ = 20
_PlayAudioCallbackRoutine PROC NEAR

; 8791 : 	// get the dectalk error mesage ID.. 
; 8792 : 	UINT uiID_Error_Msg;
; 8793 : 	
; 8794 : #ifdef API_DEBUG
; 8795 : 	OutputDebugString("PlayAudioCallbackRoutine().\n");
; 8796 : #endif //API_DEBUG
; 8797 : 	/********************************************************************/
; 8798 : 	/*  Get the DECtalk error message.                                  */
; 8799 : 	/********************************************************************/
; 8800 : #if defined __osf__ || defined __linux__
; 8801 : 	uiID_Error_Msg = ((LPTTS_HANDLE_T)aInstance)->uiID_Error_Message;
; 8802 : #endif
; 8803 : 	
; 8804 : #ifdef WIN32
; 8805 : #ifdef UNDER_CE
; 8806 :    uiID_Error_Msg = RegisterWindowMessage(_T("DECtalkErrorMessage"));
; 8807 : #else
; 8808 :     uiID_Error_Msg = RegisterWindowMessage("DECtalkErrorMessage");

  03380	68 00 00 00 00	 push	 OFFSET FLAT:$SG72727
  03385	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4

; 8809 : #endif
; 8810 : #endif
; 8811 :     switch ( aMessage )
; 8812 : 	{

  0338b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aMessage$[esp-4]
  0338f	49		 dec	 ecx
  03390	83 f9 06	 cmp	 ecx, 6
  03393	77 7c		 ja	 SHORT $L72744
  03395	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L73319[ecx*4]
$L72732:

; 8848 : 		break;
; 8849 : 		
; 8850 : 	case PA_GET_CAPS_ERROR:
; 8851 : 		
; 8852 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8853 : 			uiID_Error_Msg,
; 8854 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 8855 : 			aParam );

  0339c	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  033a0	6a 00		 push	 0
  033a2	6a 0c		 push	 12			; 0000000cH
  033a4	50		 push	 eax
  033a5	52		 push	 edx
  033a6	e8 00 00 00 00	 call	 _Report_TTS_Status
  033ab	83 c4 10	 add	 esp, 16			; 00000010H

; 8856 : 		break;
; 8857 : 		
; 8858 : 	default:
; 8859 : 		
; 8860 : 		break;
; 8861 : 	}
; 8862 : 	
; 8863 : 	return FALSE;

  033ae	33 c0		 xor	 eax, eax

; 8864 : }

  033b0	c3		 ret	 0
$L72734:

; 8813 : 		
; 8814 : 	case PA_PLAY_START:
; 8815 : 		
; 8816 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8817 : 			uiID_Error_Msg,
; 8818 : 			TTS_AUDIO_PLAY_START,
; 8819 : 			MMSYSERR_NOERROR );
; 8820 : 		break;
; 8821 : 		
; 8822 : 	case PA_PLAY_STOP:
; 8823 : 		
; 8824 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8825 : 			uiID_Error_Msg,
; 8826 : 			TTS_AUDIO_PLAY_STOP,
; 8827 : 			MMSYSERR_NOERROR );

  033b1	6a 00		 push	 0
  033b3	6a 0d		 push	 13			; 0000000dH
  033b5	50		 push	 eax
  033b6	8b 44 24 14	 mov	 eax, DWORD PTR _aInstance$[esp+8]
  033ba	50		 push	 eax

; 8848 : 		break;
; 8849 : 		
; 8850 : 	case PA_GET_CAPS_ERROR:
; 8851 : 		
; 8852 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8853 : 			uiID_Error_Msg,
; 8854 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 8855 : 			aParam );

  033bb	e8 00 00 00 00	 call	 _Report_TTS_Status
  033c0	83 c4 10	 add	 esp, 16			; 00000010H

; 8856 : 		break;
; 8857 : 		
; 8858 : 	default:
; 8859 : 		
; 8860 : 		break;
; 8861 : 	}
; 8862 : 	
; 8863 : 	return FALSE;

  033c3	33 c0		 xor	 eax, eax

; 8864 : }

  033c5	c3		 ret	 0
$L72736:

; 8828 : 		
; 8829 : 		break;
; 8830 : 		
; 8831 : 	case PA_DEVICE_OPEN_FAILURE:
; 8832 : 		
; 8833 : 		if (((LPTTS_HANDLE_T)aInstance)->dwDeviceOptions & REPORT_OPEN_ERROR )

  033c6	8b 4c 24 08	 mov	 ecx, DWORD PTR _aInstance$[esp-4]
  033ca	f6 41 74 02	 test	 BYTE PTR [ecx+116], 2
  033ce	74 41		 je	 SHORT $L72744

; 8834 : 		{
; 8835 : 			Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8836 : 				uiID_Error_Msg,
; 8837 : 				ERROR_OPENING_WAVE_OUTPUT_DEVICE,
; 8838 : 				aParam );

  033d0	8b 54 24 10	 mov	 edx, DWORD PTR _aParam$[esp-4]
  033d4	52		 push	 edx
  033d5	6a 02		 push	 2
  033d7	50		 push	 eax
  033d8	51		 push	 ecx

; 8848 : 		break;
; 8849 : 		
; 8850 : 	case PA_GET_CAPS_ERROR:
; 8851 : 		
; 8852 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8853 : 			uiID_Error_Msg,
; 8854 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 8855 : 			aParam );

  033d9	e8 00 00 00 00	 call	 _Report_TTS_Status
  033de	83 c4 10	 add	 esp, 16			; 00000010H

; 8856 : 		break;
; 8857 : 		
; 8858 : 	default:
; 8859 : 		
; 8860 : 		break;
; 8861 : 	}
; 8862 : 	
; 8863 : 	return FALSE;

  033e1	33 c0		 xor	 eax, eax

; 8864 : }

  033e3	c3		 ret	 0
$L72740:

; 8839 : 		}
; 8840 : 		break;
; 8841 : 		
; 8842 : 	case PA_WRITE_ERROR:
; 8843 : 		
; 8844 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8845 : 			uiID_Error_Msg,
; 8846 : 			ERROR_IN_AUDIO_WRITE,
; 8847 : 			aParam );

  033e4	8b 4c 24 10	 mov	 ecx, DWORD PTR _aParam$[esp-4]

; 8848 : 		break;
; 8849 : 		
; 8850 : 	case PA_GET_CAPS_ERROR:
; 8851 : 		
; 8852 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8853 : 			uiID_Error_Msg,
; 8854 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 8855 : 			aParam );

  033e8	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  033ec	51		 push	 ecx
  033ed	6a 01		 push	 1
  033ef	50		 push	 eax
  033f0	52		 push	 edx
  033f1	e8 00 00 00 00	 call	 _Report_TTS_Status
  033f6	83 c4 10	 add	 esp, 16			; 00000010H

; 8856 : 		break;
; 8857 : 		
; 8858 : 	default:
; 8859 : 		
; 8860 : 		break;
; 8861 : 	}
; 8862 : 	
; 8863 : 	return FALSE;

  033f9	33 c0		 xor	 eax, eax

; 8864 : }

  033fb	c3		 ret	 0
$L72742:

; 8848 : 		break;
; 8849 : 		
; 8850 : 	case PA_GET_CAPS_ERROR:
; 8851 : 		
; 8852 : 		Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
; 8853 : 			uiID_Error_Msg,
; 8854 : 			ERROR_GETTING_DEVICE_CAPABILITIES,
; 8855 : 			aParam );

  033fc	8b 4c 24 10	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  03400	8b 54 24 08	 mov	 edx, DWORD PTR _aInstance$[esp-4]
  03404	51		 push	 ecx
  03405	6a 03		 push	 3
  03407	50		 push	 eax
  03408	52		 push	 edx
  03409	e8 00 00 00 00	 call	 _Report_TTS_Status
  0340e	83 c4 10	 add	 esp, 16			; 00000010H
$L72744:

; 8856 : 		break;
; 8857 : 		
; 8858 : 	default:
; 8859 : 		
; 8860 : 		break;
; 8861 : 	}
; 8862 : 	
; 8863 : 	return FALSE;

  03411	33 c0		 xor	 eax, eax

; 8864 : }

  03413	c3		 ret	 0
$L73319:
  03414	00 00 00 00	 DD	 $L72732
  03418	00 00 00 00	 DD	 $L72734
  0341c	00 00 00 00	 DD	 $L72736
  03420	00 00 00 00	 DD	 $L72744
  03424	00 00 00 00	 DD	 $L72744
  03428	00 00 00 00	 DD	 $L72742
  0342c	00 00 00 00	 DD	 $L72740
_PlayAudioCallbackRoutine ENDP
_TEXT	ENDS
EXTRN	_OP_LockMutex:NEAR
EXTRN	_OP_UnlockMutex:NEAR
_TEXT	SEGMENT
_ttsHandle$ = 8
_uiMsg$ = 12
_lParam1$ = 16
_lParam2$ = 20
_Report_TTS_Status PROC NEAR

; 8879 : {

  03430	56		 push	 esi

; 8880 : 	if (lParam1 == TTS_AUDIO_PLAY_START)	ttsHandle->IsSpeaking = TRUE;	// KSB - Used for start of speech

  03431	8b 74 24 08	 mov	 esi, DWORD PTR _ttsHandle$[esp]
  03435	57		 push	 edi
  03436	8b 7c 24 14	 mov	 edi, DWORD PTR _lParam1$[esp+4]
  0343a	83 ff 0c	 cmp	 edi, 12			; 0000000cH
  0343d	75 0c		 jne	 SHORT $L72754
  0343f	c7 86 c8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+200], 1

; 8881 : 	if (lParam1 == TTS_AUDIO_PLAY_STOP)	ttsHandle->IsSpeaking = FALSE;	// KSB - Used for end of speech

  03449	eb 0f		 jmp	 SHORT $L72755
$L72754:
  0344b	83 ff 0d	 cmp	 edi, 13			; 0000000dH
  0344e	75 0a		 jne	 SHORT $L72755
  03450	c7 86 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+200], 0
$L72755:

; 8882 : 	
; 8883 : 	if (ttsHandle->DtCallbackRoutine != NULL)

  0345a	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  03460	85 c0		 test	 eax, eax
  03462	74 33		 je	 SHORT $L72757

; 8884 : 	{
; 8885 : #ifdef API_DEBUG
; 8886 : 		char szTemp[256]="";
; 8887 : 		sprintf(szTemp,"RTTSStatus(%08lx %08lx)\n",
; 8888 : 			lParam1, lParam2);
; 8889 : 		OutputDebugString(szTemp);
; 8890 : #endif //API_DEBUG
; 8891 : 		
; 8892 : 		OP_LockMutex( ttsHandle->hmxCallback );

  03464	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  0346a	50		 push	 eax
  0346b	e8 00 00 00 00	 call	 _OP_LockMutex

; 8893 : 		(*ttsHandle->DtCallbackRoutine)( lParam1,
; 8894 : 			lParam2,
; 8895 : 			ttsHandle->dwTTSInstanceParameter,
; 8896 : 			uiMsg);

  03470	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiMsg$[esp+8]
  03474	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  0347a	8b 44 24 1c	 mov	 eax, DWORD PTR _lParam2$[esp+8]
  0347e	51		 push	 ecx
  0347f	52		 push	 edx
  03480	50		 push	 eax
  03481	57		 push	 edi
  03482	ff 96 a4 00 00
	00		 call	 DWORD PTR [esi+164]

; 8897 : 		
; 8898 : 		OP_UnlockMutex( ttsHandle->hmxCallback );

  03488	8b 8e ac 00 00
	00		 mov	 ecx, DWORD PTR [esi+172]
  0348e	51		 push	 ecx
  0348f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  03494	83 c4 18	 add	 esp, 24			; 00000018H
$L72757:
  03497	5f		 pop	 edi
  03498	5e		 pop	 esi

; 8899 : 	}
; 8900 : 	return;
; 8901 : }

  03499	c3		 ret	 0
_Report_TTS_Status ENDP
_TEXT	ENDS
EXTRN	_SWFlushPipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_DrainPipes PROC NEAR

; 8925 : {

  034a0	56		 push	 esi

; 8926 : 	// empty the CMD, LTS and PH pipes..
; 8927 : 	SWFlushPipe(phTTS->pKernelShareData->cmd_pipe);

  034a1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  034a5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  034a8	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  034ae	51		 push	 ecx
  034af	e8 00 00 00 00	 call	 _SWFlushPipe

; 8928 : 	SWFlushPipe(phTTS->pKernelShareData->lts_pipe);

  034b4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  034b7	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  034bd	50		 push	 eax
  034be	e8 00 00 00 00	 call	 _SWFlushPipe

; 8929 : 	SWFlushPipe(phTTS->pKernelShareData->ph_pipe);

  034c3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  034c6	8b 91 d4 00 00
	00		 mov	 edx, DWORD PTR [ecx+212]
  034cc	52		 push	 edx
  034cd	e8 00 00 00 00	 call	 _SWFlushPipe
  034d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  034d5	5e		 pop	 esi

; 8930 : 	
; 8931 : }

  034d6	c3		 ret	 0
_DrainPipes ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechVersion
_BSS	SEGMENT
_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9 DB 032H DUP (?)
	ALIGN	4

$SG72766 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG72767 DB	'v2.20 R008 ACCESS32', 00H
$SG72768 DB	'%s %s', 00H
_DATA	ENDS
_TEXT	SEGMENT
_VersionStr$ = 8
_TextToSpeechVersion PROC NEAR

; 8940 : 	//removed unsigned form next line 11/12/96 cjl
; 8941 : 	static char   DECtalk_Version_String[50];
; 8942 : 	
; 8943 : 	sprintf(DECtalk_Version_String,"%s %s",DTALK_STR_VERSION, CUSTR_STR_VERSION);

  034e0	68 00 00 00 00	 push	 OFFSET FLAT:$SG72766
  034e5	68 00 00 00 00	 push	 OFFSET FLAT:$SG72767
  034ea	68 00 00 00 00	 push	 OFFSET FLAT:$SG72768
  034ef	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9
  034f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 8944 : 	if (VersionStr != NULL) *VersionStr = DECtalk_Version_String;

  034fa	8b 44 24 14	 mov	 eax, DWORD PTR _VersionStr$[esp+12]
  034fe	83 c4 10	 add	 esp, 16			; 00000010H
  03501	85 c0		 test	 eax, eax
  03503	74 06		 je	 SHORT $L73323
  03505	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersion@@9@9
$L73323:

; 8945 : 	// Add in dbg_version. NCS KSB
; 8946 : #ifdef WIN32
; 8947 : 	return (DTALK_DBG_VERSION << 31) + (DTALK_MAJ_VERSION << 24) + (DTALK_MIN_VERSION << 16) + (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;

  0350b	b8 03 02 3c 04	 mov	 eax, 71041539		; 043c0203H

; 8948 : #endif
; 8949 : #if defined __osf__ || defined __linux__
; 8950 : 	return (DTALK_MAJ_VERSION << 24) + (DTALK_MIN_VERSION << 16) + (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;
; 8951 : #endif
; 8952 : }

  03510	c3		 ret	 0
_TextToSpeechVersion ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechControlPanel
_TEXT	SEGMENT
_TextToSpeechControlPanel PROC NEAR

; 8956 : #ifdef DTALK50
; 8957 : 	if (ttsHandle == NULL)	return;
; 8958 : 	CPShow(ttsHandle->CPanelThread);
; 8959 : #else
; 8960 : 	/* This function not supported in 4.4 */
; 8961 : #endif
; 8962 : 	return;
; 8963 : }

  03520	c3		 ret	 0
_TextToSpeechControlPanel ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetLastError
_TEXT	SEGMENT
_phTTS$ = 8
_TextToSpeechGetLastError PROC NEAR

; 8972 : 	return phTTS->LastError;

  03530	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03534	8b 80 cc 00 00
	00		 mov	 eax, DWORD PTR [eax+204]

; 8973 : }

  0353a	c3		 ret	 0
_TextToSpeechGetLastError ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechTyping
_TEXT	SEGMENT
_phTTS$ = 8
_key$ = 12
_tptPriority$ = -516
_phone$72788 = -512
_TextToSpeechTyping PROC NEAR

; 8995 : void TextToSpeechTyping(LPTTS_HANDLE_T phTTS, unsigned char key) {  /* BATS#657 JL */

  03540	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  03546	53		 push	 ebx
  03547	57		 push	 edi

; 8996 : 	unsigned short str[20];
; 8997 : #ifdef API_DEBUG
; 8998 : 	char szTemp[256]="";
; 8999 : 	ULONG ulStartTime,ulEndTime;
; 9000 : #endif //API_DEBUG
; 9001 : 	
; 9002 : 	
; 9003 : #ifdef TYPING_MODE
; 9004 : #define TYPE_MAXPHONES (256)
; 9005 : 	HANDLE hThisThread=NULL;
; 9006 : 	THREAD_PRIORITY_T tptPriority=0;

  03548	33 ff		 xor	 edi, edi
  0354a	89 7c 24 08	 mov	 DWORD PTR _tptPriority$[esp+524], edi

; 9007 : 	hThisThread = GetCurrentThread();

  0354e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  03554	8b d8		 mov	 ebx, eax

; 9008 : 	if (hThisThread)

  03556	3b df		 cmp	 ebx, edi
  03558	74 15		 je	 SHORT $L72786

; 9009 : 	{
; 9010 : #ifndef UNDER_CE
; 9011 : 		tptPriority = OP_GetThreadPriority(hThisThread);

  0355a	53		 push	 ebx
  0355b	e8 00 00 00 00	 call	 _OP_GetThreadPriority

; 9012 : 		OP_SetThreadPriority(hThisThread,OP_PRIORITY_HIGHEST);

  03560	6a 02		 push	 2
  03562	53		 push	 ebx
  03563	89 44 24 14	 mov	 DWORD PTR _tptPriority$[esp+536], eax
  03567	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  0356c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72786:
  0356f	56		 push	 esi

; 9013 : #endif
; 9014 : 	}
; 9015 : #ifdef API_DEBUG
; 9016 : 	ulStartTime=timeGetTime();
; 9017 : 	sprintf(szTemp, "TTSTyping(%c) at %ld.\n", key, ulStartTime);
; 9018 : 	OutputDebugString(szTemp);
; 9019 : #endif //API_DEBUG
; 9020 : 	TextToSpeechReset(phTTS,FALSE);

  03570	8b b4 24 14 02
	00 00		 mov	 esi, DWORD PTR _phTTS$[esp+524]
  03577	57		 push	 edi
  03578	56		 push	 esi
  03579	e8 00 00 00 00	 call	 _TextToSpeechReset

; 9021 : 	/**/
; 9022 : 	// this is the type_out code from cm_util_type_out, modified to
; 9023 : 	// do what we need here.
; 9024 : 	{
; 9025 : 		unsigned char _far *tp;
; 9026 : 		DT_PIPE_T phone[TYPE_MAXPHONES];
; 9027 : 		unsigned int i=0;
; 9028 : 		PKSD_T pKsd_t = phTTS->pKernelShareData;

  0357e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 9029 : 		
; 9030 : 		for(tp = (unsigned char _far *)pKsd_t->typing_table[key];*tp;tp++)

  03581	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR _key$[esp+532]
  03588	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0358d	83 c4 08	 add	 esp, 8
  03590	8b 8a 70 04 00
	00		 mov	 ecx, DWORD PTR [edx+1136]
  03596	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  03599	8a 01		 mov	 al, BYTE PTR [ecx]
  0359b	84 c0		 test	 al, al
  0359d	74 25		 je	 SHORT $L72794
  0359f	55		 push	 ebp
  035a0	8d 74 24 14	 lea	 esi, DWORD PTR _phone$72788[esp+532]
$L72792:

; 9031 : 		{
; 9032 : 			phone[i++] = pKsd_t->reverse_ascky[(*tp) & 0xff];

  035a4	8b aa 60 04 00
	00		 mov	 ebp, DWORD PTR [edx+1120]
  035aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  035af	47		 inc	 edi
  035b0	83 c6 02	 add	 esi, 2
  035b3	66 8b 44 85 00	 mov	 ax, WORD PTR [ebp+eax*4]
  035b8	41		 inc	 ecx
  035b9	66 89 46 fe	 mov	 WORD PTR [esi-2], ax
  035bd	8a 01		 mov	 al, BYTE PTR [ecx]
  035bf	84 c0		 test	 al, al
  035c1	75 e1		 jne	 SHORT $L72792
  035c3	5d		 pop	 ebp
$L72794:

; 9033 : 		}
; 9034 : 		//phone[i++] = (PFUSA<<PSFONT) | COMMA;		
; 9035 : 		phone[i++] = SYNC;

  035c4	66 c7 44 7c 10
	0a 1f		 mov	 WORD PTR _phone$72788[esp+edi*2+528], 7946 ; 00001f0aH

; 9036 : 		write_pipe(pKsd_t->ph_pipe,phone,i);

  035cb	8b 92 d4 00 00
	00		 mov	 edx, DWORD PTR [edx+212]
  035d1	47		 inc	 edi
  035d2	8d 4c 24 10	 lea	 ecx, DWORD PTR _phone$72788[esp+528]
  035d6	57		 push	 edi
  035d7	51		 push	 ecx
  035d8	52		 push	 edx
  035d9	e8 00 00 00 00	 call	 _write_pipe
  035de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9037 : 	}
; 9038 : 	// end of type_out code
; 9039 : 	
; 9040 : 	
; 9041 : #ifdef API_DEBUG
; 9042 : 	ulEndTime=timeGetTime();
; 9043 : 	sprintf(szTemp, "TTSTyping() exit %ld (%ld)\n", 
; 9044 : 		ulEndTime, ulEndTime-ulStartTime);
; 9045 : 	OutputDebugString(szTemp);
; 9046 : #endif //API_DEBUG	
; 9047 : #ifndef UNDER_CE
; 9048 : 	if (hThisThread)

  035e1	85 db		 test	 ebx, ebx
  035e3	5e		 pop	 esi
  035e4	74 0e		 je	 SHORT $L72795

; 9049 : 		OP_SetThreadPriority(hThisThread,tptPriority);

  035e6	8b 44 24 08	 mov	 eax, DWORD PTR _tptPriority$[esp+524]
  035ea	50		 push	 eax
  035eb	53		 push	 ebx
  035ec	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  035f1	83 c4 08	 add	 esp, 8
$L72795:
  035f4	5f		 pop	 edi
  035f5	5b		 pop	 ebx

; 9050 : #endif
; 9051 : #endif TYPING_MODE
; 9052 : 	return;
; 9053 : }

  035f6	81 c4 04 02 00
	00		 add	 esp, 516		; 00000204H
  035fc	c3		 ret	 0
_TextToSpeechTyping ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved1
EXTRN	_paul_8:BYTE
EXTRN	_betty_8:BYTE
EXTRN	_harry_8:BYTE
EXTRN	_frank_8:BYTE
EXTRN	_kit_8:BYTE
EXTRN	_ursula_8:BYTE
EXTRN	_rita_8:BYTE
EXTRN	_wendy_8:BYTE
EXTRN	_dennis_8:BYTE
EXTRN	_paul:BYTE
EXTRN	_betty:BYTE
EXTRN	_harry:BYTE
EXTRN	_frank:BYTE
EXTRN	_kit:BYTE
EXTRN	_ursula:BYTE
EXTRN	_rita:BYTE
EXTRN	_wendy:BYTE
EXTRN	_dennis:BYTE
_TEXT	SEGMENT
_voices$ = 8
_voice$ = 12
_bEightk$ = 16
_bReadData$ = 20
_TextToSpeechReserved1 PROC NEAR

; 9057 : 	short *sdef;
; 9058 : 	
; 9059 : 	if (bEightk == FALSE) {	// High-quality

  03600	8b 44 24 0c	 mov	 eax, DWORD PTR _bEightk$[esp-4]
  03604	85 c0		 test	 eax, eax

; 9060 : 		
; 9061 : 		switch (voice) {

  03606	8b 44 24 08	 mov	 eax, DWORD PTR _voice$[esp-4]
  0360a	75 5a		 jne	 SHORT $L72807
  0360c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03611	83 f8 08	 cmp	 eax, 8
  03614	0f 87 21 01 00
	00		 ja	 $L72821
  0361a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L73331[eax*4]
$L72812:

; 9062 : 		case 0:	sdef = paul;	break;

  03621	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_paul
  03626	e9 8d 00 00 00	 jmp	 $L72824
$L72813:

; 9063 : 		case 1:	sdef = betty;	break;

  0362b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_betty
  03630	e9 83 00 00 00	 jmp	 $L72824
$L72814:

; 9064 : 		case 2:	sdef = harry;	break;

  03635	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_harry
  0363a	eb 7c		 jmp	 SHORT $L72824
$L72815:

; 9065 : 		case 3:	sdef = frank;	break;

  0363c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_frank
  03641	eb 75		 jmp	 SHORT $L72824
$L72816:

; 9066 : 		case 4:	sdef = dennis;	break;

  03643	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_dennis
  03648	eb 6e		 jmp	 SHORT $L72824
$L72817:

; 9067 : 		case 5:	sdef = kit;		break;

  0364a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_kit
  0364f	eb 67		 jmp	 SHORT $L72824
$L72818:

; 9068 : 		case 6:	sdef = ursula;	break;

  03651	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ursula
  03656	eb 60		 jmp	 SHORT $L72824
$L72819:

; 9069 : 		case 7:	sdef = rita;	break;

  03658	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_rita
  0365d	eb 59		 jmp	 SHORT $L72824
$L72820:

; 9070 : 		case 8:	sdef = wendy;	break;

  0365f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wendy

; 9071 : 		default:	return 0;
; 9072 : 		}
; 9073 : 	} else {

  03664	eb 52		 jmp	 SHORT $L72824
$L72807:

; 9074 : 		switch (voice) {

  03666	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0366b	83 f8 08	 cmp	 eax, 8
  0366e	0f 87 c7 00 00
	00		 ja	 $L72821
  03674	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L73332[eax*4]
$L72827:

; 9075 : 		case 0:	sdef = paul_8;		break;

  0367b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_paul_8
  03680	eb 36		 jmp	 SHORT $L72824
$L72828:

; 9076 : 		case 1:	sdef = betty_8;		break;

  03682	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_betty_8
  03687	eb 2f		 jmp	 SHORT $L72824
$L72829:

; 9077 : 		case 2:	sdef = harry_8;		break;

  03689	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_harry_8
  0368e	eb 28		 jmp	 SHORT $L72824
$L72830:

; 9078 : 		case 3:	sdef = frank_8;		break;

  03690	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_frank_8
  03695	eb 21		 jmp	 SHORT $L72824
$L72831:

; 9079 : 		case 4:	sdef = dennis_8;	break;

  03697	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_dennis_8
  0369c	eb 1a		 jmp	 SHORT $L72824
$L72832:

; 9080 : 		case 5:	sdef = kit_8;		break;

  0369e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_kit_8
  036a3	eb 13		 jmp	 SHORT $L72824
$L72833:

; 9081 : 		case 6:	sdef = ursula_8;	break;

  036a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ursula_8
  036aa	eb 0c		 jmp	 SHORT $L72824
$L72834:

; 9082 : 		case 7:	sdef = rita_8;		break;

  036ac	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_rita_8
  036b1	eb 05		 jmp	 SHORT $L72824
$L72835:

; 9083 : 		case 8:	sdef = wendy_8;		break;

  036b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wendy_8
$L72824:

; 9085 : 		}
; 9086 : 	}
; 9087 : 	
; 9088 : 	if (bReadData) {

  036b8	8b 4c 24 10	 mov	 ecx, DWORD PTR _bReadData$[esp-4]
  036bc	85 c9		 test	 ecx, ecx
  036be	74 33		 je	 SHORT $L72837

; 9089 : 		voices[0] = sdef[SP_GV];

  036c0	8b 4c 24 04	 mov	 ecx, DWORD PTR _voices$[esp-4]
  036c4	8a 50 24	 mov	 dl, BYTE PTR [eax+36]
  036c7	88 11		 mov	 BYTE PTR [ecx], dl

; 9090 : 		voices[1] = sdef[SP_GN];

  036c9	8a 50 26	 mov	 dl, BYTE PTR [eax+38]
  036cc	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 9091 : 		voices[2] = sdef[SP_G1];

  036cf	8a 50 28	 mov	 dl, BYTE PTR [eax+40]
  036d2	88 51 02	 mov	 BYTE PTR [ecx+2], dl

; 9092 : 		voices[3] = sdef[SP_G2];

  036d5	8a 50 2a	 mov	 dl, BYTE PTR [eax+42]
  036d8	88 51 03	 mov	 BYTE PTR [ecx+3], dl

; 9093 : 		voices[4] = sdef[SP_G3];

  036db	8a 50 2c	 mov	 dl, BYTE PTR [eax+44]
  036de	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 9094 : 		voices[5] = sdef[SP_G4];

  036e1	8a 50 2e	 mov	 dl, BYTE PTR [eax+46]
  036e4	88 51 05	 mov	 BYTE PTR [ecx+5], dl

; 9095 : 		voices[6] = sdef[SP_LO];

  036e7	8a 40 30	 mov	 al, BYTE PTR [eax+48]
  036ea	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 9104 : 	}
; 9105 : 	return 7;

  036ed	b8 07 00 00 00	 mov	 eax, 7

; 9106 : }

  036f2	c3		 ret	 0
$L72837:

; 9096 : 	} else {
; 9097 : 		sdef[SP_GV] = voices[0];

  036f3	8b 4c 24 04	 mov	 ecx, DWORD PTR _voices$[esp-4]
  036f7	66 0f b6 11	 movzx	 dx, BYTE PTR [ecx]
  036fb	66 89 50 24	 mov	 WORD PTR [eax+36], dx

; 9098 : 		sdef[SP_GN] = voices[1];

  036ff	66 0f b6 51 01	 movzx	 dx, BYTE PTR [ecx+1]
  03704	66 89 50 26	 mov	 WORD PTR [eax+38], dx

; 9099 : 		sdef[SP_G1] = voices[2];

  03708	66 0f b6 51 02	 movzx	 dx, BYTE PTR [ecx+2]
  0370d	66 89 50 28	 mov	 WORD PTR [eax+40], dx

; 9100 : 		sdef[SP_G2] = voices[3];

  03711	66 0f b6 51 03	 movzx	 dx, BYTE PTR [ecx+3]
  03716	66 89 50 2a	 mov	 WORD PTR [eax+42], dx

; 9101 : 		sdef[SP_G3] = voices[4];

  0371a	66 0f b6 51 04	 movzx	 dx, BYTE PTR [ecx+4]
  0371f	66 89 50 2c	 mov	 WORD PTR [eax+44], dx

; 9102 : 		sdef[SP_G4] = voices[5];

  03723	66 0f b6 51 05	 movzx	 dx, BYTE PTR [ecx+5]
  03728	66 89 50 2e	 mov	 WORD PTR [eax+46], dx

; 9103 : 		sdef[SP_LO] = voices[6];

  0372c	66 0f b6 49 06	 movzx	 cx, BYTE PTR [ecx+6]
  03731	66 89 48 30	 mov	 WORD PTR [eax+48], cx

; 9104 : 	}
; 9105 : 	return 7;

  03735	b8 07 00 00 00	 mov	 eax, 7

; 9106 : }

  0373a	c3		 ret	 0
$L72821:

; 9084 : 		default:	return 0;

  0373b	33 c0		 xor	 eax, eax

; 9106 : }

  0373d	c3		 ret	 0
  0373e	8b ff		 npad	 2
$L73331:
  03740	00 00 00 00	 DD	 $L72812
  03744	00 00 00 00	 DD	 $L72813
  03748	00 00 00 00	 DD	 $L72814
  0374c	00 00 00 00	 DD	 $L72815
  03750	00 00 00 00	 DD	 $L72816
  03754	00 00 00 00	 DD	 $L72817
  03758	00 00 00 00	 DD	 $L72818
  0375c	00 00 00 00	 DD	 $L72819
  03760	00 00 00 00	 DD	 $L72820
$L73332:
  03764	00 00 00 00	 DD	 $L72827
  03768	00 00 00 00	 DD	 $L72828
  0376c	00 00 00 00	 DD	 $L72829
  03770	00 00 00 00	 DD	 $L72830
  03774	00 00 00 00	 DD	 $L72831
  03778	00 00 00 00	 DD	 $L72832
  0377c	00 00 00 00	 DD	 $L72833
  03780	00 00 00 00	 DD	 $L72834
  03784	00 00 00 00	 DD	 $L72835
_TextToSpeechReserved1 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved2
_TEXT	SEGMENT
_TextToSpeechReserved2 PROC NEAR

; 9109 : #ifdef API_DEBUG
; 9110 : 	PVTM_T pVtm_t = phTTS->pVTMThreadData;
; 9111 : 	int i;
; 9112 : 	
; 9113 : 	for (i = 0; i < 7; i++)	gains[i] = pVtm_t->TunerData[i];
; 9114 : 	return 7;
; 9115 : #else
; 9116 : 	return 0;

  03790	33 c0		 xor	 eax, eax

; 9117 : #endif
; 9118 : }

  03792	c3		 ret	 0
_TextToSpeechReserved2 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetFeatures
PUBLIC	_TextToSpeechVersionEx
_BSS	SEGMENT
	ALIGN	4

_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9 DB 032H DUP (?)
	ALIGN	4

_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9 DB 032H DUP (?)
	ALIGN	4

$SG72852 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+2
$SG72853 DB	'v2.20 R008 ACCESS32', 00H
$SG72854 DB	'%s %s', 00H
	ORG $+2
$SG72855 DB	'ER: Error', 00H
	ORG $+2
$SG72856 DB	'US: American English', 00H
_DATA	ENDS
_TEXT	SEGMENT
_ver$ = 8
_TextToSpeechVersionEx PROC NEAR

; 9127 : {

  037a0	56		 push	 esi

; 9128 : 				static char DECtalk_Language_String[50];
; 9129 : 				static char DECtalk_Version_String[50];
; 9130 : 				
; 9131 : 				sprintf(DECtalk_Version_String,"%s %s",DTALK_STR_VERSION, CUSTR_STR_VERSION);

  037a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__sprintf
  037a7	68 00 00 00 00	 push	 OFFSET FLAT:$SG72852
  037ac	68 00 00 00 00	 push	 OFFSET FLAT:$SG72853
  037b1	68 00 00 00 00	 push	 OFFSET FLAT:$SG72854
  037b6	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9
  037bb	ff d6		 call	 esi

; 9132 : 				sprintf(DECtalk_Language_String, "ER: Error");

  037bd	68 00 00 00 00	 push	 OFFSET FLAT:$SG72855
  037c2	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9
  037c7	ff d6		 call	 esi

; 9133 : #ifdef ENGLISH_US
; 9134 : 				sprintf(DECtalk_Language_String, "US: American English");

  037c9	68 00 00 00 00	 push	 OFFSET FLAT:$SG72856
  037ce	68 00 00 00 00	 push	 OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9
  037d3	ff d6		 call	 esi

; 9135 : #endif
; 9136 : #ifdef SPANISH_LA
; 9137 : 				sprintf(DECtalk_Language_String, "LA: Latin American Spanish");
; 9138 : #endif
; 9139 : #ifdef SPANISH_SP
; 9140 : 				sprintf(DECtalk_Language_String, "SP: Castillian Spanish");
; 9141 : #endif
; 9142 : #ifdef GERMAN
; 9143 : 				sprintf(DECtalk_Language_String, "GR: German");
; 9144 : #endif
; 9145 : #ifdef FRENCH
; 9146 : 				sprintf(DECtalk_Language_String, "FR: French");
; 9147 : #endif
; 9148 : #ifdef SWAHILI
; 9149 : 				sprintf(DECtalk_Language_String, "SW: Swahili");
; 9150 : #endif
; 9151 : #ifdef ENGLISH_UK
; 9152 : 				sprintf(DECtalk_Language_String, "UK: British English");
; 9153 : #endif
; 9154 : 
; 9155 : 				if ((*ver = malloc(sizeof(VERSION_INFO))) == NULL)	return 0;

  037d5	6a 18		 push	 24			; 00000018H
  037d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  037dd	8b 74 24 2c	 mov	 esi, DWORD PTR _ver$[esp+36]
  037e1	83 c4 24	 add	 esp, 36			; 00000024H
  037e4	85 c0		 test	 eax, eax
  037e6	89 06		 mov	 DWORD PTR [esi], eax
  037e8	75 02		 jne	 SHORT $L72859
  037ea	5e		 pop	 esi

; 9164 : }

  037eb	c3		 ret	 0
$L72859:

; 9156 : 				(*ver)->StructSize = sizeof(VERSION_INFO);

  037ec	c7 00 18 00 00
	00		 mov	 DWORD PTR [eax], 24	; 00000018H

; 9157 : 				(*ver)->StructVersion = VERSION_STRUCT_VER;

  037f2	8b 06		 mov	 eax, DWORD PTR [esi]
  037f4	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 9158 : 				(*ver)->DLLVersion = (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;

  037fb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  037fd	66 c7 41 08 03
	02		 mov	 WORD PTR [ecx+8], 515	; 00000203H

; 9159 : 				(*ver)->DTalkVersion = (DTALK_DBG_VERSION << 15) + (DTALK_MAJ_VERSION << 8) + DTALK_MIN_VERSION;

  03803	8b 16		 mov	 edx, DWORD PTR [esi]
  03805	66 c7 42 0a 3c
	04		 mov	 WORD PTR [edx+10], 1084	; 0000043cH

; 9160 : 				(*ver)->VerString = DECtalk_Version_String;

  0380b	8b 06		 mov	 eax, DWORD PTR [esi]
  0380d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET FLAT:_?DECtalk_Version_String@?1??TextToSpeechVersionEx@@9@9

; 9161 : 				(*ver)->Language = DECtalk_Language_String;

  03814	8b 0e		 mov	 ecx, DWORD PTR [esi]
  03816	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET FLAT:_?DECtalk_Language_String@?1??TextToSpeechVersionEx@@9@9

; 9162 : 				(*ver)->Features = TextToSpeechGetFeatures();

  0381d	e8 00 00 00 00	 call	 _TextToSpeechGetFeatures
  03822	8b 16		 mov	 edx, DWORD PTR [esi]
  03824	5e		 pop	 esi
  03825	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 9163 : 				return (sizeof(VERSION_INFO));

  03828	b8 18 00 00 00	 mov	 eax, 24			; 00000018H

; 9164 : }

  0382d	c3		 ret	 0
_TextToSpeechVersionEx ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechStartLang
_TEXT	SEGMENT
_TextToSpeechStartLang PROC NEAR

; 9173 : 				return TTS_NOT_SUPPORTED;

  03830	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 9174 : }

  03835	c3		 ret	 0
_TextToSpeechStartLang ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechCloseLang
_TEXT	SEGMENT
_TextToSpeechCloseLang PROC NEAR

; 9176 : 				return FALSE;

  03840	33 c0		 xor	 eax, eax

; 9177 : }

  03842	c3		 ret	 0
_TextToSpeechCloseLang ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSelectLang
_TEXT	SEGMENT
_TextToSpeechSelectLang PROC NEAR

; 9191 : 				return FALSE;

  03850	33 c0		 xor	 eax, eax

; 9192 : }

  03852	c3		 ret	 0
_TextToSpeechSelectLang ENDP
_TextToSpeechGetFeatures PROC NEAR

; 9203 : 	unsigned long int feats;
; 9204 : 	
; 9205 : #ifdef ACCESS32
; 9206 : 	feats = TTS_FEATS_TYPINGMODE;
; 9207 : #else
; 9208 : 	feats = 0;
; 9209 : #endif
; 9210 : 	return feats;

  03860	b8 02 00 00 00	 mov	 eax, 2

; 9211 : }

  03865	c3		 ret	 0
_TextToSpeechGetFeatures ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechEnumLangs
_TEXT	SEGMENT
_langs$ = 8
_verinfo$ = -4
_TextToSpeechEnumLangs PROC NEAR

; 9214 : U32 TextToSpeechEnumLangs(LPLANG_ENUM *langs) {

  03870	51		 push	 ecx
  03871	56		 push	 esi

; 9215 : 	LPVERSION_INFO verinfo;
; 9216 : 	
; 9217 : 	if (((*langs) = malloc(sizeof(LANG_ENUM))) == NULL)	return 0;

  03872	6a 0c		 push	 12			; 0000000cH
  03874	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0387a	8b 74 24 10	 mov	 esi, DWORD PTR _langs$[esp+8]
  0387e	83 c4 04	 add	 esp, 4
  03881	85 c0		 test	 eax, eax
  03883	89 06		 mov	 DWORD PTR [esi], eax
  03885	74 4b		 je	 SHORT $L73341

; 9218 : 	(*langs)->Languages = 1;

  03887	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 9219 : 	(*langs)->MultiLang = FALSE;

  0388d	8b 06		 mov	 eax, DWORD PTR [esi]

; 9220 : 	if (((*langs)->Entries = calloc(1, sizeof(LANG_ENTRY))) == NULL) {

  0388f	6a 2b		 push	 43			; 0000002bH
  03891	6a 01		 push	 1
  03893	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0389a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  038a0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  038a2	83 c4 08	 add	 esp, 8
  038a5	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  038a8	8b 16		 mov	 edx, DWORD PTR [esi]
  038aa	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  038ad	85 c0		 test	 eax, eax

; 9221 : 		free(langs);
; 9222 : 		(*langs) = NULL;
; 9223 : 		return 0;

  038af	74 11		 je	 SHORT $L73340

; 9224 : 	}
; 9225 : 	if (TextToSpeechVersionEx(&verinfo) == 0) {

  038b1	8d 44 24 04	 lea	 eax, DWORD PTR _verinfo$[esp+8]
  038b5	50		 push	 eax
  038b6	e8 00 00 00 00	 call	 _TextToSpeechVersionEx
  038bb	83 c4 04	 add	 esp, 4
  038be	85 c0		 test	 eax, eax
  038c0	75 15		 jne	 SHORT $L72887
$L73340:

; 9226 : 		free(langs);

  038c2	56		 push	 esi
  038c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  038c9	83 c4 04	 add	 esp, 4

; 9227 : 		(*langs) = NULL;

  038cc	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$L73341:

; 9228 : 		return 0;

  038d2	33 c0		 xor	 eax, eax
  038d4	5e		 pop	 esi

; 9234 : }

  038d5	59		 pop	 ecx
  038d6	c3		 ret	 0
$L72887:

; 9229 : 	}
; 9230 : 	memcpy((*langs)->Entries[0].lang_code,verinfo->Language,2);

  038d7	8b 4c 24 04	 mov	 ecx, DWORD PTR _verinfo$[esp+8]
  038db	8b 06		 mov	 eax, DWORD PTR [esi]
  038dd	57		 push	 edi
  038de	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  038e1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  038e4	66 8b 12	 mov	 dx, WORD PTR [edx]
  038e7	66 89 11	 mov	 WORD PTR [ecx], dx

; 9231 : 	(*langs)->Entries[0].lang_code[2] = '\0';

  038ea	8b 06		 mov	 eax, DWORD PTR [esi]
  038ec	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  038ef	c6 41 02 00	 mov	 BYTE PTR [ecx+2], 0

; 9232 : 	strcpy((*langs)->Entries[0].lang_name,verinfo->Language+4);

  038f3	8b 54 24 08	 mov	 edx, DWORD PTR _verinfo$[esp+12]
  038f7	8b 06		 mov	 eax, DWORD PTR [esi]
  038f9	83 c9 ff	 or	 ecx, -1
  038fc	8b 7a 10	 mov	 edi, DWORD PTR [edx+16]
  038ff	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  03902	83 c7 04	 add	 edi, 4
  03905	33 c0		 xor	 eax, eax
  03907	83 c2 03	 add	 edx, 3
  0390a	f2 ae		 repne scasb
  0390c	f7 d1		 not	 ecx
  0390e	2b f9		 sub	 edi, ecx
  03910	8b c1		 mov	 eax, ecx
  03912	8b f7		 mov	 esi, edi
  03914	8b fa		 mov	 edi, edx
  03916	c1 e9 02	 shr	 ecx, 2
  03919	f3 a5		 rep movsd
  0391b	8b c8		 mov	 ecx, eax

; 9233 : 	return (sizeof(LANG_ENUM));

  0391d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  03922	83 e1 03	 and	 ecx, 3
  03925	f3 a4		 rep movsb
  03927	5f		 pop	 edi
  03928	5e		 pop	 esi

; 9234 : }

  03929	59		 pop	 ecx
  0392a	c3		 ret	 0
_TextToSpeechEnumLangs ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechReserved3
EXTRN	_GetNumUserEntries:NEAR
EXTRN	_GetUserEntry:NEAR
EXTRN	_UserDictionaryHit:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_type$ = 12
_data$ = 16
_max_size$ = 20
_entry$ = -132
_TextToSpeechReserved3 PROC NEAR

; 9246 : 	struct dic_entry entry; /* used to find a user dictionary entry's index, JAW 8/7/98 */
; 9247 : 	
; 9248 : 	PKSD_T  pKsd_t;
; 9249 : 	pKsd_t = phTTS->pKernelShareData;
; 9250 : 	
; 9251 : 	switch (type)
; 9252 : 	{

  03930	8b 44 24 08	 mov	 eax, DWORD PTR _type$[esp-4]
  03934	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  0393a	48		 dec	 eax
  0393b	53		 push	 ebx
  0393c	8b 9c 24 8c 00
	00 00		 mov	 ebx, DWORD PTR _phTTS$[esp+132]
  03943	56		 push	 esi
  03944	83 f8 06	 cmp	 eax, 6
  03947	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0394a	57		 push	 edi
  0394b	0f 87 12 01 00
	00		 ja	 $L72924
  03951	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L73343[eax*4]
$L72928:

; 9253 : 	case 1: 
; 9254 : 		/* return the size of the arpabet table */
; 9255 : 		return(pKsd_t->arpa_size);
; 9256 : 	case 2:
; 9257 : 		/* return the arpabet table */
; 9258 : 		if (max_size<pKsd_t->arpa_size)

  03958	8b 82 68 04 00
	00		 mov	 eax, DWORD PTR [edx+1128]
  0395e	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  03965	3b c8		 cmp	 ecx, eax
  03967	7d 0c		 jge	 SHORT $L72929
  03969	5f		 pop	 edi
  0396a	5e		 pop	 esi

; 9259 : 		{
; 9260 : 			return(-pKsd_t->arpa_size);

  0396b	f7 d8		 neg	 eax
  0396d	5b		 pop	 ebx

; 9296 : }

  0396e	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03974	c3		 ret	 0
$L72929:

; 9261 : 		}
; 9262 : 		else
; 9263 : 		{
; 9264 : 			memcpy(data,pKsd_t->arpabet,pKsd_t->arpa_size);

  03975	8b b2 64 04 00
	00		 mov	 esi, DWORD PTR [edx+1124]
  0397b	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  03982	8b c8		 mov	 ecx, eax
  03984	c1 e9 02	 shr	 ecx, 2
  03987	f3 a5		 rep movsd
  03989	8b c8		 mov	 ecx, eax
  0398b	83 e1 03	 and	 ecx, 3
  0398e	f3 a4		 rep movsb
$L72927:

; 9265 : 			return(pKsd_t->arpa_size);

  03990	8b 82 68 04 00
	00		 mov	 eax, DWORD PTR [edx+1128]
  03996	5f		 pop	 edi
  03997	5e		 pop	 esi
  03998	5b		 pop	 ebx

; 9296 : }

  03999	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  0399f	c3		 ret	 0
$L72930:
  039a0	5f		 pop	 edi
  039a1	5e		 pop	 esi

; 9266 : 		}
; 9267 : 	case 3:
; 9268 : 		/* return the number of entries the the asky conversion table */
; 9269 : 		return(sizeof(ptab));

  039a2	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  039a7	5b		 pop	 ebx

; 9296 : }

  039a8	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  039ae	c3		 ret	 0
$L72932:

; 9270 : 	case 4:
; 9271 : 		/* return the asky conversion table */
; 9272 : 		if (max_size<sizeof(ptab))

  039af	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  039b6	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  039bb	3b c8		 cmp	 ecx, eax
  039bd	73 0f		 jae	 SHORT $L72933
  039bf	5f		 pop	 edi
  039c0	5e		 pop	 esi

; 9273 : 		{
; 9274 : 			return(-(int)sizeof(ptab));

  039c1	b8 7e ff ff ff	 mov	 eax, -130		; ffffff7eH
  039c6	5b		 pop	 ebx

; 9296 : }

  039c7	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  039cd	c3		 ret	 0
$L72933:

; 9275 : 		}
; 9276 : 		else
; 9277 : 		{
; 9278 : 			memcpy(data,(char *)ptab,sizeof(ptab));

  039ce	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  039d5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  039da	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_ptab
  039df	f3 a5		 rep movsd
  039e1	66 a5		 movsw
  039e3	5f		 pop	 edi
  039e4	5e		 pop	 esi
  039e5	5b		 pop	 ebx

; 9296 : }

  039e6	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  039ec	c3		 ret	 0
$L72935:

; 9279 : 			return(sizeof(ptab));
; 9280 : 		}
; 9281 : 	case 5:
; 9282 : 		/* return number of user dictionary entries */
; 9283 : 		return GetNumUserEntries(phTTS); /* GetNumUserEntries is defined in ls_dict.c */

  039ed	53		 push	 ebx
  039ee	e8 00 00 00 00	 call	 _GetNumUserEntries
  039f3	83 c4 04	 add	 esp, 4
  039f6	5f		 pop	 edi
  039f7	5e		 pop	 esi
  039f8	5b		 pop	 ebx

; 9296 : }

  039f9	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  039ff	c3		 ret	 0
$L72938:

; 9284 : 	case 6:
; 9285 : 		/* return the grapheme/phoneme string for the user dictionary entry at max_size in data 
; 9286 : 		   (don't let the variable name confuse you; max_size is simply being used as an index)
; 9287 : 		   */
; 9288 : 		return GetUserEntry(phTTS, data, max_size); /* GetUserEntry is defined in ls_dict.c,

  03a00	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _max_size$[esp+140]
  03a07	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR _data$[esp+140]
  03a0e	51		 push	 ecx
  03a0f	52		 push	 edx
  03a10	53		 push	 ebx
  03a11	e8 00 00 00 00	 call	 _GetUserEntry
  03a16	83 c4 0c	 add	 esp, 12			; 0000000cH
  03a19	5f		 pop	 edi
  03a1a	5e		 pop	 esi
  03a1b	5b		 pop	 ebx

; 9296 : }

  03a1c	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03a22	c3		 ret	 0
$L72939:

; 9289 : 													   and it returns the starting index of the
; 9290 : 													   phoneme. */
; 9291 : 	case 7:
; 9292 : 		strcpy(entry.text, data);

  03a23	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _data$[esp+140]
  03a2a	83 c9 ff	 or	 ecx, -1
  03a2d	33 c0		 xor	 eax, eax
  03a2f	8d 54 24 10	 lea	 edx, DWORD PTR _entry$[esp+148]
  03a33	f2 ae		 repne scasb
  03a35	f7 d1		 not	 ecx
  03a37	2b f9		 sub	 edi, ecx
  03a39	8b c1		 mov	 eax, ecx
  03a3b	8b f7		 mov	 esi, edi
  03a3d	8b fa		 mov	 edi, edx
  03a3f	c1 e9 02	 shr	 ecx, 2
  03a42	f3 a5		 rep movsd
  03a44	8b c8		 mov	 ecx, eax
  03a46	83 e1 03	 and	 ecx, 3
  03a49	f3 a4		 rep movsb

; 9293 : 		return UserDictionaryHit(phTTS, &entry); /* returns the index of the entry */

  03a4b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _entry$[esp+144]
  03a4f	51		 push	 ecx
  03a50	53		 push	 ebx
  03a51	e8 00 00 00 00	 call	 _UserDictionaryHit
  03a56	83 c4 08	 add	 esp, 8
  03a59	5f		 pop	 edi
  03a5a	5e		 pop	 esi
  03a5b	5b		 pop	 ebx

; 9296 : }

  03a5c	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03a62	c3		 ret	 0
$L72924:
  03a63	5f		 pop	 edi
  03a64	5e		 pop	 esi

; 9294 : 	}
; 9295 : 	return(-1);

  03a65	83 c8 ff	 or	 eax, -1
  03a68	5b		 pop	 ebx

; 9296 : }

  03a69	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  03a6f	c3		 ret	 0
$L73343:
  03a70	00 00 00 00	 DD	 $L72927
  03a74	00 00 00 00	 DD	 $L72928
  03a78	00 00 00 00	 DD	 $L72930
  03a7c	00 00 00 00	 DD	 $L72932
  03a80	00 00 00 00	 DD	 $L72935
  03a84	00 00 00 00	 DD	 $L72938
  03a88	00 00 00 00	 DD	 $L72939
_TextToSpeechReserved3 ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechGetSpeakerParams
EXTRN	_GetSpeakerParams:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_uiIndex$ = 12
_ppspCur$ = 16
_ppspLoLimit$ = 20
_ppspHiLimit$ = 24
_ppspDefault$ = 28
_TextToSpeechGetSpeakerParams PROC NEAR

; 9316 : 	return GetSpeakerParams(phTTS, uiIndex, ppspCur, ppspLoLimit, ppspHiLimit, ppspDefault);

  03a90	8b 44 24 18	 mov	 eax, DWORD PTR _ppspDefault$[esp-4]
  03a94	8b 4c 24 14	 mov	 ecx, DWORD PTR _ppspHiLimit$[esp-4]
  03a98	8b 54 24 10	 mov	 edx, DWORD PTR _ppspLoLimit$[esp-4]
  03a9c	50		 push	 eax
  03a9d	8b 44 24 10	 mov	 eax, DWORD PTR _ppspCur$[esp]
  03aa1	51		 push	 ecx
  03aa2	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiIndex$[esp+4]
  03aa6	52		 push	 edx
  03aa7	8b 54 24 10	 mov	 edx, DWORD PTR _phTTS$[esp+8]
  03aab	50		 push	 eax
  03aac	51		 push	 ecx
  03aad	52		 push	 edx
  03aae	e8 00 00 00 00	 call	 _GetSpeakerParams
  03ab3	83 c4 18	 add	 esp, 24			; 00000018H

; 9317 : }

  03ab6	c3		 ret	 0
_TextToSpeechGetSpeakerParams ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSetSpeakerParams
EXTRN	_SetSpeakerParams:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pspSet$ = 12
_TextToSpeechSetSpeakerParams PROC NEAR

; 9334 : 	return SetSpeakerParams(phTTS, pspSet);

  03ac0	8b 44 24 08	 mov	 eax, DWORD PTR _pspSet$[esp-4]
  03ac4	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]
  03ac8	50		 push	 eax
  03ac9	51		 push	 ecx
  03aca	e8 00 00 00 00	 call	 _SetSpeakerParams
  03acf	83 c4 08	 add	 esp, 8

; 9335 : }

  03ad2	c3		 ret	 0
_TextToSpeechSetSpeakerParams ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDictionaryHit
EXTRN	_DictionaryHit:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechDictionaryHit PROC NEAR

; 9351 : 	long i;
; 9352 : 	
; 9353 : 	
; 9354 : 	if (phTTS == NULL)

  03ae0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03ae4	85 c0		 test	 eax, eax
  03ae6	75 04		 jne	 SHORT $L73019

; 9355 : 		return -1;

  03ae8	83 c8 ff	 or	 eax, -1

; 9359 : 		return 0;
; 9360 : 	return 1;
; 9361 : }

  03aeb	c3		 ret	 0
$L73019:

; 9356 : 	
; 9357 : 	i = DictionaryHit(phTTS, entry);

  03aec	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03af0	51		 push	 ecx
  03af1	50		 push	 eax
  03af2	e8 00 00 00 00	 call	 _DictionaryHit
  03af7	83 c4 08	 add	 esp, 8

; 9358 : 	if (i == -1)

  03afa	33 d2		 xor	 edx, edx
  03afc	83 f8 ff	 cmp	 eax, -1
  03aff	0f 95 c2	 setne	 dl
  03b02	8b c2		 mov	 eax, edx

; 9359 : 		return 0;
; 9360 : 	return 1;
; 9361 : }

  03b04	c3		 ret	 0
_TextToSpeechDictionaryHit ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDumpDictionary
EXTRN	_DumpDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechDumpDictionary PROC NEAR

; 9366 : 	if (phTTS == NULL)

  03b10	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b14	85 c0		 test	 eax, eax
  03b16	75 06		 jne	 SHORT $L73027

; 9367 : 		return MMSYSERR_INVALHANDLE;

  03b18	b8 05 00 00 00	 mov	 eax, 5

; 9370 : }

  03b1d	c3		 ret	 0
$L73027:

; 9368 : 	
; 9369 : 	return DumpDictionary(phTTS, filename);

  03b1e	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03b22	51		 push	 ecx
  03b23	50		 push	 eax
  03b24	e8 00 00 00 00	 call	 _DumpDictionary
  03b29	83 c4 08	 add	 esp, 8

; 9370 : }

  03b2c	c3		 ret	 0
_TextToSpeechDumpDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechUserDictionaryHit
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechUserDictionaryHit PROC NEAR

; 9375 : 	long i;
; 9376 : 	
; 9377 : 	
; 9378 : 	if (phTTS == NULL)

  03b30	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b34	85 c0		 test	 eax, eax
  03b36	75 04		 jne	 SHORT $L73035

; 9379 : 		return -1;

  03b38	83 c8 ff	 or	 eax, -1

; 9383 : 		return 0;
; 9384 : 	return 1;
; 9385 : }

  03b3b	c3		 ret	 0
$L73035:

; 9380 : 	
; 9381 : 	i = UserDictionaryHit(phTTS, entry);

  03b3c	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03b40	51		 push	 ecx
  03b41	50		 push	 eax
  03b42	e8 00 00 00 00	 call	 _UserDictionaryHit
  03b47	83 c4 08	 add	 esp, 8

; 9382 : 	if (i == -1)

  03b4a	33 d2		 xor	 edx, edx
  03b4c	83 f8 ff	 cmp	 eax, -1
  03b4f	0f 95 c2	 setne	 dl
  03b52	8b c2		 mov	 eax, edx

; 9383 : 		return 0;
; 9384 : 	return 1;
; 9385 : }

  03b54	c3		 ret	 0
_TextToSpeechUserDictionaryHit ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDumpUserDictionary
EXTRN	_DumpUserDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechDumpUserDictionary PROC NEAR

; 9390 : 	if (phTTS == NULL)

  03b60	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b64	85 c0		 test	 eax, eax
  03b66	75 06		 jne	 SHORT $L73043

; 9391 : 		return MMSYSERR_INVALHANDLE;

  03b68	b8 05 00 00 00	 mov	 eax, 5

; 9394 : }

  03b6d	c3		 ret	 0
$L73043:

; 9392 : 	
; 9393 : 	return DumpUserDictionary(phTTS, filename);

  03b6e	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03b72	51		 push	 ecx
  03b73	50		 push	 eax
  03b74	e8 00 00 00 00	 call	 _DumpUserDictionary
  03b79	83 c4 08	 add	 esp, 8

; 9394 : }

  03b7c	c3		 ret	 0
_TextToSpeechDumpUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechAddUserEntry
EXTRN	_AddUserEntry:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechAddUserEntry PROC NEAR

; 9399 : 	if (phTTS == NULL)

  03b80	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03b84	85 c0		 test	 eax, eax
  03b86	75 06		 jne	 SHORT $L73050

; 9400 : 		return MMSYSERR_INVALHANDLE;

  03b88	b8 05 00 00 00	 mov	 eax, 5

; 9403 : }

  03b8d	c3		 ret	 0
$L73050:

; 9401 : 	
; 9402 : 	return AddUserEntry(phTTS, entry);

  03b8e	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03b92	51		 push	 ecx
  03b93	50		 push	 eax
  03b94	e8 00 00 00 00	 call	 _AddUserEntry
  03b99	83 c4 08	 add	 esp, 8

; 9403 : }

  03b9c	c3		 ret	 0
_TextToSpeechAddUserEntry ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechDeleteUserEntry
EXTRN	_DeleteUserEntry:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_TextToSpeechDeleteUserEntry PROC NEAR

; 9408 : 	if (phTTS == NULL)

  03ba0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03ba4	85 c0		 test	 eax, eax
  03ba6	75 06		 jne	 SHORT $L73057

; 9409 : 		return MMSYSERR_INVALHANDLE;																

  03ba8	b8 05 00 00 00	 mov	 eax, 5

; 9412 : }

  03bad	c3		 ret	 0
$L73057:

; 9410 : 	
; 9411 : 	return DeleteUserEntry(phTTS, entry);

  03bae	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp-4]
  03bb2	51		 push	 ecx
  03bb3	50		 push	 eax
  03bb4	e8 00 00 00 00	 call	 _DeleteUserEntry
  03bb9	83 c4 08	 add	 esp, 8

; 9412 : }

  03bbc	c3		 ret	 0
_TextToSpeechDeleteUserEntry ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechChangeUserPhoneme
EXTRN	_ChangeUserPhoneme:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_entry$ = 12
_new_phoneme$ = 16
_TextToSpeechChangeUserPhoneme PROC NEAR

; 9418 : 	if (phTTS == NULL)

  03bc0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03bc4	85 c0		 test	 eax, eax
  03bc6	75 06		 jne	 SHORT $L73066

; 9419 : 		return MMSYSERR_INVALHANDLE;

  03bc8	b8 05 00 00 00	 mov	 eax, 5

; 9422 : }

  03bcd	c3		 ret	 0
$L73066:

; 9420 : 	
; 9421 : 	return ChangeUserPhoneme(phTTS, entry, new_phoneme);

  03bce	8b 4c 24 0c	 mov	 ecx, DWORD PTR _new_phoneme$[esp-4]
  03bd2	8b 54 24 08	 mov	 edx, DWORD PTR _entry$[esp-4]
  03bd6	51		 push	 ecx
  03bd7	52		 push	 edx
  03bd8	50		 push	 eax
  03bd9	e8 00 00 00 00	 call	 _ChangeUserPhoneme
  03bde	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9422 : }

  03be1	c3		 ret	 0
_TextToSpeechChangeUserPhoneme ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechSaveUserDictionary
EXTRN	_SaveUserDictionary:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_filename$ = 12
_TextToSpeechSaveUserDictionary PROC NEAR

; 9438 : 	if (phTTS == NULL)

  03bf0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03bf4	85 c0		 test	 eax, eax
  03bf6	75 06		 jne	 SHORT $L73078

; 9439 : 		return MMSYSERR_INVALHANDLE;

  03bf8	b8 05 00 00 00	 mov	 eax, 5

; 9442 : }

  03bfd	c3		 ret	 0
$L73078:

; 9440 : 
; 9441 : 	return SaveUserDictionary(phTTS, filename);

  03bfe	8b 4c 24 08	 mov	 ecx, DWORD PTR _filename$[esp-4]
  03c02	51		 push	 ecx
  03c03	50		 push	 eax
  03c04	e8 00 00 00 00	 call	 _SaveUserDictionary
  03c09	83 c4 08	 add	 esp, 8

; 9442 : }

  03c0c	c3		 ret	 0
_TextToSpeechSaveUserDictionary ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechConvertToPhonemes
EXTRN	__imp__IsBadReadPtr@8:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_szPhonemeBuf$ = 12
_dwBufSize$ = 16
_szText$ = 24
_dwCvtFlags$ = 32
_TextToSpeechConvertToPhonemes PROC NEAR

; 9452 : {

  03c10	53		 push	 ebx
  03c11	55		 push	 ebp
  03c12	56		 push	 esi

; 9453 : 	if (phTTS == NULL)

  03c13	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  03c17	33 db		 xor	 ebx, ebx
  03c19	57		 push	 edi
  03c1a	3b f3		 cmp	 esi, ebx
  03c1c	75 0a		 jne	 SHORT $L73095
  03c1e	5f		 pop	 edi
  03c1f	5e		 pop	 esi
  03c20	5d		 pop	 ebp

; 9454 : 		return MMSYSERR_INVALHANDLE;

  03c21	b8 05 00 00 00	 mov	 eax, 5
  03c26	5b		 pop	 ebx

; 9485 : }

  03c27	c3		 ret	 0
$L73095:

; 9455 : 	if (   IsBadReadPtr(szText,1)
; 9456 : 		|| IsBadReadPtr(dwBufSize,1)
; 9457 : 		|| IsBadWritePtr(szPhonemeBuf,*dwBufSize) )

  03c28	8b 44 24 24	 mov	 eax, DWORD PTR _szText$[esp+12]
  03c2c	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__IsBadReadPtr@8
  03c32	6a 01		 push	 1
  03c34	50		 push	 eax
  03c35	ff d5		 call	 ebp
  03c37	85 c0		 test	 eax, eax
  03c39	0f 85 94 00 00
	00		 jne	 $L73097
  03c3f	8b 7c 24 1c	 mov	 edi, DWORD PTR _dwBufSize$[esp+12]
  03c43	6a 01		 push	 1
  03c45	57		 push	 edi
  03c46	ff d5		 call	 ebp
  03c48	85 c0		 test	 eax, eax
  03c4a	0f 85 83 00 00
	00		 jne	 $L73097
  03c50	8b 0f		 mov	 ecx, DWORD PTR [edi]
  03c52	8b 6c 24 18	 mov	 ebp, DWORD PTR _szPhonemeBuf$[esp+12]
  03c56	51		 push	 ecx
  03c57	55		 push	 ebp
  03c58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  03c5e	85 c0		 test	 eax, eax
  03c60	75 71		 jne	 SHORT $L73097

; 9460 : 	}
; 9461 : 
; 9462 : 	// come to a complete stop;
; 9463 : 	TextToSpeechSync(phTTS);

  03c62	56		 push	 esi
  03c63	e8 00 00 00 00	 call	 _TextToSpeechSync

; 9464 : 	// Set up to log phonemes
; 9465 : 	phTTS->dwPhonemeBufferPtr = 0;
; 9466 : 	phTTS->dwPhonemeBufferSize = *dwBufSize;
; 9467 : 	phTTS->dwPhonemeCvtFlags = dwCvtFlags;
; 9468 : 	phTTS->szPhonemeBuffer = szPhonemeBuf;
; 9469 : 
; 9470 : 	// send along the text
; 9471 : 	TextToSpeechSpeak( phTTS, szText, TTS_FORCE);

  03c68	8b 4c 24 28	 mov	 ecx, DWORD PTR _szText$[esp+16]
  03c6c	8b 44 24 30	 mov	 eax, DWORD PTR _dwCvtFlags$[esp+16]
  03c70	89 9e e8 00 00
	00		 mov	 DWORD PTR [esi+232], ebx
  03c76	8b 17		 mov	 edx, DWORD PTR [edi]
  03c78	6a 01		 push	 1
  03c7a	51		 push	 ecx
  03c7b	56		 push	 esi
  03c7c	89 96 e4 00 00
	00		 mov	 DWORD PTR [esi+228], edx
  03c82	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  03c88	89 ae e0 00 00
	00		 mov	 DWORD PTR [esi+224], ebp
  03c8e	e8 00 00 00 00	 call	 _TextToSpeechSpeak

; 9472 : 	// wait for completion
; 9473 : 	TextToSpeechSync(phTTS);

  03c93	56		 push	 esi
  03c94	e8 00 00 00 00	 call	 _TextToSpeechSync

; 9474 : 	// clear the flags to the VTM
; 9475 : 	phTTS->dwPhonemeCvtFlags = 0;
; 9476 : 	// vtmiont leaves enough space for a terminating null..
; 9477 : 	phTTS->szPhonemeBuffer[phTTS->dwPhonemeBufferPtr++]='\0';

  03c99	8b 96 e8 00 00
	00		 mov	 edx, DWORD PTR [esi+232]
  03c9f	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  03ca5	89 9e ec 00 00
	00		 mov	 DWORD PTR [esi+236], ebx
  03cab	83 c4 14	 add	 esp, 20			; 00000014H
  03cae	88 1c 02	 mov	 BYTE PTR [edx+eax], bl
  03cb1	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  03cb7	40		 inc	 eax
  03cb8	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax

; 9478 : 	// return the count in the BufSize arg
; 9479 : 	*dwBufSize = phTTS->dwPhonemeBufferPtr;

  03cbe	89 07		 mov	 DWORD PTR [edi], eax

; 9480 : 	// stop logging
; 9481 : 	phTTS->szPhonemeBuffer = NULL;

  03cc0	89 9e e0 00 00
	00		 mov	 DWORD PTR [esi+224], ebx

; 9482 : 	phTTS->dwPhonemeBufferSize = 0;

  03cc6	89 9e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ebx
  03ccc	5f		 pop	 edi
  03ccd	5e		 pop	 esi
  03cce	5d		 pop	 ebp

; 9483 : 
; 9484 : 	return MMSYSERR_NOERROR;

  03ccf	33 c0		 xor	 eax, eax
  03cd1	5b		 pop	 ebx

; 9485 : }

  03cd2	c3		 ret	 0
$L73097:
  03cd3	5f		 pop	 edi
  03cd4	5e		 pop	 esi
  03cd5	5d		 pop	 ebp

; 9458 : 	{
; 9459 : 		return MMSYSERR_INVALPARAM;

  03cd6	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  03cdb	5b		 pop	 ebx

; 9485 : }

  03cdc	c3		 ret	 0
_TextToSpeechConvertToPhonemes ENDP
_TEXT	ENDS
PUBLIC	_TextToSpeechTuning
_TEXT	SEGMENT
_phTTS$ = 8
_iFunction$ = 12
_pvtdArg$ = 16
_TextToSpeechTuning PROC NEAR

; 9501 : 	PVTM_T pVtm_t = phTTS->pVTMThreadData;

  03ce0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  03ce4	53		 push	 ebx

; 9502 : 
; 9503 : 	// make sure we haven't been handed junk..
; 9504 : 	if (IsBadWritePtr(phTTS, sizeof(LPTTS_HANDLE_T)))

  03ce5	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__IsBadWritePtr@8
  03ceb	56		 push	 esi
  03cec	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  03cef	57		 push	 edi
  03cf0	6a 04		 push	 4
  03cf2	50		 push	 eax
  03cf3	ff d3		 call	 ebx
  03cf5	85 c0		 test	 eax, eax
  03cf7	74 09		 je	 SHORT $L73109
  03cf9	5f		 pop	 edi
  03cfa	5e		 pop	 esi

; 9505 : 	{
; 9506 : 		// bad handle
; 9507 : 		return MMSYSERR_INVALHANDLE;

  03cfb	b8 05 00 00 00	 mov	 eax, 5
  03d00	5b		 pop	 ebx

; 9559 : 
; 9560 : } // TextToSpeechTuning

  03d01	c3		 ret	 0
$L73109:

; 9508 : 	}
; 9509 : 
; 9510 : 	// decide what to do..
; 9511 : 	switch (iFunction)
; 9512 : 	{

  03d02	8b 44 24 14	 mov	 eax, DWORD PTR _iFunction$[esp+8]
  03d06	48		 dec	 eax
  03d07	74 48		 je	 SHORT $L73114
  03d09	48		 dec	 eax
  03d0a	74 35		 je	 SHORT $L73115
  03d0c	48		 dec	 eax
  03d0d	74 09		 je	 SHORT $L73116
  03d0f	5f		 pop	 edi
  03d10	5e		 pop	 esi

; 9552 : 		break;
; 9553 : 
; 9554 : 	default:
; 9555 : 		return MMSYSERR_INVALPARAM; // bad function request.

  03d11	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  03d16	5b		 pop	 ebx

; 9559 : 
; 9560 : } // TextToSpeechTuning

  03d17	c3		 ret	 0
$L73116:

; 9541 : 		break;
; 9542 : 
; 9543 : 	case TTSTUNING_GET_RESULTS:
; 9544 : 		// tek 01dec98
; 9545 : 		if (IsBadWritePtr(pvtdArg, sizeof(VTM_TUNER_DATA)))

  03d18	8b 7c 24 18	 mov	 edi, DWORD PTR _pvtdArg$[esp+8]
  03d1c	6a 34		 push	 52			; 00000034H
  03d1e	57		 push	 edi
  03d1f	ff d3		 call	 ebx
  03d21	85 c0		 test	 eax, eax
  03d23	74 09		 je	 SHORT $L73118
  03d25	5f		 pop	 edi
  03d26	5e		 pop	 esi

; 9546 : 		{
; 9547 : 			// bad handle
; 9548 : 			return MMSYSERR_INVALPARAM;

  03d27	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  03d2c	5b		 pop	 ebx

; 9559 : 
; 9560 : } // TextToSpeechTuning

  03d2d	c3		 ret	 0
$L73118:

; 9549 : 		}
; 9550 : 		// do the copy
; 9551 : 		memcpy(pvtdArg, &pVtm_t->vtdTuneResults, sizeof(VTM_TUNER_DATA));

  03d2e	81 c6 70 01 00
	00		 add	 esi, 368		; 00000170H
  03d34	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  03d39	f3 a5		 rep movsd
  03d3b	5f		 pop	 edi
  03d3c	5e		 pop	 esi

; 9556 : 
; 9557 : 	} // switch (iFunction)
; 9558 : 	return MMSYSERR_NOERROR; 

  03d3d	33 c0		 xor	 eax, eax
  03d3f	5b		 pop	 ebx

; 9559 : 
; 9560 : } // TextToSpeechTuning

  03d40	c3		 ret	 0
$L73115:

; 9536 : 		break;
; 9537 : 
; 9538 : 	case TTSTUNING_DISABLE:
; 9539 : 		// clear the switch
; 9540 : 		pVtm_t->bDoTuning = FALSE;

  03d41	c7 86 1c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+540], 0
  03d4b	5f		 pop	 edi
  03d4c	5e		 pop	 esi

; 9556 : 
; 9557 : 	} // switch (iFunction)
; 9558 : 	return MMSYSERR_NOERROR; 

  03d4d	33 c0		 xor	 eax, eax
  03d4f	5b		 pop	 ebx

; 9559 : 
; 9560 : } // TextToSpeechTuning

  03d50	c3		 ret	 0
$L73114:

; 9513 : 	case TTSTUNING_ENABLE:
; 9514 : 		// clear all the old data
; 9515 : 		pVtm_t->vtdTuneResults.rnpmax=0;      /*maximum value within filter of casade rnp*/

  03d51	33 c0		 xor	 eax, eax

; 9516 : 		pVtm_t->vtdTuneResults.rnzmax=0;      /*maximum value within filter of casade rnz*/
; 9517 : 		pVtm_t->vtdTuneResults.c1max=0;       /*maximum value within filter of casade 1*/
; 9518 : 		pVtm_t->vtdTuneResults.c2max=0;       /*maximum value within filter of casade 2*/
; 9519 : 		pVtm_t->vtdTuneResults.c3max=0;       /*maximum value within filter of casade 3*/
; 9520 : 		pVtm_t->vtdTuneResults.c4max=0;       /*maximum value within filter of casade 4*/
; 9521 : 		pVtm_t->vtdTuneResults.c5max=0;       /*maximum value within filter of casade 5*/
; 9522 : 		pVtm_t->vtdTuneResults.purevmax=0;    /*maximum value of downsampled voice */
; 9523 : 		pVtm_t->vtdTuneResults.dwThisPhoneme=0;	/* the phoneme we overloaded on */
; 9524 : 		pVtm_t->vtdTuneResults.dwLastPhoneme=0;	/* the phoneme we overloaded on */
; 9525 : 
; 9526 : 		pVtm_t->vtdTuneResults.r1cd2=0;
; 9527 : 		pVtm_t->vtdTuneResults.r2cd2=0;
; 9528 : 		pVtm_t->vtdTuneResults.r3cd2=0;
; 9529 : 		pVtm_t->vtdTuneResults.r4cd2=0;
; 9530 : 		pVtm_t->vtdTuneResults.r5cd2=0;
; 9531 : 		pVtm_t->vtdTuneResults.rnpd2=0;
; 9532 : 		pVtm_t->vtdTuneResults.rnzd2=0;
; 9533 : 		pVtm_t->vtdTuneResults.rlpd2=0;
; 9534 : 		// set the enable bit 
; 9535 : 		pVtm_t->bDoTuning = TRUE;

  03d53	c7 86 1c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+540], 1
  03d5d	66 89 86 70 01
	00 00		 mov	 WORD PTR [esi+368], ax
  03d64	66 89 86 72 01
	00 00		 mov	 WORD PTR [esi+370], ax
  03d6b	66 89 86 74 01
	00 00		 mov	 WORD PTR [esi+372], ax
  03d72	66 89 86 76 01
	00 00		 mov	 WORD PTR [esi+374], ax
  03d79	66 89 86 78 01
	00 00		 mov	 WORD PTR [esi+376], ax
  03d80	66 89 86 7a 01
	00 00		 mov	 WORD PTR [esi+378], ax
  03d87	66 89 86 7c 01
	00 00		 mov	 WORD PTR [esi+380], ax
  03d8e	66 89 86 7e 01
	00 00		 mov	 WORD PTR [esi+382], ax
  03d95	89 86 8c 01 00
	00		 mov	 DWORD PTR [esi+396], eax
  03d9b	89 86 90 01 00
	00		 mov	 DWORD PTR [esi+400], eax
  03da1	66 89 86 94 01
	00 00		 mov	 WORD PTR [esi+404], ax
  03da8	66 89 86 96 01
	00 00		 mov	 WORD PTR [esi+406], ax
  03daf	66 89 86 98 01
	00 00		 mov	 WORD PTR [esi+408], ax
  03db6	66 89 86 9a 01
	00 00		 mov	 WORD PTR [esi+410], ax
  03dbd	66 89 86 9c 01
	00 00		 mov	 WORD PTR [esi+412], ax
  03dc4	66 89 86 9e 01
	00 00		 mov	 WORD PTR [esi+414], ax
  03dcb	66 89 86 a0 01
	00 00		 mov	 WORD PTR [esi+416], ax
  03dd2	66 89 86 a2 01
	00 00		 mov	 WORD PTR [esi+418], ax
  03dd9	5f		 pop	 edi
  03dda	5e		 pop	 esi
  03ddb	5b		 pop	 ebx

; 9559 : 
; 9560 : } // TextToSpeechTuning

  03ddc	c3		 ret	 0
_TextToSpeechTuning ENDP
_PumpModeMessage PROC NEAR

; 9580 : 	return(TRUE);

  03de0	b8 01 00 00 00	 mov	 eax, 1

; 9581 : }

  03de5	c3		 ret	 0
_PumpModeMessage ENDP
_TEXT	ENDS
END
